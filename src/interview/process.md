---
title: 进程编程
order: 2
category:
  - 面试题
tag:
  - c++ 多进程
---

## 进程状态

###  进程的基本状态

1. **新建（New）**：
   - 进程正在被创建，还未进入准备就绪队列。

2. **就绪（Ready）**：
   - 进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。

3. **运行（Running）**：
   - 进程正在 CPU 上执行代码。

4. **阻塞（Blocked）**：
   - 进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。

5. **终止（Terminated）**：
   - 进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。

###  进程状态之间的转换

进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：

1. **新建 → 就绪**：
   - 当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。

2. **就绪 → 运行**：
   - 调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。

3. **运行 → 就绪**：
   - 如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。

4. **运行 → 阻塞**：
   - 当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。

5. **阻塞 → 就绪**：
   - 当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。

6. **运行 → 终止**：
   - 当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。

### 状态转换示意图

```
stateDiagram
    [*] --> 新建: 创建进程
    新建 --> 就绪: 进程创建完成
    就绪 --> 运行: 调度进程
    运行 --> 阻塞: 等待事件
    阻塞 --> 就绪: 事件完成
    运行 --> 就绪: 时间片耗尽/被抢占
    运行 --> 终止: 进程完成/被终止
    终止 --> [*]
```


## 僵尸进程

**僵尸进程**（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 `wait()` 或 `waitpid()` 函数回收子进程的退出状态信息，从而导致的进程状态。

具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 `wait()` 或 `waitpid()` 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。

### 僵尸进程的影响

- **资源占用**：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。
- **系统管理的麻烦**：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。

### 如何避免产生僵尸进程？

避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：

1. **及时调用 `wait()` 或 `waitpid()`**：

   父进程在适当的时机调用 `wait()` 或 `waitpid()` 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。

   ```cpp
   pid_t pid = fork();
   if (pid == 0) {
       // 子进程代码
       exit(0);
   } else {
       // 父进程代码
       wait(NULL); // 等待子进程结束并回收资源
   }
   ```

2. **使用 `SIGCHLD` 信号处理子进程的结束**：

   当子进程结束时，父进程会收到 `SIGCHLD` 信号。父进程可以在信号处理程序中调用 `wait()` 或 `waitpid()` 以回收子进程的资源。

   ```cpp
   #include <iostream>
   #include <sys/wait.h>
   #include <unistd.h>
   #include <signal.h>

   void sigchld_handler(int signum) {
       // 等待所有已终止的子进程
       while (waitpid(-1, NULL, WNOHANG) > 0);
   }

   int main() {
       // 注册 SIGCHLD 信号处理程序
       signal(SIGCHLD, sigchld_handler);

       pid_t pid = fork();
       if (pid == 0) {
           // 子进程代码
           exit(0);
       } else {
           // 父进程代码
           // 父进程继续执行其任务
           pause(); // 等待信号（例如 SIGCHLD）
       }

       return 0;
   }
   ```

3. **将子进程的父进程设置为 `init` 进程（或 systemd）**：

   如果父进程在子进程结束前退出，子进程会被 `init` 进程（PID 为 1 的进程）接管。`init` 进程会自动调用 `wait()` 回收子进程的资源，避免僵尸进程的产生。可以通过调用 `fork()` 后使父进程退出，子进程被 `init` 接管。

   ```cpp
   pid_t pid = fork();
   if (pid > 0) {
       // 父进程退出
       exit(0);
   }

   // 子进程继续执行
   // 此时子进程的父进程是 init 进程
   ```

4. **采用 `double fork()` 技术**：

   父进程通过 `fork()` 创建一个子进程，子进程再 `fork()` 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 `init` 进程接管。

   ```cpp
   pid_t pid = fork();
   if (pid == 0) {
       // 第一个子进程
       pid_t pid2 = fork();
       if (pid2 == 0) {
           // 孙子进程
           // 在此处执行需要守护的任务
           exit(0);
       } else {
           // 第一个子进程退出
           exit(0);
       }
   } else {
       // 父进程等待第一个子进程退出
       wait(NULL);
   }
   ```

### 

僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 `wait()` 系列函数、处理 `SIGCHLD` 信号、使用 `init` 进程接管孤儿进程或采用 `double fork()` 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。