const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":121,\"nextId\":121,\"documentIds\":{\"0\":\"0\",\"1\":\"0#c-相关的面-笔试题\",\"2\":\"0#基本的数据结构\",\"3\":\"0#架构设计\",\"4\":\"0@1\",\"5\":\"1\",\"6\":\"1@0\",\"7\":\"2\",\"8\":\"2#数组\",\"9\":\"2#数组常用操作\",\"10\":\"2#初始化数组\",\"11\":\"2#访问元素\",\"12\":\"2#插入元素\",\"13\":\"2#删除元素\",\"14\":\"2#遍历数组\",\"15\":\"2#查找元素\",\"16\":\"2#扩容数组\",\"17\":\"2#数组的优点与局限性\",\"18\":\"2#数组典型应用\",\"19\":\"2#链表\",\"20\":\"2#链表常用操作\",\"21\":\"2#初始化链表\",\"22\":\"2#插入节点\",\"23\":\"2#删除节点\",\"24\":\"2#访问节点\",\"25\":\"2#查找节点\",\"26\":\"2#数组-vs-链表\",\"27\":\"2#常见链表类型\",\"28\":\"2#链表典型应用\",\"29\":\"2#列表\",\"30\":\"2#列表常用操作\",\"31\":\"2#初始化列表\",\"32\":\"2#访问元素-1\",\"33\":\"2#插入与删除元素\",\"34\":\"2#遍历列表\",\"35\":\"2#列表实现\",\"36\":\"2#重点回顾\",\"37\":\"2#q-a\",\"38\":\"2@0\",\"39\":\"2@1\",\"40\":\"3\",\"41\":\"3#队列\",\"42\":\"3#队列常用操作\",\"43\":\"3#队列实现\",\"44\":\"3#基于链表的实现\",\"45\":\"3#基于数组的实现\",\"46\":\"3#队列典型应用\",\"47\":\"3#栈\",\"48\":\"3#栈的常用操作\",\"49\":\"3#栈的实现\",\"50\":\"3#基于链表的实现-1\",\"51\":\"3#基于数组的实现-1\",\"52\":\"3#两种实现对比\",\"53\":\"3#栈的典型应用\",\"54\":\"3#重点回顾\",\"55\":\"3#q-a\",\"56\":\"3@0\",\"57\":\"3@1\",\"58\":\"4\",\"59\":\"4@0\",\"60\":\"5\",\"61\":\"5#设计模式\",\"62\":\"5#设计原则\",\"63\":\"5@0\",\"64\":\"5@1\",\"65\":\"6\",\"66\":\"6@0\",\"67\":\"6@1\",\"68\":\"7\",\"69\":\"7#组成部分\",\"70\":\"7#例子\",\"71\":\"7@0\",\"72\":\"7@1\",\"73\":\"8\",\"74\":\"8#入门推荐\",\"75\":\"8#进阶推荐\",\"76\":\"8@0\",\"77\":\"9\",\"78\":\"9@0\",\"79\":\"10\",\"80\":\"10#_1-static-关键字的作用\",\"81\":\"10#_2-new-delete与malloc-new的区别\",\"82\":\"10#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"83\":\"10#_4-宏与constexpr-区别\",\"84\":\"10#_5-extern-c\",\"85\":\"10#_6-const-关键字的作用\",\"86\":\"10@0\",\"87\":\"10@1\",\"88\":\"11\",\"89\":\"11#进程状态\",\"90\":\"11#进程的基本状态\",\"91\":\"11#进程状态之间的转换\",\"92\":\"11#状态转换示意图\",\"93\":\"11#僵尸进程\",\"94\":\"11#僵尸进程的影响\",\"95\":\"11#如何避免产生僵尸进程\",\"96\":\"11@0\",\"97\":\"11@1\",\"98\":\"12\",\"99\":\"12#线程创建\",\"100\":\"12#线程同步机制\",\"101\":\"12#_1-互斥量-mutex\",\"102\":\"12#_2-读写锁-shared-mutex\",\"103\":\"12#_3-条件变量-condition-variable\",\"104\":\"12#_4-原子操作-atomic-operations\",\"105\":\"12#_5-信号量-semaphore\",\"106\":\"12#_6-自旋锁-spinlock\",\"107\":\"12#_7-屏障-barrier\",\"108\":\"12#_8-锁存器-latch\",\"109\":\"12#无锁编程\",\"110\":\"12#_1-基本概念\",\"111\":\"12#_2-c-中的原子操作\",\"112\":\"12#_3-使用原子变量实现无锁队列\",\"113\":\"12#_4-代码结构和作用\",\"114\":\"12#_5-内存顺序的选择\",\"115\":\"12@0\",\"116\":\"12@1\",\"117\":\"13\",\"118\":\"13@0\",\"119\":\"14\",\"120\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,10],\"1\":[3,3],\"2\":[1,1],\"3\":[1,2],\"4\":[null,null,1],\"5\":[1],\"6\":[null,null,1],\"7\":[1],\"8\":[1,8],\"9\":[1],\"10\":[1,23],\"11\":[1,40],\"12\":[1,35],\"13\":[1,52],\"14\":[1,19],\"15\":[1,23],\"16\":[1,36],\"17\":[1,30],\"18\":[1,37],\"19\":[1,69],\"20\":[1],\"21\":[1,37],\"22\":[1,29],\"23\":[1,30],\"24\":[1,36],\"25\":[1,26],\"26\":[3,24],\"27\":[1,42],\"28\":[1,59],\"29\":[1,49],\"30\":[1],\"31\":[1,21],\"32\":[1,17],\"33\":[1,29],\"34\":[1,18],\"35\":[1,37],\"36\":[1,38],\"37\":[2,217],\"38\":[null,null,1],\"39\":[null,null,4],\"40\":[1],\"41\":[1,17],\"42\":[1,35],\"43\":[1,6],\"44\":[1,78],\"45\":[1,128],\"46\":[1,15],\"47\":[1,21],\"48\":[1,45],\"49\":[1,13],\"50\":[1,73],\"51\":[1,49],\"52\":[1,56],\"53\":[1,16],\"54\":[1,21],\"55\":[2,55],\"56\":[null,null,1],\"57\":[null,null,3],\"58\":[1],\"59\":[null,null,1],\"60\":[1],\"61\":[1,15],\"62\":[1,40],\"63\":[null,null,1],\"64\":[null,null,3],\"65\":[1],\"66\":[null,null,1],\"67\":[null,null,4],\"68\":[1,9],\"69\":[1,8],\"70\":[1,9],\"71\":[null,null,1],\"72\":[null,null,3],\"73\":[1,6],\"74\":[1,17],\"75\":[1,30],\"76\":[null,null,1],\"77\":[1],\"78\":[null,null,1],\"79\":[2],\"80\":[4,10],\"81\":[5,17],\"82\":[9,21],\"83\":[4,7],\"84\":[4,23],\"85\":[4,8],\"86\":[null,null,1],\"87\":[null,null,1],\"88\":[1],\"89\":[1],\"90\":[1,29],\"91\":[1,37],\"92\":[1],\"93\":[1,32],\"94\":[1,12],\"95\":[2,102],\"96\":[null,null,1],\"97\":[null,null,3],\"98\":[1],\"99\":[1,37],\"100\":[1],\"101\":[4,62],\"102\":[5,78],\"103\":[5,90],\"104\":[5,64],\"105\":[4,74],\"106\":[4,78],\"107\":[4,61],\"108\":[4,64],\"109\":[1,11],\"110\":[2,26],\"111\":[3,13],\"112\":[2,80],\"113\":[2,131],\"114\":[2,26],\"115\":[null,null,1],\"116\":[null,null,3],\"117\":[1],\"118\":[null,null,1],\"119\":[1,3],\"120\":[1]},\"averageFieldLength\":[1.5855406834975962,34.648662725394004,0.7000850863837998],\"storedFields\":{\"0\":{\"h\":\"首页\",\"t\":[\"本站是一个面向 c++ 程序员的知识库，主要包含一些基本的 c++ 面试题和数据结构算法。其目的在于帮助想学习 c++ 编程同学，掌握一些基本的算法和数据结构。主要有以下几部分：\"]},\"1\":{\"h\":\"c++ 相关的面/笔试题\",\"t\":[\"c++面试题\",\"线程编程\",\"进程编程\"]},\"2\":{\"h\":\"基本的数据结构\",\"t\":[\"数组与链表\"]},\"3\":{\"h\":\"架构设计\",\"t\":[\"设计原则\",\"策略模式\"]},\"4\":{\"c\":[\"c++\"]},\"5\":{\"h\":\"数据结构\"},\"6\":{\"c\":[\"数据结构\"]},\"7\":{\"h\":\"数组与链表\"},\"8\":{\"h\":\"数组\",\"t\":[\"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。下图展示了数组的主要概念和存储方式。\",\"数组定义与存储方式\"]},\"9\":{\"h\":\"数组常用操作\"},\"10\":{\"h\":\"初始化数组\",\"t\":[\"我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 ：\",\"/* 初始化数组 */ // 存储在栈上 int arr[5]; int nums[5] = { 1, 3, 2, 5, 4 }; // 存储在堆上（需要手动释放空间） int* arr1 = new int[5]; int* nums1 = new int[5] { 1, 3, 2, 5, 4 };\"]},\"11\":{\"h\":\"访问元素\",\"t\":[\"数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问该元素。\",\"数组元素的内存地址计算\",\"观察上图，我们发现数组首个元素的索引为 $0$ ，这似乎有些反直觉，因为从 $1$ 开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是 0 ，因此它的索引为 0 是合理的。\",\"在数组中访问元素非常高效，我们可以在 O(1) 时间内随机访问数组中的任意一个元素。\",\"/* 随机访问元素 */ int randomAccess(int *nums, int size) { // 在区间 [0, size) 中随机抽取一个数字 int randomIndex = rand() % size; // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum; }\"]},\"12\":{\"h\":\"插入元素\",\"t\":[\"数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。\",\"数组插入元素示例\",\"值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。\",\"/* 在数组的索引 index 处插入元素 num */ void insert(int *nums, int size, int num, int index) { // 把索引 index 以及之后的所有元素向后移动一位 for (int i = size - 1; i > index; i--) { nums[i] = nums[i - 1]; } // 将 num 赋给 index 处的元素 nums[index] = num; }\"]},\"13\":{\"h\":\"删除元素\",\"t\":[\"同理，如下图所示，若想删除索引 $i$ 处的元素，则需要把索引 $i$ 之后的元素都向前移动一位。\",\"数组删除元素示例\",\"请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。\",\"/* 删除索引 index 处的元素 */ void remove(int *nums, int size, int index) { // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i < size - 1; i++) { nums[i] = nums[i + 1]; } }\",\"总的来看，数组的插入与删除操作有以下缺点。\",\"时间复杂度高：数组的插入和删除的平均时间复杂度均为 $O(n)$ ，其中 $n$ 为数组长度。\",\"丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。\",\"内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。\"]},\"14\":{\"h\":\"遍历数组\",\"t\":[\"在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：\",\"/* 遍历数组 */ void traverse(int *nums, int size) { int count = 0; // 通过索引遍历数组 for (int i = 0; i < size; i++) { count += nums[i]; } }\"]},\"15\":{\"h\":\"查找元素\",\"t\":[\"在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。\",\"因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。\",\"/* 在数组中查找指定元素 */ int find(int *nums, int size, int target) { for (int i = 0; i < size; i++) { if (nums[i] == target) return i; } return -1; }\"]},\"16\":{\"h\":\"扩容数组\",\"t\":[\"在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的。\",\"如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。代码如下所示：\",\"/* 扩展数组长度 */ int *extend(int *nums, int size, int enlarge) { // 初始化一个扩展长度后的数组 int *res = new int[size + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i < size; i++) { res[i] = nums[i]; } // 释放内存 delete[] nums; // 返回扩展后的新数组 return res; }\"]},\"17\":{\"h\":\"数组的优点与局限性\",\"t\":[\"数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\",\"空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\",\"支持随机访问：数组允许在 O(1) 时间内访问任何元素。\",\"缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\",\"连续空间存储是一把双刃剑，其存在以下局限性。\",\"插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\",\"长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\",\"空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\"]},\"18\":{\"h\":\"数组典型应用\",\"t\":[\"数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\",\"随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\",\"排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\",\"查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\",\"机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\",\"数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\"]},\"19\":{\"h\":\"链表\",\"t\":[\"内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。\",\"链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。\",\"链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。\",\"链表定义与存储方式\",\"观察上图，链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\",\"链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\",\"尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\",\"在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\",\"如以下代码所示，链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间。\",\"/* 链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向下一节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数 };\"]},\"20\":{\"h\":\"链表常用操作\"},\"21\":{\"h\":\"初始化链表\",\"t\":[\"建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点。\",\" /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */ // 初始化各个节点 ListNode* n0 = new ListNode(1); ListNode* n1 = new ListNode(3); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(5); ListNode* n4 = new ListNode(4); // 构建节点之间的引用 n0->next = n1; n1->next = n2; n2->next = n3; n3->next = n4;\",\"数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0 。\"]},\"22\":{\"h\":\"插入节点\",\"t\":[\"在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为 O(1) 。\",\"相比之下，在数组中插入元素的时间复杂度为 $O(n)$ ，在大数据量下的效率较低。\",\"链表插入节点示例\",\"/* 在链表的节点 n0 之后插入节点 P */ void insert(ListNode *n0, ListNode *P) { ListNode *n1 = n0->next; P->next = n1; n0->next = P; }\"]},\"23\":{\"h\":\"删除节点\",\"t\":[\"如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。\",\"请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\",\"链表删除节点\",\"/* 删除链表的节点 n0 之后的首个节点 */ void remove(ListNode *n0) { if (n0->next == nullptr) return; // n0 -> P -> n1 ListNode *P = n0->next; ListNode *n1 = P->next; n0->next = n1; // 释放内存 delete P; }\"]},\"24\":{\"h\":\"访问节点\",\"t\":[\"在链表中访问节点的效率较低。如上一节所述，我们可以在 O(1) 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i$ 个节点需要循环 i - 1 轮，时间复杂度为 O(n) 。\",\"/* 访问链表中索引为 index 的节点 */ ListNode *access(ListNode *head, int index) { for (int i = 0; i < index; i++) { if (head == nullptr) return nullptr; head = head->next; } return head; }\"]},\"25\":{\"h\":\"查找节点\",\"t\":[\"遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：\",\"/* 在链表中查找值为 target 的首个节点 */ int find(ListNode *head, int target) { int index = 0; while (head != nullptr) { if (head->val == target) return index; head = head->next; index++; } return -1; }\"]},\"26\":{\"h\":\"数组 vs. 链表\",\"t\":[\"下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。\",\"数组\",\"链表\",\"存储方式\",\"连续内存空间\",\"分散内存空间\",\"容量扩展\",\"长度不可变\",\"可灵活扩展\",\"内存效率\",\"元素占用内存少、但可能浪费空间\",\"元素占用内存多\",\"访问元素\",\"$O(1)$\",\"O(n)\",\"添加元素\",\"$O(n)$\",\"O(1)\",\"删除元素\",\"$O(n)$\",\"O(1)\"]},\"27\":{\"h\":\"常见链表类型\",\"t\":[\"如下图所示，常见的链表类型包括三种。\",\"单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\",\"环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\",\"双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\",\"/* 双向链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向后继节点的指针 ListNode *prev; // 指向前驱节点的指针 ListNode(int x) : val(x), next(nullptr), prev(nullptr) {} // 构造函数 };\",\"常见链表种类\"]},\"28\":{\"h\":\"链表典型应用\",\"t\":[\"单向链表通常用于实现栈、队列、哈希表和图等数据结构。\",\"栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。\",\"哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\",\"图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\",\"双向链表常用于需要快速查找前一个和后一个元素的场景。\",\"高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\",\"浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\",\"LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\",\"环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\",\"时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\",\"数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\"]},\"29\":{\"h\":\"列表\",\"t\":[\"列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。\",\"链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。\",\"数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。\",\"当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。\",\"为解决此问题，我们可以使用**动态数组（dynamic array）**来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\",\"实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。\"]},\"30\":{\"h\":\"列表常用操作\"},\"31\":{\"h\":\"初始化列表\",\"t\":[\"我们通常使用“无初始值”和“有初始值”这两种初始化方法：\",\"/* 初始化列表 */ // 需注意，C++ 中 vector 即是本文描述的 nums // 无初始值 vector<int> nums1; // 有初始值 vector<int> nums = { 1, 3, 2, 5, 4 };\"]},\"32\":{\"h\":\"访问元素\",\"t\":[\"列表本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。\",\" /* 访问元素 */ int num = nums[1]; // 访问索引 1 处的元素 /* 更新元素 */ nums[1] = 0; // 将索引 1 处的元素更新为 0\"]},\"33\":{\"h\":\"插入与删除元素\",\"t\":[\"相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。\",\"/* 清空列表 */ nums.clear(); /* 在尾部添加元素 */ nums.push_back(1); nums.push_back(3); nums.push_back(2); nums.push_back(5); nums.push_back(4); /* 在中间插入元素 */ nums.insert(nums.begin() + 3, 6); // 在索引 3 处插入数字 6 /* 删除元素 */ nums.erase(nums.begin() + 3); // 删除索引 3 处的元素\"]},\"34\":{\"h\":\"遍历列表\",\"t\":[\"与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。\",\" /* 通过索引遍历列表 */ int count = 0; for (int i = 0; i < nums.size(); i++) { count += nums[i]; } /* 直接遍历列表元素 */ count = 0; for (int num : nums) { count += num; }\"]},\"35\":{\"h\":\"列表实现\",\"t\":[\"许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。\",\"为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\",\"初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。\",\"数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\",\"扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。\"]},\"36\":{\"h\":\"重点回顾\",\"t\":[\"数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。\",\"数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。\",\"链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。\",\"列表是一种支持增删查改的元素有序集合，通常基于动态数组实现。它保留了数组的优势，同时可以灵活调整长度。\",\"列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。\",\"程序运行时，数据主要存储在内存中。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。\",\"缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。\",\"由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。\"]},\"37\":{\"h\":\"Q & A\",\"t\":[\"Q：数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？\",\"存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。\",\"分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。\",\"大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。\",\"灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。\",\"Q：为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？\",\"链表由节点组成，节点之间通过引用（指针）连接，各个节点可以存储不同类型的数据，例如 int、double、string、object 等。\",\"相对地，数组元素则必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节 和 8 字节 ，此时就不能用以下公式计算偏移量了，因为数组中包含了两种“元素长度”。\",\"# 元素内存地址 = 数组内存地址（首元素内存地址） + 元素长度 * 元素索引\",\"Q：删除节点 P 后，是否需要把 P.next 设为 None 呢？\",\"不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。\",\"从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。\",\"Q：在链表中插入和删除操作的时间复杂度是 $O(1)$ 。但是增删之前都需要 $O(n)$ 的时间查找元素，那为什么时间复杂度不是 $O(n)$ 呢？\",\"如果是先查找元素、再删除元素，时间复杂度确实是 $O(n)$ 。然而，链表的 $O(1)$ 增删的优势可以在其他应用上得到体现。例如，双向队列适合使用链表实现，我们维护一个指针变量始终指向头节点、尾节点，每次插入与删除操作都是 $O(1)$ 。\",\"Q：图“链表定义与存储方式”中，浅蓝色的存储节点指针是占用一块内存地址吗？还是和节点值各占一半呢？\",\"该示意图只是定性表示，定量表示需要根据具体情况进行分析。\",\"不同类型的节点值占用的空间是不同的，比如 int、long、double 和实例对象等。\",\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定，大多为 8 字节或 4 字节。\",\"Q：在列表末尾添加元素是否时时刻刻都为 $O(1)$ ？\",\"如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 $O(n)$ 。\",\"Q：“列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？\",\"这里的空间浪费主要有两方面含义：一方面，列表都会设定一个初始长度，我们不一定需要用这么多；另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 $\\\\times 1.5$ 。这样一来，也会出现很多空位，我们通常不能完全填满它们。\",\"Q：在 Python 中初始化 n = [1, 2, 3] 后，这 3 个元素的地址是相连的，但是初始化 m = [2, 1, 3] 会发现它们每个元素的 id 并不是连续的，而是分别跟 n 中的相同。这些元素的地址不连续，那么 m 还是数组吗？\",\"假如把列表元素换成链表节点 n = [n1, n2, n3, n4, n5] ，通常情况下这 5 个节点对象也分散存储在内存各处。然而，给定一个列表索引，我们仍然可以在 $O(1)$ 时间内获取节点内存地址，从而访问到对应的节点。这是因为数组中存储的是节点的引用，而非节点本身。\",\"与许多语言不同，Python 中的数字也被包装为对象，列表中存储的不是数字本身，而是对数字的引用。因此，我们会发现两个数组中的相同数字拥有同一个 id ，并且这些数字的内存地址无须连续。\",\"Q：C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？\",\"一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。\",\"空间开销：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以 std::list 通常比 std::vector 更占用空间。\",\"缓存不友好：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下，std::vector 的性能会更好。\",\"另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。\",\"Q：初始化列表 res = [0] * self.size() 操作，会导致 res 的每个元素引用相同的地址吗？\",\"不会。但二维数组会有这个问题，例如初始化二维列表 res = [[0]] * self.size() ，则多次引用了同一个列表 [0] 。\"]},\"38\":{\"c\":[\"数据结构\"]},\"39\":{\"c\":[\"c++\",\"线性结构\",\"数组\",\"链表\"]},\"40\":{\"h\":\"队列和栈\"},\"41\":{\"h\":\"队列\",\"t\":[\"队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\",\"如下图所示，我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。\",\"队列的先入先出规则\"]},\"42\":{\"h\":\"队列常用操作\",\"t\":[\"队列的常见操作如下表所示。需要注意的是，不同编程语言的方法名称可能会有所不同。我们在此采用与栈相同的方法命名。\",\"方法名\",\"描述\",\"时间复杂度\",\"push()\",\"元素入队，即将元素添加至队尾\",\"$O(1)$\",\"pop()\",\"队首元素出队\",\"$O(1)$\",\"peek()\",\"访问队首元素\",\"$O(1)$\",\"我们可以直接使用编程语言中现成的队列类：\",\" /* 初始化队列 */ queue<int> queue; /* 元素入队 */ queue.push(1); queue.push(3); queue.push(2); queue.push(5); queue.push(4); /* 访问队首元素 */ int front = queue.front(); /* 元素出队 */ queue.pop(); /* 获取队列的长度 */ int size = queue.size(); /* 判断队列是否为空 */ bool empty = queue.empty();\"]},\"43\":{\"h\":\"队列实现\",\"t\":[\"为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素，链表和数组都符合要求。\"]},\"44\":{\"h\":\"基于链表的实现\",\"t\":[\"如下图所示，我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。\",\"基于链表实现队列的入队出队操作\",\"linkedlist_queue_push\",\"linkedlist_queue_pop\",\"以下是用链表实现队列的代码：\",\"/* 基于链表实现的队列 */ class LinkedListQueue { private: ListNode *front, *rear; // 头节点 front ，尾节点 rear int queSize; public: LinkedListQueue() { front = nullptr; rear = nullptr; queSize = 0; } ~LinkedListQueue() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(front); } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return queSize == 0; } /* 入队 */ void push(int num) { // 在尾节点后添加 num ListNode *node = new ListNode(num); // 如果队列为空，则令头、尾节点都指向该节点 if (front == nullptr) { front = node; rear = node; } // 如果队列不为空，则将该节点添加到尾节点后 else { rear->next = node; rear = node; } queSize++; } /* 出队 */ int pop() { int num = peek(); // 删除头节点 ListNode *tmp = front; front = front->next; // 释放内存 delete tmp; queSize--; return num; } /* 访问队首元素 */ int peek() { if (size() == 0) throw out_of_range(\\\"队列为空\\\"); return front->val; } /* 将链表转化为 Vector 并返回 */ vector<int> toVector() { ListNode *node = front; vector<int> res(size()); for (int i = 0; i < res.size(); i++) { res[i] = node->val; node = node->next; } return res; } };\"]},\"45\":{\"h\":\"基于数组的实现\",\"t\":[\"在数组中删除首元素的时间复杂度为 $O(n)$ ，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。\",\"我们可以使用一个变量 front 指向队首元素的索引，并维护一个变量 size 用于记录队列长度。定义 rear = front + size ，这个公式计算出的 rear 指向队尾元素之后的下一个位置。\",\"基于此设计，数组中包含元素的有效区间为 [front, rear - 1]，各种操作的实现方法如下图所示。\",\"入队操作：将输入元素赋值给 rear 索引处，并将 size 增加 1 。\",\"出队操作：只需将 front 增加 1 ，并将 size 减少 1 。\",\"可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 $O(1)$ 。\",\"你可能会发现一个问题：在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。\",\"对于环形数组，我们需要让 front 或 rear 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示：\",\"/* 基于环形数组实现的队列 */ class ArrayQueue { private: int *nums; // 用于存储队列元素的数组 int front; // 队首指针，指向队首元素 int queSize; // 队列长度 int queCapacity; // 队列容量 public: ArrayQueue(int capacity) { // 初始化数组 nums = new int[capacity]; queCapacity = capacity; front = queSize = 0; } ~ArrayQueue() { delete[] nums; } /* 获取队列的容量 */ int capacity() { return queCapacity; } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return size() == 0; } /* 入队 */ void push(int num) { if (queSize == queCapacity) { cout << \\\"队列已满\\\" << endl; return; } // 计算队尾指针，指向队尾索引 + 1 // 通过取余操作实现 rear 越过数组尾部后回到头部 int rear = (front + queSize) % queCapacity; // 将 num 添加至队尾 nums[rear] = num; queSize++; } /* 出队 */ int pop() { int num = peek(); // 队首指针向后移动一位，若越过尾部，则返回到数组头部 front = (front + 1) % queCapacity; queSize--; return num; } /* 访问队首元素 */ int peek() { if (isEmpty()) throw out_of_range(\\\"队列为空\\\"); return nums[front]; } /* 将数组转化为 Vector 并返回 */ vector<int> toVector() { // 仅转换有效长度范围内的列表元素 vector<int> arr(queSize); for (int i = 0, j = front; i < queSize; i++, j++) { arr[i] = nums[j % queCapacity]; } return arr; } };\",\"以上实现的队列仍然具有局限性：其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的读者可以尝试自行实现。\",\"两种实现的对比结论与栈一致，在此不再赘述。\"]},\"46\":{\"h\":\"队列典型应用\",\"t\":[\"淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。\",\"各类待办事项。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。\"]},\"47\":{\"h\":\"栈\",\"t\":[\"栈（stack）是一种遵循先入后出逻辑的线性数据结构。\",\"我们可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。我们将盘子替换为各种类型的元素（如整数、字符、对象等），就得到了栈这种数据结构。\",\"如下图所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。\",\"栈的先入后出规则\"]},\"48\":{\"h\":\"栈的常用操作\",\"t\":[\"栈的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。在此，我们以常见的 push()、pop()、peek() 命名为例。\",\"方法\",\"描述\",\"时间复杂度\",\"push()\",\"元素入栈（添加至栈顶）\",\"O(1)\",\"pop()\",\"栈顶元素出栈\",\"O(1)\",\"peek()\",\"访问栈顶元素\",\"O(1)\",\"通常情况下，我们可以直接使用编程语言内置的栈类。然而，某些语言可能没有专门提供栈类，这时我们可以将该语言的“数组”或“链表”当作栈来使用，并在程序逻辑上忽略与栈无关的操作。\",\" /* 初始化栈 */ stack<int> stack; /* 元素入栈 */ stack.push(1); stack.push(3); stack.push(2); stack.push(5); stack.push(4); /* 访问栈顶元素 */ int top = stack.top(); /* 元素出栈 */ stack.pop(); // 无返回值 /* 获取栈的长度 */ int size = stack.size(); /* 判断是否为空 */ bool empty = stack.empty();\"]},\"49\":{\"h\":\"栈的实现\",\"t\":[\"为了深入了解栈的运行机制，我们来尝试自己实现一个栈类。\",\"栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素。然而，数组和链表都可以在任意位置添加和删除元素，因此栈可以视为一种受限制的数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。\"]},\"50\":{\"h\":\"基于链表的实现\",\"t\":[\"使用链表实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。\",\"如下图所示，对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。\",\"基于链表实现栈的入栈出栈操作\",\"linkedlist_stack_push\",\"linkedlist_stack_pop\",\"以下是基于链表实现栈的示例代码：\",\"/* 基于链表实现的栈 */ class LinkedListStack { private: ListNode *stackTop; // 将头节点作为栈顶 int stkSize; // 栈的长度 public: LinkedListStack() { stackTop = nullptr; stkSize = 0; } ~LinkedListStack() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(stackTop); } /* 获取栈的长度 */ int size() { return stkSize; } /* 判断栈是否为空 */ bool isEmpty() { return size() == 0; } /* 入栈 */ void push(int num) { ListNode *node = new ListNode(num); node->next = stackTop; stackTop = node; stkSize++; } /* 出栈 */ int pop() { int num = top(); ListNode *tmp = stackTop; stackTop = stackTop->next; // 释放内存 delete tmp; stkSize--; return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stackTop->val; } /* 将 List 转化为 Array 并返回 */ vector<int> toVector() { ListNode *node = stackTop; vector<int> res(size()); for (int i = res.size() - 1; i >= 0; i--) { res[i] = node->val; node = node->next; } return res; } };\"]},\"51\":{\"h\":\"基于数组的实现\",\"t\":[\"使用数组实现栈时，我们可以将数组的尾部作为栈顶。如下图所示，入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为 O(1) 。\",\"基于数组实现栈的入栈出栈操作\",\"array_stack_push\",\"array_stack_pop\",\"由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。以下为示例代码：\",\"/* 基于数组实现的栈 */ class ArrayStack { private: vector<int> stack; public: /* 获取栈的长度 */ int size() { return stack.size(); } /* 判断栈是否为空 */ bool isEmpty() { return stack.size() == 0; } /* 入栈 */ void push(int num) { stack.push_back(num); } /* 出栈 */ int pop() { int num = top(); stack.pop_back(); return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stack.back(); } /* 返回 Vector */ vector<int> toVector() { return stack; } };\"]},\"52\":{\"h\":\"两种实现对比\",\"t\":[\"支持操作\",\"两种实现都支持栈定义中的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到。\",\"时间效率\",\"在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为 O(n) 。\",\"在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。\",\"综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double ，我们可以得出以下结论。\",\"基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。\",\"基于链表实现的栈可以提供更加稳定的效率表现。\",\"空间效率\",\"在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费。\",\"然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。\",\"综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。\"]},\"53\":{\"h\":\"栈的典型应用\",\"t\":[\"浏览器中的后退与前进、软件中的撤销与反撤销。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。\",\"程序内存管理。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。\"]},\"54\":{\"h\":\"重点回顾\",\"t\":[\"栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。\",\"在时间效率方面，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 O(n) 。相比之下，栈的链表实现具有更为稳定的效率表现。\",\"在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。\",\"队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。\",\"双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。\"]},\"55\":{\"h\":\"Q & A\",\"t\":[\"Q：浏览器的前进后退是否是双向链表实现？\",\"浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便地实现一些额外操作，这个在“双向队列”章节有提到。\",\"Q：在出栈后，是否需要释放出栈节点的内存？\",\"如果后续仍需要使用弹出节点，则不需要释放内存。若之后不需要用到，Java 和 Python 等语言拥有自动垃圾回收机制，因此不需要手动释放内存；在 C 和 C++ 中需要手动释放内存。\",\"Q：双向队列像是两个栈拼接在了一起，它的用途是什么？\",\"双向队列就像是栈和队列的组合或两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。\",\"Q：撤销（undo）和反撤销（redo）具体是如何实现的？\",\"使用两个栈，栈 A 用于撤销，栈 B 用于反撤销。\",\"每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。\",\"当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。\",\"当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。\"]},\"56\":{\"c\":[\"数据结构\"]},\"57\":{\"c\":[\"c++\",\"栈\",\"队列\"]},\"58\":{\"h\":\"架构设计\"},\"59\":{\"c\":[\"架构设计\"]},\"60\":{\"h\":\"设计模式与设计原则\"},\"61\":{\"h\":\"设计模式\",\"t\":[\"设计模式是解决常见软件设计问题的通用解决方案。它们分为三大类：\",\"创建型模式：关注对象创建，如单例模式、工厂模式。\",\"结构型模式：关注对象组合，如适配器模式、代理模式。\",\"行为型模式：关注对象间通信，如观察者模式、策略模式。\"]},\"62\":{\"h\":\"设计原则\",\"t\":[\"设计原则是指导代码设计的基本准则，如：\",\"单一职责原则 (SRP)\",\"定义: 一个类应只有一个引起其变化的原因，即一个类只负责一项职责。\",\"目的: 提高代码的可维护性和可读性，减少类的复杂性。\",\"开闭原则 (OCP)\",\"定义: 软件实体应对扩展开放，对修改关闭。\",\"目的: 通过抽象和接口，允许添加新功能而无需修改现有代码，减少引入新 bug 的风险。\",\"里氏替换原则 (LSP)\",\"定义: 子类对象必须能够替换其父类对象且行为一致。\",\"目的: 保证继承层次的正确性，避免运行时错误。\",\"依赖倒置原则 (DIP)\",\"定义: 高层模块不应依赖于低层模块，二者都应该依赖于抽象；抽象不应依赖于细节，细节应该依赖于抽象。\",\"目的: 减少模块之间的耦合性，提高系统的灵活性和可扩展性。\",\"接口隔离原则 (ISP)\",\"定义: 不应强迫一个类依赖于它不需要的接口，接口应尽量细化。\",\"目的: 通过多个特定接口来代替单一的总接口，减少代码的复杂性，提高系统的灵活性。\"]},\"63\":{\"c\":[\"架构设计\"]},\"64\":{\"c\":[\"c++\",\"设计模式\",\"设计原则\"]},\"65\":{\"h\":\"观察者模式\"},\"66\":{\"c\":[\"架构设计\"]},\"67\":{\"c\":[\"c++\",\"设计模式\",\"观察者模式\",\"事件模式\"]},\"68\":{\"h\":\"策略模式\",\"t\":[\"策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装在独立的策略类中，使得它们可以互相替换。策略模式使得算法的变化不会影响到使用算法的客户类。\"]},\"69\":{\"h\":\"组成部分\",\"t\":[\"策略接口：定义算法的通用接口。\",\"具体策略类：实现策略接口的不同算法。\",\"上下文类：持有一个策略对象，并在运行时决定使用哪种策略。\"]},\"70\":{\"h\":\"例子\",\"t\":[\"假设我们有一个水果计价系统，需要计算不同水果的价格。可以通过策略模式将计算逻辑封装成独立的策略类，这样可以动态选择合适的计算策略。\",\"在使用策略模式时，可以轻松更改折扣策略，而无需修改订单类的代码，从而提高了代码的可扩展性和维护性。\"]},\"71\":{\"c\":[\"架构设计\"]},\"72\":{\"c\":[\"c++\",\"设计模式\",\"策略模式\"]},\"73\":{\"h\":\"书籍推荐\",\"t\":[\"推荐几本C++书籍，从入门，到进阶，到实战，一网打尽。\"]},\"74\":{\"h\":\"入门推荐\",\"t\":[\"<<C++ Primer>>\",\"前些年这本书可以说是C++入门必备，C++基础知识介绍的非常全面，缺点也很明显。。。就是是书太厚了-_-||\",\"<<C++20高级编程>>\",\"C++基础、C++进阶、C++20各种新特性、C++实战经验，本书都有涉及，内容丰富且有条理有深度，唯一的缺点，就是有点厚。\"]},\"75\":{\"h\":\"进阶推荐\",\"t\":[\"<<C++程序设计 进阶篇>>\",\"C++之父大作，关于C++，应该没谁比C++之父更有发言权吧，不过这本书我更推荐有一定基础，想提升C++达到进阶水平的朋友学习。\",\"<<Effective Modern C++>>\",\"本书介绍的多是C++11的新特性，如果C++98的朋友想进阶到C++11，推荐学习这本书。\",\"<<C++ Core Guidelines解析>>\",\"它的前身C++之父的很多心得经验的博客，英文不错的朋友可以直接看原文https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines，国内有大佬把它翻译成了中文书籍，内容质量很高，推荐阅读。\",\"<<深入理解计算机系统>>\",\"C++不能只学习语言本身，还需要对操作系统有深刻的理解，操作系统我只推荐这一本书。\"]},\"76\":{\"c\":[\"书籍\"]},\"77\":{\"h\":\"面试集锦\"},\"78\":{\"c\":[\"面试题\"]},\"79\":{\"h\":\"c++ 基础\"},\"80\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"81\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"82\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"83\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"84\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"85\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"86\":{\"c\":[\"面试题\"]},\"87\":{\"c\":[\"c++\"]},\"88\":{\"h\":\"进程编程\"},\"89\":{\"h\":\"进程状态\"},\"90\":{\"h\":\"进程的基本状态\",\"t\":[\"新建（New）：\",\"进程正在被创建，还未进入准备就绪队列。\",\"就绪（Ready）：\",\"进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。\",\"运行（Running）：\",\"进程正在 CPU 上执行代码。\",\"阻塞（Blocked）：\",\"进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。\",\"终止（Terminated）：\",\"进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。\"]},\"91\":{\"h\":\"进程状态之间的转换\",\"t\":[\"进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：\",\"新建 → 就绪：\",\"当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。\",\"就绪 → 运行：\",\"调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。\",\"运行 → 就绪：\",\"如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。\",\"运行 → 阻塞：\",\"当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。\",\"阻塞 → 就绪：\",\"当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。\",\"运行 → 终止：\",\"当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。\"]},\"92\":{\"h\":\"状态转换示意图\"},\"93\":{\"h\":\"僵尸进程\",\"t\":[\"僵尸进程（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 wait() 或 waitpid() 函数回收子进程的退出状态信息，从而导致的进程状态。\",\"具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 wait() 或 waitpid() 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。\"]},\"94\":{\"h\":\"僵尸进程的影响\",\"t\":[\"资源占用：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。\",\"系统管理的麻烦：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。\"]},\"95\":{\"h\":\"如何避免产生僵尸进程？\",\"t\":[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：\",\"及时调用 wait() 或 waitpid()：\",\"父进程在适当的时机调用 wait() 或 waitpid() 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。\",\"pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 wait(NULL); // 等待子进程结束并回收资源 }\",\"使用 SIGCHLD 信号处理子进程的结束：\",\"当子进程结束时，父进程会收到 SIGCHLD 信号。父进程可以在信号处理程序中调用 wait() 或 waitpid() 以回收子进程的资源。\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> #include <signal.h> void sigchld_handler(int signum) { // 等待所有已终止的子进程 while (waitpid(-1, NULL, WNOHANG) > 0); } int main() { // 注册 SIGCHLD 信号处理程序 signal(SIGCHLD, sigchld_handler); pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 // 父进程继续执行其任务 pause(); // 等待信号（例如 SIGCHLD） } return 0; }\",\"将子进程的父进程设置为 init 进程（或 systemd）：\",\"如果父进程在子进程结束前退出，子进程会被 init 进程（PID 为 1 的进程）接管。init 进程会自动调用 wait() 回收子进程的资源，避免僵尸进程的产生。可以通过调用 fork() 后使父进程退出，子进程被 init 接管。\",\"pid_t pid = fork(); if (pid > 0) { // 父进程退出 exit(0); } // 子进程继续执行 // 此时子进程的父进程是 init 进程\",\"采用 double fork() 技术：\",\"父进程通过 fork() 创建一个子进程，子进程再 fork() 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 init 进程接管。\",\"pid_t pid = fork(); if (pid == 0) { // 第一个子进程 pid_t pid2 = fork(); if (pid2 == 0) { // 孙子进程 // 在此处执行需要守护的任务 exit(0); } else { // 第一个子进程退出 exit(0); } } else { // 父进程等待第一个子进程退出 wait(NULL); }\",\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 wait() 系列函数、处理 SIGCHLD 信号、使用 init 进程接管孤儿进程或采用 double fork() 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。\"]},\"96\":{\"c\":[\"面试题\"]},\"97\":{\"c\":[\"c++\",\"多进程\",\"进程通信\"]},\"98\":{\"h\":\"线程编程\"},\"99\":{\"h\":\"线程创建\",\"t\":[\"// thread example #include <iostream> // std::cout #include <thread> // std::thread void foo() { // do stuff... } void bar(int x) { // do stuff... } int main() { std::thread first (foo); // spawn new thread that calls foo() std::thread second (bar,0); // spawn new thread that calls bar(0) std::cout << \\\"main, foo and bar now execute concurrently...\\\\n\\\"; // synchronize threads: first.join(); // pauses until first finishes second.join(); // pauses until second finishes std::cout << \\\"foo and bar completed.\\\\n\\\"; return 0; }\"]},\"100\":{\"h\":\"线程同步机制\"},\"101\":{\"h\":\"1. 互斥量 (Mutex)\",\"t\":[\"实现原理：\",\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问。具体实现步骤如下：\",\"基本结构：\",\"互斥量有一个内部状态，通常用布尔值或整数表示（锁定或未锁定）。\",\"维护一个等待队列，用于保存等待锁的线程。\",\"锁定 (Lock)：\",\"当一个线程尝试锁定互斥量时，如果互斥量未锁定，则线程成功锁定，并将互斥量状态设置为锁定。\",\"如果互斥量已锁定，则该线程进入等待队列并挂起，直到互斥量被解锁。\",\"解锁 (Unlock)：\",\"当一个线程解锁互斥量时，如果等待队列中有其他线程，则唤醒一个线程，使其尝试重新锁定互斥量。\",\"如果没有线程在等待，则将互斥量状态设置为未锁定。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> std::mutex mtx; void print_thread_id(int id) { std::lock_guard<std::mutex> guard(mtx); // 自动加锁和解锁 std::cout << \\\"Thread #\\\" << id << std::endl; } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_thread_id, i); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"102\":{\"h\":\"2. 读写锁 (Shared Mutex)\",\"t\":[\"实现原理：\",\"读写锁允许多个线程同时读取，但在写入时只允许一个线程操作。其实现原理如下：\",\"基本结构：\",\"读写锁包含两个计数器：一个用于记录当前正在读取的线程数，另一个用于记录是否有写线程在等待。\",\"维护一个等待队列，用于保存等待的线程。\",\"读锁定 (Read Lock)：\",\"当一个线程请求读锁定时，如果没有写锁存在，则增加读计数器，线程继续执行。\",\"如果有写锁存在，则线程进入等待队列。\",\"写锁定 (Write Lock)：\",\"当一个线程请求写锁定时，如果没有读锁和写锁存在，则锁定成功。\",\"如果有读锁或写锁存在，则线程进入等待队列。\",\"解锁 (Unlock)：\",\"当读线程解锁时，减少读计数器，如果读计数器为0且有写线程在等待，则唤醒一个写线程。\",\"当写线程解锁时，如果有读线程在等待，则唤醒所有读线程；如果有写线程在等待，则唤醒一个写线程。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <shared_mutex> #include <vector> std::shared_mutex rw_mtx; std::vector<int> data; void reader() { std::shared_lock<std::shared_mutex> lock(rw_mtx); for (const auto& d : data) { std::cout << d << \\\" \\\"; } std::cout << std::endl; } void writer(int value) { std::unique_lock<std::shared_mutex> lock(rw_mtx); data.push_back(value); } int main() { std::thread t1(writer, 1); std::thread t2(reader); std::thread t3(writer, 2); std::thread t4(reader); t1.join(); t2.join(); t3.join(); t4.join(); return 0; }\"]},\"103\":{\"h\":\"3. 条件变量 (Condition Variable)\",\"t\":[\"实现原理：\",\"条件变量用于线程之间的等待和通知机制。其实现原理如下：\",\"基本结构：\",\"条件变量与一个互斥量和一个条件状态相关联。\",\"维护一个等待队列，用于保存等待条件的线程。\",\"等待 (Wait)：\",\"线程在等待条件变量时，需要持有相关的互斥量。\",\"线程将自己添加到等待队列，并释放互斥量，等待条件变量的通知。\",\"通知 (Notify)：\",\"当一个线程修改条件状态并调用 notify_one 或 notify_all 时，唤醒一个或所有等待队列中的线程。\",\"被唤醒的线程重新获得互斥量，检查条件状态，如果条件满足，线程继续执行；如果条件不满足，线程再次进入等待状态。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> std::mutex cv_mtx; std::condition_variable cv; bool ready = false; void print_id(int id) { std::unique_lock<std::mutex> lock(cv_mtx); cv.wait(lock, [] { return ready; }); // 等待 ready 变为 true std::cout << \\\"Thread #\\\" << id << std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard<std::mutex> lock(cv_mtx); ready = true; } cv.notify_all(); // 唤醒所有等待的线程 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_id, i); } std::thread t(set_ready); for (auto& th : threads) { th.join(); } t.join(); return 0; }\",\"使用场景：\",\"条件变量常用于线程之间的协调，例如在生产者-消费者模型中，生产者线程通知消费者线程有新数据可用，消费者线程等待该通知。\"]},\"104\":{\"h\":\"4. 原子操作 (Atomic Operations)\",\"t\":[\"实现原理：\",\"原子操作通过硬件支持的指令集实现，保证在并发环境下操作的不可分割性。其实现原理如下：\",\"硬件支持：\",\"原子操作依赖于硬件提供的原子指令，如 compare-and-swap (CAS)、fetch-and-add 等，这些指令能够确保在多个线程操作同一数据时不会产生竞争条件。\",\"内存模型：\",\"C++ 中的 std::atomic 提供了对不同内存模型的支持，确保在不同平台上实现一致的原子操作行为。\",\"无需锁定：\",\"原子操作直接操作共享变量，不需要加锁解锁，因此在高并发场景下具有更好的性能。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> std::atomic<int> counter(0); void increment() { for (int i = 0; i < 1000; ++i) { ++counter; // 原子操作 } } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(increment); } for (auto& th : threads) { th.join(); } std::cout << \\\"Final counter value: \\\" << counter << std::endl; return 0; }\",\"使用场景：\",\"原子操作适用于需要高效并发访问的场景，如计数器、标志位等，避免使用锁机制带来的开销。\"]},\"105\":{\"h\":\"5. 信号量 (Semaphore)\",\"t\":[\"实现原理：\",\"信号量是一种控制对共享资源访问的计数器，分为计数信号量和二进制信号量。其实现原理如下：\",\"计数器：\",\"信号量内部维护一个计数器，表示当前可用资源的数量。计数器初始值通常为资源的总量。\",\"P 操作 (等待操作)：\",\"当一个线程执行 P 操作（wait 或 acquire）时，计数器减 1。如果计数器值为正，线程继续执行；如果计数器值为零或负，线程进入等待队列，等待资源释放。\",\"V 操作 (释放操作)：\",\"当一个线程执行 V 操作（signal 或 release）时，计数器加 1。如果有线程在等待队列中，唤醒一个线程，使其继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <semaphore> std::counting_semaphore<1> sem(1); void worker(int id) { sem.acquire(); // P 操作 std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); sem.release(); // V 操作 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"信号量适用于控制对资源的并发访问数量，例如限制同时访问文件的线程数、实现生产者-消费者模型等。\"]},\"106\":{\"h\":\"6. 自旋锁 (Spinlock)\",\"t\":[\"实现原理：\",\"自旋锁是一种忙等待锁，线程在尝试获取锁时会反复检查锁的状态，而不会阻塞或挂起。其实现原理如下：\",\"忙等待：\",\"当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，线程将反复检查锁的状态，直到锁可用为止。\",\"自旋锁通常通过硬件的原子操作实现，如 test-and-set、compare-and-swap 等。\",\"解锁：\",\"当持有锁的线程释放自旋锁时，其他线程可以成功获取锁并继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> class Spinlock { std::atomic_flag flag = ATOMIC_FLAG_INIT; public: void lock() { while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待 } void unlock() { flag.clear(std::memory_order_release); } }; Spinlock spinlock; void worker(int id) { spinlock.lock(); std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); spinlock.unlock(); } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"自旋锁适用于锁定时间非常短的场景，例如在中断上下文或需要避免线程调度开销的情况下使用。\"]},\"107\":{\"h\":\"7. 屏障 (Barrier)\",\"t\":[\"实现原理：\",\"屏障用于同步一组线程，确保所有线程都到达某个同步点后才能继续执行。其实现原理如下：\",\"计数器：\",\"屏障内部维护一个计数器，表示已到达屏障的线程数量。每当一个线程到达屏障点时，计数器减 1。\",\"等待机制：\",\"当计数器达到零时，表示所有线程都已到达屏障点，屏障解除，所有等待的线程继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <barrier> #include <vector> std::barrier sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" is waiting\\\" << std::endl; sync_point.arrive_and_wait(); // 等待所有线程到达屏障点 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"屏障适用于并行计算中需要同步多个线程的场景，例如在每个计算步骤完成后同步所有线程。\"]},\"108\":{\"h\":\"8. 锁存器 (Latch)\",\"t\":[\"实现原理：\",\"锁存器类似于屏障，但只能使用一次，线程等待直到锁存器倒数到零。其实现原理如下：\",\"倒数计数器：\",\"锁存器内部维护一个倒数计数器，表示需要完成的任务数量。每次完成任务时，计数器减 1。\",\"等待机制：\",\"当计数器减为零时，所有等待的线程被唤醒，继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <latch> #include <vector> std::latch sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" has reached the latch point\\\" << std::endl; sync_point.count_down(); // 锁存器计数减少 sync_point.wait(); // 等待所有线程到达锁存器 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景，例如初始化任务完成后启动主任务。\"]},\"109\":{\"h\":\"无锁编程\",\"t\":[\"无锁编程（Lock-Free Programming）是一种在多线程环境中实现并发访问的技术，目的是避免传统锁机制（如互斥锁）带来的性能开销和死锁风险。无锁编程主要依赖于原子操作和内存序列模型，以确保在没有锁的情况下实现线程安全。\"]},\"110\":{\"h\":\"1. 基本概念\",\"t\":[\"原子操作：原子操作是不可分割的，多个线程对同一变量进行原子操作时，不会引起数据竞争。\",\"CAS (Compare-and-Swap)：这是无锁编程的核心操作之一，它检查一个变量是否有特定的值，如果是，则将其更改为新值。这个操作是原子的，即在执行时不会被其他线程打断。\",\"内存序列模型：C++ 提供了一组内存序列模型（如 memory_order_relaxed、memory_order_acquire、memory_order_release 等），以控制并发操作的顺序性。\"]},\"111\":{\"h\":\"2. C++ 中的原子操作\",\"t\":[\"C++11 引入了 std::atomic 模板类，为实现无锁编程提供了基础设施。它支持以下操作：\",\"原子加载和存储\",\"原子递增和递减\",\"原子交换\",\"原子比较并交换（CAS）\"]},\"112\":{\"h\":\"3. 使用原子变量实现无锁队列\",\"t\":[\"下面是一个简单的无锁单生产者单消费者队列的实现示例：\",\"#include <atomic> #include <iostream> #include <thread> #include <vector> template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; // 使用 memory_order_release 确保更新操作一定在取值之后 head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } private: T* buffer; size_t capacity; std::atomic<size_t> head; std::atomic<size_t> tail; }; int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\"]},\"113\":{\"h\":\"4. 代码结构和作用\",\"t\":[\"类定义与构造函数\",\"template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; }\",\"LockFreeQueue 类是一个泛型队列，使用模板参数 T 来定义队列元素的类型。\",\"构造函数初始化队列的容量 capacity，并将 head 和 tail 指针初始化为 0。\",\"队列使用一个动态分配的数组 buffer 来存储元素。\",\"enqueue 方法\",\"bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; }\",\"enqueue 方法用于将一个元素插入队列。\",\"tail.load(std::memory_order_relaxed)：原子地加载当前的尾部指针 tail 的值。使用 memory_order_relaxed 是因为我们不需要同步其他内存操作，仅仅读取尾部的值。\",\"nextTail = (currentTail + 1) % capacity：计算插入元素后的尾部指针值，使用取模操作来实现循环队列。\",\"if (nextTail == head.load(std::memory_order_acquire))：检查队列是否已满。如果 nextTail 与头部指针 head 相等，说明队列已满。\",\"buffer[currentTail] = item：将元素存储在当前尾部指针所指向的位置。\",\"tail.store(nextTail, std::memory_order_release)：将新的尾部指针存储到 tail，并使用 memory_order_release 以确保插入操作完成后，其他线程能正确地看到更新的尾部指针。\",\"dequeue 方法\",\"bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; head.store((currentHead + 1) % capacity, std::memory_order_release); return true; }\",\"dequeue 方法用于从队列中取出一个元素。\",\"currentHead = head.load(std::memory_order_relaxed)：原子地加载当前的头部指针 head 的值。\",\"if (currentHead == tail.load(std::memory_order_acquire))：检查队列是否为空。如果 head 与 tail 相等，说明队列为空。\",\"item = buffer[currentHead]：将头部指针所指向的元素存储到 item 中。\",\"head.store((currentHead + 1) % capacity, std::memory_order_release)：更新头部指针，指向下一个元素的位置，并使用 memory_order_release 以确保取出操作完成后，其他线程能正确地看到更新的头部指针。\",\"主函数中的生产者和消费者\",\"int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\",\"在 main 函数中，创建了一个 LockFreeQueue 对象 queue，容量为 10。\",\"生产者线程 producer 向队列中插入元素，使用 while (!queue.enqueue(i)) 检查插入操作是否成功。如果队列已满，线程会持续等待直到成功插入。\",\"消费者线程 consumer 从队列中取出元素，使用 while (!queue.dequeue(item)) 检查取出操作是否成功。如果队列为空，线程会持续等待直到成功取出元素。\",\"两个线程同时运行，生产者插入数据，消费者取出数据，并输出相应的信息。\",\"最后，通过 join() 等待线程完成，确保主线程在两个子线程结束后才退出。\"]},\"114\":{\"h\":\"5. 内存顺序的选择\",\"t\":[\"memory_order_relaxed：用于没有数据依赖的地方，只要求操作是原子的，不需要同步内存顺序。适用于 load 和 store，如 tail.load(std::memory_order_relaxed)。\",\"memory_order_acquire：用于加载操作，以确保加载的结果及其后续的操作不会被重排序到 acquire 之前。适用于检查队列是否满或空，如 head.load(std::memory_order_acquire)。\",\"memory_order_release：用于存储操作，以确保在此之前的所有操作不会被重排序到 release 之后。适用于更新指针操作，如 tail.store(nextTail, std::memory_order_release)。\"]},\"115\":{\"c\":[\"面试题\"]},\"116\":{\"c\":[\"c++\",\"多线程\",\"线程同步\"]},\"117\":{\"h\":\"副业搞钱\"},\"118\":{\"c\":[\"副业\"]},\"119\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"120\":{\"h\":\"Books\"}},\"dirtCount\":0,\"index\":[[\"副业\",{\"2\":{\"118\":1}}],[\"副业搞钱\",{\"0\":{\"117\":1}}],[\"适用于更新指针操作\",{\"1\":{\"114\":1}}],[\"适用于检查队列是否满或空\",{\"1\":{\"114\":1}}],[\"适用于\",{\"1\":{\"114\":1}}],[\"最后\",{\"1\":{\"113\":1}}],[\"最后一个节点被称为\",{\"1\":{\"19\":1}}],[\"生产者插入数据\",{\"1\":{\"113\":1}}],[\"生产者线程\",{\"1\":{\"113\":1}}],[\"生产者线程通知消费者线程有新数据可用\",{\"1\":{\"103\":1}}],[\"向队列中插入元素\",{\"1\":{\"113\":1}}],[\"向下递推阶段会不断执行入栈操作\",{\"1\":{\"53\":1}}],[\"容量为\",{\"1\":{\"113\":1}}],[\"容量扩展\",{\"1\":{\"26\":1}}],[\"主函数中的生产者和消费者\",{\"1\":{\"113\":1}}],[\"主要有两个原因\",{\"1\":{\"37\":1}}],[\"主要有以下几部分\",{\"1\":{\"0\":1}}],[\"主要包含一些基本的\",{\"1\":{\"0\":1}}],[\"说明队列为空\",{\"1\":{\"113\":1}}],[\"说明队列已满\",{\"1\":{\"113\":1}}],[\"检查取出操作是否成功\",{\"1\":{\"113\":1}}],[\"检查插入操作是否成功\",{\"1\":{\"113\":1}}],[\"检查队列是否为空\",{\"1\":{\"113\":1}}],[\"检查队列是否已满\",{\"1\":{\"113\":1}}],[\"检查条件状态\",{\"1\":{\"103\":1}}],[\"仅仅读取尾部的值\",{\"1\":{\"113\":1}}],[\"仅转换有效长度范围内的列表元素\",{\"1\":{\"45\":1}}],[\"来存储元素\",{\"1\":{\"113\":1}}],[\"来定义队列元素的类型\",{\"1\":{\"113\":1}}],[\"来实现\",{\"1\":{\"45\":1}}],[\"来实现列表\",{\"1\":{\"29\":1}}],[\"启动消费者线程\",{\"1\":{\"112\":1,\"113\":1}}],[\"启动生产者线程\",{\"1\":{\"112\":1,\"113\":1}}],[\"模板类\",{\"1\":{\"111\":1}}],[\"引入了\",{\"1\":{\"111\":1}}],[\"引用记录了下一个节点的内存地址\",{\"1\":{\"19\":1}}],[\"引用\",{\"1\":{\"19\":3}}],[\"多线程\",{\"2\":{\"116\":1}}],[\"多个线程对同一变量进行原子操作时\",{\"1\":{\"110\":1}}],[\"多进程\",{\"2\":{\"97\":1}}],[\"带来的性能开销和死锁风险\",{\"1\":{\"109\":1}}],[\"继续执行\",{\"1\":{\"108\":1}}],[\"倒数计数器\",{\"1\":{\"108\":1}}],[\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景\",{\"1\":{\"108\":1}}],[\"锁存器计数减少\",{\"1\":{\"108\":1}}],[\"锁存器内部维护一个倒数计数器\",{\"1\":{\"108\":1}}],[\"锁存器类似于屏障\",{\"1\":{\"108\":1}}],[\"锁存器\",{\"0\":{\"108\":1}}],[\"锁定\",{\"1\":{\"101\":1}}],[\"锁定或未锁定\",{\"1\":{\"101\":1}}],[\"表示需要完成的任务数量\",{\"1\":{\"108\":1}}],[\"表示所有线程都已到达屏障点\",{\"1\":{\"107\":1}}],[\"表示已到达屏障的线程数量\",{\"1\":{\"107\":1}}],[\"表示当前可用资源的数量\",{\"1\":{\"105\":1}}],[\"确保主线程在两个子线程结束后才退出\",{\"1\":{\"113\":1}}],[\"确保更新操作一定在取值之后\",{\"1\":{\"112\":1}}],[\"确保所有线程都到达某个同步点后才能继续执行\",{\"1\":{\"107\":1}}],[\"确保在不同平台上实现一致的原子操作行为\",{\"1\":{\"104\":1}}],[\"屏障适用于并行计算中需要同步多个线程的场景\",{\"1\":{\"107\":1}}],[\"屏障解除\",{\"1\":{\"107\":1}}],[\"屏障内部维护一个计数器\",{\"1\":{\"107\":1}}],[\"屏障用于同步一组线程\",{\"1\":{\"107\":1}}],[\"屏障\",{\"0\":{\"107\":1}}],[\"屏蔽\",{\"1\":{\"49\":1}}],[\"7\",{\"0\":{\"107\":1}}],[\"忙等待\",{\"1\":{\"106\":1}}],[\"自旋等待\",{\"1\":{\"106\":1}}],[\"自旋锁适用于锁定时间非常短的场景\",{\"1\":{\"106\":1}}],[\"自旋锁通常通过硬件的原子操作实现\",{\"1\":{\"106\":1}}],[\"自旋锁是一种忙等待锁\",{\"1\":{\"106\":1}}],[\"自旋锁\",{\"0\":{\"106\":1}}],[\"自动加锁和解锁\",{\"1\":{\"101\":1}}],[\"计数器加\",{\"1\":{\"105\":1}}],[\"计数器减\",{\"1\":{\"105\":1,\"107\":1,\"108\":1}}],[\"计数器初始值通常为资源的总量\",{\"1\":{\"105\":1}}],[\"计数器\",{\"1\":{\"105\":1,\"107\":1}}],[\"计算插入元素后的尾部指针值\",{\"1\":{\"113\":1}}],[\"计算队尾指针\",{\"1\":{\"45\":1}}],[\"计算机不仅会加载它\",{\"1\":{\"17\":1}}],[\"标志位等\",{\"1\":{\"104\":1}}],[\"硬件支持\",{\"1\":{\"104\":1}}],[\"原子地加载当前的头部指针\",{\"1\":{\"113\":1}}],[\"原子地加载当前的尾部指针\",{\"1\":{\"113\":1}}],[\"原子比较并交换\",{\"1\":{\"111\":1}}],[\"原子交换\",{\"1\":{\"111\":1}}],[\"原子递增和递减\",{\"1\":{\"111\":1}}],[\"原子加载和存储\",{\"1\":{\"111\":1}}],[\"原子操作是不可分割的\",{\"1\":{\"110\":1}}],[\"原子操作适用于需要高效并发访问的场景\",{\"1\":{\"104\":1}}],[\"原子操作直接操作共享变量\",{\"1\":{\"104\":1}}],[\"原子操作依赖于硬件提供的原子指令\",{\"1\":{\"104\":1}}],[\"原子操作通过硬件支持的指令集实现\",{\"1\":{\"104\":1}}],[\"原子操作\",{\"0\":{\"104\":1},\"1\":{\"104\":1,\"110\":1}}],[\"原先末尾的元素变得\",{\"1\":{\"13\":1}}],[\"消费者取出数据\",{\"1\":{\"113\":1}}],[\"消费者线程\",{\"1\":{\"113\":1}}],[\"消费者线程等待该通知\",{\"1\":{\"103\":1}}],[\"消费者模型等\",{\"1\":{\"105\":1}}],[\"消费者模型中\",{\"1\":{\"103\":1}}],[\"唤醒一个线程\",{\"1\":{\"105\":1}}],[\"唤醒一个或所有等待队列中的线程\",{\"1\":{\"103\":1}}],[\"唤醒所有等待的线程\",{\"1\":{\"103\":1}}],[\"变为\",{\"1\":{\"103\":1}}],[\"条件变量常用于线程之间的协调\",{\"1\":{\"103\":1}}],[\"条件变量与一个互斥量和一个条件状态相关联\",{\"1\":{\"103\":1}}],[\"条件变量用于线程之间的等待和通知机制\",{\"1\":{\"103\":1}}],[\"条件变量\",{\"0\":{\"103\":1}}],[\"写锁定\",{\"1\":{\"102\":1}}],[\"读锁定\",{\"1\":{\"102\":1}}],[\"读写锁包含两个计数器\",{\"1\":{\"102\":1}}],[\"读写锁允许多个线程同时读取\",{\"1\":{\"102\":1}}],[\"读写锁\",{\"0\":{\"102\":1}}],[\"另一个用于记录是否有写线程在等待\",{\"1\":{\"102\":1}}],[\"另一方面\",{\"1\":{\"37\":2}}],[\"解锁\",{\"1\":{\"101\":1,\"102\":1,\"106\":1}}],[\"维护一个等待队列\",{\"1\":{\"101\":1,\"102\":1,\"103\":1}}],[\"互斥量有一个内部状态\",{\"1\":{\"101\":1}}],[\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问\",{\"1\":{\"101\":1}}],[\"互斥量\",{\"0\":{\"101\":1}}],[\"选择适当的方法管理子进程的生命周期\",{\"1\":{\"95\":1}}],[\"选取一个合理的数组初始容量\",{\"1\":{\"35\":1}}],[\"系列函数\",{\"1\":{\"95\":1}}],[\"系统管理的麻烦\",{\"1\":{\"94\":1}}],[\"系统\",{\"1\":{\"93\":1}}],[\"系统将其从内存中清除\",{\"1\":{\"91\":1}}],[\"系统将其从内存中移除\",{\"1\":{\"90\":1}}],[\"系统都会在栈顶添加一个栈帧\",{\"1\":{\"53\":1}}],[\"系统会为列表分配\",{\"1\":{\"52\":1}}],[\"系统会申请一块新的内存\",{\"1\":{\"37\":1}}],[\"系统随后会根据顺序处理队列中的订单\",{\"1\":{\"46\":1}}],[\"系统可以利用这些信息来优化数据结构的操作效率\",{\"1\":{\"17\":1}}],[\"孙子进程\",{\"1\":{\"95\":1}}],[\"孙子进程则由\",{\"1\":{\"95\":1}}],[\"创建了一个\",{\"1\":{\"113\":1}}],[\"创建一个孙子进程\",{\"1\":{\"95\":1}}],[\"创建一个子进程\",{\"1\":{\"95\":1}}],[\"创建型模式\",{\"1\":{\"61\":1}}],[\"采用\",{\"1\":{\"95\":1}}],[\"回收子进程的资源\",{\"1\":{\"95\":1}}],[\"接管\",{\"1\":{\"95\":2}}],[\"接口应尽量细化\",{\"1\":{\"62\":1}}],[\"接口隔离原则\",{\"1\":{\"62\":1}}],[\"注册\",{\"1\":{\"95\":1}}],[\"has\",{\"1\":{\"108\":1}}],[\"handler\",{\"1\":{\"95\":2}}],[\"h>\",{\"1\":{\"95\":3}}],[\"head\",{\"1\":{\"24\":5,\"25\":5,\"112\":5,\"113\":11,\"114\":1}}],[\"信号量适用于控制对资源的并发访问数量\",{\"1\":{\"105\":1}}],[\"信号量内部维护一个计数器\",{\"1\":{\"105\":1}}],[\"信号量是一种控制对共享资源访问的计数器\",{\"1\":{\"105\":1}}],[\"信号量\",{\"0\":{\"105\":1}}],[\"信号处理程序\",{\"1\":{\"95\":1}}],[\"信号处理子进程的结束\",{\"1\":{\"95\":1}}],[\"信号\",{\"1\":{\"95\":2}}],[\"父进程等待第一个子进程退出\",{\"1\":{\"95\":1}}],[\"父进程只需等待子进程的退出状态\",{\"1\":{\"95\":1}}],[\"父进程通过\",{\"1\":{\"95\":1}}],[\"父进程退出\",{\"1\":{\"95\":1}}],[\"父进程继续执行其任务\",{\"1\":{\"95\":1}}],[\"父进程可以在信号处理程序中调用\",{\"1\":{\"95\":1}}],[\"父进程会收到\",{\"1\":{\"95\":1}}],[\"父进程代码\",{\"1\":{\"95\":2}}],[\"父进程在适当的时机调用\",{\"1\":{\"95\":1}}],[\"及时调用\",{\"1\":{\"95\":1}}],[\"避免使用锁机制带来的开销\",{\"1\":{\"104\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"95\":1}}],[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态\",{\"1\":{\"95\":1}}],[\"避免运行时错误\",{\"1\":{\"62\":1}}],[\"虽然僵尸进程不会占用内存或\",{\"1\":{\"94\":1}}],[\"仍然保留在系统中\",{\"1\":{\"93\":1}}],[\"仍然指向\",{\"1\":{\"23\":1}}],[\"文件描述符等\",{\"1\":{\"93\":1}}],[\"working\",{\"1\":{\"105\":1,\"106\":1}}],[\"worker\",{\"1\":{\"105\":2,\"106\":2,\"107\":2,\"108\":2}}],[\"writer\",{\"1\":{\"102\":3}}],[\"write\",{\"1\":{\"102\":1}}],[\"wnohang\",{\"1\":{\"95\":1}}],[\"waiting\",{\"1\":{\"107\":1}}],[\"waitpid\",{\"1\":{\"93\":2,\"95\":4}}],[\"wait\",{\"1\":{\"93\":2,\"95\":8,\"103\":2,\"105\":1,\"107\":1,\"108\":1}}],[\"while\",{\"1\":{\"25\":1,\"95\":1,\"106\":1,\"112\":2,\"113\":4}}],[\"子进程再\",{\"1\":{\"95\":1}}],[\"子进程继续执行\",{\"1\":{\"95\":1}}],[\"子进程被\",{\"1\":{\"95\":1}}],[\"子进程会被\",{\"1\":{\"95\":1}}],[\"子进程代码\",{\"1\":{\"95\":2}}],[\"子进程终止后\",{\"1\":{\"93\":1}}],[\"子类对象必须能够替换其父类对象且行为一致\",{\"1\":{\"62\":1}}],[\"unique\",{\"1\":{\"102\":1,\"103\":1}}],[\"unix\",{\"1\":{\"93\":2}}],[\"unlock\",{\"1\":{\"101\":1,\"102\":1,\"106\":2}}],[\"until\",{\"1\":{\"99\":2}}],[\"undo\",{\"1\":{\"55\":1}}],[\"zombie\",{\"1\":{\"93\":1}}],[\"zfooei\",{\"1\":{\"84\":1}}],[\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的\",{\"1\":{\"95\":1}}],[\"僵尸进程的影响\",{\"0\":{\"94\":1}}],[\"僵尸进程的进程描述符才会被完全清除\",{\"1\":{\"93\":1}}],[\"僵尸进程\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"状态转换示意图\",{\"0\":{\"92\":1}}],[\"被唤醒的线程重新获得互斥量\",{\"1\":{\"103\":1}}],[\"被释放给其他就绪进程\",{\"1\":{\"91\":1}}],[\"被mutable\",{\"1\":{\"85\":1}}],[\"调度器选择一个就绪的进程并将其分配给\",{\"1\":{\"91\":1}}],[\"调度算法\",{\"1\":{\"28\":1}}],[\"→\",{\"1\":{\"91\":6}}],[\"终止\",{\"1\":{\"90\":1,\"91\":1}}],[\"发生\",{\"1\":{\"90\":1}}],[\"完成或资源可用\",{\"1\":{\"91\":1}}],[\"完成\",{\"1\":{\"90\":1}}],[\"正在等待某个事件\",{\"1\":{\"90\":1}}],[\"阻塞的进程会被移回就绪队列\",{\"1\":{\"91\":1}}],[\"阻塞\",{\"1\":{\"90\":1,\"91\":2}}],[\"运行\",{\"1\":{\"90\":1,\"91\":4}}],[\"资源占用\",{\"1\":{\"94\":1}}],[\"资源可用\",{\"1\":{\"90\":1}}],[\"资源\",{\"1\":{\"90\":1}}],[\"新建\",{\"1\":{\"90\":1,\"91\":1}}],[\"问题\",{\"1\":{\"84\":1}}],[\"语言一样的方式\",{\"1\":{\"84\":1}}],[\"保证在并发环境下操作的不可分割性\",{\"1\":{\"104\":1}}],[\"保证继承层次的正确性\",{\"1\":{\"62\":1}}],[\"保持与c\",{\"1\":{\"84\":1}}],[\"让c++\",{\"1\":{\"84\":1}}],[\"函数中\",{\"1\":{\"113\":1}}],[\"函数\",{\"1\":{\"95\":1}}],[\"函数回收子进程的退出状态信息\",{\"1\":{\"93\":1}}],[\"函数时会失败\",{\"1\":{\"84\":1}}],[\"函数名被修饰成\",{\"1\":{\"84\":1}}],[\"函数return\",{\"1\":{\"80\":1}}],[\"技术\",{\"1\":{\"84\":1,\"95\":2}}],[\"用来定义常量和函数\",{\"1\":{\"83\":1}}],[\"用于存储操作\",{\"1\":{\"114\":1}}],[\"用于存储队列元素的数组\",{\"1\":{\"45\":1}}],[\"用于加载操作\",{\"1\":{\"114\":1}}],[\"用于没有数据依赖的地方\",{\"1\":{\"114\":1}}],[\"用于保存等待条件的线程\",{\"1\":{\"103\":1}}],[\"用于保存等待的线程\",{\"1\":{\"102\":1}}],[\"用于保存等待锁的线程\",{\"1\":{\"101\":1}}],[\"用于函数穿参数\",{\"1\":{\"85\":1}}],[\"用于反撤销\",{\"1\":{\"55\":1}}],[\"用于撤销\",{\"1\":{\"55\":1}}],[\"用于记录函数的上下文信息\",{\"1\":{\"53\":1}}],[\"用于记录队列长度\",{\"1\":{\"45\":1}}],[\"用于记录列表当前元素数量\",{\"1\":{\"35\":1}}],[\"宏没有类型安全检查\",{\"1\":{\"83\":1}}],[\"宏用于定义常量和简单的代码片段\",{\"1\":{\"83\":1}}],[\"宏与constexpr\",{\"0\":{\"83\":1}}],[\"区别\",{\"0\":{\"83\":1}}],[\"地址值+sizeof\",{\"1\":{\"82\":2}}],[\"三者做运算时有差异\",{\"1\":{\"82\":1}}],[\"都会被操作系统回收\",{\"1\":{\"93\":1}}],[\"都是一个指针代表一个内存\",{\"1\":{\"82\":1}}],[\"都在向右移动\",{\"1\":{\"45\":1}}],[\"析构函数\",{\"1\":{\"81\":2}}],[\"释放操作\",{\"1\":{\"105\":1}}],[\"释放对象的操作符\",{\"1\":{\"81\":1}}],[\"释放内存的基础上还会额外调用构造\",{\"1\":{\"81\":1}}],[\"释放内存\",{\"1\":{\"16\":1,\"23\":1,\"44\":2,\"50\":2}}],[\"类是一个泛型队列\",{\"1\":{\"113\":1}}],[\"类定义与构造函数\",{\"1\":{\"113\":1}}],[\"类成员或函数可以直接通过类名访问无需创建对象\",{\"1\":{\"80\":1}}],[\"类似于双向链表\",{\"1\":{\"28\":1}}],[\"延长变量的生命周期为整个程序的生命周期\",{\"1\":{\"80\":1}}],[\"限制作用范围\",{\"1\":{\"80\":1}}],[\"修饰除外\",{\"1\":{\"85\":1}}],[\"修饰成员函数表示函数体不会修改类成员\",{\"1\":{\"85\":1}}],[\"修饰局部变量\",{\"1\":{\"80\":1}}],[\"修饰全局变量或函数\",{\"1\":{\"80\":1}}],[\"修改\",{\"1\":{\"29\":1}}],[\"面试题\",{\"2\":{\"78\":1,\"86\":1,\"96\":1,\"115\":1}}],[\"面试题和数据结构算法\",{\"1\":{\"0\":1}}],[\"面试集锦\",{\"0\":{\"77\":1}}],[\"书籍\",{\"2\":{\"76\":1}}],[\"书籍推荐\",{\"0\":{\"73\":1}}],[\"国内有大佬把它翻译成了中文书籍\",{\"1\":{\"75\":1}}],[\"英文不错的朋友可以直接看原文https\",{\"1\":{\"75\":1}}],[\"guard\",{\"1\":{\"101\":1}}],[\"guard<std\",{\"1\":{\"101\":1,\"103\":1}}],[\"guidelines解析>>\",{\"1\":{\"75\":1}}],[\"github\",{\"1\":{\"75\":1}}],[\"go\",{\"1\":{\"19\":1}}],[\"推荐阅读\",{\"1\":{\"75\":1}}],[\"推荐学习这本书\",{\"1\":{\"75\":1}}],[\"推荐几本c++书籍\",{\"1\":{\"73\":1}}],[\"想提升c++达到进阶水平的朋友学习\",{\"1\":{\"75\":1}}],[\"关键字的作用\",{\"0\":{\"80\":1,\"85\":1}}],[\"关于c++\",{\"1\":{\"75\":1}}],[\"关注对象间通信\",{\"1\":{\"61\":1}}],[\"关注对象组合\",{\"1\":{\"61\":1}}],[\"关注对象创建\",{\"1\":{\"61\":1}}],[\"唯一的缺点\",{\"1\":{\"74\":1}}],[\"内容质量很高\",{\"1\":{\"75\":1}}],[\"内容丰富且有条理有深度\",{\"1\":{\"74\":1}}],[\"内存顺序的选择\",{\"0\":{\"114\":1}}],[\"内存序列模型\",{\"1\":{\"110\":1}}],[\"内存模型\",{\"1\":{\"104\":1}}],[\"内存地址偏移一个数组的位置\",{\"1\":{\"82\":1}}],[\"内存效率\",{\"1\":{\"26\":1}}],[\"内存可能无法提供如此大的连续空间\",{\"1\":{\"19\":1}}],[\"内存空间是所有程序的公共资源\",{\"1\":{\"19\":1}}],[\"内存浪费\",{\"1\":{\"13\":1}}],[\"本书介绍的多是c++11的新特性\",{\"1\":{\"75\":1}}],[\"本书都有涉及\",{\"1\":{\"74\":1}}],[\"本站是一个面向\",{\"1\":{\"0\":1}}],[\"||\",{\"1\":{\"74\":1}}],[\"就会进入就绪状态\",{\"1\":{\"91\":1}}],[\"就绪\",{\"1\":{\"90\":1,\"91\":4}}],[\"就是有点厚\",{\"1\":{\"74\":1}}],[\"就是是书太厚了\",{\"1\":{\"74\":1}}],[\"就得到了栈这种数据结构\",{\"1\":{\"47\":1}}],[\"缺点也很明显\",{\"1\":{\"74\":1}}],[\"前些年这本书可以说是c++入门必备\",{\"1\":{\"74\":1}}],[\"到实战\",{\"1\":{\"73\":1}}],[\"到进阶\",{\"1\":{\"73\":1}}],[\"例子\",{\"0\":{\"70\":1}}],[\"例如在每个计算步骤完成后同步所有线程\",{\"1\":{\"107\":1}}],[\"例如在中断上下文或需要避免线程调度开销的情况下使用\",{\"1\":{\"106\":1}}],[\"例如在生产者\",{\"1\":{\"103\":1}}],[\"例如限制同时访问文件的线程数\",{\"1\":{\"105\":1}}],[\"例如打印机的任务队列\",{\"1\":{\"46\":1}}],[\"例如初始化任务完成后启动主任务\",{\"1\":{\"108\":1}}],[\"例如初始化二维列表\",{\"1\":{\"37\":1}}],[\"例如初始容量\",{\"1\":{\"35\":1}}],[\"例如\",{\"1\":{\"18\":1,\"29\":1,\"35\":1,\"37\":3,\"52\":2,\"95\":1}}],[\"持有一个策略对象\",{\"1\":{\"69\":1}}],[\"策略接口\",{\"1\":{\"69\":1}}],[\"策略模式使得算法的变化不会影响到使用算法的客户类\",{\"1\":{\"68\":1}}],[\"策略模式\",{\"0\":{\"68\":1},\"1\":{\"3\":1,\"61\":1,\"68\":1},\"2\":{\"72\":1}}],[\"组成部分\",{\"0\":{\"69\":1}}],[\"事件模式\",{\"2\":{\"67\":1}}],[\"观察者模式\",{\"0\":{\"65\":1},\"2\":{\"67\":1}}],[\"观察上图\",{\"1\":{\"11\":1,\"19\":1}}],[\"细节应该依赖于抽象\",{\"1\":{\"62\":1}}],[\"抽象不应依赖于细节\",{\"1\":{\"62\":1}}],[\"二者都应该依赖于抽象\",{\"1\":{\"62\":1}}],[\"二分查找等都主要在数组上进行\",{\"1\":{\"18\":1}}],[\"依赖倒置原则\",{\"1\":{\"62\":1}}],[\"依次访问所有节点\",{\"1\":{\"21\":1}}],[\"里氏替换原则\",{\"1\":{\"62\":1}}],[\"里面的\",{\"1\":{\"37\":1}}],[\"允许添加新功能而无需修改现有代码\",{\"1\":{\"62\":1}}],[\"软件实体应对扩展开放\",{\"1\":{\"62\":1}}],[\"软件中的撤销与反撤销\",{\"1\":{\"53\":1}}],[\"提供了一组内存序列模型\",{\"1\":{\"110\":1}}],[\"提供了对不同内存模型的支持\",{\"1\":{\"104\":1}}],[\"提供快速数据访问\",{\"1\":{\"36\":1}}],[\"提高系统的灵活性\",{\"1\":{\"62\":1}}],[\"提高系统的灵活性和可扩展性\",{\"1\":{\"62\":1}}],[\"提高代码的可维护性和可读性\",{\"1\":{\"62\":1}}],[\"目的是避免传统锁机制\",{\"1\":{\"109\":1}}],[\"目的\",{\"1\":{\"62\":5}}],[\"行为型模式\",{\"1\":{\"61\":1}}],[\"代码结构和作用\",{\"0\":{\"113\":1}}],[\"代码示例\",{\"1\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1}}],[\"代码的存在的link\",{\"1\":{\"84\":1}}],[\"代码编译时不使用name\",{\"1\":{\"84\":1}}],[\"代码link\",{\"1\":{\"84\":1}}],[\"代码如下所示\",{\"1\":{\"16\":1,\"25\":1,\"45\":1}}],[\"代理模式\",{\"1\":{\"61\":1}}],[\"结构型模式\",{\"1\":{\"61\":1}}],[\"工厂模式\",{\"1\":{\"61\":1}}],[\"反撤销\",{\"1\":{\"55\":1}}],[\"时\",{\"1\":{\"55\":2,\"91\":1,\"103\":1,\"105\":2}}],[\"时间效率\",{\"1\":{\"52\":1}}],[\"时间片轮转调度算法是一种常见的\",{\"1\":{\"28\":1}}],[\"时间片轮转调度算法\",{\"1\":{\"28\":1}}],[\"时间下访问数组中的任意元素\",{\"1\":{\"24\":1}}],[\"时间复杂度都为\",{\"1\":{\"51\":1}}],[\"时间复杂度均为\",{\"1\":{\"45\":1}}],[\"时间复杂度\",{\"1\":{\"42\":1,\"48\":1}}],[\"时间复杂度确实是\",{\"1\":{\"37\":1}}],[\"时间复杂度为\",{\"1\":{\"22\":1,\"24\":1,\"33\":1}}],[\"时间复杂度高\",{\"1\":{\"13\":1}}],[\"时间内获取节点内存地址\",{\"1\":{\"37\":1}}],[\"时间内访问和更新元素\",{\"1\":{\"32\":1}}],[\"时间内访问任何元素\",{\"1\":{\"17\":1}}],[\"时间内随机访问数组中的任意一个元素\",{\"1\":{\"11\":1}}],[\"撤销\",{\"1\":{\"55\":2}}],[\"章节有提到\",{\"1\":{\"55\":1}}],[\"章节中讨论\",{\"1\":{\"12\":1}}],[\"综上\",{\"1\":{\"52\":1}}],[\"综上所述\",{\"1\":{\"52\":1}}],[\"进程通信\",{\"2\":{\"97\":1}}],[\"进程接管孤儿进程或采用\",{\"1\":{\"95\":1}}],[\"进程接管\",{\"1\":{\"95\":1}}],[\"进程会自动调用\",{\"1\":{\"95\":1}}],[\"进程\",{\"1\":{\"95\":3}}],[\"进程表项的数量是有限的\",{\"1\":{\"94\":1}}],[\"进程进入终止状态\",{\"1\":{\"91\":1}}],[\"进程进入阻塞状态\",{\"1\":{\"91\":1}}],[\"进程进入运行状态\",{\"1\":{\"91\":1}}],[\"进程在其生命周期内可以在不同状态之间进行转换\",{\"1\":{\"91\":1}}],[\"进程已完成执行或因某种原因被强制终止\",{\"1\":{\"90\":1}}],[\"进程已经被创建并准备好执行\",{\"1\":{\"90\":1}}],[\"进程无法继续执行\",{\"1\":{\"90\":1}}],[\"进程正在\",{\"1\":{\"90\":1}}],[\"进程正在被创建\",{\"1\":{\"90\":1}}],[\"进程的基本状态\",{\"0\":{\"90\":1}}],[\"进程状态之间的转换\",{\"0\":{\"91\":1}}],[\"进程状态\",{\"0\":{\"89\":1}}],[\"进程编程\",{\"0\":{\"88\":1},\"1\":{\"1\":1}}],[\"进阶篇>>\",{\"1\":{\"75\":1}}],[\"进阶推荐\",{\"0\":{\"75\":1}}],[\"进行扩容的\",{\"1\":{\"52\":1}}],[\"该页面会从栈顶弹出\",{\"1\":{\"55\":1}}],[\"该页面会被添加到栈顶\",{\"1\":{\"55\":1}}],[\"该容量可能超出实际需求\",{\"1\":{\"52\":1}}],[\"该示意图只是定性表示\",{\"1\":{\"37\":1}}],[\"导致该次入栈操作的时间复杂度变为\",{\"1\":{\"52\":1}}],[\"具体实现步骤如下\",{\"1\":{\"101\":1}}],[\"具体来说\",{\"1\":{\"93\":1}}],[\"具体策略类\",{\"1\":{\"69\":1}}],[\"具体是如何实现的\",{\"1\":{\"55\":1}}],[\"具体的方法名需要根据所使用的编程语言来确定\",{\"1\":{\"48\":1}}],[\"具有很好的缓存本地性\",{\"1\":{\"52\":1}}],[\"返回\",{\"1\":{\"51\":1}}],[\"返回扩展后的新数组\",{\"1\":{\"16\":1}}],[\"转化为\",{\"1\":{\"50\":1}}],[\"头插法\",{\"1\":{\"50\":1}}],[\"头节点\",{\"1\":{\"19\":1,\"44\":2}}],[\"使其继续执行\",{\"1\":{\"105\":1}}],[\"使其尝试重新锁定互斥量\",{\"1\":{\"101\":1}}],[\"使其对外表现的逻辑符合栈的特性\",{\"1\":{\"49\":1}}],[\"使得它们可以互相替换\",{\"1\":{\"68\":1}}],[\"使用取模操作来实现循环队列\",{\"1\":{\"113\":1}}],[\"使用模板参数\",{\"1\":{\"113\":1}}],[\"使用原子变量实现无锁队列\",{\"0\":{\"112\":1}}],[\"使用场景\",{\"1\":{\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1}}],[\"使用\",{\"1\":{\"95\":2,\"112\":1,\"113\":3}}],[\"使用两个栈\",{\"1\":{\"55\":1}}],[\"使用双向队列可以方便地实现一些额外操作\",{\"1\":{\"55\":1}}],[\"使用数组实现栈时\",{\"1\":{\"51\":1}}],[\"使用链表实现栈时\",{\"1\":{\"50\":1}}],[\"换句话说\",{\"1\":{\"49\":1}}],[\"判断栈是否为空\",{\"1\":{\"50\":1,\"51\":1}}],[\"判断是否为空\",{\"1\":{\"48\":1}}],[\"判断队列是否为空\",{\"1\":{\"42\":1,\"44\":1,\"45\":1}}],[\"某些语言可能没有专门提供栈类\",{\"1\":{\"48\":1}}],[\"方法用于从队列中取出一个元素\",{\"1\":{\"113\":1}}],[\"方法用于将一个元素插入队列\",{\"1\":{\"113\":1}}],[\"方法\",{\"1\":{\"48\":1,\"113\":2}}],[\"方法名\",{\"1\":{\"42\":1}}],[\"命名为例\",{\"1\":{\"48\":1}}],[\"出栈\",{\"1\":{\"47\":1,\"50\":1,\"51\":1}}],[\"出队操作\",{\"1\":{\"45\":1}}],[\"出队\",{\"1\":{\"41\":1,\"44\":1,\"45\":1}}],[\"入门推荐\",{\"0\":{\"74\":1}}],[\"入栈操作需要初始化节点对象并修改指针\",{\"1\":{\"52\":1}}],[\"入栈和出栈操作都在预先分配好的连续内存中进行\",{\"1\":{\"52\":1}}],[\"入栈与出栈操作分别对应在数组尾部添加元素与删除元素\",{\"1\":{\"51\":1}}],[\"入栈\",{\"1\":{\"47\":1,\"50\":1,\"51\":1}}],[\"入队和出队操作都只需进行一次操作\",{\"1\":{\"45\":1}}],[\"入队操作\",{\"1\":{\"45\":1}}],[\"入队\",{\"1\":{\"41\":1,\"44\":1,\"45\":1}}],[\"底部称为\",{\"1\":{\"47\":1}}],[\"字符\",{\"1\":{\"47\":1}}],[\"字节或\",{\"1\":{\"37\":1}}],[\"字节\",{\"1\":{\"37\":3}}],[\"餐厅的出餐队列等\",{\"1\":{\"46\":1}}],[\"功能的场景\",{\"1\":{\"46\":1}}],[\"先来后到\",{\"1\":{\"46\":1}}],[\"先根据扩容倍数创建一个更大的数组\",{\"1\":{\"35\":1}}],[\"任何需要实现\",{\"1\":{\"46\":1}}],[\"任意节点都可以视作头节点\",{\"1\":{\"27\":1}}],[\"高层模块不应依赖于低层模块\",{\"1\":{\"62\":1}}],[\"高并发成为工程师们需要重点攻克的问题\",{\"1\":{\"46\":1}}],[\"高级数据结构\",{\"1\":{\"28\":1}}],[\"短时间内会产生海量订单\",{\"1\":{\"46\":1}}],[\"订单将加入队列中\",{\"1\":{\"46\":1}}],[\"购物者下单后\",{\"1\":{\"46\":1}}],[\"淘宝订单\",{\"1\":{\"46\":1}}],[\"有兴趣的读者可以尝试自行实现\",{\"1\":{\"45\":1}}],[\"有初始值\",{\"1\":{\"31\":2}}],[\"join\",{\"1\":{\"99\":2,\"101\":1,\"102\":4,\"103\":2,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":2,\"113\":3}}],[\"j++\",{\"1\":{\"45\":1}}],[\"j\",{\"1\":{\"45\":2}}],[\"java\",{\"1\":{\"19\":1,\"29\":1,\"35\":1,\"55\":1}}],[\"越过数组尾部后回到头部\",{\"1\":{\"45\":1}}],[\"~lockfreequeue\",{\"1\":{\"112\":1,\"113\":1}}],[\"~linkedliststack\",{\"1\":{\"50\":1}}],[\"~linkedlistqueue\",{\"1\":{\"44\":1}}],[\"~arrayqueue\",{\"1\":{\"45\":1}}],[\"取余操作\",{\"1\":{\"45\":1}}],[\"或类\",{\"1\":{\"93\":1}}],[\"或者由于其他更高优先级的进程需要\",{\"1\":{\"91\":1}}],[\"或\",{\"1\":{\"45\":1,\"48\":1,\"52\":1,\"93\":2,\"95\":4,\"103\":1,\"105\":2}}],[\"环形数组\",{\"1\":{\"45\":1}}],[\"环形链表常用于需要周期性操作的场景\",{\"1\":{\"28\":1}}],[\"环形链表\",{\"1\":{\"27\":1,\"36\":1}}],[\"你可能会发现一个问题\",{\"1\":{\"45\":1}}],[\"减少读计数器\",{\"1\":{\"102\":1}}],[\"减少代码的复杂性\",{\"1\":{\"62\":1}}],[\"减少模块之间的耦合性\",{\"1\":{\"62\":1}}],[\"减少引入新\",{\"1\":{\"62\":1}}],[\"减少类的复杂性\",{\"1\":{\"62\":1}}],[\"减少\",{\"1\":{\"45\":1}}],[\"增加\",{\"1\":{\"45\":2}}],[\"增删的优势可以在其他应用上得到体现\",{\"1\":{\"37\":1}}],[\"索引处\",{\"1\":{\"45\":1}}],[\"索引本质上是内存地址的偏移量\",{\"1\":{\"11\":1}}],[\"各类待办事项\",{\"1\":{\"46\":1}}],[\"各种操作的实现方法如下图所示\",{\"1\":{\"45\":1}}],[\"各个节点可以存储不同类型的数据\",{\"1\":{\"37\":1}}],[\"各个节点通过\",{\"1\":{\"19\":1}}],[\"各个参数的设定也非常考究\",{\"1\":{\"35\":1}}],[\"定义常量\",{\"1\":{\"85\":1}}],[\"定义算法的通用接口\",{\"1\":{\"69\":1}}],[\"定义\",{\"1\":{\"45\":1,\"62\":5}}],[\"定量表示需要根据具体情况进行分析\",{\"1\":{\"37\":1}}],[\"规定队尾仅可添加节点\",{\"1\":{\"44\":1}}],[\"基本概念\",{\"0\":{\"110\":1}}],[\"基本结构\",{\"1\":{\"101\":1,\"102\":1,\"103\":1}}],[\"基本的数据结构\",{\"0\":{\"2\":1}}],[\"基础\",{\"0\":{\"79\":1}}],[\"基于数组实现的栈可能造成一定的空间浪费\",{\"1\":{\"52\":1}}],[\"基于数组实现的栈在触发扩容时效率会降低\",{\"1\":{\"52\":1}}],[\"基于数组实现的栈\",{\"1\":{\"51\":1}}],[\"基于数组实现栈的入栈出栈操作\",{\"1\":{\"51\":1}}],[\"基于数组的实现\",{\"0\":{\"45\":1,\"51\":1}}],[\"基于环形数组实现的队列\",{\"1\":{\"45\":1}}],[\"基于此设计\",{\"1\":{\"45\":1}}],[\"基于链表实现的栈可以提供更加稳定的效率表现\",{\"1\":{\"52\":1}}],[\"基于链表实现的栈\",{\"1\":{\"50\":1}}],[\"基于链表实现的队列\",{\"1\":{\"44\":1}}],[\"基于链表实现栈的入栈出栈操作\",{\"1\":{\"50\":1}}],[\"基于链表实现队列的入队出队操作\",{\"1\":{\"44\":1}}],[\"基于链表的实现\",{\"0\":{\"44\":1,\"50\":1}}],[\"获取子进程的退出状态后\",{\"1\":{\"93\":1}}],[\"获取栈的长度\",{\"1\":{\"48\":1,\"50\":1,\"51\":1}}],[\"获取队列的容量\",{\"1\":{\"45\":1}}],[\"获取队列的长度\",{\"1\":{\"42\":1,\"44\":1,\"45\":1}}],[\"获取并返回随机元素\",{\"1\":{\"11\":1}}],[\"描述\",{\"1\":{\"42\":1,\"48\":1}}],[\"尾部称为\",{\"1\":{\"41\":1}}],[\"尾节点视为栈底\",{\"1\":{\"50\":1}}],[\"尾节点都指向该节点\",{\"1\":{\"44\":1}}],[\"尾节点指向空\",{\"1\":{\"27\":1}}],[\"尾节点指向的是\",{\"1\":{\"19\":1}}],[\"尾节点\",{\"1\":{\"19\":1,\"37\":1,\"44\":2}}],[\"队尾\",{\"1\":{\"41\":1,\"44\":1}}],[\"队首指针向后移动一位\",{\"1\":{\"45\":1}}],[\"队首指针\",{\"1\":{\"45\":1}}],[\"队首仅可删除节点\",{\"1\":{\"44\":1}}],[\"队首元素出队\",{\"1\":{\"42\":1}}],[\"队首\",{\"1\":{\"41\":1,\"44\":1}}],[\"队列使用一个动态分配的数组\",{\"1\":{\"113\":1}}],[\"队列是一种遵循先入先出原则的数据结构\",{\"1\":{\"54\":1}}],[\"队列在这些场景中可以有效地维护处理顺序\",{\"1\":{\"46\":1}}],[\"队列典型应用\",{\"0\":{\"46\":1}}],[\"队列已满\",{\"1\":{\"45\":1,\"112\":1,\"113\":1}}],[\"队列容量\",{\"1\":{\"45\":1}}],[\"队列长度\",{\"1\":{\"45\":1}}],[\"队列为空\",{\"1\":{\"44\":1,\"45\":1,\"112\":1,\"113\":1}}],[\"队列实现\",{\"0\":{\"43\":1}}],[\"队列的逻辑\",{\"1\":{\"55\":1}}],[\"队列的结论与前述栈的结论相似\",{\"1\":{\"54\":1}}],[\"队列的常见操作如下表所示\",{\"1\":{\"42\":1}}],[\"队列的先入先出规则\",{\"1\":{\"41\":1}}],[\"队列常用操作\",{\"0\":{\"42\":1}}],[\"队列模拟了排队现象\",{\"1\":{\"41\":1}}],[\"队列和栈\",{\"0\":{\"40\":1}}],[\"队列\",{\"0\":{\"41\":1},\"1\":{\"18\":1,\"28\":1,\"41\":1},\"2\":{\"57\":1}}],[\"顾名思义\",{\"1\":{\"41\":1}}],[\"会触发扩容机制\",{\"1\":{\"52\":1}}],[\"会导致\",{\"1\":{\"37\":1}}],[\"会发现它们每个元素的\",{\"1\":{\"37\":1}}],[\"操作或等待某个事件发生\",{\"1\":{\"91\":1}}],[\"操作系统我只推荐这一本书\",{\"1\":{\"75\":1}}],[\"操作\",{\"1\":{\"37\":1,\"105\":6}}],[\"必要使用链表的情况主要是二叉树和图\",{\"1\":{\"37\":1}}],[\"一网打尽\",{\"1\":{\"73\":1}}],[\"一个类应只有一个引起其变化的原因\",{\"1\":{\"62\":1}}],[\"一个用于记录当前正在读取的线程数\",{\"1\":{\"102\":1}}],[\"一个用于后一个元素\",{\"1\":{\"37\":1}}],[\"一个用于前一个元素\",{\"1\":{\"37\":1}}],[\"一般情况下\",{\"1\":{\"37\":1}}],[\"一方面\",{\"1\":{\"37\":2}}],[\"memory\",{\"1\":{\"106\":2,\"110\":3,\"112\":7,\"113\":15,\"114\":6}}],[\"mtx\",{\"1\":{\"101\":2,\"102\":3,\"103\":3}}],[\"mutex>\",{\"1\":{\"101\":1,\"102\":3,\"103\":2}}],[\"mutex\",{\"0\":{\"101\":1,\"102\":1},\"1\":{\"101\":1,\"102\":1,\"103\":1}}],[\"main\",{\"1\":{\"95\":1,\"99\":2,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":1,\"113\":2}}],[\"mangling\",{\"1\":{\"84\":2}}],[\"malloc\",{\"1\":{\"81\":2}}],[\"modern\",{\"1\":{\"75\":1}}],[\"m\",{\"1\":{\"37\":2}}],[\"个节点对象也分散存储在内存各处\",{\"1\":{\"37\":1}}],[\"个节点需要循环\",{\"1\":{\"24\":1}}],[\"个元素的地址是相连的\",{\"1\":{\"37\":1}}],[\"长度\",{\"1\":{\"37\":1}}],[\"长度不可变的性质会导致列表的实用性降低\",{\"1\":{\"29\":1}}],[\"长度不可变\",{\"1\":{\"17\":1,\"26\":1}}],[\"浅蓝色的存储节点指针是占用一块内存地址吗\",{\"1\":{\"37\":1}}],[\"双向队列就像是栈和队列的组合或两个栈拼在了一起\",{\"1\":{\"55\":1}}],[\"双向队列像是两个栈拼接在了一起\",{\"1\":{\"55\":1}}],[\"双向队列\",{\"1\":{\"55\":1}}],[\"双向队列是一种具有更高自由度的队列\",{\"1\":{\"54\":1}}],[\"双向队列适合使用链表实现\",{\"1\":{\"37\":1}}],[\"双向链表的特性使得这种操作变得简单\",{\"1\":{\"28\":1}}],[\"双向链表的节点定义同时包含指向后继节点\",{\"1\":{\"27\":1}}],[\"双向链表常用于需要快速查找前一个和后一个元素的场景\",{\"1\":{\"28\":1}}],[\"双向链表节点结构体\",{\"1\":{\"27\":1}}],[\"双向链表更具灵活性\",{\"1\":{\"27\":1}}],[\"双向链表记录了两个方向的引用\",{\"1\":{\"27\":1}}],[\"双向链表\",{\"1\":{\"27\":1,\"36\":1}}],[\"再删除元素\",{\"1\":{\"37\":1}}],[\"再将当前数组的所有元素依次移动至新数组\",{\"1\":{\"35\":1}}],[\"那为什么时间复杂度不是\",{\"1\":{\"37\":1}}],[\"那么需要两个栈来配合实现\",{\"1\":{\"53\":1}}],[\"那么可以省去初始化步骤\",{\"1\":{\"52\":1}}],[\"那么可以用数组存储\",{\"1\":{\"18\":1}}],[\"那么\",{\"1\":{\"37\":1}}],[\"那么它会影响后继节点的内存回收\",{\"1\":{\"37\":1}}],[\"那么多余的空间就被浪费了\",{\"1\":{\"17\":1}}],[\"逻辑更加清晰\",{\"1\":{\"37\":1}}],[\"断开更加安全\",{\"1\":{\"37\":1}}],[\"不需要同步内存顺序\",{\"1\":{\"114\":1}}],[\"不需要加锁解锁\",{\"1\":{\"104\":1}}],[\"不应强迫一个类依赖于它不需要的接口\",{\"1\":{\"62\":1}}],[\"不过这本书我更推荐有一定基础\",{\"1\":{\"75\":1}}],[\"不过\",{\"1\":{\"52\":1}}],[\"不存在上述数组扩容时效率降低的问题\",{\"1\":{\"52\":1}}],[\"不同编程语言的方法名称可能会有所不同\",{\"1\":{\"42\":1}}],[\"不同类型的节点值占用的空间是不同的\",{\"1\":{\"37\":1}}],[\"不会引起数据竞争\",{\"1\":{\"110\":1}}],[\"不会\",{\"1\":{\"37\":1}}],[\"不断开没有关系\",{\"1\":{\"37\":1}}],[\"不修改\",{\"1\":{\"37\":1}}],[\"做题\",{\"1\":{\"37\":1}}],[\"已经实现了双向链表\",{\"1\":{\"37\":1}}],[\"已经从链表中删除了\",{\"1\":{\"37\":1}}],[\"已经不再属于该链表了\",{\"1\":{\"23\":1}}],[\"从队列中取出元素\",{\"1\":{\"113\":1}}],[\"从入门\",{\"1\":{\"73\":1}}],[\"从栈\",{\"1\":{\"55\":2}}],[\"从标准库的角度看\",{\"1\":{\"37\":1}}],[\"从数据结构与算法\",{\"1\":{\"37\":1}}],[\"从头节点遍历到尾节点已经不会遇到\",{\"1\":{\"37\":1}}],[\"从该链表的角度看\",{\"1\":{\"37\":1}}],[\"从而防止僵尸进程的产生\",{\"1\":{\"95\":1}}],[\"从而导致的进程状态\",{\"1\":{\"93\":1}}],[\"从而导致以下不同点\",{\"1\":{\"37\":1}}],[\"从而提高了代码的可扩展性和维护性\",{\"1\":{\"70\":1}}],[\"从而提高效率\",{\"1\":{\"52\":1}}],[\"从而引入扩容机制\",{\"1\":{\"45\":1}}],[\"从而访问到对应的节点\",{\"1\":{\"37\":1}}],[\"从而难以选择合适的列表长度\",{\"1\":{\"29\":1}}],[\"从而借助高速缓存来提升后续操作的执行速度\",{\"1\":{\"17\":1}}],[\"从而无法安全地扩展数组容量\",{\"1\":{\"16\":1}}],[\"从而直接访问该元素\",{\"1\":{\"11\":1}}],[\"呢\",{\"1\":{\"37\":2}}],[\"设计模式是解决常见软件设计问题的通用解决方案\",{\"1\":{\"61\":1}}],[\"设计模式\",{\"0\":{\"61\":1},\"2\":{\"64\":1,\"67\":1,\"72\":1}}],[\"设计模式与设计原则\",{\"0\":{\"60\":1}}],[\"设计原则是指导代码设计的基本准则\",{\"1\":{\"62\":1}}],[\"设计原则\",{\"0\":{\"62\":1},\"1\":{\"3\":1},\"2\":{\"64\":1}}],[\"设为\",{\"1\":{\"37\":1}}],[\"后使父进程退出\",{\"1\":{\"95\":1}}],[\"后变量不会释放\",{\"1\":{\"80\":1}}],[\"后退操作实际上是在执行出栈\",{\"1\":{\"53\":1}}],[\"后\",{\"1\":{\"37\":2}}],[\"元素出栈\",{\"1\":{\"48\":1}}],[\"元素出队\",{\"1\":{\"42\":1}}],[\"元素入栈\",{\"1\":{\"48\":2}}],[\"元素入队\",{\"1\":{\"42\":2}}],[\"元素索引\",{\"1\":{\"37\":1}}],[\"元素内存地址\",{\"1\":{\"37\":1}}],[\"元素长度\",{\"1\":{\"37\":2}}],[\"元素占用内存多\",{\"1\":{\"26\":1}}],[\"元素占用内存少\",{\"1\":{\"26\":1}}],[\"8\",{\"0\":{\"108\":1},\"1\":{\"37\":2}}],[\"单一职责原则\",{\"1\":{\"62\":1}}],[\"单次入栈操作的时间复杂度会劣化至\",{\"1\":{\"54\":1}}],[\"单个元素分别占用\",{\"1\":{\"37\":1}}],[\"单向链表通常用于实现栈\",{\"1\":{\"28\":1}}],[\"单向链表的节点包含值和指向下一节点的引用两项数据\",{\"1\":{\"27\":1}}],[\"单向链表\",{\"1\":{\"27\":1}}],[\"两个线程同时运行\",{\"1\":{\"113\":1}}],[\"两种实现都支持栈定义中的各项操作\",{\"1\":{\"52\":1}}],[\"两种实现对比\",{\"0\":{\"52\":1}}],[\"两种实现的对比结论与栈一致\",{\"1\":{\"45\":1}}],[\"两种类型\",{\"1\":{\"37\":1}}],[\"两者的特点呈现出互补的特性\",{\"1\":{\"36\":1}}],[\"连接\",{\"1\":{\"37\":1}}],[\"连续空间存储和分散空间存储\",{\"1\":{\"36\":1}}],[\"连续空间存储是一把双刃剑\",{\"1\":{\"17\":1}}],[\"连续内存空间\",{\"1\":{\"26\":1}}],[\"灵活性\",{\"1\":{\"37\":1}}],[\"大量僵尸进程可能会让系统管理者难以管理和监控系统状态\",{\"1\":{\"94\":1}}],[\"大多为\",{\"1\":{\"37\":1}}],[\"大多数编程语言会将数组元素初始化为\",{\"1\":{\"10\":1}}],[\"大小限制\",{\"1\":{\"37\":1}}],[\"更新头部指针\",{\"1\":{\"113\":1}}],[\"更新元素\",{\"1\":{\"32\":1}}],[\"更占用空间\",{\"1\":{\"37\":1}}],[\"更容易碎片化\",{\"1\":{\"37\":1}}],[\"栈是一种遵循先入后出原则的数据结构\",{\"1\":{\"54\":1}}],[\"栈是一块较小的内存\",{\"1\":{\"37\":1}}],[\"栈为空\",{\"1\":{\"50\":1,\"51\":1}}],[\"栈遵循先入后出的原则\",{\"1\":{\"49\":1}}],[\"栈的数组实现可能导致一定程度的空间浪费\",{\"1\":{\"54\":1}}],[\"栈的数组实现具有较高的平均效率\",{\"1\":{\"54\":1}}],[\"栈的链表实现具有更为稳定的效率表现\",{\"1\":{\"54\":1}}],[\"栈的典型应用\",{\"0\":{\"53\":1}}],[\"栈的长度\",{\"1\":{\"50\":1}}],[\"栈的实现\",{\"0\":{\"49\":1}}],[\"栈的常用操作如下表所示\",{\"1\":{\"48\":1}}],[\"栈的常用操作\",{\"0\":{\"48\":1}}],[\"栈的先入后出规则\",{\"1\":{\"47\":1}}],[\"栈底\",{\"1\":{\"47\":1}}],[\"栈顶元素出栈\",{\"1\":{\"48\":1}}],[\"栈顶\",{\"1\":{\"47\":1}}],[\"栈\",{\"0\":{\"47\":1},\"1\":{\"47\":1,\"55\":3},\"2\":{\"57\":1}}],[\"栈和队列往往会使用编程语言提供的\",{\"1\":{\"37\":1}}],[\"栈和堆具有各自的特点\",{\"1\":{\"37\":1}}],[\"栈上的数组的大小需要在编译时确定\",{\"1\":{\"37\":1}}],[\"栈内存相对较小\",{\"1\":{\"37\":1}}],[\"栈与队列\",{\"1\":{\"28\":1}}],[\"然后子进程立即退出\",{\"1\":{\"95\":1}}],[\"然后把原数组元素依次复制到新数组\",{\"1\":{\"16\":1}}],[\"然而\",{\"1\":{\"37\":3,\"45\":2,\"48\":1,\"49\":1,\"52\":2}}],[\"quecapacity\",{\"1\":{\"45\":7}}],[\"quesize++\",{\"1\":{\"44\":1,\"45\":1}}],[\"quesize\",{\"1\":{\"44\":5,\"45\":8}}],[\"queue<int>\",{\"1\":{\"42\":1}}],[\"queue\",{\"1\":{\"37\":1,\"41\":1,\"42\":10,\"44\":2,\"112\":5,\"113\":8}}],[\"q\",{\"0\":{\"37\":1,\"55\":1},\"1\":{\"37\":10,\"55\":4}}],[\"应该没谁比c++之父更有发言权吧\",{\"1\":{\"75\":1}}],[\"应根据具体需求和场景做出恰当选择\",{\"1\":{\"36\":1}}],[\"应被替换为\",{\"1\":{\"19\":1}}],[\"显著提升程序的执行效率\",{\"1\":{\"36\":1}}],[\"预取机制以及空间局部性和时间局部性等数据加载机制\",{\"1\":{\"36\":1}}],[\"缓存不友好\",{\"1\":{\"37\":1}}],[\"缓存通过缓存行\",{\"1\":{\"36\":1}}],[\"缓存局部性\",{\"1\":{\"17\":1}}],[\"同样可以通过数组或链表来实现\",{\"1\":{\"54\":1}}],[\"同时可以灵活调整长度\",{\"1\":{\"36\":1}}],[\"同理\",{\"1\":{\"13\":1}}],[\"通知\",{\"1\":{\"103\":1}}],[\"通常用布尔值或整数表示\",{\"1\":{\"101\":1}}],[\"通常情况下\",{\"1\":{\"48\":1}}],[\"通常情况下这\",{\"1\":{\"37\":1}}],[\"通常比\",{\"1\":{\"37\":1}}],[\"通常基于动态数组实现\",{\"1\":{\"36\":1}}],[\"通过\",{\"1\":{\"113\":1}}],[\"通过及时调用\",{\"1\":{\"95\":1}}],[\"通过多个特定接口来代替单一的总接口\",{\"1\":{\"62\":1}}],[\"通过抽象和接口\",{\"1\":{\"62\":1}}],[\"通过取余操作实现\",{\"1\":{\"45\":1}}],[\"通过索引遍历列表\",{\"1\":{\"34\":1}}],[\"通过索引遍历数组\",{\"1\":{\"14\":1}}],[\"通过引用指向\",{\"1\":{\"21\":1}}],[\"通过它可以从当前节点访问到下一个节点\",{\"1\":{\"19\":1}}],[\"占用内存较多\",{\"1\":{\"36\":1}}],[\"占用内存较少\",{\"1\":{\"36\":1}}],[\"实现生产者\",{\"1\":{\"105\":1}}],[\"实现原理\",{\"1\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1}}],[\"实现的基础\",{\"1\":{\"81\":1}}],[\"实现策略接口的不同算法\",{\"1\":{\"69\":1}}],[\"实现高效的节点插入与删除\",{\"1\":{\"36\":1}}],[\"实际上\",{\"1\":{\"29\":1}}],[\"且值相同\",{\"1\":{\"82\":1}}],[\"且可以灵活调整长度\",{\"1\":{\"36\":1}}],[\"且初始化后长度不可变\",{\"1\":{\"36\":1}}],[\"且元素类型相同\",{\"1\":{\"17\":1}}],[\"分为计数信号量和二进制信号量\",{\"1\":{\"105\":1}}],[\"分别视为\",{\"1\":{\"44\":1}}],[\"分别代表数据在计算机内存中的两种存储方式\",{\"1\":{\"36\":1}}],[\"分配了必要的资源后\",{\"1\":{\"91\":1}}],[\"分配由编译器自动完成\",{\"1\":{\"37\":1}}],[\"分配和释放效率\",{\"1\":{\"37\":1}}],[\"分散内存空间\",{\"1\":{\"26\":1}}],[\"重点回顾\",{\"0\":{\"36\":1,\"54\":1}}],[\"倍\",{\"1\":{\"35\":1,\"52\":1}}],[\"根据此变量\",{\"1\":{\"35\":1}}],[\"根据索引实现随机抽样\",{\"1\":{\"18\":1}}],[\"声明一个变量\",{\"1\":{\"35\":1}}],[\"作为初始容量\",{\"1\":{\"35\":1}}],[\"初始容量\",{\"1\":{\"35\":1,\"52\":1}}],[\"初始化栈\",{\"1\":{\"48\":1}}],[\"初始化队列\",{\"1\":{\"42\":1}}],[\"初始化列表\",{\"0\":{\"31\":1},\"1\":{\"31\":1,\"37\":1}}],[\"初始化各个节点\",{\"1\":{\"21\":1}}],[\"初始化完成后\",{\"1\":{\"21\":1}}],[\"初始化链表\",{\"0\":{\"21\":1},\"1\":{\"21\":1}}],[\"初始化一个扩展长度后的数组\",{\"1\":{\"16\":1}}],[\"初始化数组\",{\"0\":{\"10\":1},\"1\":{\"10\":1,\"45\":1}}],[\"包含退出状态信息等\",{\"1\":{\"93\":1}}],[\"包含元素\",{\"1\":{\"21\":1}}],[\"包括以下三个重点设计\",{\"1\":{\"35\":1}}],[\"感兴趣的读者可以查阅源码进行学习\",{\"1\":{\"35\":1}}],[\"许多编程语言内置了列表\",{\"1\":{\"35\":1}}],[\"许多编程语言中的标准库提供的列表是基于动态数组实现的\",{\"1\":{\"29\":1}}],[\"直到锁可用为止\",{\"1\":{\"106\":1}}],[\"直到互斥量被解锁\",{\"1\":{\"101\":1}}],[\"直接回到数组头部继续遍历\",{\"1\":{\"45\":1}}],[\"直接遍历列表元素\",{\"1\":{\"34\":1}}],[\"直至找到目标节点\",{\"1\":{\"24\":1}}],[\"与头部指针\",{\"1\":{\"113\":1}}],[\"与\",{\"0\":{\"82\":1},\"1\":{\"82\":1,\"113\":1}}],[\"与许多语言不同\",{\"1\":{\"37\":1}}],[\"与数组一样\",{\"1\":{\"34\":1}}],[\"与单向链表相比\",{\"1\":{\"27\":1}}],[\"6\",{\"0\":{\"85\":1,\"106\":1},\"1\":{\"33\":2}}],[\"清空列表\",{\"1\":{\"33\":1}}],[\"效率很高\",{\"1\":{\"32\":1}}],[\"需要持有相关的互斥量\",{\"1\":{\"103\":1}}],[\"需要计算不同水果的价格\",{\"1\":{\"70\":1}}],[\"需要针对具体情况进行分析\",{\"1\":{\"52\":1}}],[\"需要注意的是\",{\"1\":{\"42\":1}}],[\"需要手动释放空间\",{\"1\":{\"10\":1}}],[\"需注意\",{\"1\":{\"31\":1}}],[\"视为等同的概念\",{\"1\":{\"29\":1}}],[\"视频播放器中\",{\"1\":{\"28\":1}}],[\"dequeue\",{\"1\":{\"112\":2,\"113\":5}}],[\"delete是c++语言标准库提供的一组用于动态创建\",{\"1\":{\"81\":1}}],[\"delete与malloc\",{\"0\":{\"81\":1}}],[\"delete\",{\"1\":{\"16\":1,\"23\":1,\"44\":1,\"45\":1,\"50\":1,\"81\":1,\"112\":1,\"113\":1}}],[\"d\",{\"1\":{\"102\":2}}],[\"data\",{\"1\":{\"102\":3}}],[\"down\",{\"1\":{\"108\":1}}],[\"do\",{\"1\":{\"99\":2}}],[\"double\",{\"1\":{\"37\":2,\"52\":1,\"95\":2}}],[\"dip\",{\"1\":{\"62\":1}}],[\"dynamic\",{\"1\":{\"29\":1}}],[\"动态数组\",{\"1\":{\"29\":2}}],[\"为实现无锁编程提供了基础设施\",{\"1\":{\"111\":1}}],[\"为支持函数重载引入了name\",{\"1\":{\"84\":1}}],[\"为数组的指针\",{\"1\":{\"82\":1}}],[\"为数组名指向首元素地址即与\",{\"1\":{\"82\":1}}],[\"为数组长度\",{\"1\":{\"13\":1}}],[\"为了深入了解栈的运行机制\",{\"1\":{\"49\":1}}],[\"为了解决此问题\",{\"1\":{\"45\":1}}],[\"为了实现队列\",{\"1\":{\"43\":1}}],[\"为了防止频繁扩容\",{\"1\":{\"37\":1}}],[\"为了加深对列表工作原理的理解\",{\"1\":{\"35\":1}}],[\"为什么数组要求相同类型的元素\",{\"1\":{\"37\":1}}],[\"为\",{\"1\":{\"36\":1,\"95\":1}}],[\"为解决此问题\",{\"1\":{\"29\":1}}],[\"并输出相应的信息\",{\"1\":{\"113\":1}}],[\"并使用\",{\"1\":{\"113\":2}}],[\"并释放互斥量\",{\"1\":{\"103\":1}}],[\"并清空栈\",{\"1\":{\"55\":1}}],[\"并在运行时决定使用哪种策略\",{\"1\":{\"69\":1}}],[\"并在程序逻辑上忽略与栈无关的操作\",{\"1\":{\"48\":1}}],[\"并在另一端删除元素\",{\"1\":{\"43\":1}}],[\"并将互斥量状态设置为锁定\",{\"1\":{\"101\":1}}],[\"并将每个算法封装在独立的策略类中\",{\"1\":{\"68\":1}}],[\"并将其压入栈\",{\"1\":{\"55\":2}}],[\"并将\",{\"1\":{\"45\":2,\"113\":1}}],[\"并将原列表的所有元素搬运过去\",{\"1\":{\"37\":1}}],[\"并维护一个变量\",{\"1\":{\"45\":1}}],[\"并返回\",{\"1\":{\"44\":1,\"45\":1,\"50\":1}}],[\"并且更加灵活\",{\"1\":{\"55\":1}}],[\"并且\",{\"1\":{\"52\":1}}],[\"并且这些数字的内存地址无须连续\",{\"1\":{\"37\":1}}],[\"并且可以在程序运行过程中进行动态扩容\",{\"1\":{\"29\":1}}],[\"并且可以灵活动态扩容\",{\"1\":{\"29\":1}}],[\"并不是连续的\",{\"1\":{\"37\":1}}],[\"并随着元素插入和删除实时更新\",{\"1\":{\"35\":1}}],[\"并生成一个随机序列\",{\"1\":{\"18\":1}}],[\"添加至栈顶\",{\"1\":{\"48\":1}}],[\"添加至队尾\",{\"1\":{\"45\":1}}],[\"添加\",{\"1\":{\"29\":1}}],[\"添加元素\",{\"1\":{\"26\":1}}],[\"支持操作\",{\"1\":{\"52\":1}}],[\"支持元素访问\",{\"1\":{\"29\":1}}],[\"支持随机访问\",{\"1\":{\"17\":1}}],[\"以确保在此之前的所有操作不会被重排序到\",{\"1\":{\"114\":1}}],[\"以确保在没有锁的情况下实现线程安全\",{\"1\":{\"109\":1}}],[\"以确保加载的结果及其后续的操作不会被重排序到\",{\"1\":{\"114\":1}}],[\"以确保取出操作完成后\",{\"1\":{\"113\":1}}],[\"以确保插入操作完成后\",{\"1\":{\"113\":1}}],[\"以控制并发操作的顺序性\",{\"1\":{\"110\":1}}],[\"以回收子进程的资源\",{\"1\":{\"95\":1}}],[\"以获取并处理子进程的退出状态\",{\"1\":{\"95\":1}}],[\"以下为示例代码\",{\"1\":{\"51\":1}}],[\"以下是几种常用的方法\",{\"1\":{\"95\":1}}],[\"以下是常见的状态转换路径\",{\"1\":{\"91\":1}}],[\"以下是基于链表实现栈的示例代码\",{\"1\":{\"50\":1}}],[\"以下是用链表实现队列的代码\",{\"1\":{\"44\":1}}],[\"以上实现的队列仍然具有局限性\",{\"1\":{\"45\":1}}],[\"以便实现无缝播放\",{\"1\":{\"28\":1}}],[\"以及判断是否需要扩容\",{\"1\":{\"35\":1}}],[\"以及支持快速添加和删除节点\",{\"1\":{\"28\":1}}],[\"以及之后的所有元素向后移动一位\",{\"1\":{\"12\":1}}],[\"算法中\",{\"1\":{\"28\":1}}],[\"算法\",{\"1\":{\"28\":1}}],[\"latch\",{\"0\":{\"108\":1},\"1\":{\"108\":2}}],[\"load\",{\"1\":{\"112\":4,\"113\":8,\"114\":3}}],[\"lockfreequeue<int>\",{\"1\":{\"112\":1,\"113\":1}}],[\"lockfreequeue\",{\"1\":{\"112\":2,\"113\":4}}],[\"lock<std\",{\"1\":{\"102\":2,\"103\":1}}],[\"lock\",{\"1\":{\"101\":2,\"102\":4,\"103\":4,\"106\":2,\"109\":1}}],[\"long\",{\"1\":{\"37\":2}}],[\"lsp\",{\"1\":{\"62\":1}}],[\"lru\",{\"1\":{\"28\":2}}],[\"linux\",{\"1\":{\"93\":1}}],[\"linkedliststack\",{\"1\":{\"50\":2}}],[\"linkedlistqueue\",{\"1\":{\"44\":2}}],[\"linkedlist\",{\"1\":{\"44\":2,\"50\":2}}],[\"linked\",{\"1\":{\"19\":1}}],[\"listnode\",{\"1\":{\"19\":4,\"21\":10,\"22\":3,\"23\":3,\"24\":2,\"25\":1,\"27\":4,\"44\":5,\"50\":5}}],[\"list\",{\"1\":{\"19\":1,\"29\":3,\"37\":3,\"50\":1}}],[\"浏览器的前进后退功能本质上是\",{\"1\":{\"55\":1}}],[\"浏览器的前进后退是否是双向链表实现\",{\"1\":{\"55\":1}}],[\"浏览器就会对上一个网页执行入栈\",{\"1\":{\"53\":1}}],[\"浏览器中的后退与前进\",{\"1\":{\"53\":1}}],[\"浏览器需要知道用户访问过的前一个和后一个网页\",{\"1\":{\"28\":1}}],[\"浏览器历史\",{\"1\":{\"28\":1}}],[\"树中\",{\"1\":{\"28\":1}}],[\"books\",{\"0\":{\"120\":1}}],[\"bool\",{\"1\":{\"42\":1,\"44\":1,\"45\":1,\"48\":1,\"50\":1,\"51\":1,\"103\":1,\"112\":2,\"113\":2}}],[\"buffer\",{\"1\":{\"112\":5,\"113\":7}}],[\"bug\",{\"1\":{\"62\":1}}],[\"barrier\",{\"0\":{\"107\":1},\"1\":{\"107\":1}}],[\"bar\",{\"1\":{\"99\":5}}],[\"back\",{\"1\":{\"33\":5,\"51\":3,\"102\":1,\"107\":1,\"108\":1}}],[\"blocked\",{\"1\":{\"90\":1}}],[\"begin\",{\"1\":{\"33\":2}}],[\"b\",{\"1\":{\"28\":1,\"55\":4}}],[\"邻接表是表示图的一种常用方式\",{\"1\":{\"28\":1}}],[\"所有等待的线程被唤醒\",{\"1\":{\"108\":1}}],[\"所有等待的线程继续执行\",{\"1\":{\"107\":1}}],[\"所有冲突的元素都会被放到一个链表中\",{\"1\":{\"28\":1}}],[\"所以\",{\"1\":{\"37\":1}}],[\"所以上述查找操作被称为\",{\"1\":{\"15\":1}}],[\"所以我们无须特意去修改它\",{\"1\":{\"13\":1}}],[\"链式地址是解决哈希冲突的主流方案之一\",{\"1\":{\"28\":1}}],[\"链表和数组都符合要求\",{\"1\":{\"43\":1}}],[\"链表由节点组成\",{\"1\":{\"37\":1}}],[\"链表通过更改引用\",{\"1\":{\"36\":1}}],[\"链表天然可以看作一个列表\",{\"1\":{\"29\":1}}],[\"链表中的每个元素都代表与该顶点相连的其他顶点\",{\"1\":{\"28\":1}}],[\"链表典型应用\",{\"0\":{\"28\":1}}],[\"链表则不然\",{\"1\":{\"24\":1}}],[\"链表删除节点\",{\"1\":{\"23\":1}}],[\"链表插入节点示例\",{\"1\":{\"22\":1}}],[\"链表常用操作\",{\"0\":{\"20\":1}}],[\"链表比数组占用更多的内存空间\",{\"1\":{\"19\":1}}],[\"链表节点所占用的内存空间比数组元素更大\",{\"1\":{\"54\":1}}],[\"链表节点结构体\",{\"1\":{\"19\":1}}],[\"链表节点\",{\"1\":{\"19\":1}}],[\"链表的扩容非常灵活\",{\"1\":{\"52\":1}}],[\"链表的\",{\"1\":{\"37\":1}}],[\"链表的首个节点被称为\",{\"1\":{\"19\":1}}],[\"链表的组成单位是节点\",{\"1\":{\"19\":1}}],[\"链表的设计使得各个节点可以分散存储在内存各处\",{\"1\":{\"19\":1}}],[\"链表定义与存储方式\",{\"1\":{\"19\":1,\"37\":1}}],[\"链表\",{\"0\":{\"19\":1,\"26\":1},\"1\":{\"19\":1,\"26\":1,\"48\":1},\"2\":{\"39\":1}}],[\"上执行代码\",{\"1\":{\"90\":1}}],[\"上下文类\",{\"1\":{\"69\":1}}],[\"上一个节点\",{\"1\":{\"27\":1}}],[\"上述\",{\"1\":{\"19\":1}}],[\"即在执行时不会被其他线程打断\",{\"1\":{\"110\":1}}],[\"即进程描述符\",{\"1\":{\"94\":1}}],[\"即进程控制块\",{\"1\":{\"93\":1}}],[\"即被修饰变量不可以被修改\",{\"1\":{\"85\":1}}],[\"即指向第二个元素a\",{\"1\":{\"82\":1}}],[\"即一个类只负责一项职责\",{\"1\":{\"62\":1}}],[\"即将元素添加至队尾\",{\"1\":{\"42\":1}}],[\"即新来的人不断加入队列尾部\",{\"1\":{\"41\":1}}],[\"即是本文描述的\",{\"1\":{\"31\":1}}],[\"即前面介绍的普通链表\",{\"1\":{\"27\":1}}],[\"即可\",{\"1\":{\"22\":1,\"23\":1}}],[\"常见的链表类型包括单向链表\",{\"1\":{\"36\":1}}],[\"常见的链表类型包括三种\",{\"1\":{\"27\":1}}],[\"常见链表种类\",{\"1\":{\"27\":1}}],[\"常见链表类型\",{\"0\":{\"27\":1}}],[\"可能会导致系统无法创建新进程\",{\"1\":{\"94\":1}}],[\"可通过数组或链表来实现\",{\"1\":{\"54\":1}}],[\"可以有效避免僵尸进程的产生\",{\"1\":{\"95\":1}}],[\"可以通过调用\",{\"1\":{\"95\":1}}],[\"可以通过策略模式将计算逻辑封装成独立的策略类\",{\"1\":{\"70\":1}}],[\"可以取代宏的功能\",{\"1\":{\"83\":1}}],[\"可以轻松更改折扣策略\",{\"1\":{\"70\":1}}],[\"可以看到\",{\"1\":{\"45\":1}}],[\"可以在一端添加元素\",{\"1\":{\"43\":1}}],[\"可以在代码中动态分配\",{\"1\":{\"37\":1}}],[\"可以朝两个方向遍历链表\",{\"1\":{\"27\":1}}],[\"可以使用数组作为查找表\",{\"1\":{\"18\":1}}],[\"可灵活扩展\",{\"1\":{\"26\":1}}],[\"由于链表节点需要额外存储指针\",{\"1\":{\"52\":1}}],[\"由于入栈的元素可能会源源不断地增加\",{\"1\":{\"51\":1}}],[\"由于数据不是连续存放的\",{\"1\":{\"37\":1}}],[\"由于数组具有更高的缓存命中率\",{\"1\":{\"36\":1}}],[\"由于数组的长度不可变\",{\"1\":{\"13\":1}}],[\"由于数组的长度是固定的\",{\"1\":{\"12\":1}}],[\"由于每个元素需要两个额外的指针\",{\"1\":{\"37\":1}}],[\"由于它们采用两种相反的存储策略\",{\"1\":{\"26\":1}}],[\"下面是一个简单的无锁单生产者单消费者队列的实现示例\",{\"1\":{\"112\":1}}],[\"下一个节点\",{\"1\":{\"27\":1}}],[\"下表总结了数组和链表的各项特点并对比了操作效率\",{\"1\":{\"26\":1}}],[\"下图展示了数组的主要概念和存储方式\",{\"1\":{\"8\":1}}],[\"此时子进程的父进程是\",{\"1\":{\"95\":1}}],[\"此时节点\",{\"1\":{\"37\":1}}],[\"此时就不能用以下公式计算偏移量了\",{\"1\":{\"37\":1}}],[\"此时链表的灵活性优势就体现出来了\",{\"1\":{\"19\":1}}],[\"此过程也属于线性查找\",{\"1\":{\"25\":1}}],[\"输出该节点在链表中的索引\",{\"1\":{\"25\":1}}],[\"遍历列表\",{\"0\":{\"34\":1}}],[\"遍历链表删除节点\",{\"1\":{\"44\":1,\"50\":1}}],[\"遍历链表\",{\"1\":{\"25\":1}}],[\"遍历数组\",{\"0\":{\"14\":1},\"1\":{\"14\":1}}],[\"轮\",{\"1\":{\"24\":1}}],[\"也会出现很多空位\",{\"1\":{\"37\":1}}],[\"也就是说\",{\"1\":{\"24\":1}}],[\"也可以\",{\"1\":{\"37\":1}}],[\"也可以直接遍历各元素\",{\"1\":{\"34\":1}}],[\"也可以直接遍历获取数组中的每个元素\",{\"1\":{\"14\":1}}],[\"也可能会使用环形链表\",{\"1\":{\"28\":1}}],[\"也可用于实现各种复杂数据结构\",{\"1\":{\"18\":1}}],[\"逐个向后遍历\",{\"1\":{\"24\":1}}],[\"访问栈顶元素\",{\"1\":{\"48\":2,\"50\":1,\"51\":1}}],[\"访问队首元素\",{\"1\":{\"42\":2,\"44\":1,\"45\":1}}],[\"访问索引\",{\"1\":{\"32\":1}}],[\"访问链表中索引为\",{\"1\":{\"24\":1}}],[\"访问链表的第\",{\"1\":{\"24\":1}}],[\"访问节点\",{\"0\":{\"24\":1}}],[\"访问元素\",{\"0\":{\"11\":1,\"32\":1},\"1\":{\"26\":1,\"32\":1}}],[\"尽管在删除操作完成后节点\",{\"1\":{\"23\":1}}],[\"只要求操作是原子的\",{\"1\":{\"114\":1}}],[\"只要保证程序的逻辑是正确的就行\",{\"1\":{\"37\":1}}],[\"只可以在当前文件访问\",{\"1\":{\"80\":1}}],[\"只需将头节点从链表中删除即可\",{\"1\":{\"50\":1}}],[\"只需将\",{\"1\":{\"45\":1}}],[\"只需改变一个节点的引用\",{\"1\":{\"23\":1}}],[\"只用前面一部分\",{\"1\":{\"13\":1}}],[\"point\",{\"1\":{\"107\":2,\"108\":4}}],[\"pop\",{\"1\":{\"42\":2,\"44\":2,\"45\":1,\"48\":3,\"50\":2,\"51\":3}}],[\"pauses\",{\"1\":{\"99\":2}}],[\"pause\",{\"1\":{\"95\":1}}],[\"pattern\",{\"1\":{\"68\":1}}],[\"pid2\",{\"1\":{\"95\":2}}],[\"pid\",{\"1\":{\"95\":14}}],[\"public\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1,\"106\":1,\"112\":1,\"113\":1}}],[\"push\",{\"1\":{\"33\":5,\"42\":6,\"44\":2,\"45\":1,\"48\":7,\"50\":2,\"51\":3,\"102\":1}}],[\"produced\",{\"1\":{\"112\":1,\"113\":1}}],[\"producer\",{\"1\":{\"112\":2,\"113\":3}}],[\"programming\",{\"1\":{\"109\":1}}],[\"proceeding\",{\"1\":{\"107\":1,\"108\":1}}],[\"process\",{\"1\":{\"93\":1}}],[\"print\",{\"1\":{\"101\":2,\"103\":2}}],[\"primer>>\",{\"1\":{\"74\":1}}],[\"private\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1,\"112\":1}}],[\"prev\",{\"1\":{\"27\":2}}],[\"peek\",{\"1\":{\"42\":1,\"44\":2,\"45\":2,\"48\":2}}],[\"p\",{\"1\":{\"22\":5,\"23\":7,\"37\":6,\"105\":3}}],[\"python\",{\"1\":{\"19\":1,\"29\":1,\"35\":1,\"37\":2,\"55\":1}}],[\"之前\",{\"1\":{\"114\":1}}],[\"之间插入一个新节点\",{\"1\":{\"22\":1}}],[\"之后\",{\"1\":{\"114\":1}}],[\"之后插入节点\",{\"1\":{\"22\":1}}],[\"之后的首个节点\",{\"1\":{\"23\":1}}],[\"之后的所有元素向前移动一位\",{\"1\":{\"13\":1}}],[\"之后的元素都向前移动一位\",{\"1\":{\"13\":1}}],[\"之后再把元素赋值给该索引\",{\"1\":{\"12\":1}}],[\"假如把列表元素换成链表节点\",{\"1\":{\"37\":1}}],[\"假如我们想实现字符到\",{\"1\":{\"18\":1}}],[\"假设有数组\",{\"0\":{\"82\":1}}],[\"假设我们有一个水果计价系统\",{\"1\":{\"70\":1}}],[\"假设我们想在相邻的两个节点\",{\"1\":{\"22\":1}}],[\"假设被删除节点未被正常回收\",{\"1\":{\"37\":1}}],[\"比如\",{\"1\":{\"37\":2}}],[\"比如在音频\",{\"1\":{\"28\":1}}],[\"比如在红黑树\",{\"1\":{\"28\":1}}],[\"比如操作系统的资源调度\",{\"1\":{\"28\":1}}],[\"比如以上代码中的链表可记作链表\",{\"1\":{\"21\":1}}],[\"比如数组\",{\"1\":{\"21\":1}}],[\"而不会阻塞或挂起\",{\"1\":{\"106\":1}}],[\"而constexpr有\",{\"1\":{\"83\":1}}],[\"而无需修改订单类的代码\",{\"1\":{\"70\":1}}],[\"而向上回溯阶段则会不断执行出栈操作\",{\"1\":{\"53\":1}}],[\"而对于出栈操作\",{\"1\":{\"50\":1}}],[\"而位于队列头部的人逐个离开\",{\"1\":{\"41\":1}}],[\"而非链表\",{\"1\":{\"37\":1}}],[\"而非节点本身\",{\"1\":{\"37\":1}}],[\"而只在必要时才使用链表\",{\"1\":{\"37\":1}}],[\"而是对数字的引用\",{\"1\":{\"37\":1}}],[\"而是分别跟\",{\"1\":{\"37\":1}}],[\"而在链表中却没有强调相同类型呢\",{\"1\":{\"37\":1}}],[\"而堆上的数组的大小可以在运行时动态确定\",{\"1\":{\"37\":1}}],[\"而堆内存相对更大\",{\"1\":{\"37\":1}}],[\"而链表则在内存使用上更加灵活\",{\"1\":{\"36\":1}}],[\"而链表是由多个独立的节点对象组成的\",{\"1\":{\"21\":1}}],[\"而当数组非常大时\",{\"1\":{\"19\":1}}],[\"等待线程完成\",{\"1\":{\"113\":1}}],[\"等待所有线程到达锁存器\",{\"1\":{\"108\":1}}],[\"等待所有线程到达屏障点\",{\"1\":{\"107\":1}}],[\"等待所有已终止的子进程\",{\"1\":{\"95\":1}}],[\"等待机制\",{\"1\":{\"107\":1,\"108\":1}}],[\"等待操作\",{\"1\":{\"105\":1}}],[\"等待条件变量的通知\",{\"1\":{\"103\":1}}],[\"等待\",{\"1\":{\"103\":2,\"112\":2,\"113\":2}}],[\"等待信号\",{\"1\":{\"95\":1}}],[\"等待子进程结束并回收资源\",{\"1\":{\"95\":1}}],[\"等待再次被调度\",{\"1\":{\"91\":1}}],[\"等待资源释放\",{\"1\":{\"105\":1}}],[\"等待资源\",{\"1\":{\"91\":1}}],[\"等待下一次调度\",{\"1\":{\"91\":1}}],[\"等待调度器的调度\",{\"1\":{\"91\":1}}],[\"等待被调度器分配\",{\"1\":{\"90\":1}}],[\"等语言拥有自动垃圾回收机制\",{\"1\":{\"55\":1}}],[\"等\",{\"1\":{\"21\":1,\"29\":1,\"35\":1,\"37\":1,\"104\":1,\"106\":1,\"110\":1}}],[\"等支持指针的语言中\",{\"1\":{\"19\":1}}],[\"构建节点之间的引用\",{\"1\":{\"21\":1}}],[\"构造函数初始化队列的容量\",{\"1\":{\"113\":1}}],[\"构造函数\",{\"1\":{\"19\":1,\"27\":1,\"81\":1}}],[\"第一个子进程退出\",{\"1\":{\"95\":1}}],[\"第一个子进程\",{\"1\":{\"95\":1}}],[\"第一步是初始化各个节点对象\",{\"1\":{\"21\":1}}],[\"第二步是构建节点之间的引用关系\",{\"1\":{\"21\":1}}],[\"建立链表分为两步\",{\"1\":{\"21\":1}}],[\"x\",{\"1\":{\"19\":2,\"27\":2,\"99\":1}}],[\"指向下一个元素的位置\",{\"1\":{\"113\":1}}],[\"指向下一节点的指针\",{\"1\":{\"19\":1}}],[\"指向队尾索引\",{\"1\":{\"45\":1}}],[\"指向队尾元素之后的下一个位置\",{\"1\":{\"45\":1}}],[\"指向队首元素\",{\"1\":{\"45\":1}}],[\"指向队首元素的索引\",{\"1\":{\"45\":1}}],[\"指向哪里都不会对该链表产生影响\",{\"1\":{\"37\":1}}],[\"指向前驱节点的指针\",{\"1\":{\"27\":1}}],[\"指向后继节点的指针\",{\"1\":{\"27\":1}}],[\"指针初始化为\",{\"1\":{\"113\":1}}],[\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定\",{\"1\":{\"37\":1}}],[\"指针\",{\"1\":{\"19\":2,\"22\":1,\"23\":1,\"27\":1,\"36\":1,\"37\":1}}],[\"节点之间通过引用\",{\"1\":{\"37\":1}}],[\"节点值\",{\"1\":{\"19\":1,\"27\":1}}],[\"节点的\",{\"1\":{\"19\":1}}],[\"v\",{\"1\":{\"105\":3}}],[\"variable>\",{\"1\":{\"103\":1}}],[\"variable\",{\"0\":{\"103\":1},\"1\":{\"103\":1}}],[\"value\",{\"1\":{\"102\":2,\"104\":1}}],[\"val\",{\"1\":{\"19\":2,\"27\":2}}],[\"vector<std\",{\"1\":{\"107\":1,\"108\":1}}],[\"vector<int>\",{\"1\":{\"31\":2,\"44\":2,\"45\":2,\"50\":2,\"51\":2,\"102\":1}}],[\"vector\",{\"1\":{\"29\":1,\"31\":1,\"37\":2,\"44\":1,\"45\":1,\"51\":1}}],[\"vs\",{\"0\":{\"26\":1}}],[\"void\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"22\":1,\"23\":1,\"44\":1,\"45\":1,\"50\":1,\"51\":1,\"95\":1,\"99\":2,\"101\":1,\"102\":2,\"103\":2,\"104\":1,\"105\":1,\"106\":3,\"107\":1,\"108\":1}}],[\"spinlock\",{\"0\":{\"106\":1},\"1\":{\"106\":5}}],[\"spawn\",{\"1\":{\"99\":2}}],[\"swap\",{\"1\":{\"104\":1,\"106\":1,\"110\":1}}],[\"sleep\",{\"1\":{\"103\":1,\"105\":1,\"106\":1}}],[\"shared\",{\"0\":{\"102\":1},\"1\":{\"102\":4}}],[\"sync\",{\"1\":{\"107\":2,\"108\":3}}],[\"synchronize\",{\"1\":{\"99\":1}}],[\"systemd\",{\"1\":{\"95\":1}}],[\"sem\",{\"1\":{\"105\":3}}],[\"semaphore<1>\",{\"1\":{\"105\":1}}],[\"semaphore\",{\"0\":{\"105\":1}}],[\"set\",{\"1\":{\"103\":2,\"106\":2}}],[\"seconds\",{\"1\":{\"103\":1,\"105\":1,\"106\":1}}],[\"second\",{\"1\":{\"99\":3}}],[\"self\",{\"1\":{\"37\":2}}],[\"signal\",{\"1\":{\"95\":1,\"105\":1}}],[\"signum\",{\"1\":{\"95\":1}}],[\"sigchld\",{\"1\":{\"95\":8}}],[\"size\",{\"1\":{\"11\":3,\"12\":2,\"13\":2,\"14\":2,\"15\":2,\"16\":3,\"34\":1,\"35\":1,\"37\":2,\"42\":2,\"44\":4,\"45\":6,\"48\":2,\"50\":4,\"51\":3,\"112\":5,\"113\":4}}],[\"srp\",{\"1\":{\"62\":1}}],[\"store\",{\"1\":{\"112\":2,\"113\":4,\"114\":2}}],[\"stuff\",{\"1\":{\"99\":2}}],[\"static\",{\"0\":{\"80\":1}}],[\"stacktop\",{\"1\":{\"50\":10}}],[\"stack<int>\",{\"1\":{\"48\":1}}],[\"stack\",{\"1\":{\"37\":1,\"47\":1,\"48\":10,\"50\":2,\"51\":9}}],[\"stksize++\",{\"1\":{\"50\":1}}],[\"stksize\",{\"1\":{\"50\":4}}],[\"std\",{\"1\":{\"37\":5,\"99\":6,\"101\":6,\"102\":11,\"103\":11,\"104\":6,\"105\":7,\"106\":9,\"107\":6,\"108\":6,\"111\":1,\"112\":14,\"113\":18,\"114\":3}}],[\"stl\",{\"1\":{\"37\":1}}],[\"strategy\",{\"1\":{\"68\":1}}],[\"string\",{\"1\":{\"37\":1}}],[\"struct\",{\"1\":{\"19\":1,\"27\":1}}],[\"还未进入准备就绪队列\",{\"1\":{\"90\":1}}],[\"还需要对操作系统有深刻的理解\",{\"1\":{\"75\":1}}],[\"还需额外保存一个引用\",{\"1\":{\"19\":1}}],[\"还是数组吗\",{\"1\":{\"37\":1}}],[\"还是和节点值各占一半呢\",{\"1\":{\"37\":1}}],[\"还会缓存其周围的其他数据\",{\"1\":{\"17\":1}}],[\"除了包含值\",{\"1\":{\"19\":1}}],[\"中弹出最近的操作\",{\"1\":{\"55\":2}}],[\"中需要手动释放内存\",{\"1\":{\"55\":1}}],[\"中初始化\",{\"1\":{\"37\":1}}],[\"中\",{\"1\":{\"31\":1,\"37\":1,\"93\":1,\"113\":1}}],[\"中的原子操作\",{\"0\":{\"111\":1}}],[\"中的数字也被包装为对象\",{\"1\":{\"37\":1}}],[\"中的相同\",{\"1\":{\"37\":1}}],[\"中的\",{\"1\":{\"29\":4,\"104\":1}}],[\"中分别被记为\",{\"1\":{\"19\":1}}],[\"中随机抽取一个数字\",{\"1\":{\"11\":1}}],[\"它支持以下操作\",{\"1\":{\"111\":1}}],[\"它检查一个变量是否有特定的值\",{\"1\":{\"110\":1}}],[\"它的所有资源\",{\"1\":{\"93\":1}}],[\"它的前身c++之父的很多心得经验的博客\",{\"1\":{\"75\":1}}],[\"它的用途是什么\",{\"1\":{\"55\":1}}],[\"它定义了一系列算法\",{\"1\":{\"68\":1}}],[\"它允许在两端进行元素的添加和删除操作\",{\"1\":{\"54\":1}}],[\"它保留了数组的优势\",{\"1\":{\"36\":1}}],[\"它继承了数组的各项优点\",{\"1\":{\"29\":1}}],[\"它表现的是栈\",{\"1\":{\"55\":1}}],[\"它表现的特性为先进先出\",{\"1\":{\"28\":1}}],[\"它表现的特性为先进后出\",{\"1\":{\"28\":1}}],[\"它表示元素的有序集合\",{\"1\":{\"29\":1}}],[\"它需要对一组进程进行循环\",{\"1\":{\"28\":1}}],[\"它在\",{\"1\":{\"19\":1}}],[\"它们分为三大类\",{\"1\":{\"61\":1}}],[\"它们的实现比较复杂\",{\"1\":{\"35\":1}}],[\"它们的内存地址无须连续\",{\"1\":{\"19\":1}}],[\"它们之间没有空间再存放任何数据\",{\"1\":{\"12\":1}}],[\"和反撤销\",{\"1\":{\"55\":1}}],[\"和实例对象等\",{\"1\":{\"37\":1}}],[\"和前驱节点\",{\"1\":{\"27\":1}}],[\"和\",{\"1\":{\"19\":3,\"21\":1,\"22\":1,\"29\":2,\"31\":1,\"37\":3,\"44\":2,\"45\":1,\"55\":2,\"82\":1,\"113\":1,\"114\":1}}],[\"和指向下一节点的\",{\"1\":{\"19\":1}}],[\"和某个元素的索引\",{\"1\":{\"11\":1}}],[\"值\",{\"1\":{\"19\":1}}],[\"值得注意的是\",{\"1\":{\"12\":1}}],[\"每当一个线程到达屏障点时\",{\"1\":{\"107\":1}}],[\"每当用户执行一个操作\",{\"1\":{\"55\":1}}],[\"每当我们打开新的网页\",{\"1\":{\"53\":1}}],[\"每次完成任务时\",{\"1\":{\"108\":1}}],[\"每次调用函数时\",{\"1\":{\"53\":1}}],[\"每次插入与删除操作都是\",{\"1\":{\"37\":1}}],[\"每个进程被赋予一个时间片\",{\"1\":{\"28\":1}}],[\"每个节点都包含两项数据\",{\"1\":{\"19\":1}}],[\"每轮判断元素值是否匹配\",{\"1\":{\"15\":1}}],[\"对修改关闭\",{\"1\":{\"62\":1}}],[\"对于保持系统的稳定性和资源利用率至关重要\",{\"1\":{\"95\":1}}],[\"对于入栈操作\",{\"1\":{\"50\":1}}],[\"对于环形数组\",{\"1\":{\"45\":1}}],[\"对缓存的利用率较低\",{\"1\":{\"37\":1}}],[\"对时间效率和空间效率是否有影响\",{\"1\":{\"37\":1}}],[\"对应队列\",{\"1\":{\"28\":1}}],[\"对应栈\",{\"1\":{\"28\":1}}],[\"对应的元素存放在数组中的对应位置\",{\"1\":{\"18\":1}}],[\"对象等\",{\"1\":{\"47\":1}}],[\"对象\",{\"1\":{\"19\":1,\"113\":1}}],[\"相等\",{\"1\":{\"113\":2}}],[\"相同\",{\"1\":{\"82\":1}}],[\"相对地\",{\"1\":{\"37\":1}}],[\"相较于数组\",{\"1\":{\"33\":1}}],[\"相较于单向链表\",{\"1\":{\"27\":1}}],[\"相比之下\",{\"1\":{\"22\":1,\"54\":1}}],[\"相连接\",{\"1\":{\"19\":1}}],[\"相关的面\",{\"0\":{\"1\":1}}],[\"存储方式\",{\"1\":{\"26\":1}}],[\"存储数组的内存空间必须是连续的\",{\"1\":{\"19\":1}}],[\"存储在堆上\",{\"1\":{\"10\":1}}],[\"存储在栈上和堆上的数组都被存储在连续内存空间内\",{\"1\":{\"37\":1}}],[\"存储在栈上\",{\"1\":{\"10\":1}}],[\"空\",{\"1\":{\"19\":1}}],[\"空闲的内存空间可能散落在内存各处\",{\"1\":{\"19\":1}}],[\"空间效率\",{\"1\":{\"52\":1}}],[\"空间效率高\",{\"1\":{\"17\":1}}],[\"空间开销\",{\"1\":{\"37\":1}}],[\"空间浪费\",{\"1\":{\"17\":1}}],[\"图\",{\"1\":{\"28\":1,\"37\":1}}],[\"图的邻接矩阵表示实际上是一个二维数组\",{\"1\":{\"18\":1}}],[\"图等数据结构\",{\"1\":{\"18\":1}}],[\"堆的大小一般受限于可用内存\",{\"1\":{\"37\":1}}],[\"堆上的分配和释放操作通常比栈上的慢\",{\"1\":{\"37\":1}}],[\"堆\",{\"1\":{\"18\":1}}],[\"哈希表和图等数据结构\",{\"1\":{\"28\":1}}],[\"哈希表\",{\"1\":{\"18\":1,\"28\":1}}],[\"张量之间的线性代数运算\",{\"1\":{\"18\":1}}],[\"矩阵\",{\"1\":{\"18\":1}}],[\"神经网络中大量使用了向量\",{\"1\":{\"18\":1}}],[\"机器学习\",{\"1\":{\"18\":1}}],[\"码值作为索引\",{\"1\":{\"18\":1}}],[\"码的映射\",{\"1\":{\"18\":1}}],[\"则唤醒所有读线程\",{\"1\":{\"102\":1}}],[\"则唤醒一个写线程\",{\"1\":{\"102\":2}}],[\"则唤醒一个线程\",{\"1\":{\"101\":1}}],[\"则锁定成功\",{\"1\":{\"102\":1}}],[\"则线程进入等待队列\",{\"1\":{\"102\":2}}],[\"则线程成功锁定\",{\"1\":{\"101\":1}}],[\"则增加读计数器\",{\"1\":{\"102\":1}}],[\"则将其更改为新值\",{\"1\":{\"110\":1}}],[\"则将互斥量状态设置为未锁定\",{\"1\":{\"101\":1}}],[\"则将该节点添加到尾节点后\",{\"1\":{\"44\":1}}],[\"则该线程进入等待队列并挂起\",{\"1\":{\"101\":1}}],[\"则该进程被挂起并返回到就绪队列中\",{\"1\":{\"91\":1}}],[\"则不需要释放内存\",{\"1\":{\"55\":1}}],[\"则返回到数组头部\",{\"1\":{\"45\":1}}],[\"则令头\",{\"1\":{\"44\":1}}],[\"则多次引用了同一个列表\",{\"1\":{\"37\":1}}],[\"则会造成内存空间浪费\",{\"1\":{\"29\":1}}],[\"则很可能无法满足使用需求\",{\"1\":{\"29\":1}}],[\"则得到一个环形链表\",{\"1\":{\"27\":1}}],[\"则只需改变两个节点引用\",{\"1\":{\"22\":1}}],[\"则可以将字符的\",{\"1\":{\"18\":1}}],[\"则需重新建立一个更大的数组\",{\"1\":{\"16\":1}}],[\"则需要先将上面的盘子依次移走\",{\"1\":{\"47\":1}}],[\"则需要先扩容列表再添加\",{\"1\":{\"37\":1}}],[\"则需要进行扩容\",{\"1\":{\"35\":1}}],[\"则需要把索引\",{\"1\":{\"13\":1}}],[\"则需要将该元素之后的所有元素都向后移动一位\",{\"1\":{\"12\":1}}],[\"acquire\",{\"1\":{\"105\":2,\"106\":1,\"110\":1,\"112\":2,\"113\":4,\"114\":3}}],[\"access\",{\"1\":{\"24\":1}}],[\"add\",{\"1\":{\"104\":1}}],[\"atomic<size\",{\"1\":{\"112\":2}}],[\"atomic<int>\",{\"1\":{\"104\":1}}],[\"atomic\",{\"0\":{\"104\":1},\"1\":{\"104\":1,\"106\":2,\"111\":1}}],[\"all\",{\"1\":{\"103\":2}}],[\"auto\",{\"1\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1}}],[\"and\",{\"1\":{\"99\":2,\"104\":2,\"106\":3,\"107\":1,\"110\":1}}],[\"a+1\",{\"1\":{\"82\":2}}],[\"a\",{\"0\":{\"37\":1,\"55\":1,\"82\":4},\"1\":{\"55\":4,\"82\":6}}],[\"ascii\",{\"1\":{\"18\":2}}],[\"arrive\",{\"1\":{\"107\":1}}],[\"arr1\",{\"1\":{\"10\":1}}],[\"arr\",{\"1\":{\"10\":1,\"45\":3}}],[\"arraystack\",{\"1\":{\"51\":1}}],[\"arrayqueue\",{\"1\":{\"45\":2}}],[\"arraylist\",{\"1\":{\"29\":1}}],[\"array\",{\"1\":{\"8\":1,\"29\":1,\"50\":1,\"51\":2}}],[\"查找其中值为\",{\"1\":{\"25\":1}}],[\"查找节点\",{\"0\":{\"25\":1}}],[\"查找表\",{\"1\":{\"18\":1}}],[\"查找元素\",{\"0\":{\"15\":1}}],[\"归并排序\",{\"1\":{\"18\":1}}],[\"快速排序\",{\"1\":{\"18\":1}}],[\"排序和搜索\",{\"1\":{\"18\":1}}],[\"随机访问\",{\"1\":{\"18\":1}}],[\"随机访问元素\",{\"1\":{\"11\":1}}],[\"既频繁应用在各类算法之中\",{\"1\":{\"18\":1}}],[\"开闭原则\",{\"1\":{\"62\":1}}],[\"开销很大\",{\"1\":{\"17\":1}}],[\"开始计数会更自然\",{\"1\":{\"11\":1}}],[\"当计数器减为零时\",{\"1\":{\"108\":1}}],[\"当计数器达到零时\",{\"1\":{\"107\":1}}],[\"当持有锁的线程释放自旋锁时\",{\"1\":{\"106\":1}}],[\"当写线程解锁时\",{\"1\":{\"102\":1}}],[\"当读线程解锁时\",{\"1\":{\"102\":1}}],[\"当一个线程尝试获取自旋锁时\",{\"1\":{\"106\":1}}],[\"当一个线程尝试锁定互斥量时\",{\"1\":{\"101\":1}}],[\"当一个线程执行\",{\"1\":{\"105\":2}}],[\"当一个线程修改条件状态并调用\",{\"1\":{\"103\":1}}],[\"当一个线程请求写锁定时\",{\"1\":{\"102\":1}}],[\"当一个线程请求读锁定时\",{\"1\":{\"102\":1}}],[\"当一个线程解锁互斥量时\",{\"1\":{\"101\":1}}],[\"当一个子进程结束时\",{\"1\":{\"93\":1}}],[\"当子进程结束时\",{\"1\":{\"95\":1}}],[\"当父进程调用\",{\"1\":{\"93\":1}}],[\"当等待的事件发生\",{\"1\":{\"91\":1}}],[\"当进程完成其任务或被强制终止时\",{\"1\":{\"91\":1}}],[\"当进程执行\",{\"1\":{\"91\":1}}],[\"当进程创建完成\",{\"1\":{\"91\":1}}],[\"当用户执行\",{\"1\":{\"55\":2}}],[\"当用户点击后退按钮时\",{\"1\":{\"55\":1}}],[\"当用户点击前进或后退按钮时\",{\"1\":{\"28\":1}}],[\"当用户访问一个新页面时\",{\"1\":{\"55\":1}}],[\"当入栈与出栈操作的元素是基本数据类型时\",{\"1\":{\"52\":1}}],[\"当作栈来使用\",{\"1\":{\"48\":1}}],[\"当它们到达数组尾部时就无法继续移动了\",{\"1\":{\"45\":1}}],[\"当使用数组实现列表时\",{\"1\":{\"29\":1}}],[\"当时间片用完时\",{\"1\":{\"28\":1}}],[\"当插入操作在链表的一端进行\",{\"1\":{\"28\":1}}],[\"当插入和删除操作都在链表的一端进行时\",{\"1\":{\"28\":1}}],[\"当需要快速查找一个元素或其对应关系时\",{\"1\":{\"18\":1}}],[\"当数组中元素较多时\",{\"1\":{\"17\":1}}],[\"当访问数组元素时\",{\"1\":{\"17\":1}}],[\"插入节点\",{\"0\":{\"22\":1}}],[\"插入与删除元素\",{\"0\":{\"33\":1}}],[\"插入与删除操作需要移动大量的元素\",{\"1\":{\"17\":1}}],[\"插入与删除效率低\",{\"1\":{\"17\":1}}],[\"插入元素\",{\"0\":{\"12\":1}}],[\"emplace\",{\"1\":{\"107\":1,\"108\":1}}],[\"empty\",{\"1\":{\"42\":2,\"48\":2}}],[\"execute\",{\"1\":{\"99\":1}}],[\"example\",{\"1\":{\"99\":1}}],[\"exit\",{\"1\":{\"95\":5}}],[\"extern\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"extend\",{\"1\":{\"16\":1}}],[\"enqueue\",{\"1\":{\"112\":2,\"113\":5}}],[\"endl\",{\"1\":{\"45\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":2,\"108\":2,\"112\":2,\"113\":2}}],[\"enlarge\",{\"1\":{\"16\":2}}],[\"else\",{\"1\":{\"44\":1,\"95\":4}}],[\"erase\",{\"1\":{\"33\":1}}],[\"扩容后的容量也可能超出实际需求\",{\"1\":{\"52\":1}}],[\"扩容一般会乘以一个系数\",{\"1\":{\"37\":1}}],[\"扩容倍数所占的内存吗\",{\"1\":{\"37\":1}}],[\"扩容倍数等\",{\"1\":{\"35\":1}}],[\"扩容机制通常是按照特定倍率\",{\"1\":{\"52\":1}}],[\"扩容机制\",{\"1\":{\"35\":1}}],[\"扩容数组需要将所有数据复制到新数组\",{\"1\":{\"17\":1}}],[\"扩容数组\",{\"0\":{\"16\":1}}],[\"扩展数组长度\",{\"1\":{\"16\":1}}],[\"程序内存管理\",{\"1\":{\"53\":1}}],[\"程序运行时\",{\"1\":{\"36\":1}}],[\"程序需要从头节点出发\",{\"1\":{\"24\":1}}],[\"程序难以保证数组之后的内存空间是可用的\",{\"1\":{\"16\":1}}],[\"程序员的知识库\",{\"1\":{\"0\":1}}],[\"tail\",{\"1\":{\"112\":5,\"113\":11,\"114\":2}}],[\"target\",{\"1\":{\"15\":2,\"25\":4}}],[\"t>\",{\"1\":{\"112\":3,\"113\":1}}],[\"template\",{\"1\":{\"112\":1,\"113\":1}}],[\"test\",{\"1\":{\"106\":2}}],[\"terminated\",{\"1\":{\"90\":1}}],[\"true\",{\"1\":{\"103\":2,\"112\":2,\"113\":2}}],[\"traverse\",{\"1\":{\"14\":1}}],[\"t4\",{\"1\":{\"102\":2}}],[\"t3\",{\"1\":{\"102\":2}}],[\"t2\",{\"1\":{\"102\":2}}],[\"t1\",{\"1\":{\"102\":2}}],[\"the\",{\"1\":{\"108\":1}}],[\"this\",{\"1\":{\"103\":1,\"105\":1,\"106\":1}}],[\"th\",{\"1\":{\"101\":2,\"103\":2,\"104\":2,\"105\":2,\"106\":2,\"107\":2,\"108\":2}}],[\"that\",{\"1\":{\"99\":2}}],[\"thread>\",{\"1\":{\"107\":1,\"108\":1}}],[\"threads\",{\"1\":{\"99\":1,\"101\":3,\"103\":3,\"104\":3,\"105\":3,\"106\":3,\"107\":3,\"108\":3}}],[\"thread\",{\"1\":{\"99\":6,\"101\":5,\"102\":4,\"103\":5,\"104\":2,\"105\":4,\"106\":4,\"107\":2,\"108\":2,\"112\":2,\"113\":2}}],[\"throw\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1}}],[\"t\",{\"1\":{\"95\":5,\"103\":2,\"112\":9,\"113\":8}}],[\"top\",{\"1\":{\"48\":2,\"50\":2,\"51\":2}}],[\"tovector\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1}}],[\"tmp\",{\"1\":{\"44\":2,\"50\":2}}],[\"times\",{\"1\":{\"37\":1}}],[\"flag\",{\"1\":{\"106\":5}}],[\"fetch\",{\"1\":{\"104\":1}}],[\"false\",{\"1\":{\"103\":1,\"112\":2,\"113\":2}}],[\"final\",{\"1\":{\"104\":1}}],[\"finishes\",{\"1\":{\"99\":2}}],[\"find\",{\"1\":{\"15\":1,\"25\":1}}],[\"first\",{\"1\":{\"99\":3}}],[\"found\",{\"1\":{\"119\":1}}],[\"foo\",{\"1\":{\"84\":2,\"99\":5}}],[\"fork\",{\"1\":{\"95\":10}}],[\"for\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"24\":1,\"34\":2,\"44\":1,\"45\":1,\"50\":1,\"101\":2,\"102\":1,\"103\":3,\"104\":3,\"105\":3,\"106\":3,\"107\":2,\"108\":2,\"112\":2,\"113\":2}}],[\"free\",{\"1\":{\"81\":1,\"109\":1}}],[\"freememorylinkedlist\",{\"1\":{\"44\":1,\"50\":1}}],[\"front\",{\"1\":{\"42\":2,\"44\":11,\"45\":13}}],[\"线程同步\",{\"2\":{\"116\":1}}],[\"线程同步机制\",{\"0\":{\"100\":1}}],[\"线程会持续等待直到成功取出元素\",{\"1\":{\"113\":1}}],[\"线程会持续等待直到成功插入\",{\"1\":{\"113\":1}}],[\"线程等待直到锁存器倒数到零\",{\"1\":{\"108\":1}}],[\"线程将反复检查锁的状态\",{\"1\":{\"106\":1}}],[\"线程将自己添加到等待队列\",{\"1\":{\"103\":1}}],[\"线程在尝试获取锁时会反复检查锁的状态\",{\"1\":{\"106\":1}}],[\"线程在等待条件变量时\",{\"1\":{\"103\":1}}],[\"线程进入等待队列\",{\"1\":{\"105\":1}}],[\"线程再次进入等待状态\",{\"1\":{\"103\":1}}],[\"线程继续执行\",{\"1\":{\"102\":1,\"103\":1,\"105\":1}}],[\"线程创建\",{\"0\":{\"99\":1}}],[\"线程编程\",{\"0\":{\"98\":1},\"1\":{\"1\":1}}],[\"线性结构\",{\"2\":{\"39\":1}}],[\"线性查找\",{\"1\":{\"15\":1}}],[\"若之后不需要用到\",{\"1\":{\"55\":1}}],[\"若越过尾部\",{\"1\":{\"45\":1}}],[\"若插入元素时列表容量已满\",{\"1\":{\"35\":1}}],[\"若长度过大\",{\"1\":{\"29\":1}}],[\"若长度过小\",{\"1\":{\"29\":1}}],[\"若匹配则输出对应索引\",{\"1\":{\"15\":1}}],[\"若想删除索引\",{\"1\":{\"13\":1}}],[\"currenthead\",{\"1\":{\"112\":4,\"113\":8}}],[\"currenttail\",{\"1\":{\"112\":3,\"113\":5}}],[\"chrono\",{\"1\":{\"103\":1,\"105\":1,\"106\":1}}],[\"cv\",{\"1\":{\"103\":6}}],[\"cas\",{\"1\":{\"104\":1,\"110\":1,\"111\":1}}],[\"calls\",{\"1\":{\"99\":2}}],[\"capacity\",{\"1\":{\"45\":4,\"112\":7,\"113\":9}}],[\"cppcoreguidelines\",{\"1\":{\"75\":2}}],[\"cpu\",{\"1\":{\"28\":2,\"36\":1,\"90\":2,\"91\":3,\"94\":1}}],[\"compare\",{\"1\":{\"104\":1,\"106\":1,\"110\":1}}],[\"completed\",{\"1\":{\"99\":1}}],[\"consumed\",{\"1\":{\"112\":1,\"113\":1}}],[\"consumer\",{\"1\":{\"112\":2,\"113\":3}}],[\"const\",{\"0\":{\"85\":1},\"1\":{\"85\":1,\"102\":1,\"112\":1,\"113\":1}}],[\"constexpr\",{\"1\":{\"83\":1}}],[\"condition\",{\"0\":{\"103\":1},\"1\":{\"103\":1}}],[\"concurrently\",{\"1\":{\"99\":1}}],[\"core\",{\"1\":{\"75\":1}}],[\"cout\",{\"1\":{\"45\":1,\"99\":3,\"101\":1,\"102\":2,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":2,\"108\":2,\"112\":2,\"113\":2}}],[\"counting\",{\"1\":{\"105\":1}}],[\"counter\",{\"1\":{\"104\":3}}],[\"count\",{\"1\":{\"14\":2,\"34\":4,\"108\":1}}],[\"class\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1,\"106\":1,\"112\":1,\"113\":1}}],[\"clear\",{\"1\":{\"33\":1,\"106\":1}}],[\"c\",{\"0\":{\"84\":1},\"1\":{\"19\":1,\"29\":1,\"55\":1,\"84\":2}}],[\"c++11\",{\"1\":{\"111\":1}}],[\"c++不能只学习语言本身\",{\"1\":{\"75\":1}}],[\"c++>>\",{\"1\":{\"75\":1}}],[\"c++之父大作\",{\"1\":{\"75\":1}}],[\"c++实战经验\",{\"1\":{\"74\":1}}],[\"c++20各种新特性\",{\"1\":{\"74\":1}}],[\"c++进阶\",{\"1\":{\"74\":1}}],[\"c++基础\",{\"1\":{\"74\":1}}],[\"c++基础知识介绍的非常全面\",{\"1\":{\"74\":1}}],[\"c++面试题\",{\"1\":{\"1\":1}}],[\"c++\",{\"0\":{\"1\":1,\"79\":1,\"111\":1},\"1\":{\"0\":3,\"19\":2,\"29\":1,\"31\":1,\"35\":1,\"37\":1,\"55\":1,\"84\":1,\"104\":1,\"110\":1},\"2\":{\"4\":1,\"39\":1,\"57\":1,\"64\":1,\"67\":1,\"72\":1,\"87\":1,\"97\":1,\"116\":1}}],[\"但只能使用一次\",{\"1\":{\"108\":1}}],[\"但在写入时只允许一个线程操作\",{\"1\":{\"102\":1}}],[\"但在扩容过程中\",{\"1\":{\"54\":1}}],[\"但它会占用一个进程表项\",{\"1\":{\"94\":1}}],[\"但它的进程描述符\",{\"1\":{\"93\":1}}],[\"但需要注意的是\",{\"1\":{\"54\":1}}],[\"但由于扩容是低频操作\",{\"1\":{\"52\":1}}],[\"但由于其长度不可变\",{\"1\":{\"29\":1}}],[\"但这已超出了栈的定义范畴\",{\"1\":{\"52\":1}}],[\"但这样做会造成部分内存空间浪费\",{\"1\":{\"13\":1}}],[\"但二维数组会有这个问题\",{\"1\":{\"37\":1}}],[\"但好像一些算法书上不怎么直接使用它\",{\"1\":{\"37\":1}}],[\"但是\",{\"1\":{\"52\":1}}],[\"但是初始化\",{\"1\":{\"37\":1}}],[\"但是增删之前都需要\",{\"1\":{\"37\":1}}],[\"但可能导致部分内存空间浪费\",{\"1\":{\"36\":1,\"37\":1}}],[\"但可能浪费空间\",{\"1\":{\"26\":1}}],[\"但节点访问效率低\",{\"1\":{\"36\":1}}],[\"但插入和删除元素效率低\",{\"1\":{\"36\":1}}],[\"但插入和删除元素的效率仍与数组相同\",{\"1\":{\"33\":1}}],[\"但相应地也需要占用更多的内存空间\",{\"1\":{\"27\":1}}],[\"但实际上遍历此链表已经无法访问到\",{\"1\":{\"23\":1}}],[\"但从地址计算公式的角度看\",{\"1\":{\"11\":1}}],[\"的值\",{\"1\":{\"113\":2}}],[\"的进程\",{\"1\":{\"95\":1}}],[\"的风险\",{\"1\":{\"62\":1}}],[\"的体现\",{\"1\":{\"55\":1}}],[\"的每个元素引用相同的地址吗\",{\"1\":{\"37\":1}}],[\"的性能会更好\",{\"1\":{\"37\":1}}],[\"的时间查找元素\",{\"1\":{\"37\":1}}],[\"的角度看\",{\"1\":{\"37\":1}}],[\"的引用\",{\"1\":{\"27\":1}}],[\"的首个节点\",{\"1\":{\"25\":1}}],[\"的节点\",{\"1\":{\"24\":1,\"25\":1}}],[\"的操作\",{\"1\":{\"16\":1}}],[\"的\",{\"1\":{\"13\":1}}],[\"超出数组长度范围的元素会丢失\",{\"1\":{\"13\":1}}],[\"总的来看\",{\"1\":{\"13\":1}}],[\"++counter\",{\"1\":{\"104\":1}}],[\"++i\",{\"1\":{\"101\":1,\"103\":1,\"104\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":2,\"113\":2}}],[\"+1\",{\"1\":{\"82\":1}}],[\"+=\",{\"1\":{\"14\":1,\"34\":2}}],[\"+\",{\"1\":{\"13\":1,\"16\":1,\"33\":2,\"37\":1,\"45\":4,\"55\":1,\"81\":2,\"112\":2,\"113\":4}}],[\"<typename\",{\"1\":{\"112\":1,\"113\":1}}],[\"<thread>\",{\"1\":{\"99\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":1}}],[\"<latch>\",{\"1\":{\"108\":1}}],[\"<barrier>\",{\"1\":{\"107\":1}}],[\"<atomic>\",{\"1\":{\"104\":1,\"106\":1,\"112\":1}}],[\"<condition\",{\"1\":{\"103\":1}}],[\"<vector>\",{\"1\":{\"102\":1,\"107\":1,\"108\":1,\"112\":1}}],[\"<mutex>\",{\"1\":{\"101\":1,\"103\":1}}],[\"<semaphore>\",{\"1\":{\"105\":1}}],[\"<shared\",{\"1\":{\"102\":1}}],[\"<signal\",{\"1\":{\"95\":1}}],[\"<sys\",{\"1\":{\"95\":1}}],[\"<unistd\",{\"1\":{\"95\":1}}],[\"<iostream>\",{\"1\":{\"95\":1,\"99\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":1}}],[\"<<深入理解计算机系统>>\",{\"1\":{\"75\":1}}],[\"<<effective\",{\"1\":{\"75\":1}}],[\"<<c++程序设计\",{\"1\":{\"75\":1}}],[\"<<c++20高级编程>>\",{\"1\":{\"74\":1}}],[\"<<c++\",{\"1\":{\"74\":1,\"75\":1}}],[\"<<\",{\"1\":{\"45\":2,\"99\":2,\"101\":3,\"102\":3,\"103\":3,\"104\":3,\"105\":4,\"106\":4,\"107\":8,\"108\":8,\"112\":6,\"113\":6}}],[\"<\",{\"1\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"24\":1,\"34\":1,\"44\":1,\"45\":1,\"101\":1,\"103\":1,\"104\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":2,\"113\":2}}],[\"删除栈顶元素的操作叫作\",{\"1\":{\"47\":1}}],[\"删除头节点\",{\"1\":{\"44\":1}}],[\"删除队首元素的操作称为\",{\"1\":{\"41\":1}}],[\"删除和遍历等操作\",{\"1\":{\"29\":1}}],[\"删除操作在链表的另一端进行\",{\"1\":{\"28\":1}}],[\"删除链表的节点\",{\"1\":{\"23\":1}}],[\"删除节点\",{\"0\":{\"23\":1},\"1\":{\"37\":1}}],[\"删除索引\",{\"1\":{\"13\":1,\"33\":1}}],[\"删除元素完成后\",{\"1\":{\"13\":1}}],[\"删除元素\",{\"0\":{\"13\":1},\"1\":{\"26\":1,\"33\":1}}],[\"了\",{\"1\":{\"13\":1,\"37\":1}}],[\"无锁编程主要依赖于原子操作和内存序列模型\",{\"1\":{\"109\":1}}],[\"无锁编程\",{\"0\":{\"109\":1},\"1\":{\"109\":1}}],[\"无需锁定\",{\"1\":{\"104\":1}}],[\"无返回值\",{\"1\":{\"48\":1}}],[\"无须使用者考虑容量限制的问题\",{\"1\":{\"29\":1}}],[\"无须额外的结构开销\",{\"1\":{\"17\":1}}],[\"无意义\",{\"1\":{\"13\":2}}],[\"无初始值\",{\"1\":{\"10\":1,\"31\":2}}],[\"请注意\",{\"1\":{\"13\":1,\"23\":1}}],[\"处理\",{\"1\":{\"95\":1}}],[\"处插入数字\",{\"1\":{\"33\":1}}],[\"处插入元素\",{\"1\":{\"12\":1}}],[\"处的元素更新为\",{\"1\":{\"32\":1}}],[\"处的元素\",{\"1\":{\"12\":1,\"13\":2,\"32\":1,\"33\":1}}],[\"赋给\",{\"1\":{\"12\":1}}],[\"将头部指针所指向的元素存储到\",{\"1\":{\"113\":1}}],[\"将头节点作为栈顶\",{\"1\":{\"50\":1}}],[\"将新的尾部指针存储到\",{\"1\":{\"113\":1}}],[\"将元素存储在当前尾部指针所指向的位置\",{\"1\":{\"113\":1}}],[\"将子进程的父进程设置为\",{\"1\":{\"95\":1}}],[\"将重载函数重新命名成唯一的标识符\",{\"1\":{\"84\":1}}],[\"将这个操作压入栈\",{\"1\":{\"55\":1}}],[\"将把元素添加到栈顶的操作叫作\",{\"1\":{\"47\":1}}],[\"将把元素加入队尾的操作称为\",{\"1\":{\"41\":1}}],[\"将数组转化为\",{\"1\":{\"45\":1}}],[\"将输入元素赋值给\",{\"1\":{\"45\":1}}],[\"将链表转化为\",{\"1\":{\"44\":1}}],[\"将索引\",{\"1\":{\"32\":1}}],[\"将切换到下一个进程\",{\"1\":{\"28\":1}}],[\"将最后一个节点称为尾节点\",{\"1\":{\"27\":1}}],[\"将原数组中的所有元素复制到新数组\",{\"1\":{\"16\":1}}],[\"将\",{\"1\":{\"12\":1,\"45\":1,\"50\":1}}],[\">=\",{\"1\":{\"50\":1}}],[\">val\",{\"1\":{\"25\":1,\"44\":2,\"50\":2}}],[\">next\",{\"1\":{\"21\":4,\"22\":3,\"23\":4,\"24\":1,\"25\":1,\"44\":3,\"50\":3}}],[\">\",{\"1\":{\"12\":1,\"21\":4,\"23\":2,\"95\":2}}],[\"item\",{\"1\":{\"112\":7,\"113\":11}}],[\"io\",{\"1\":{\"75\":1}}],[\"is\",{\"1\":{\"105\":1,\"106\":1,\"107\":2,\"108\":1}}],[\"isocpp\",{\"1\":{\"75\":1}}],[\"isp\",{\"1\":{\"62\":1}}],[\"isempty\",{\"1\":{\"44\":1,\"45\":2,\"50\":2,\"51\":2}}],[\"id\",{\"1\":{\"37\":2,\"101\":4,\"103\":4,\"105\":2,\"106\":2,\"107\":3,\"108\":3}}],[\"i$\",{\"1\":{\"24\":1}}],[\"if\",{\"1\":{\"15\":1,\"23\":1,\"24\":1,\"25\":1,\"44\":2,\"45\":2,\"50\":1,\"51\":1,\"95\":5,\"112\":2,\"113\":4}}],[\"i++\",{\"1\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"24\":1,\"34\":1,\"44\":1,\"45\":1}}],[\"i\",{\"1\":{\"12\":5,\"13\":4,\"14\":3,\"15\":4,\"16\":4,\"24\":3,\"34\":3,\"44\":3,\"45\":3,\"50\":4,\"90\":1,\"91\":2,\"101\":4,\"103\":4,\"104\":5,\"105\":4,\"106\":4,\"107\":3,\"108\":3,\"112\":6,\"113\":7}}],[\"increment\",{\"1\":{\"104\":2}}],[\"include\",{\"1\":{\"95\":4,\"99\":2,\"101\":3,\"102\":4,\"103\":4,\"104\":3,\"105\":3,\"106\":3,\"107\":4,\"108\":4,\"112\":4}}],[\"init\",{\"1\":{\"95\":7,\"106\":1}}],[\"insert\",{\"1\":{\"12\":1,\"22\":1,\"33\":1}}],[\"int\",{\"0\":{\"82\":1},\"1\":{\"10\":6,\"11\":5,\"12\":5,\"13\":4,\"14\":4,\"15\":5,\"16\":7,\"19\":2,\"24\":2,\"25\":3,\"27\":2,\"32\":1,\"34\":3,\"37\":3,\"42\":2,\"44\":7,\"45\":14,\"48\":2,\"50\":7,\"51\":5,\"52\":1,\"82\":2,\"84\":1,\"95\":2,\"99\":2,\"101\":3,\"102\":2,\"103\":3,\"104\":3,\"105\":3,\"106\":3,\"107\":3,\"108\":3,\"112\":4,\"113\":4}}],[\"index++\",{\"1\":{\"25\":1}}],[\"index\",{\"1\":{\"8\":1,\"12\":6,\"13\":4,\"24\":3,\"25\":2}}],[\"把索引\",{\"1\":{\"12\":1,\"13\":1}}],[\"列表中存储的不是数字本身\",{\"1\":{\"37\":1}}],[\"列表都会设定一个初始长度\",{\"1\":{\"37\":1}}],[\"列表的出现极大地提高了数组的实用性\",{\"1\":{\"37\":1}}],[\"列表的出现大幅提高了数组的实用性\",{\"1\":{\"36\":1}}],[\"列表是一种支持增删查改的元素有序集合\",{\"1\":{\"36\":1}}],[\"列表实现\",{\"0\":{\"35\":1}}],[\"列表可以根据索引遍历\",{\"1\":{\"34\":1}}],[\"列表可以自由地添加与删除元素\",{\"1\":{\"33\":1}}],[\"列表可以基于链表或数组实现\",{\"1\":{\"29\":1}}],[\"列表本质上是数组\",{\"1\":{\"32\":1}}],[\"列表常用操作\",{\"0\":{\"30\":1}}],[\"列表\",{\"0\":{\"29\":1},\"1\":{\"12\":1,\"29\":2}}],[\"丢失的末尾元素都是\",{\"1\":{\"13\":1}}],[\"丢失元素\",{\"1\":{\"13\":1}}],[\"丢失\",{\"1\":{\"12\":1}}],[\"如互斥锁\",{\"1\":{\"109\":1}}],[\"如计数器\",{\"1\":{\"104\":1}}],[\"如何避免产生僵尸进程\",{\"0\":{\"95\":1}}],[\"如内存\",{\"1\":{\"93\":1}}],[\"如等待信号\",{\"1\":{\"91\":1}}],[\"如void\",{\"1\":{\"84\":1}}],[\"如\",{\"1\":{\"62\":1,\"90\":1,\"91\":1,\"93\":1,\"104\":1,\"106\":1,\"110\":1,\"114\":3}}],[\"如观察者模式\",{\"1\":{\"61\":1}}],[\"如适配器模式\",{\"1\":{\"61\":1}}],[\"如单例模式\",{\"1\":{\"61\":1}}],[\"如整数\",{\"1\":{\"47\":1}}],[\"如上一节所述\",{\"1\":{\"24\":1}}],[\"如以下代码所示\",{\"1\":{\"19\":1}}],[\"如果\",{\"1\":{\"113\":2}}],[\"如果是\",{\"1\":{\"110\":1}}],[\"如果是先查找元素\",{\"1\":{\"37\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"106\":1}}],[\"如果计数器值为零或负\",{\"1\":{\"105\":1}}],[\"如果计数器值为正\",{\"1\":{\"105\":1}}],[\"如果条件不满足\",{\"1\":{\"103\":1}}],[\"如果条件满足\",{\"1\":{\"103\":1}}],[\"如果读计数器为0且有写线程在等待\",{\"1\":{\"102\":1}}],[\"如果有线程在等待队列中\",{\"1\":{\"105\":1}}],[\"如果有写线程在等待\",{\"1\":{\"102\":1}}],[\"如果有写锁存在\",{\"1\":{\"102\":1}}],[\"如果有读线程在等待\",{\"1\":{\"102\":1}}],[\"如果有读锁或写锁存在\",{\"1\":{\"102\":1}}],[\"如果有大量僵尸进程存在\",{\"1\":{\"94\":1}}],[\"如果没有读锁和写锁存在\",{\"1\":{\"102\":1}}],[\"如果没有写锁存在\",{\"1\":{\"102\":1}}],[\"如果没有线程在等待\",{\"1\":{\"101\":1}}],[\"如果等待队列中有其他线程\",{\"1\":{\"101\":1}}],[\"如果互斥量已锁定\",{\"1\":{\"101\":1}}],[\"如果互斥量未锁定\",{\"1\":{\"101\":1}}],[\"如果父进程在子进程结束前退出\",{\"1\":{\"95\":1}}],[\"如果运行中的进程的时间片耗尽\",{\"1\":{\"91\":1}}],[\"如果c++98的朋友想进阶到c++11\",{\"1\":{\"75\":1}}],[\"如果后续仍需要使用弹出节点\",{\"1\":{\"55\":1}}],[\"如果要同时支持后退和前进\",{\"1\":{\"53\":1}}],[\"如果入栈元素本身就是节点对象\",{\"1\":{\"52\":1}}],[\"如果入栈时超出数组容量\",{\"1\":{\"52\":1}}],[\"如果想取出底部的盘子\",{\"1\":{\"47\":1}}],[\"如果想在数组中间插入一个元素\",{\"1\":{\"12\":1}}],[\"如果队列已满\",{\"1\":{\"112\":1,\"113\":2}}],[\"如果队列不为空\",{\"1\":{\"44\":1}}],[\"如果队列为空\",{\"1\":{\"44\":1,\"112\":1,\"113\":2}}],[\"如果添加元素时超出列表长度\",{\"1\":{\"37\":1}}],[\"如果不断开\",{\"1\":{\"37\":1}}],[\"如果我们令单向链表的尾节点指向头节点\",{\"1\":{\"27\":1}}],[\"如果我们想随机抽取一些样本\",{\"1\":{\"18\":1}}],[\"如果我们希望扩容数组\",{\"1\":{\"16\":1}}],[\"如果数组分配的大小超过实际所需\",{\"1\":{\"17\":1}}],[\"如下图所示\",{\"1\":{\"12\":1,\"13\":1,\"22\":1,\"23\":1,\"27\":1,\"41\":1,\"44\":1,\"47\":1,\"50\":1,\"51\":1}}],[\"紧挨着的\",{\"1\":{\"12\":1}}],[\"rw\",{\"1\":{\"102\":3}}],[\"running\",{\"1\":{\"90\":1}}],[\"rust\",{\"1\":{\"19\":1}}],[\"raii\",{\"1\":{\"81\":1}}],[\"range\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1}}],[\"rand\",{\"1\":{\"11\":1}}],[\"randomnum\",{\"1\":{\"11\":2}}],[\"randomindex\",{\"1\":{\"11\":2}}],[\"randomaccess\",{\"1\":{\"11\":1}}],[\"relaxed\",{\"1\":{\"110\":1,\"112\":2,\"113\":5,\"114\":2}}],[\"release\",{\"1\":{\"105\":2,\"106\":1,\"110\":1,\"112\":3,\"113\":6,\"114\":3}}],[\"reached\",{\"1\":{\"108\":1}}],[\"reader\",{\"1\":{\"102\":3}}],[\"read\",{\"1\":{\"102\":1}}],[\"ready\",{\"1\":{\"90\":1,\"103\":6}}],[\"rear\",{\"1\":{\"44\":6,\"45\":9}}],[\"redo\",{\"1\":{\"55\":1}}],[\"res\",{\"1\":{\"16\":3,\"37\":3,\"44\":4,\"50\":4}}],[\"remove\",{\"1\":{\"13\":1,\"23\":1}}],[\"return\",{\"1\":{\"11\":1,\"15\":2,\"16\":1,\"23\":1,\"24\":2,\"25\":2,\"44\":5,\"45\":7,\"50\":5,\"51\":5,\"95\":1,\"99\":1,\"101\":1,\"102\":1,\"103\":2,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"112\":5,\"113\":5}}],[\"order\",{\"1\":{\"106\":2,\"110\":3,\"112\":7,\"113\":15,\"114\":6}}],[\"operations\",{\"0\":{\"104\":1}}],[\"one\",{\"1\":{\"103\":1}}],[\"ocp\",{\"1\":{\"62\":1}}],[\"of\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1}}],[\"out\",{\"1\":{\"44\":1,\"45\":1,\"50\":1,\"51\":1}}],[\"object\",{\"1\":{\"37\":1}}],[\"o\",{\"1\":{\"11\":1,\"16\":1,\"17\":1,\"22\":1,\"24\":2,\"26\":3,\"32\":1,\"33\":2,\"48\":3,\"51\":1,\"52\":1,\"54\":1,\"90\":1,\"91\":2}}],[\"在实际开发中\",{\"1\":{\"95\":1}}],[\"在系统中\",{\"1\":{\"94\":1}}],[\"在预编译时期会被完整替换\",{\"1\":{\"83\":1}}],[\"在申请\",{\"1\":{\"81\":1}}],[\"在class中用于声明类成员或函数\",{\"1\":{\"80\":1}}],[\"在使用策略模式时\",{\"1\":{\"70\":1}}],[\"在出栈后\",{\"1\":{\"55\":1}}],[\"在时间效率和空间效率的对比上\",{\"1\":{\"54\":1}}],[\"在时间效率方面\",{\"1\":{\"54\":1}}],[\"在空间效率方面\",{\"1\":{\"54\":1}}],[\"在递归函数中\",{\"1\":{\"53\":1}}],[\"在初始化列表时\",{\"1\":{\"52\":1}}],[\"在基于链表的实现中\",{\"1\":{\"52\":1}}],[\"在基于数组的实现中\",{\"1\":{\"52\":1}}],[\"在此处执行需要守护的任务\",{\"1\":{\"95\":1}}],[\"在此\",{\"1\":{\"48\":1}}],[\"在此不再赘述\",{\"1\":{\"45\":1}}],[\"在双十一期间\",{\"1\":{\"46\":1}}],[\"在越过数组尾部时\",{\"1\":{\"45\":1}}],[\"在不断进行入队和出队的过程中\",{\"1\":{\"45\":1}}],[\"在尾节点后添加\",{\"1\":{\"44\":1}}],[\"在尾部添加元素\",{\"1\":{\"33\":1}}],[\"在列表末尾添加元素是否时时刻刻都为\",{\"1\":{\"37\":1}}],[\"在列表尾部添加元素的时间复杂度为\",{\"1\":{\"33\":1}}],[\"在选择数据结构时\",{\"1\":{\"36\":1}}],[\"在本示例中\",{\"1\":{\"35\":2}}],[\"在索引\",{\"1\":{\"33\":1}}],[\"在中间插入元素\",{\"1\":{\"33\":1}}],[\"在接下来的讨论中\",{\"1\":{\"29\":1}}],[\"在某些数据缓冲区的实现中\",{\"1\":{\"28\":1}}],[\"在操作系统中\",{\"1\":{\"28\":1}}],[\"在缓存淘汰\",{\"1\":{\"28\":1}}],[\"在网页浏览器中\",{\"1\":{\"28\":1}}],[\"在该方案中\",{\"1\":{\"28\":1}}],[\"在环形链表中\",{\"1\":{\"27\":1}}],[\"在链表中插入和删除操作的时间复杂度是\",{\"1\":{\"37\":1}}],[\"在链表中插入节点非常容易\",{\"1\":{\"22\":1}}],[\"在链表中查找值为\",{\"1\":{\"25\":1}}],[\"在链表中访问节点的效率较低\",{\"1\":{\"24\":1}}],[\"在链表中删除节点也非常方便\",{\"1\":{\"23\":1}}],[\"在链表的节点\",{\"1\":{\"22\":1}}],[\"在大数据量下的效率较低\",{\"1\":{\"22\":1}}],[\"在大多数编程语言中\",{\"1\":{\"14\":1}}],[\"在\",{\"1\":{\"19\":1,\"37\":1,\"55\":1,\"113\":1}}],[\"在一个复杂的系统运行环境下\",{\"1\":{\"19\":1}}],[\"在复杂的系统环境中\",{\"1\":{\"16\":1}}],[\"在数组很大的情况下非常耗时\",{\"1\":{\"16\":1}}],[\"在数组中删除首元素的时间复杂度为\",{\"1\":{\"45\":1}}],[\"在数组中插入元素的时间复杂度为\",{\"1\":{\"22\":1}}],[\"在数组中查找指定元素\",{\"1\":{\"15\":1}}],[\"在数组中查找指定元素需要遍历数组\",{\"1\":{\"15\":1}}],[\"在数组中访问元素非常高效\",{\"1\":{\"11\":1}}],[\"在数组的索引\",{\"1\":{\"12\":1}}],[\"在区间\",{\"1\":{\"11\":1}}],[\"在未指定初始值的情况下\",{\"1\":{\"10\":1}}],[\"是因为我们不需要同步其他内存操作\",{\"1\":{\"113\":1}}],[\"是在\",{\"1\":{\"93\":1}}],[\"是内存地址偏移一个元素的位置\",{\"1\":{\"82\":1}}],[\"是c++\",{\"1\":{\"81\":1}}],[\"是c语言标准库提供的一组用于动态申请释放内存的api\",{\"1\":{\"81\":1}}],[\"是否需要释放出栈节点的内存\",{\"1\":{\"55\":1}}],[\"是否需要把\",{\"1\":{\"37\":1}}],[\"是不是因为有什么局限性呢\",{\"1\":{\"37\":1}}],[\"是一种在多线程环境中实现并发访问的技术\",{\"1\":{\"109\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"68\":1}}],[\"是一种遵循先入后出逻辑的线性数据结构\",{\"1\":{\"47\":1}}],[\"是一种遵循先入先出规则的线性数据结构\",{\"1\":{\"41\":1}}],[\"是一种线性数据结构\",{\"1\":{\"8\":1,\"19\":1}}],[\"是一个抽象的数据结构概念\",{\"1\":{\"29\":1}}],[\"是合理的\",{\"1\":{\"11\":1}}],[\"因为数组中包含了两种\",{\"1\":{\"37\":1}}],[\"因为数组是线性数据结构\",{\"1\":{\"15\":1}}],[\"因为从\",{\"1\":{\"11\":1}}],[\"因此可以实现栈与队列的所有应用\",{\"1\":{\"55\":1}}],[\"因此可以在\",{\"1\":{\"32\":1}}],[\"因此不需要手动释放内存\",{\"1\":{\"55\":1}}],[\"因此链表节点占用的空间相对较大\",{\"1\":{\"52\":1}}],[\"因此平均效率更高\",{\"1\":{\"52\":1}}],[\"因此效率相对较低\",{\"1\":{\"52\":1}}],[\"因此效率较高\",{\"1\":{\"52\":1}}],[\"因此一般不会用到\",{\"1\":{\"52\":1}}],[\"因此我们可以使用动态数组\",{\"1\":{\"51\":1}}],[\"因此我们只能在栈顶添加或删除元素\",{\"1\":{\"49\":1}}],[\"因此栈可以视为一种受限制的数组或链表\",{\"1\":{\"49\":1}}],[\"因此堆更加适合存储大型数组\",{\"1\":{\"37\":1}}],[\"因此\",{\"1\":{\"37\":3,\"52\":1}}],[\"因此它通常比链表更高效\",{\"1\":{\"36\":1}}],[\"因此它的索引为\",{\"1\":{\"11\":1}}],[\"因此只能看作一个具有长度限制的列表\",{\"1\":{\"29\":1}}],[\"因此各种性质和操作效率也呈现对立的特点\",{\"1\":{\"26\":1}}],[\"因此在高并发场景下具有更好的性能\",{\"1\":{\"104\":1}}],[\"因此在相同数据量下\",{\"1\":{\"19\":1}}],[\"因此在大多数编程语言中\",{\"1\":{\"16\":1}}],[\"因此在插入元素后\",{\"1\":{\"13\":1}}],[\"因此插入一个元素必定会导致数组尾部元素\",{\"1\":{\"12\":1}}],[\"$n$\",{\"1\":{\"13\":1}}],[\"$\",{\"1\":{\"13\":1,\"22\":1,\"26\":3,\"37\":10,\"42\":3,\"45\":2}}],[\"$o\",{\"1\":{\"13\":1,\"22\":1,\"26\":3,\"37\":9,\"42\":3,\"45\":2}}],[\"$i$\",{\"1\":{\"13\":2}}],[\"$1$\",{\"1\":{\"11\":1}}],[\"$0$\",{\"1\":{\"11\":1}}],[\"这3者的区别\",{\"0\":{\"82\":1}}],[\"这时我们可以将该语言的\",{\"1\":{\"48\":1}}],[\"这时候时间复杂度就会是\",{\"1\":{\"37\":1}}],[\"这时候使用双向链表就非常合适\",{\"1\":{\"28\":1}}],[\"这个操作是原子的\",{\"1\":{\"110\":1}}],[\"这个在\",{\"1\":{\"55\":1}}],[\"这个问题不难解决\",{\"1\":{\"45\":1}}],[\"这个公式计算出的\",{\"1\":{\"45\":1}}],[\"这会导致出队操作效率较低\",{\"1\":{\"45\":1}}],[\"这些指令能够确保在多个线程操作同一数据时不会产生竞争条件\",{\"1\":{\"104\":1}}],[\"这些元素的地址不连续\",{\"1\":{\"37\":1}}],[\"这些数据都是以数组的形式构建的\",{\"1\":{\"18\":1}}],[\"这\",{\"1\":{\"37\":1}}],[\"这里的空间浪费主要有两方面含义\",{\"1\":{\"37\":1}}],[\"这里的空间浪费是指额外增加的变量如容量\",{\"1\":{\"37\":1}}],[\"这样就可以解决c代码调用c++\",{\"1\":{\"84\":1}}],[\"这样就无须自行处理数组扩容问题\",{\"1\":{\"51\":1}}],[\"这样\",{\"1\":{\"84\":1}}],[\"这样可以动态选择合适的计算策略\",{\"1\":{\"70\":1}}],[\"这样我们就可以通过后退操作回到上一个网页\",{\"1\":{\"53\":1}}],[\"这样一来\",{\"1\":{\"37\":1}}],[\"这样才能通过计算偏移量来获取对应元素位置\",{\"1\":{\"37\":1}}],[\"这样在插入数据时\",{\"1\":{\"13\":1}}],[\"这两种初始化方法\",{\"1\":{\"31\":1}}],[\"这是无锁编程的核心操作之一\",{\"1\":{\"110\":1}}],[\"这是为了允许父进程能够获取子进程的退出状态\",{\"1\":{\"93\":1}}],[\"这是因为数组中存储的是节点的引用\",{\"1\":{\"37\":1}}],[\"这是因为我们通常无法事先确定需要存储多少数据\",{\"1\":{\"29\":1}}],[\"这是一个\",{\"1\":{\"16\":1}}],[\"这种节点插入方法被称为\",{\"1\":{\"50\":1}}],[\"这种周期性规律可以通过\",{\"1\":{\"45\":1}}],[\"这种循环操作可以通过环形链表来实现\",{\"1\":{\"28\":1}}],[\"这种做法包含丰富的先验信息\",{\"1\":{\"17\":1}}],[\"这可以通过在节点中保存一个指向父节点的引用来实现\",{\"1\":{\"28\":1}}],[\"这意味着节点\",{\"1\":{\"37\":1}}],[\"这意味着\",{\"1\":{\"23\":1}}],[\"这意味着计算数组元素的内存地址非常容易\",{\"1\":{\"11\":1}}],[\"这似乎有些反直觉\",{\"1\":{\"11\":1}}],[\"首尾相接\",{\"1\":{\"27\":1}}],[\"首个元素的地址偏移量是\",{\"1\":{\"11\":1}}],[\"首元素内存地址\",{\"1\":{\"11\":1,\"37\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"给定一个列表索引\",{\"1\":{\"37\":1}}],[\"给定数组内存地址\",{\"1\":{\"11\":1}}],[\"给定初始值\",{\"1\":{\"10\":1}}],[\"n5\",{\"1\":{\"37\":1}}],[\"n4\",{\"1\":{\"21\":2,\"37\":1}}],[\"n3\",{\"1\":{\"21\":3,\"37\":1}}],[\"n2\",{\"1\":{\"21\":3,\"37\":1}}],[\"n1\",{\"1\":{\"21\":3,\"22\":3,\"23\":4,\"37\":1}}],[\"n0\",{\"1\":{\"21\":3,\"22\":5,\"23\":6}}],[\"nexttail\",{\"1\":{\"112\":3,\"113\":7,\"114\":1}}],[\"next\",{\"1\":{\"19\":2,\"21\":1,\"27\":2,\"37\":2}}],[\"new的区别\",{\"0\":{\"81\":1}}],[\"new\",{\"0\":{\"81\":1},\"1\":{\"10\":2,\"16\":1,\"21\":5,\"44\":1,\"45\":1,\"50\":1,\"81\":3,\"90\":1,\"99\":2,\"112\":1,\"113\":1}}],[\"not\",{\"1\":{\"119\":1}}],[\"notify\",{\"1\":{\"103\":4}}],[\"now\",{\"1\":{\"99\":1}}],[\"none\",{\"1\":{\"19\":1,\"27\":1,\"37\":1}}],[\"node\",{\"1\":{\"19\":1,\"44\":9,\"50\":7}}],[\"nullptr\",{\"1\":{\"19\":2,\"23\":1,\"24\":2,\"25\":1,\"27\":2,\"44\":3,\"50\":1}}],[\"null\",{\"1\":{\"19\":1,\"95\":3}}],[\"num\",{\"1\":{\"12\":4,\"32\":1,\"34\":2,\"44\":5,\"45\":5,\"50\":4,\"51\":4}}],[\"nums1\",{\"1\":{\"10\":1,\"31\":1}}],[\"nums\",{\"1\":{\"10\":1,\"11\":2,\"12\":4,\"13\":3,\"14\":2,\"15\":2,\"16\":3,\"21\":3,\"31\":2,\"32\":2,\"33\":10,\"34\":3,\"45\":6}}],[\"n\",{\"1\":{\"13\":1,\"16\":1,\"22\":1,\"24\":1,\"26\":3,\"33\":1,\"37\":7,\"45\":1,\"52\":1,\"54\":1,\"99\":2}}],[\"404\",{\"1\":{\"119\":1}}],[\"4\",{\"0\":{\"83\":1,\"104\":1,\"113\":1},\"1\":{\"10\":2,\"21\":2,\"31\":1,\"33\":1,\"37\":2,\"42\":1,\"48\":1}}],[\"20\",{\"1\":{\"112\":2,\"113\":2}}],[\"2\",{\"0\":{\"81\":1,\"102\":1,\"111\":1},\"1\":{\"10\":2,\"21\":2,\"31\":1,\"33\":1,\"35\":1,\"37\":2,\"42\":1,\"48\":1,\"52\":1,\"102\":1}}],[\"3\",{\"0\":{\"82\":1,\"103\":1,\"112\":1},\"1\":{\"10\":2,\"21\":2,\"31\":1,\"33\":5,\"37\":3,\"42\":1,\"48\":1}}],[\"1000\",{\"1\":{\"104\":1}}],[\"10\",{\"0\":{\"82\":1},\"1\":{\"35\":1,\"82\":1,\"101\":2,\"103\":2,\"104\":2,\"105\":2,\"106\":2,\"107\":2,\"108\":2,\"112\":1,\"113\":2}}],[\"1\",{\"0\":{\"80\":1,\"101\":1,\"110\":1},\"1\":{\"10\":2,\"11\":1,\"12\":2,\"13\":2,\"15\":1,\"17\":1,\"21\":3,\"22\":1,\"24\":2,\"25\":1,\"26\":3,\"31\":1,\"32\":5,\"33\":2,\"37\":8,\"42\":4,\"45\":7,\"48\":4,\"50\":1,\"51\":1,\"82\":1,\"95\":2,\"102\":1,\"103\":1,\"105\":4,\"106\":1,\"107\":1,\"108\":1,\"112\":2,\"113\":4}}],[\"==\",{\"1\":{\"15\":1,\"23\":1,\"24\":1,\"25\":1,\"44\":3,\"45\":2,\"50\":1,\"51\":1,\"95\":4,\"112\":2,\"113\":4}}],[\"=\",{\"1\":{\"10\":3,\"11\":2,\"12\":3,\"13\":2,\"14\":2,\"15\":1,\"16\":3,\"21\":9,\"22\":3,\"23\":3,\"24\":2,\"25\":3,\"31\":1,\"32\":2,\"34\":3,\"37\":6,\"42\":3,\"44\":15,\"45\":12,\"48\":3,\"50\":12,\"51\":1,\"81\":2,\"95\":5,\"101\":2,\"103\":4,\"104\":3,\"105\":2,\"106\":3,\"107\":1,\"108\":1,\"112\":8,\"113\":12}}],[\"5$\",{\"1\":{\"37\":1}}],[\"5\",{\"0\":{\"84\":1,\"105\":1,\"114\":1},\"1\":{\"10\":6,\"21\":2,\"31\":1,\"33\":1,\"37\":1,\"42\":1,\"48\":1}}],[\"0\",{\"0\":{\"82\":1},\"1\":{\"10\":1,\"11\":3,\"14\":2,\"15\":1,\"16\":1,\"21\":1,\"24\":1,\"25\":1,\"32\":2,\"34\":3,\"37\":3,\"44\":4,\"45\":3,\"50\":3,\"51\":1,\"82\":3,\"95\":12,\"99\":3,\"101\":2,\"102\":1,\"103\":2,\"104\":4,\"105\":2,\"106\":2,\"107\":2,\"108\":2,\"112\":5,\"113\":6}}],[\"我们不能简单地确定哪种实现更加节省内存\",{\"1\":{\"52\":1}}],[\"我们不一定需要用这么多\",{\"1\":{\"37\":1}}],[\"我们只需将元素插入链表头部\",{\"1\":{\"50\":1}}],[\"我们来尝试自己实现一个栈类\",{\"1\":{\"49\":1}}],[\"我们以常见的\",{\"1\":{\"48\":1}}],[\"我们把堆叠元素的顶部称为\",{\"1\":{\"47\":1}}],[\"我们在此采用与栈相同的方法命名\",{\"1\":{\"42\":1}}],[\"我们往往更青睐使用数组实现算法\",{\"1\":{\"37\":1}}],[\"我们会发现两个数组中的相同数字拥有同一个\",{\"1\":{\"37\":1}}],[\"我们仍然可以在\",{\"1\":{\"37\":1}}],[\"我们维护一个指针变量始终指向头节点\",{\"1\":{\"37\":1}}],[\"我们规定每次将数组扩容至之前的\",{\"1\":{\"35\":1}}],[\"我们选择\",{\"1\":{\"35\":1}}],[\"我们尝试实现一个简易版列表\",{\"1\":{\"35\":1}}],[\"我们通常不能完全填满它们\",{\"1\":{\"37\":1}}],[\"我们通常使用\",{\"1\":{\"31\":1}}],[\"我们通常将头节点当作链表的代称\",{\"1\":{\"21\":1}}],[\"我们需要让\",{\"1\":{\"45\":1}}],[\"我们需要一种数据结构\",{\"1\":{\"43\":1}}],[\"我们需要快速找到最近最少使用的数据\",{\"1\":{\"28\":1}}],[\"我们需要访问节点的父节点\",{\"1\":{\"28\":1}}],[\"我们就可以从链表的头节点出发\",{\"1\":{\"21\":1}}],[\"我们知道\",{\"1\":{\"19\":1}}],[\"我们既可以通过索引遍历数组\",{\"1\":{\"14\":1}}],[\"我们将盘子替换为各种类型的元素\",{\"1\":{\"47\":1}}],[\"我们将队列头部称为\",{\"1\":{\"41\":1}}],[\"我们将把\",{\"1\":{\"29\":1}}],[\"我们将首个节点称为头节点\",{\"1\":{\"27\":1}}],[\"我们将这个问题的解决方案留在\",{\"1\":{\"12\":1}}],[\"我们将元素在数组中的位置称为该元素的索引\",{\"1\":{\"8\":1}}],[\"我们发现数组首个元素的索引为\",{\"1\":{\"11\":1}}],[\"我们可以得出以下结论\",{\"1\":{\"52\":1}}],[\"我们可以\",{\"1\":{\"49\":1}}],[\"我们可以直接使用编程语言内置的栈类\",{\"1\":{\"48\":1}}],[\"我们可以直接使用编程语言中现成的队列类\",{\"1\":{\"42\":1}}],[\"我们可以将栈类比为桌面上的一摞盘子\",{\"1\":{\"47\":1}}],[\"我们可以将数组的尾部作为栈顶\",{\"1\":{\"51\":1}}],[\"我们可以将数组替换为动态数组\",{\"1\":{\"45\":1}}],[\"我们可以将数组视为首尾相接的\",{\"1\":{\"45\":1}}],[\"我们可以将链表的头节点视为栈顶\",{\"1\":{\"50\":1}}],[\"我们可以将链表的\",{\"1\":{\"44\":1}}],[\"我们可以采用以下巧妙方法来避免这个问题\",{\"1\":{\"45\":1}}],[\"我们可以定位列表尾部\",{\"1\":{\"35\":1}}],[\"我们可以使用一个变量\",{\"1\":{\"45\":1}}],[\"我们可以使用\",{\"1\":{\"29\":1}}],[\"我们可以使用下图所示的公式计算得到该元素的内存地址\",{\"1\":{\"11\":1}}],[\"我们可以初始化一个比较长的数组\",{\"1\":{\"13\":1}}],[\"我们可以在\",{\"1\":{\"11\":1,\"24\":1}}],[\"我们可以根据需求选用数组的两种初始化方式\",{\"1\":{\"10\":1}}],[\"其他线程能正确地看到更新的头部指针\",{\"1\":{\"113\":1}}],[\"其他线程能正确地看到更新的尾部指针\",{\"1\":{\"113\":1}}],[\"其他线程可以成功获取锁并继续执行\",{\"1\":{\"106\":1}}],[\"其实现原理如下\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1}}],[\"其父进程没有及时调用\",{\"1\":{\"93\":1}}],[\"其长度不可变\",{\"1\":{\"45\":1}}],[\"其支持元素增删查改操作\",{\"1\":{\"29\":1}}],[\"其存在以下局限性\",{\"1\":{\"17\":1}}],[\"其中a\",{\"1\":{\"82\":1}}],[\"其中图的每个顶点都与一个链表相关联\",{\"1\":{\"28\":1}}],[\"其中的每个元素都是一个节点对象\",{\"1\":{\"19\":1}}],[\"其中\",{\"1\":{\"13\":1}}],[\"其将相同类型的元素存储在连续的内存空间中\",{\"1\":{\"8\":1}}],[\"其目的在于帮助想学习\",{\"1\":{\"0\":1}}],[\"数量记录\",{\"1\":{\"35\":1}}],[\"数据操作效率基本一致\",{\"1\":{\"37\":1}}],[\"数据主要存储在内存中\",{\"1\":{\"36\":1}}],[\"数据流可能会被分成多个缓冲块并放入一个环形链表\",{\"1\":{\"28\":1}}],[\"数据缓冲区\",{\"1\":{\"28\":1}}],[\"数据结构实现\",{\"1\":{\"18\":1}}],[\"数据结构\",{\"0\":{\"5\":1},\"2\":{\"6\":1,\"38\":1,\"56\":1}}],[\"数组实现额外支持随机访问\",{\"1\":{\"52\":1}}],[\"数组或链表的部分无关操作\",{\"1\":{\"49\":1}}],[\"数组和链表都可以在任意位置添加和删除元素\",{\"1\":{\"49\":1}}],[\"数组和链表是两种基本的数据结构\",{\"1\":{\"36\":1}}],[\"数组中包含元素的有效区间为\",{\"1\":{\"45\":1}}],[\"数组内存地址\",{\"1\":{\"37\":1}}],[\"数组同时包含\",{\"1\":{\"37\":1}}],[\"数组存储在栈上和存储在堆上\",{\"1\":{\"37\":1}}],[\"数组存储在连续的内存空间内\",{\"1\":{\"17\":1}}],[\"数组可提供更高的内存空间效率\",{\"1\":{\"36\":1}}],[\"数组可以用于实现栈\",{\"1\":{\"18\":1}}],[\"数组支持随机访问\",{\"1\":{\"36\":1}}],[\"数组也支持元素增删查改\",{\"1\":{\"29\":1}}],[\"数组整体是一个变量\",{\"1\":{\"21\":1}}],[\"数组是神经网络编程中最常使用的数据结构\",{\"1\":{\"18\":1}}],[\"数组是排序和搜索算法最常用的数据结构\",{\"1\":{\"18\":1}}],[\"数组是一种基础且常见的数据结构\",{\"1\":{\"18\":1}}],[\"数组典型应用\",{\"0\":{\"18\":1}}],[\"数组在初始化后长度就固定了\",{\"1\":{\"17\":1}}],[\"数组允许在\",{\"1\":{\"17\":1}}],[\"数组为数据分配了连续的内存块\",{\"1\":{\"17\":1}}],[\"数组的优点与局限性\",{\"0\":{\"17\":1}}],[\"数组的长度是不可变的\",{\"1\":{\"16\":1}}],[\"数组的插入和删除的平均时间复杂度均为\",{\"1\":{\"13\":1}}],[\"数组的插入与删除操作有以下缺点\",{\"1\":{\"13\":1}}],[\"数组删除元素示例\",{\"1\":{\"13\":1}}],[\"数组插入元素示例\",{\"1\":{\"12\":1}}],[\"数组元素则必须是相同类型的\",{\"1\":{\"37\":1}}],[\"数组元素在内存中是\",{\"1\":{\"12\":1}}],[\"数组元素的内存地址计算\",{\"1\":{\"11\":1}}],[\"数组元素被存储在连续的内存空间中\",{\"1\":{\"11\":1}}],[\"数组常用操作\",{\"0\":{\"9\":1}}],[\"数组定义与存储方式\",{\"1\":{\"8\":1}}],[\"数组\",{\"0\":{\"8\":1,\"26\":1},\"1\":{\"8\":1,\"26\":1,\"48\":1},\"2\":{\"39\":1}}],[\"数组与链表\",{\"0\":{\"7\":1},\"1\":{\"2\":1}}],[\"架构设计\",{\"0\":{\"3\":1,\"58\":1},\"2\":{\"59\":1,\"63\":1,\"66\":1,\"71\":1}}],[\"笔试题\",{\"0\":{\"1\":1}}],[\"掌握一些基本的算法和数据结构\",{\"1\":{\"0\":1}}],[\"编程同学\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
