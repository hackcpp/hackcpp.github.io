const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":40,\"nextId\":40,\"documentIds\":{\"0\":\"0\",\"1\":\"0#_1-static-关键字的作用\",\"2\":\"0#_2-new-delete与malloc-new的区别\",\"3\":\"0#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"4\":\"0#_4-宏与constexpr-区别\",\"5\":\"0#_5-extern-c\",\"6\":\"0#_6-const-关键字的作用\",\"7\":\"1\",\"8\":\"1#_1-static-关键字的作用\",\"9\":\"1#_2-new-delete与malloc-new的区别\",\"10\":\"1#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"11\":\"1#_4-宏与constexpr-区别\",\"12\":\"1#_5-extern-c\",\"13\":\"1#_6-const-关键字的作用\",\"14\":\"3\",\"15\":\"3#进程状态\",\"16\":\"3#进程的基本状态\",\"17\":\"3#进程状态之间的转换\",\"18\":\"3#状态转换示意图\",\"19\":\"3#僵尸进程\",\"20\":\"3#僵尸进程的影响\",\"21\":\"3#如何避免产生僵尸进程\",\"22\":\"4\",\"23\":\"4#线程创建\",\"24\":\"4#线程同步机制\",\"25\":\"4#_1-互斥量-mutex\",\"26\":\"4#_2-读写锁-shared-mutex\",\"27\":\"4#_3-条件变量-condition-variable\",\"28\":\"4#_4-原子操作-atomic-operations\",\"29\":\"4#_5-信号量-semaphore\",\"30\":\"4#_6-自旋锁-spinlock\",\"31\":\"4#_7-屏障-barrier\",\"32\":\"4#_8-锁存器-latch\",\"33\":\"4#无锁编程\",\"34\":\"4#_1-基本概念\",\"35\":\"4#_2-c-中的原子操作\",\"36\":\"4#_3-使用原子变量实现无锁队列\",\"37\":\"4#_4-代码结构和作用\",\"38\":\"4#_5-内存顺序的选择\",\"39\":\"5\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[4,10],\"2\":[5,17],\"3\":[9,21],\"4\":[4,7],\"5\":[4,23],\"6\":[4,8],\"7\":[1],\"8\":[4,10],\"9\":[5,17],\"10\":[9,21],\"11\":[4,7],\"12\":[4,23],\"13\":[4,8],\"14\":[1],\"15\":[1],\"16\":[1,29],\"17\":[1,37],\"18\":[1,17],\"19\":[1,32],\"20\":[1,12],\"21\":[2,102],\"22\":[1],\"23\":[1,37],\"24\":[1],\"25\":[4,62],\"26\":[5,78],\"27\":[5,90],\"28\":[5,64],\"29\":[4,74],\"30\":[4,78],\"31\":[4,61],\"32\":[4,64],\"33\":[1,11],\"34\":[2,26],\"35\":[3,13],\"36\":[2,80],\"37\":[2,131],\"38\":[2,26],\"39\":[1,3]},\"averageFieldLength\":[3.05,34.45715155380334],\"storedFields\":{\"0\":{\"h\":\"\"},\"1\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"2\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"3\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"4\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"5\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"6\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"7\":{\"h\":\"\"},\"8\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"9\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"10\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"11\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"12\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"13\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"14\":{\"h\":\"\"},\"15\":{\"h\":\"进程状态\"},\"16\":{\"h\":\"进程的基本状态\",\"t\":[\"新建（New）：\",\"进程正在被创建，还未进入准备就绪队列。\",\"就绪（Ready）：\",\"进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。\",\"运行（Running）：\",\"进程正在 CPU 上执行代码。\",\"阻塞（Blocked）：\",\"进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。\",\"终止（Terminated）：\",\"进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。\"]},\"17\":{\"h\":\"进程状态之间的转换\",\"t\":[\"进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：\",\"新建 → 就绪：\",\"当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。\",\"就绪 → 运行：\",\"调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。\",\"运行 → 就绪：\",\"如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。\",\"运行 → 阻塞：\",\"当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。\",\"阻塞 → 就绪：\",\"当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。\",\"运行 → 终止：\",\"当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。\"]},\"18\":{\"h\":\"状态转换示意图\",\"t\":[\"stateDiagram [*] --> 新建: 创建进程 新建 --> 就绪: 进程创建完成 就绪 --> 运行: 调度进程 运行 --> 阻塞: 等待事件 阻塞 --> 就绪: 事件完成 运行 --> 就绪: 时间片耗尽/被抢占 运行 --> 终止: 进程完成/被终止 终止 --> [*] \"]},\"19\":{\"h\":\"僵尸进程\",\"t\":[\"僵尸进程（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 wait() 或 waitpid() 函数回收子进程的退出状态信息，从而导致的进程状态。\",\"具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 wait() 或 waitpid() 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。\"]},\"20\":{\"h\":\"僵尸进程的影响\",\"t\":[\"资源占用：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。\",\"系统管理的麻烦：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。\"]},\"21\":{\"h\":\"如何避免产生僵尸进程？\",\"t\":[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：\",\"及时调用 wait() 或 waitpid()：\",\"父进程在适当的时机调用 wait() 或 waitpid() 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。\",\"pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 wait(NULL); // 等待子进程结束并回收资源 } \",\"使用 SIGCHLD 信号处理子进程的结束：\",\"当子进程结束时，父进程会收到 SIGCHLD 信号。父进程可以在信号处理程序中调用 wait() 或 waitpid() 以回收子进程的资源。\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> #include <signal.h> void sigchld_handler(int signum) { // 等待所有已终止的子进程 while (waitpid(-1, NULL, WNOHANG) > 0); } int main() { // 注册 SIGCHLD 信号处理程序 signal(SIGCHLD, sigchld_handler); pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 // 父进程继续执行其任务 pause(); // 等待信号（例如 SIGCHLD） } return 0; } \",\"将子进程的父进程设置为 init 进程（或 systemd）：\",\"如果父进程在子进程结束前退出，子进程会被 init 进程（PID 为 1 的进程）接管。init 进程会自动调用 wait() 回收子进程的资源，避免僵尸进程的产生。可以通过调用 fork() 后使父进程退出，子进程被 init 接管。\",\"pid_t pid = fork(); if (pid > 0) { // 父进程退出 exit(0); } // 子进程继续执行 // 此时子进程的父进程是 init 进程 \",\"采用 double fork() 技术：\",\"父进程通过 fork() 创建一个子进程，子进程再 fork() 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 init 进程接管。\",\"pid_t pid = fork(); if (pid == 0) { // 第一个子进程 pid_t pid2 = fork(); if (pid2 == 0) { // 孙子进程 // 在此处执行需要守护的任务 exit(0); } else { // 第一个子进程退出 exit(0); } } else { // 父进程等待第一个子进程退出 wait(NULL); } \",\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 wait() 系列函数、处理 SIGCHLD 信号、使用 init 进程接管孤儿进程或采用 double fork() 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。\"]},\"22\":{\"h\":\"\"},\"23\":{\"h\":\"线程创建\",\"t\":[\"// thread example #include <iostream> // std::cout #include <thread> // std::thread void foo() { // do stuff... } void bar(int x) { // do stuff... } int main() { std::thread first (foo); // spawn new thread that calls foo() std::thread second (bar,0); // spawn new thread that calls bar(0) std::cout << \\\"main, foo and bar now execute concurrently...\\\\n\\\"; // synchronize threads: first.join(); // pauses until first finishes second.join(); // pauses until second finishes std::cout << \\\"foo and bar completed.\\\\n\\\"; return 0; } \"]},\"24\":{\"h\":\"线程同步机制\"},\"25\":{\"h\":\"1. 互斥量 (Mutex)\",\"t\":[\"实现原理：\",\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问。具体实现步骤如下：\",\"基本结构：\",\"互斥量有一个内部状态，通常用布尔值或整数表示（锁定或未锁定）。\",\"维护一个等待队列，用于保存等待锁的线程。\",\"锁定 (Lock)：\",\"当一个线程尝试锁定互斥量时，如果互斥量未锁定，则线程成功锁定，并将互斥量状态设置为锁定。\",\"如果互斥量已锁定，则该线程进入等待队列并挂起，直到互斥量被解锁。\",\"解锁 (Unlock)：\",\"当一个线程解锁互斥量时，如果等待队列中有其他线程，则唤醒一个线程，使其尝试重新锁定互斥量。\",\"如果没有线程在等待，则将互斥量状态设置为未锁定。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> std::mutex mtx; void print_thread_id(int id) { std::lock_guard<std::mutex> guard(mtx); // 自动加锁和解锁 std::cout << \\\"Thread #\\\" << id << std::endl; } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_thread_id, i); } for (auto& th : threads) { th.join(); } return 0; } \"]},\"26\":{\"h\":\"2. 读写锁 (Shared Mutex)\",\"t\":[\"实现原理：\",\"读写锁允许多个线程同时读取，但在写入时只允许一个线程操作。其实现原理如下：\",\"基本结构：\",\"读写锁包含两个计数器：一个用于记录当前正在读取的线程数，另一个用于记录是否有写线程在等待。\",\"维护一个等待队列，用于保存等待的线程。\",\"读锁定 (Read Lock)：\",\"当一个线程请求读锁定时，如果没有写锁存在，则增加读计数器，线程继续执行。\",\"如果有写锁存在，则线程进入等待队列。\",\"写锁定 (Write Lock)：\",\"当一个线程请求写锁定时，如果没有读锁和写锁存在，则锁定成功。\",\"如果有读锁或写锁存在，则线程进入等待队列。\",\"解锁 (Unlock)：\",\"当读线程解锁时，减少读计数器，如果读计数器为0且有写线程在等待，则唤醒一个写线程。\",\"当写线程解锁时，如果有读线程在等待，则唤醒所有读线程；如果有写线程在等待，则唤醒一个写线程。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <shared_mutex> #include <vector> std::shared_mutex rw_mtx; std::vector<int> data; void reader() { std::shared_lock<std::shared_mutex> lock(rw_mtx); for (const auto& d : data) { std::cout << d << \\\" \\\"; } std::cout << std::endl; } void writer(int value) { std::unique_lock<std::shared_mutex> lock(rw_mtx); data.push_back(value); } int main() { std::thread t1(writer, 1); std::thread t2(reader); std::thread t3(writer, 2); std::thread t4(reader); t1.join(); t2.join(); t3.join(); t4.join(); return 0; } \"]},\"27\":{\"h\":\"3. 条件变量 (Condition Variable)\",\"t\":[\"实现原理：\",\"条件变量用于线程之间的等待和通知机制。其实现原理如下：\",\"基本结构：\",\"条件变量与一个互斥量和一个条件状态相关联。\",\"维护一个等待队列，用于保存等待条件的线程。\",\"等待 (Wait)：\",\"线程在等待条件变量时，需要持有相关的互斥量。\",\"线程将自己添加到等待队列，并释放互斥量，等待条件变量的通知。\",\"通知 (Notify)：\",\"当一个线程修改条件状态并调用 notify_one 或 notify_all 时，唤醒一个或所有等待队列中的线程。\",\"被唤醒的线程重新获得互斥量，检查条件状态，如果条件满足，线程继续执行；如果条件不满足，线程再次进入等待状态。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> std::mutex cv_mtx; std::condition_variable cv; bool ready = false; void print_id(int id) { std::unique_lock<std::mutex> lock(cv_mtx); cv.wait(lock, [] { return ready; }); // 等待 ready 变为 true std::cout << \\\"Thread #\\\" << id << std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard<std::mutex> lock(cv_mtx); ready = true; } cv.notify_all(); // 唤醒所有等待的线程 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_id, i); } std::thread t(set_ready); for (auto& th : threads) { th.join(); } t.join(); return 0; } \",\"使用场景：\",\"条件变量常用于线程之间的协调，例如在生产者-消费者模型中，生产者线程通知消费者线程有新数据可用，消费者线程等待该通知。\"]},\"28\":{\"h\":\"4. 原子操作 (Atomic Operations)\",\"t\":[\"实现原理：\",\"原子操作通过硬件支持的指令集实现，保证在并发环境下操作的不可分割性。其实现原理如下：\",\"硬件支持：\",\"原子操作依赖于硬件提供的原子指令，如 compare-and-swap (CAS)、fetch-and-add 等，这些指令能够确保在多个线程操作同一数据时不会产生竞争条件。\",\"内存模型：\",\"C++ 中的 std::atomic 提供了对不同内存模型的支持，确保在不同平台上实现一致的原子操作行为。\",\"无需锁定：\",\"原子操作直接操作共享变量，不需要加锁解锁，因此在高并发场景下具有更好的性能。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> std::atomic<int> counter(0); void increment() { for (int i = 0; i < 1000; ++i) { ++counter; // 原子操作 } } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(increment); } for (auto& th : threads) { th.join(); } std::cout << \\\"Final counter value: \\\" << counter << std::endl; return 0; } \",\"使用场景：\",\"原子操作适用于需要高效并发访问的场景，如计数器、标志位等，避免使用锁机制带来的开销。\"]},\"29\":{\"h\":\"5. 信号量 (Semaphore)\",\"t\":[\"实现原理：\",\"信号量是一种控制对共享资源访问的计数器，分为计数信号量和二进制信号量。其实现原理如下：\",\"计数器：\",\"信号量内部维护一个计数器，表示当前可用资源的数量。计数器初始值通常为资源的总量。\",\"P 操作 (等待操作)：\",\"当一个线程执行 P 操作（wait 或 acquire）时，计数器减 1。如果计数器值为正，线程继续执行；如果计数器值为零或负，线程进入等待队列，等待资源释放。\",\"V 操作 (释放操作)：\",\"当一个线程执行 V 操作（signal 或 release）时，计数器加 1。如果有线程在等待队列中，唤醒一个线程，使其继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <semaphore> std::counting_semaphore<1> sem(1); void worker(int id) { sem.acquire(); // P 操作 std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); sem.release(); // V 操作 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; } \",\"使用场景：\",\"信号量适用于控制对资源的并发访问数量，例如限制同时访问文件的线程数、实现生产者-消费者模型等。\"]},\"30\":{\"h\":\"6. 自旋锁 (Spinlock)\",\"t\":[\"实现原理：\",\"自旋锁是一种忙等待锁，线程在尝试获取锁时会反复检查锁的状态，而不会阻塞或挂起。其实现原理如下：\",\"忙等待：\",\"当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，线程将反复检查锁的状态，直到锁可用为止。\",\"自旋锁通常通过硬件的原子操作实现，如 test-and-set、compare-and-swap 等。\",\"解锁：\",\"当持有锁的线程释放自旋锁时，其他线程可以成功获取锁并继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> class Spinlock { std::atomic_flag flag = ATOMIC_FLAG_INIT; public: void lock() { while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待 } void unlock() { flag.clear(std::memory_order_release); } }; Spinlock spinlock; void worker(int id) { spinlock.lock(); std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); spinlock.unlock(); } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; } \",\"使用场景：\",\"自旋锁适用于锁定时间非常短的场景，例如在中断上下文或需要避免线程调度开销的情况下使用。\"]},\"31\":{\"h\":\"7. 屏障 (Barrier)\",\"t\":[\"实现原理：\",\"屏障用于同步一组线程，确保所有线程都到达某个同步点后才能继续执行。其实现原理如下：\",\"计数器：\",\"屏障内部维护一个计数器，表示已到达屏障的线程数量。每当一个线程到达屏障点时，计数器减 1。\",\"等待机制：\",\"当计数器达到零时，表示所有线程都已到达屏障点，屏障解除，所有等待的线程继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <barrier> #include <vector> std::barrier sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" is waiting\\\" << std::endl; sync_point.arrive_and_wait(); // 等待所有线程到达屏障点 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; } \",\"使用场景：\",\"屏障适用于并行计算中需要同步多个线程的场景，例如在每个计算步骤完成后同步所有线程。\"]},\"32\":{\"h\":\"8. 锁存器 (Latch)\",\"t\":[\"实现原理：\",\"锁存器类似于屏障，但只能使用一次，线程等待直到锁存器倒数到零。其实现原理如下：\",\"倒数计数器：\",\"锁存器内部维护一个倒数计数器，表示需要完成的任务数量。每次完成任务时，计数器减 1。\",\"等待机制：\",\"当计数器减为零时，所有等待的线程被唤醒，继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <latch> #include <vector> std::latch sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" has reached the latch point\\\" << std::endl; sync_point.count_down(); // 锁存器计数减少 sync_point.wait(); // 等待所有线程到达锁存器 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; } \",\"使用场景：\",\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景，例如初始化任务完成后启动主任务。\"]},\"33\":{\"h\":\"无锁编程\",\"t\":[\"无锁编程（Lock-Free Programming）是一种在多线程环境中实现并发访问的技术，目的是避免传统锁机制（如互斥锁）带来的性能开销和死锁风险。无锁编程主要依赖于原子操作和内存序列模型，以确保在没有锁的情况下实现线程安全。\"]},\"34\":{\"h\":\"1. 基本概念\",\"t\":[\"原子操作：原子操作是不可分割的，多个线程对同一变量进行原子操作时，不会引起数据竞争。\",\"CAS (Compare-and-Swap)：这是无锁编程的核心操作之一，它检查一个变量是否有特定的值，如果是，则将其更改为新值。这个操作是原子的，即在执行时不会被其他线程打断。\",\"内存序列模型：C++ 提供了一组内存序列模型（如 memory_order_relaxed、memory_order_acquire、memory_order_release 等），以控制并发操作的顺序性。\"]},\"35\":{\"h\":\"2. C++ 中的原子操作\",\"t\":[\"C++11 引入了 std::atomic 模板类，为实现无锁编程提供了基础设施。它支持以下操作：\",\"原子加载和存储\",\"原子递增和递减\",\"原子交换\",\"原子比较并交换（CAS）\"]},\"36\":{\"h\":\"3. 使用原子变量实现无锁队列\",\"t\":[\"下面是一个简单的无锁单生产者单消费者队列的实现示例：\",\"#include <atomic> #include <iostream> #include <thread> #include <vector> template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; // 使用 memory_order_release 确保更新操作一定在取值之后 head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } private: T* buffer; size_t capacity; std::atomic<size_t> head; std::atomic<size_t> tail; }; int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; } \"]},\"37\":{\"h\":\"4. 代码结构和作用\",\"t\":[\"类定义与构造函数\",\"template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } \",\"LockFreeQueue 类是一个泛型队列，使用模板参数 T 来定义队列元素的类型。\",\"构造函数初始化队列的容量 capacity，并将 head 和 tail 指针初始化为 0。\",\"队列使用一个动态分配的数组 buffer 来存储元素。\",\"enqueue 方法\",\"bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } \",\"enqueue 方法用于将一个元素插入队列。\",\"tail.load(std::memory_order_relaxed)：原子地加载当前的尾部指针 tail 的值。使用 memory_order_relaxed 是因为我们不需要同步其他内存操作，仅仅读取尾部的值。\",\"nextTail = (currentTail + 1) % capacity：计算插入元素后的尾部指针值，使用取模操作来实现循环队列。\",\"if (nextTail == head.load(std::memory_order_acquire))：检查队列是否已满。如果 nextTail 与头部指针 head 相等，说明队列已满。\",\"buffer[currentTail] = item：将元素存储在当前尾部指针所指向的位置。\",\"tail.store(nextTail, std::memory_order_release)：将新的尾部指针存储到 tail，并使用 memory_order_release 以确保插入操作完成后，其他线程能正确地看到更新的尾部指针。\",\"dequeue 方法\",\"bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } \",\"dequeue 方法用于从队列中取出一个元素。\",\"currentHead = head.load(std::memory_order_relaxed)：原子地加载当前的头部指针 head 的值。\",\"if (currentHead == tail.load(std::memory_order_acquire))：检查队列是否为空。如果 head 与 tail 相等，说明队列为空。\",\"item = buffer[currentHead]：将头部指针所指向的元素存储到 item 中。\",\"head.store((currentHead + 1) % capacity, std::memory_order_release)：更新头部指针，指向下一个元素的位置，并使用 memory_order_release 以确保取出操作完成后，其他线程能正确地看到更新的头部指针。\",\"主函数中的生产者和消费者\",\"int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; } \",\"在 main 函数中，创建了一个 LockFreeQueue 对象 queue，容量为 10。\",\"生产者线程 producer 向队列中插入元素，使用 while (!queue.enqueue(i)) 检查插入操作是否成功。如果队列已满，线程会持续等待直到成功插入。\",\"消费者线程 consumer 从队列中取出元素，使用 while (!queue.dequeue(item)) 检查取出操作是否成功。如果队列为空，线程会持续等待直到成功取出元素。\",\"两个线程同时运行，生产者插入数据，消费者取出数据，并输出相应的信息。\",\"最后，通过 join() 等待线程完成，确保主线程在两个子线程结束后才退出。\"]},\"38\":{\"h\":\"5. 内存顺序的选择\",\"t\":[\"memory_order_relaxed：用于没有数据依赖的地方，只要求操作是原子的，不需要同步内存顺序。适用于 load 和 store，如 tail.load(std::memory_order_relaxed)。\",\"memory_order_acquire：用于加载操作，以确保加载的结果及其后续的操作不会被重排序到 acquire 之前。适用于检查队列是否满或空，如 head.load(std::memory_order_acquire)。\",\"memory_order_release：用于存储操作，以确保在此之前的所有操作不会被重排序到 release 之后。适用于更新指针操作，如 tail.store(nextTail, std::memory_order_release)。\"]},\"39\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"之后\",{\"1\":{\"38\":1}}],[\"之前\",{\"1\":{\"38\":1}}],[\"适用于更新指针操作\",{\"1\":{\"38\":1}}],[\"适用于检查队列是否满或空\",{\"1\":{\"38\":1}}],[\"适用于\",{\"1\":{\"38\":1}}],[\"只要求操作是原子的\",{\"1\":{\"38\":1}}],[\"只可以在当前文件访问\",{\"1\":{\"1\":1,\"8\":1}}],[\"最后\",{\"1\":{\"37\":1}}],[\"生产者插入数据\",{\"1\":{\"37\":1}}],[\"生产者线程\",{\"1\":{\"37\":1}}],[\"生产者线程通知消费者线程有新数据可用\",{\"1\":{\"27\":1}}],[\"两个线程同时运行\",{\"1\":{\"37\":1}}],[\"从队列中取出元素\",{\"1\":{\"37\":1}}],[\"从而防止僵尸进程的产生\",{\"1\":{\"21\":1}}],[\"从而导致的进程状态\",{\"1\":{\"19\":1}}],[\"向队列中插入元素\",{\"1\":{\"37\":1}}],[\"容量为\",{\"1\":{\"37\":1}}],[\"对象\",{\"1\":{\"37\":1}}],[\"对于保持系统的稳定性和资源利用率至关重要\",{\"1\":{\"21\":1}}],[\"主函数中的生产者和消费者\",{\"1\":{\"37\":1}}],[\"指向下一个元素的位置\",{\"1\":{\"37\":1}}],[\"指针初始化为\",{\"1\":{\"37\":1}}],[\"更新头部指针\",{\"1\":{\"37\":1}}],[\"说明队列为空\",{\"1\":{\"37\":1}}],[\"说明队列已满\",{\"1\":{\"37\":1}}],[\"相等\",{\"1\":{\"37\":2}}],[\"相同\",{\"1\":{\"3\":1,\"10\":1}}],[\"检查取出操作是否成功\",{\"1\":{\"37\":1}}],[\"检查插入操作是否成功\",{\"1\":{\"37\":1}}],[\"检查队列是否为空\",{\"1\":{\"37\":1}}],[\"检查队列是否已满\",{\"1\":{\"37\":1}}],[\"检查条件状态\",{\"1\":{\"27\":1}}],[\"计算插入元素后的尾部指针值\",{\"1\":{\"37\":1}}],[\"计数器加\",{\"1\":{\"29\":1}}],[\"计数器减\",{\"1\":{\"29\":1,\"31\":1,\"32\":1}}],[\"计数器初始值通常为资源的总量\",{\"1\":{\"29\":1}}],[\"计数器\",{\"1\":{\"29\":1,\"31\":1}}],[\"仅仅读取尾部的值\",{\"1\":{\"37\":1}}],[\"的值\",{\"1\":{\"37\":2}}],[\"的进程\",{\"1\":{\"21\":1}}],[\"方法用于从队列中取出一个元素\",{\"1\":{\"37\":1}}],[\"方法用于将一个元素插入队列\",{\"1\":{\"37\":1}}],[\"方法\",{\"1\":{\"37\":2}}],[\"来存储元素\",{\"1\":{\"37\":1}}],[\"来定义队列元素的类型\",{\"1\":{\"37\":1}}],[\"类是一个泛型队列\",{\"1\":{\"37\":1}}],[\"类定义与构造函数\",{\"1\":{\"37\":1}}],[\"类成员或函数可以直接通过类名访问无需创建对象\",{\"1\":{\"1\":1,\"8\":1}}],[\"启动消费者线程\",{\"1\":{\"36\":1,\"37\":1}}],[\"启动生产者线程\",{\"1\":{\"36\":1,\"37\":1}}],[\"queue\",{\"1\":{\"36\":5,\"37\":8}}],[\"队列使用一个动态分配的数组\",{\"1\":{\"37\":1}}],[\"队列为空\",{\"1\":{\"36\":1,\"37\":1}}],[\"队列已满\",{\"1\":{\"36\":1,\"37\":1}}],[\"~lockfreequeue\",{\"1\":{\"36\":1,\"37\":1}}],[\"下面是一个简单的无锁单生产者单消费者队列的实现示例\",{\"1\":{\"36\":1}}],[\"原子地加载当前的头部指针\",{\"1\":{\"37\":1}}],[\"原子地加载当前的尾部指针\",{\"1\":{\"37\":1}}],[\"原子比较并交换\",{\"1\":{\"35\":1}}],[\"原子交换\",{\"1\":{\"35\":1}}],[\"原子递增和递减\",{\"1\":{\"35\":1}}],[\"原子加载和存储\",{\"1\":{\"35\":1}}],[\"原子操作是不可分割的\",{\"1\":{\"34\":1}}],[\"原子操作适用于需要高效并发访问的场景\",{\"1\":{\"28\":1}}],[\"原子操作直接操作共享变量\",{\"1\":{\"28\":1}}],[\"原子操作依赖于硬件提供的原子指令\",{\"1\":{\"28\":1}}],[\"原子操作通过硬件支持的指令集实现\",{\"1\":{\"28\":1}}],[\"原子操作\",{\"0\":{\"28\":1},\"1\":{\"28\":1,\"34\":1}}],[\"模板类\",{\"1\":{\"35\":1}}],[\"引入了\",{\"1\":{\"35\":1}}],[\"提供了一组内存序列模型\",{\"1\":{\"34\":1}}],[\"提供了对不同内存模型的支持\",{\"1\":{\"28\":1}}],[\"它支持以下操作\",{\"1\":{\"35\":1}}],[\"它检查一个变量是否有特定的值\",{\"1\":{\"34\":1}}],[\"它的所有资源\",{\"1\":{\"19\":1}}],[\"不需要同步内存顺序\",{\"1\":{\"38\":1}}],[\"不需要加锁解锁\",{\"1\":{\"28\":1}}],[\"不会引起数据竞争\",{\"1\":{\"34\":1}}],[\"多个线程对同一变量进行原子操作时\",{\"1\":{\"34\":1}}],[\"基本概念\",{\"0\":{\"34\":1}}],[\"基本结构\",{\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"带来的性能开销和死锁风险\",{\"1\":{\"33\":1}}],[\"目的是避免传统锁机制\",{\"1\":{\"33\":1}}],[\"无锁编程主要依赖于原子操作和内存序列模型\",{\"1\":{\"33\":1}}],[\"无锁编程\",{\"0\":{\"33\":1},\"1\":{\"33\":1}}],[\"无需锁定\",{\"1\":{\"28\":1}}],[\"继续执行\",{\"1\":{\"32\":1}}],[\"所有等待的线程被唤醒\",{\"1\":{\"32\":1}}],[\"所有等待的线程继续执行\",{\"1\":{\"31\":1}}],[\"每次完成任务时\",{\"1\":{\"32\":1}}],[\"每当一个线程到达屏障点时\",{\"1\":{\"31\":1}}],[\"倒数计数器\",{\"1\":{\"32\":1}}],[\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景\",{\"1\":{\"32\":1}}],[\"锁存器计数减少\",{\"1\":{\"32\":1}}],[\"锁存器内部维护一个倒数计数器\",{\"1\":{\"32\":1}}],[\"锁存器类似于屏障\",{\"1\":{\"32\":1}}],[\"锁存器\",{\"0\":{\"32\":1}}],[\"锁定\",{\"1\":{\"25\":1}}],[\"锁定或未锁定\",{\"1\":{\"25\":1}}],[\"8\",{\"0\":{\"32\":1}}],[\"表示需要完成的任务数量\",{\"1\":{\"32\":1}}],[\"表示所有线程都已到达屏障点\",{\"1\":{\"31\":1}}],[\"表示已到达屏障的线程数量\",{\"1\":{\"31\":1}}],[\"表示当前可用资源的数量\",{\"1\":{\"29\":1}}],[\"确保主线程在两个子线程结束后才退出\",{\"1\":{\"37\":1}}],[\"确保更新操作一定在取值之后\",{\"1\":{\"36\":1}}],[\"确保所有线程都到达某个同步点后才能继续执行\",{\"1\":{\"31\":1}}],[\"确保在不同平台上实现一致的原子操作行为\",{\"1\":{\"28\":1}}],[\"屏障适用于并行计算中需要同步多个线程的场景\",{\"1\":{\"31\":1}}],[\"屏障解除\",{\"1\":{\"31\":1}}],[\"屏障内部维护一个计数器\",{\"1\":{\"31\":1}}],[\"屏障用于同步一组线程\",{\"1\":{\"31\":1}}],[\"屏障\",{\"0\":{\"31\":1}}],[\"7\",{\"0\":{\"31\":1}}],[\"直到锁可用为止\",{\"1\":{\"30\":1}}],[\"直到互斥量被解锁\",{\"1\":{\"25\":1}}],[\"忙等待\",{\"1\":{\"30\":1}}],[\"而不会阻塞或挂起\",{\"1\":{\"30\":1}}],[\"而constexpr有\",{\"1\":{\"4\":1,\"11\":1}}],[\"自旋等待\",{\"1\":{\"30\":1}}],[\"自旋锁适用于锁定时间非常短的场景\",{\"1\":{\"30\":1}}],[\"自旋锁通常通过硬件的原子操作实现\",{\"1\":{\"30\":1}}],[\"自旋锁是一种忙等待锁\",{\"1\":{\"30\":1}}],[\"自旋锁\",{\"0\":{\"30\":1}}],[\"自动加锁和解锁\",{\"1\":{\"25\":1}}],[\"操作\",{\"1\":{\"29\":6}}],[\"操作或等待某个事件发生\",{\"1\":{\"17\":1}}],[\"分为计数信号量和二进制信号量\",{\"1\":{\"29\":1}}],[\"分配了必要的资源后\",{\"1\":{\"17\":1}}],[\"标志位等\",{\"1\":{\"28\":1}}],[\"因此在高并发场景下具有更好的性能\",{\"1\":{\"28\":1}}],[\"内存顺序的选择\",{\"0\":{\"38\":1}}],[\"内存序列模型\",{\"1\":{\"34\":1}}],[\"内存模型\",{\"1\":{\"28\":1}}],[\"内存地址偏移一个数组的位置\",{\"1\":{\"3\":1,\"10\":1}}],[\"等\",{\"1\":{\"28\":1,\"30\":1,\"34\":1}}],[\"等待线程完成\",{\"1\":{\"37\":1}}],[\"等待所有线程到达锁存器\",{\"1\":{\"32\":1}}],[\"等待所有线程到达屏障点\",{\"1\":{\"31\":1}}],[\"等待所有已终止的子进程\",{\"1\":{\"21\":1}}],[\"等待机制\",{\"1\":{\"31\":1,\"32\":1}}],[\"等待操作\",{\"1\":{\"29\":1}}],[\"等待条件变量的通知\",{\"1\":{\"27\":1}}],[\"等待\",{\"1\":{\"27\":2,\"36\":2,\"37\":2}}],[\"等待信号\",{\"1\":{\"21\":1}}],[\"等待子进程结束并回收资源\",{\"1\":{\"21\":1}}],[\"等待事件\",{\"1\":{\"18\":1}}],[\"等待再次被调度\",{\"1\":{\"17\":1}}],[\"等待资源释放\",{\"1\":{\"29\":1}}],[\"等待资源\",{\"1\":{\"17\":1}}],[\"等待下一次调度\",{\"1\":{\"17\":1}}],[\"等待调度器的调度\",{\"1\":{\"17\":1}}],[\"等待被调度器分配\",{\"1\":{\"16\":1}}],[\"硬件支持\",{\"1\":{\"28\":1}}],[\"保证在并发环境下操作的不可分割性\",{\"1\":{\"28\":1}}],[\"保持与c\",{\"1\":{\"5\":1,\"12\":1}}],[\"消费者取出数据\",{\"1\":{\"37\":1}}],[\"消费者线程\",{\"1\":{\"37\":1}}],[\"消费者线程等待该通知\",{\"1\":{\"27\":1}}],[\"消费者模型等\",{\"1\":{\"29\":1}}],[\"消费者模型中\",{\"1\":{\"27\":1}}],[\"唤醒一个线程\",{\"1\":{\"29\":1}}],[\"唤醒一个或所有等待队列中的线程\",{\"1\":{\"27\":1}}],[\"唤醒所有等待的线程\",{\"1\":{\"27\":1}}],[\"变为\",{\"1\":{\"27\":1}}],[\"并输出相应的信息\",{\"1\":{\"37\":1}}],[\"并使用\",{\"1\":{\"37\":2}}],[\"并将\",{\"1\":{\"37\":1}}],[\"并将互斥量状态设置为锁定\",{\"1\":{\"25\":1}}],[\"并释放互斥量\",{\"1\":{\"27\":1}}],[\"需要持有相关的互斥量\",{\"1\":{\"27\":1}}],[\"条件变量常用于线程之间的协调\",{\"1\":{\"27\":1}}],[\"条件变量与一个互斥量和一个条件状态相关联\",{\"1\":{\"27\":1}}],[\"条件变量用于线程之间的等待和通知机制\",{\"1\":{\"27\":1}}],[\"条件变量\",{\"0\":{\"27\":1}}],[\"vector<std\",{\"1\":{\"31\":1,\"32\":1}}],[\"vector<int>\",{\"1\":{\"26\":1}}],[\"v\",{\"1\":{\"29\":3}}],[\"variable>\",{\"1\":{\"27\":1}}],[\"variable\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"value\",{\"1\":{\"26\":2,\"28\":1}}],[\"void\",{\"1\":{\"21\":1,\"23\":2,\"25\":1,\"26\":2,\"27\":2,\"28\":1,\"29\":1,\"30\":3,\"31\":1,\"32\":1}}],[\"减少读计数器\",{\"1\":{\"26\":1}}],[\"写锁定\",{\"1\":{\"26\":1}}],[\"读锁定\",{\"1\":{\"26\":1}}],[\"读写锁包含两个计数器\",{\"1\":{\"26\":1}}],[\"读写锁允许多个线程同时读取\",{\"1\":{\"26\":1}}],[\"读写锁\",{\"0\":{\"26\":1}}],[\"另一个用于记录是否有写线程在等待\",{\"1\":{\"26\":1}}],[\"一个用于记录当前正在读取的线程数\",{\"1\":{\"26\":1}}],[\"但只能使用一次\",{\"1\":{\"32\":1}}],[\"但在写入时只允许一个线程操作\",{\"1\":{\"26\":1}}],[\"但它会占用一个进程表项\",{\"1\":{\"20\":1}}],[\"但它的进程描述符\",{\"1\":{\"19\":1}}],[\"guard\",{\"1\":{\"25\":1}}],[\"guard<std\",{\"1\":{\"25\":1,\"27\":1}}],[\"使其继续执行\",{\"1\":{\"29\":1}}],[\"使其尝试重新锁定互斥量\",{\"1\":{\"25\":1}}],[\"使用取模操作来实现循环队列\",{\"1\":{\"37\":1}}],[\"使用模板参数\",{\"1\":{\"37\":1}}],[\"使用原子变量实现无锁队列\",{\"0\":{\"36\":1}}],[\"使用场景\",{\"1\":{\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1}}],[\"使用\",{\"1\":{\"21\":2,\"36\":1,\"37\":3}}],[\"解锁\",{\"1\":{\"25\":1,\"26\":1,\"30\":1}}],[\"则将其更改为新值\",{\"1\":{\"34\":1}}],[\"则将互斥量状态设置为未锁定\",{\"1\":{\"25\":1}}],[\"则唤醒所有读线程\",{\"1\":{\"26\":1}}],[\"则唤醒一个写线程\",{\"1\":{\"26\":2}}],[\"则唤醒一个线程\",{\"1\":{\"25\":1}}],[\"则锁定成功\",{\"1\":{\"26\":1}}],[\"则线程进入等待队列\",{\"1\":{\"26\":2}}],[\"则线程成功锁定\",{\"1\":{\"25\":1}}],[\"则增加读计数器\",{\"1\":{\"26\":1}}],[\"则该线程进入等待队列并挂起\",{\"1\":{\"25\":1}}],[\"则该进程被挂起并返回到就绪队列中\",{\"1\":{\"17\":1}}],[\"load\",{\"1\":{\"36\":4,\"37\":8,\"38\":3}}],[\"lockfreequeue<int>\",{\"1\":{\"36\":1,\"37\":1}}],[\"lockfreequeue\",{\"1\":{\"36\":2,\"37\":4}}],[\"lock<std\",{\"1\":{\"26\":2,\"27\":1}}],[\"lock\",{\"1\":{\"25\":2,\"26\":4,\"27\":4,\"30\":2,\"33\":1}}],[\"latch\",{\"0\":{\"32\":1},\"1\":{\"32\":2}}],[\"linux\",{\"1\":{\"19\":1}}],[\"维护一个等待队列\",{\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"通过\",{\"1\":{\"37\":1}}],[\"通过及时调用\",{\"1\":{\"21\":1}}],[\"通知\",{\"1\":{\"27\":1}}],[\"通常用布尔值或整数表示\",{\"1\":{\"25\":1}}],[\"具体实现步骤如下\",{\"1\":{\"25\":1}}],[\"具体来说\",{\"1\":{\"19\":1}}],[\"实现生产者\",{\"1\":{\"29\":1}}],[\"实现原理\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1}}],[\"实现的基础\",{\"1\":{\"2\":1,\"9\":1}}],[\"memory\",{\"1\":{\"30\":2,\"34\":3,\"36\":7,\"37\":15,\"38\":6}}],[\"mtx\",{\"1\":{\"25\":2,\"26\":3,\"27\":3}}],[\"mutex>\",{\"1\":{\"25\":1,\"26\":3,\"27\":2}}],[\"mutex\",{\"0\":{\"25\":1,\"26\":1},\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"main\",{\"1\":{\"21\":1,\"23\":2,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":2}}],[\"mangling\",{\"1\":{\"5\":2,\"12\":2}}],[\"malloc\",{\"1\":{\"2\":2,\"9\":2}}],[\"互斥量有一个内部状态\",{\"1\":{\"25\":1}}],[\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问\",{\"1\":{\"25\":1}}],[\"互斥量\",{\"0\":{\"25\":1}}],[\"线程会持续等待直到成功取出元素\",{\"1\":{\"37\":1}}],[\"线程会持续等待直到成功插入\",{\"1\":{\"37\":1}}],[\"线程等待直到锁存器倒数到零\",{\"1\":{\"32\":1}}],[\"线程将反复检查锁的状态\",{\"1\":{\"30\":1}}],[\"线程将自己添加到等待队列\",{\"1\":{\"27\":1}}],[\"线程在尝试获取锁时会反复检查锁的状态\",{\"1\":{\"30\":1}}],[\"线程在等待条件变量时\",{\"1\":{\"27\":1}}],[\"线程进入等待队列\",{\"1\":{\"29\":1}}],[\"线程再次进入等待状态\",{\"1\":{\"27\":1}}],[\"线程继续执行\",{\"1\":{\"26\":1,\"27\":1,\"29\":1}}],[\"线程同步机制\",{\"0\":{\"24\":1}}],[\"线程创建\",{\"0\":{\"23\":1}}],[\"unique\",{\"1\":{\"26\":1,\"27\":1}}],[\"unix\",{\"1\":{\"19\":2}}],[\"unlock\",{\"1\":{\"25\":1,\"26\":1,\"30\":2}}],[\"until\",{\"1\":{\"23\":2}}],[\"join\",{\"1\":{\"23\":2,\"25\":1,\"26\":4,\"27\":2,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":2,\"37\":3}}],[\"x\",{\"1\":{\"23\":1}}],[\"buffer\",{\"1\":{\"36\":5,\"37\":7}}],[\"bool\",{\"1\":{\"27\":1,\"36\":2,\"37\":2}}],[\"back\",{\"1\":{\"26\":1,\"31\":1,\"32\":1}}],[\"barrier\",{\"0\":{\"31\":1},\"1\":{\"31\":1}}],[\"bar\",{\"1\":{\"23\":5}}],[\"blocked\",{\"1\":{\"16\":1}}],[\"选择适当的方法管理子进程的生命周期\",{\"1\":{\"21\":1}}],[\"处理\",{\"1\":{\"21\":1}}],[\"系列函数\",{\"1\":{\"21\":1}}],[\"系统管理的麻烦\",{\"1\":{\"20\":1}}],[\"系统\",{\"1\":{\"19\":1}}],[\"系统将其从内存中清除\",{\"1\":{\"17\":1}}],[\"系统将其从内存中移除\",{\"1\":{\"16\":1}}],[\"孙子进程\",{\"1\":{\"21\":1}}],[\"孙子进程则由\",{\"1\":{\"21\":1}}],[\"第一个子进程退出\",{\"1\":{\"21\":1}}],[\"第一个子进程\",{\"1\":{\"21\":1}}],[\"然后子进程立即退出\",{\"1\":{\"21\":1}}],[\"创建了一个\",{\"1\":{\"37\":1}}],[\"创建一个孙子进程\",{\"1\":{\"21\":1}}],[\"创建一个子进程\",{\"1\":{\"21\":1}}],[\"创建进程\",{\"1\":{\"18\":1}}],[\"dequeue\",{\"1\":{\"36\":2,\"37\":5}}],[\"delete\",{\"1\":{\"2\":1,\"9\":1,\"36\":1,\"37\":1}}],[\"delete是c++语言标准库提供的一组用于动态创建\",{\"1\":{\"2\":1,\"9\":1}}],[\"delete与malloc\",{\"0\":{\"2\":1,\"9\":1}}],[\"d\",{\"1\":{\"26\":2}}],[\"data\",{\"1\":{\"26\":3}}],[\"down\",{\"1\":{\"32\":1}}],[\"do\",{\"1\":{\"23\":2}}],[\"double\",{\"1\":{\"21\":2}}],[\"采用\",{\"1\":{\"21\":1}}],[\"此时子进程的父进程是\",{\"1\":{\"21\":1}}],[\"后使父进程退出\",{\"1\":{\"21\":1}}],[\"后变量不会释放\",{\"1\":{\"1\":1,\"8\":1}}],[\"避免使用锁机制带来的开销\",{\"1\":{\"28\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"21\":1}}],[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态\",{\"1\":{\"21\":1}}],[\"回收子进程的资源\",{\"1\":{\"21\":1}}],[\"接管\",{\"1\":{\"21\":2}}],[\"将头部指针所指向的元素存储到\",{\"1\":{\"37\":1}}],[\"将新的尾部指针存储到\",{\"1\":{\"37\":1}}],[\"将元素存储在当前尾部指针所指向的位置\",{\"1\":{\"37\":1}}],[\"将子进程的父进程设置为\",{\"1\":{\"21\":1}}],[\"将重载函数重新命名成唯一的标识符\",{\"1\":{\"5\":1,\"12\":1}}],[\"例如初始化任务完成后启动主任务\",{\"1\":{\"32\":1}}],[\"例如在每个计算步骤完成后同步所有线程\",{\"1\":{\"31\":1}}],[\"例如在中断上下文或需要避免线程调度开销的情况下使用\",{\"1\":{\"30\":1}}],[\"例如在生产者\",{\"1\":{\"27\":1}}],[\"例如限制同时访问文件的线程数\",{\"1\":{\"29\":1}}],[\"例如\",{\"1\":{\"21\":1}}],[\"注册\",{\"1\":{\"21\":1}}],[\"working\",{\"1\":{\"29\":1,\"30\":1}}],[\"worker\",{\"1\":{\"29\":2,\"30\":2,\"31\":2,\"32\":2}}],[\"writer\",{\"1\":{\"26\":3}}],[\"write\",{\"1\":{\"26\":1}}],[\"wnohang\",{\"1\":{\"21\":1}}],[\"while\",{\"1\":{\"21\":1,\"30\":1,\"36\":2,\"37\":4}}],[\"waiting\",{\"1\":{\"31\":1}}],[\"waitpid\",{\"1\":{\"19\":2,\"21\":4}}],[\"wait\",{\"1\":{\"19\":2,\"21\":8,\"27\":2,\"29\":1,\"31\":1,\"32\":1}}],[\"head\",{\"1\":{\"36\":5,\"37\":11,\"38\":1}}],[\"has\",{\"1\":{\"32\":1}}],[\"handler\",{\"1\":{\"21\":2}}],[\"h>\",{\"1\":{\"21\":3}}],[\"<typename\",{\"1\":{\"36\":1,\"37\":1}}],[\"<thread>\",{\"1\":{\"23\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1}}],[\"<latch>\",{\"1\":{\"32\":1}}],[\"<barrier>\",{\"1\":{\"31\":1}}],[\"<atomic>\",{\"1\":{\"28\":1,\"30\":1,\"36\":1}}],[\"<condition\",{\"1\":{\"27\":1}}],[\"<vector>\",{\"1\":{\"26\":1,\"31\":1,\"32\":1,\"36\":1}}],[\"<\",{\"1\":{\"25\":1,\"27\":1,\"28\":2,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":2,\"37\":2}}],[\"<mutex>\",{\"1\":{\"25\":1,\"27\":1}}],[\"<<\",{\"1\":{\"23\":2,\"25\":3,\"26\":3,\"27\":3,\"28\":3,\"29\":4,\"30\":4,\"31\":8,\"32\":8,\"36\":6,\"37\":6}}],[\"<semaphore>\",{\"1\":{\"29\":1}}],[\"<shared\",{\"1\":{\"26\":1}}],[\"<signal\",{\"1\":{\"21\":1}}],[\"<sys\",{\"1\":{\"21\":1}}],[\"<unistd\",{\"1\":{\"21\":1}}],[\"<iostream>\",{\"1\":{\"21\":1,\"23\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":1}}],[\"信号量适用于控制对资源的并发访问数量\",{\"1\":{\"29\":1}}],[\"信号量内部维护一个计数器\",{\"1\":{\"29\":1}}],[\"信号量是一种控制对共享资源访问的计数器\",{\"1\":{\"29\":1}}],[\"信号量\",{\"0\":{\"29\":1}}],[\"信号处理程序\",{\"1\":{\"21\":1}}],[\"信号处理子进程的结束\",{\"1\":{\"21\":1}}],[\"信号\",{\"1\":{\"21\":2}}],[\"size\",{\"1\":{\"36\":5,\"37\":4}}],[\"signal\",{\"1\":{\"21\":1,\"29\":1}}],[\"signum\",{\"1\":{\"21\":1}}],[\"sigchld\",{\"1\":{\"21\":8}}],[\"spinlock\",{\"0\":{\"30\":1},\"1\":{\"30\":5}}],[\"spawn\",{\"1\":{\"23\":2}}],[\"swap\",{\"1\":{\"28\":1,\"30\":1,\"34\":1}}],[\"sleep\",{\"1\":{\"27\":1,\"29\":1,\"30\":1}}],[\"sem\",{\"1\":{\"29\":3}}],[\"semaphore<1>\",{\"1\":{\"29\":1}}],[\"semaphore\",{\"0\":{\"29\":1}}],[\"set\",{\"1\":{\"27\":2,\"30\":2}}],[\"seconds\",{\"1\":{\"27\":1,\"29\":1,\"30\":1}}],[\"second\",{\"1\":{\"23\":3}}],[\"shared\",{\"0\":{\"26\":1},\"1\":{\"26\":4}}],[\"sync\",{\"1\":{\"31\":2,\"32\":3}}],[\"synchronize\",{\"1\":{\"23\":1}}],[\"systemd\",{\"1\":{\"21\":1}}],[\"store\",{\"1\":{\"36\":2,\"37\":4,\"38\":2}}],[\"stuff\",{\"1\":{\"23\":2}}],[\"std\",{\"1\":{\"23\":6,\"25\":6,\"26\":11,\"27\":11,\"28\":6,\"29\":7,\"30\":9,\"31\":6,\"32\":6,\"35\":1,\"36\":14,\"37\":18,\"38\":3}}],[\"statediagram\",{\"1\":{\"18\":1}}],[\"static\",{\"0\":{\"1\":1,\"8\":1}}],[\"nexttail\",{\"1\":{\"36\":3,\"37\":7,\"38\":1}}],[\"new的区别\",{\"0\":{\"2\":1,\"9\":1}}],[\"new\",{\"0\":{\"2\":1,\"9\":1},\"1\":{\"2\":3,\"9\":3,\"16\":1,\"23\":2,\"36\":1,\"37\":1}}],[\"not\",{\"1\":{\"39\":1}}],[\"notify\",{\"1\":{\"27\":4}}],[\"now\",{\"1\":{\"23\":1}}],[\"n\",{\"1\":{\"23\":2}}],[\"null\",{\"1\":{\"21\":3}}],[\"父进程等待第一个子进程退出\",{\"1\":{\"21\":1}}],[\"父进程只需等待子进程的退出状态\",{\"1\":{\"21\":1}}],[\"父进程通过\",{\"1\":{\"21\":1}}],[\"父进程退出\",{\"1\":{\"21\":1}}],[\"父进程继续执行其任务\",{\"1\":{\"21\":1}}],[\"父进程可以在信号处理程序中调用\",{\"1\":{\"21\":1}}],[\"父进程会收到\",{\"1\":{\"21\":1}}],[\"父进程代码\",{\"1\":{\"21\":2}}],[\"父进程在适当的时机调用\",{\"1\":{\"21\":1}}],[\"enqueue\",{\"1\":{\"36\":2,\"37\":5}}],[\"endl\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":2,\"32\":2,\"36\":2,\"37\":2}}],[\"emplace\",{\"1\":{\"31\":1,\"32\":1}}],[\"else\",{\"1\":{\"21\":4}}],[\"execute\",{\"1\":{\"23\":1}}],[\"example\",{\"1\":{\"23\":1}}],[\"exit\",{\"1\":{\"21\":5}}],[\"extern\",{\"0\":{\"5\":1,\"12\":1},\"1\":{\"5\":1,\"12\":1}}],[\"子进程再\",{\"1\":{\"21\":1}}],[\"子进程继续执行\",{\"1\":{\"21\":1}}],[\"子进程被\",{\"1\":{\"21\":1}}],[\"子进程会被\",{\"1\":{\"21\":1}}],[\"子进程代码\",{\"1\":{\"21\":2}}],[\"子进程终止后\",{\"1\":{\"19\":1}}],[\"tail\",{\"1\":{\"36\":5,\"37\":11,\"38\":2}}],[\"t>\",{\"1\":{\"36\":3,\"37\":1}}],[\"template\",{\"1\":{\"36\":1,\"37\":1}}],[\"test\",{\"1\":{\"30\":2}}],[\"terminated\",{\"1\":{\"16\":1}}],[\"true\",{\"1\":{\"27\":2,\"36\":2,\"37\":2}}],[\"t4\",{\"1\":{\"26\":2}}],[\"t3\",{\"1\":{\"26\":2}}],[\"t2\",{\"1\":{\"26\":2}}],[\"t1\",{\"1\":{\"26\":2}}],[\"the\",{\"1\":{\"32\":1}}],[\"this\",{\"1\":{\"27\":1,\"29\":1,\"30\":1}}],[\"th\",{\"1\":{\"25\":2,\"27\":2,\"28\":2,\"29\":2,\"30\":2,\"31\":2,\"32\":2}}],[\"that\",{\"1\":{\"23\":2}}],[\"thread>\",{\"1\":{\"31\":1,\"32\":1}}],[\"threads\",{\"1\":{\"23\":1,\"25\":3,\"27\":3,\"28\":3,\"29\":3,\"30\":3,\"31\":3,\"32\":3}}],[\"thread\",{\"1\":{\"23\":6,\"25\":5,\"26\":4,\"27\":5,\"28\":2,\"29\":4,\"30\":4,\"31\":2,\"32\":2,\"36\":2,\"37\":2}}],[\"t\",{\"1\":{\"21\":5,\"27\":2,\"36\":9,\"37\":8}}],[\"point\",{\"1\":{\"31\":2,\"32\":4}}],[\"public\",{\"1\":{\"30\":1,\"36\":1,\"37\":1}}],[\"push\",{\"1\":{\"26\":1}}],[\"p\",{\"1\":{\"29\":3}}],[\"private\",{\"1\":{\"36\":1}}],[\"print\",{\"1\":{\"25\":2,\"27\":2}}],[\"produced\",{\"1\":{\"36\":1,\"37\":1}}],[\"producer\",{\"1\":{\"36\":2,\"37\":3}}],[\"programming\",{\"1\":{\"33\":1}}],[\"proceeding\",{\"1\":{\"31\":1,\"32\":1}}],[\"process\",{\"1\":{\"19\":1}}],[\"pauses\",{\"1\":{\"23\":2}}],[\"pause\",{\"1\":{\"21\":1}}],[\"pid2\",{\"1\":{\"21\":2}}],[\"pid\",{\"1\":{\"21\":14}}],[\"以确保在此之前的所有操作不会被重排序到\",{\"1\":{\"38\":1}}],[\"以确保在没有锁的情况下实现线程安全\",{\"1\":{\"33\":1}}],[\"以确保加载的结果及其后续的操作不会被重排序到\",{\"1\":{\"38\":1}}],[\"以确保取出操作完成后\",{\"1\":{\"37\":1}}],[\"以确保插入操作完成后\",{\"1\":{\"37\":1}}],[\"以控制并发操作的顺序性\",{\"1\":{\"34\":1}}],[\"以回收子进程的资源\",{\"1\":{\"21\":1}}],[\"以获取并处理子进程的退出状态\",{\"1\":{\"21\":1}}],[\"以下是几种常用的方法\",{\"1\":{\"21\":1}}],[\"以下是常见的状态转换路径\",{\"1\":{\"17\":1}}],[\"及时调用\",{\"1\":{\"21\":1}}],[\"大量僵尸进程可能会让系统管理者难以管理和监控系统状态\",{\"1\":{\"20\":1}}],[\"可以有效避免僵尸进程的产生\",{\"1\":{\"21\":1}}],[\"可以通过调用\",{\"1\":{\"21\":1}}],[\"可以取代宏的功能\",{\"1\":{\"4\":1,\"11\":1}}],[\"可能会导致系统无法创建新进程\",{\"1\":{\"20\":1}}],[\"虽然僵尸进程不会占用内存或\",{\"1\":{\"20\":1}}],[\"获取子进程的退出状态后\",{\"1\":{\"19\":1}}],[\"仍然保留在系统中\",{\"1\":{\"19\":1}}],[\"包含退出状态信息等\",{\"1\":{\"19\":1}}],[\"都会被操作系统回收\",{\"1\":{\"19\":1}}],[\"都是一个指针代表一个内存\",{\"1\":{\"3\":1,\"10\":1}}],[\"文件描述符等\",{\"1\":{\"19\":1}}],[\"其他线程能正确地看到更新的头部指针\",{\"1\":{\"37\":1}}],[\"其他线程能正确地看到更新的尾部指针\",{\"1\":{\"37\":1}}],[\"其他线程可以成功获取锁并继续执行\",{\"1\":{\"30\":1}}],[\"其实现原理如下\",{\"1\":{\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1}}],[\"其父进程没有及时调用\",{\"1\":{\"19\":1}}],[\"其中a\",{\"1\":{\"3\":1,\"10\":1}}],[\"中的原子操作\",{\"0\":{\"35\":1}}],[\"中的\",{\"1\":{\"28\":1}}],[\"中\",{\"1\":{\"19\":1,\"37\":1}}],[\"或\",{\"1\":{\"19\":2,\"21\":4,\"27\":1,\"29\":2}}],[\"或类\",{\"1\":{\"19\":1}}],[\"或者由于其他更高优先级的进程需要\",{\"1\":{\"17\":1}}],[\"zombie\",{\"1\":{\"19\":1}}],[\"zfooei\",{\"1\":{\"5\":1,\"12\":1}}],[\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的\",{\"1\":{\"21\":1}}],[\"僵尸进程的影响\",{\"0\":{\"20\":1}}],[\"僵尸进程的进程描述符才会被完全清除\",{\"1\":{\"19\":1}}],[\"僵尸进程\",{\"0\":{\"19\":1},\"1\":{\"19\":1}}],[\"事件完成\",{\"1\":{\"18\":1}}],[\"调度进程\",{\"1\":{\"18\":1}}],[\"调度器选择一个就绪的进程并将其分配给\",{\"1\":{\"17\":1}}],[\">\",{\"1\":{\"18\":8,\"21\":2}}],[\"状态转换示意图\",{\"0\":{\"18\":1}}],[\"当计数器减为零时\",{\"1\":{\"32\":1}}],[\"当计数器达到零时\",{\"1\":{\"31\":1}}],[\"当持有锁的线程释放自旋锁时\",{\"1\":{\"30\":1}}],[\"当写线程解锁时\",{\"1\":{\"26\":1}}],[\"当读线程解锁时\",{\"1\":{\"26\":1}}],[\"当一个线程尝试获取自旋锁时\",{\"1\":{\"30\":1}}],[\"当一个线程尝试锁定互斥量时\",{\"1\":{\"25\":1}}],[\"当一个线程执行\",{\"1\":{\"29\":2}}],[\"当一个线程修改条件状态并调用\",{\"1\":{\"27\":1}}],[\"当一个线程请求写锁定时\",{\"1\":{\"26\":1}}],[\"当一个线程请求读锁定时\",{\"1\":{\"26\":1}}],[\"当一个线程解锁互斥量时\",{\"1\":{\"25\":1}}],[\"当一个子进程结束时\",{\"1\":{\"19\":1}}],[\"当子进程结束时\",{\"1\":{\"21\":1}}],[\"当父进程调用\",{\"1\":{\"19\":1}}],[\"当等待的事件发生\",{\"1\":{\"17\":1}}],[\"当进程完成其任务或被强制终止时\",{\"1\":{\"17\":1}}],[\"当进程执行\",{\"1\":{\"17\":1}}],[\"当进程创建完成\",{\"1\":{\"17\":1}}],[\"被唤醒的线程重新获得互斥量\",{\"1\":{\"27\":1}}],[\"被终止\",{\"1\":{\"18\":1}}],[\"被抢占\",{\"1\":{\"18\":1}}],[\"被释放给其他就绪进程\",{\"1\":{\"17\":1}}],[\"被mutable\",{\"1\":{\"6\":1,\"13\":1}}],[\"时间片耗尽\",{\"1\":{\"18\":1}}],[\"时\",{\"1\":{\"17\":1,\"27\":1,\"29\":2}}],[\"就会进入就绪状态\",{\"1\":{\"17\":1}}],[\"就绪\",{\"1\":{\"16\":1,\"17\":4,\"18\":4}}],[\"→\",{\"1\":{\"17\":6}}],[\"终止\",{\"1\":{\"16\":1,\"17\":1,\"18\":2}}],[\"发生\",{\"1\":{\"16\":1}}],[\"完成或资源可用\",{\"1\":{\"17\":1}}],[\"完成\",{\"1\":{\"16\":1}}],[\"order\",{\"1\":{\"30\":2,\"34\":3,\"36\":7,\"37\":15,\"38\":6}}],[\"operations\",{\"0\":{\"28\":1}}],[\"one\",{\"1\":{\"27\":1}}],[\"o\",{\"1\":{\"16\":1,\"17\":2}}],[\"item\",{\"1\":{\"36\":7,\"37\":11}}],[\"is\",{\"1\":{\"29\":1,\"30\":1,\"31\":2,\"32\":1}}],[\"id\",{\"1\":{\"25\":4,\"27\":4,\"29\":2,\"30\":2,\"31\":3,\"32\":3}}],[\"increment\",{\"1\":{\"28\":2}}],[\"include\",{\"1\":{\"21\":4,\"23\":2,\"25\":3,\"26\":4,\"27\":4,\"28\":3,\"29\":3,\"30\":3,\"31\":4,\"32\":4,\"36\":4}}],[\"init\",{\"1\":{\"21\":7,\"30\":1}}],[\"int\",{\"0\":{\"3\":1,\"10\":1},\"1\":{\"3\":2,\"5\":1,\"10\":2,\"12\":1,\"21\":2,\"23\":2,\"25\":3,\"26\":2,\"27\":3,\"28\":3,\"29\":3,\"30\":3,\"31\":3,\"32\":3,\"36\":4,\"37\":4}}],[\"if\",{\"1\":{\"21\":5,\"36\":2,\"37\":4}}],[\"i\",{\"1\":{\"16\":1,\"17\":2,\"25\":4,\"27\":4,\"28\":5,\"29\":4,\"30\":4,\"31\":3,\"32\":3,\"36\":6,\"37\":7}}],[\"如互斥锁\",{\"1\":{\"33\":1}}],[\"如计数器\",{\"1\":{\"28\":1}}],[\"如何避免产生僵尸进程\",{\"0\":{\"21\":1}}],[\"如果\",{\"1\":{\"37\":2}}],[\"如果队列为空\",{\"1\":{\"36\":1,\"37\":2}}],[\"如果队列已满\",{\"1\":{\"36\":1,\"37\":2}}],[\"如果是\",{\"1\":{\"34\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"30\":1}}],[\"如果计数器值为零或负\",{\"1\":{\"29\":1}}],[\"如果计数器值为正\",{\"1\":{\"29\":1}}],[\"如果条件不满足\",{\"1\":{\"27\":1}}],[\"如果条件满足\",{\"1\":{\"27\":1}}],[\"如果读计数器为0且有写线程在等待\",{\"1\":{\"26\":1}}],[\"如果有线程在等待队列中\",{\"1\":{\"29\":1}}],[\"如果有写线程在等待\",{\"1\":{\"26\":1}}],[\"如果有写锁存在\",{\"1\":{\"26\":1}}],[\"如果有读线程在等待\",{\"1\":{\"26\":1}}],[\"如果有读锁或写锁存在\",{\"1\":{\"26\":1}}],[\"如果有大量僵尸进程存在\",{\"1\":{\"20\":1}}],[\"如果没有读锁和写锁存在\",{\"1\":{\"26\":1}}],[\"如果没有写锁存在\",{\"1\":{\"26\":1}}],[\"如果没有线程在等待\",{\"1\":{\"25\":1}}],[\"如果等待队列中有其他线程\",{\"1\":{\"25\":1}}],[\"如果互斥量已锁定\",{\"1\":{\"25\":1}}],[\"如果互斥量未锁定\",{\"1\":{\"25\":1}}],[\"如果父进程在子进程结束前退出\",{\"1\":{\"21\":1}}],[\"如果运行中的进程的时间片耗尽\",{\"1\":{\"17\":1}}],[\"如内存\",{\"1\":{\"19\":1}}],[\"如等待信号\",{\"1\":{\"17\":1}}],[\"如\",{\"1\":{\"16\":1,\"17\":1,\"19\":1,\"28\":1,\"30\":1,\"34\":1,\"38\":3}}],[\"如void\",{\"1\":{\"5\":1,\"12\":1}}],[\"正在等待某个事件\",{\"1\":{\"16\":1}}],[\"阻塞的进程会被移回就绪队列\",{\"1\":{\"17\":1}}],[\"阻塞\",{\"1\":{\"16\":1,\"17\":2,\"18\":2}}],[\"上执行代码\",{\"1\":{\"16\":1}}],[\"运行\",{\"1\":{\"16\":1,\"17\":4,\"18\":4}}],[\"资源占用\",{\"1\":{\"20\":1}}],[\"资源可用\",{\"1\":{\"16\":1}}],[\"资源\",{\"1\":{\"16\":1}}],[\"rw\",{\"1\":{\"26\":3}}],[\"relaxed\",{\"1\":{\"34\":1,\"36\":2,\"37\":5,\"38\":2}}],[\"release\",{\"1\":{\"29\":2,\"30\":1,\"34\":1,\"36\":3,\"37\":6,\"38\":3}}],[\"reached\",{\"1\":{\"32\":1}}],[\"reader\",{\"1\":{\"26\":3}}],[\"read\",{\"1\":{\"26\":1}}],[\"ready\",{\"1\":{\"16\":1,\"27\":6}}],[\"return\",{\"1\":{\"21\":1,\"23\":1,\"25\":1,\"26\":1,\"27\":2,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":5,\"37\":5}}],[\"running\",{\"1\":{\"16\":1}}],[\"raii\",{\"1\":{\"2\":1,\"9\":1}}],[\"还未进入准备就绪队列\",{\"1\":{\"16\":1}}],[\"新建\",{\"1\":{\"16\":1,\"17\":1,\"18\":2}}],[\"进程接管孤儿进程或采用\",{\"1\":{\"21\":1}}],[\"进程接管\",{\"1\":{\"21\":1}}],[\"进程会自动调用\",{\"1\":{\"21\":1}}],[\"进程\",{\"1\":{\"21\":3}}],[\"进程表项的数量是有限的\",{\"1\":{\"20\":1}}],[\"进程完成\",{\"1\":{\"18\":1}}],[\"进程创建完成\",{\"1\":{\"18\":1}}],[\"进程进入终止状态\",{\"1\":{\"17\":1}}],[\"进程进入阻塞状态\",{\"1\":{\"17\":1}}],[\"进程进入运行状态\",{\"1\":{\"17\":1}}],[\"进程在其生命周期内可以在不同状态之间进行转换\",{\"1\":{\"17\":1}}],[\"进程已完成执行或因某种原因被强制终止\",{\"1\":{\"16\":1}}],[\"进程已经被创建并准备好执行\",{\"1\":{\"16\":1}}],[\"进程无法继续执行\",{\"1\":{\"16\":1}}],[\"进程正在\",{\"1\":{\"16\":1}}],[\"进程正在被创建\",{\"1\":{\"16\":1}}],[\"进程的基本状态\",{\"0\":{\"16\":1}}],[\"进程状态之间的转换\",{\"0\":{\"17\":1}}],[\"进程状态\",{\"0\":{\"15\":1}}],[\"用于存储操作\",{\"1\":{\"38\":1}}],[\"用于加载操作\",{\"1\":{\"38\":1}}],[\"用于没有数据依赖的地方\",{\"1\":{\"38\":1}}],[\"用于保存等待条件的线程\",{\"1\":{\"27\":1}}],[\"用于保存等待的线程\",{\"1\":{\"26\":1}}],[\"用于保存等待锁的线程\",{\"1\":{\"25\":1}}],[\"用于函数穿参数\",{\"1\":{\"6\":1,\"13\":1}}],[\"用来定义常量和函数\",{\"1\":{\"4\":1,\"11\":1}}],[\"即在执行时不会被其他线程打断\",{\"1\":{\"34\":1}}],[\"即进程描述符\",{\"1\":{\"20\":1}}],[\"即进程控制块\",{\"1\":{\"19\":1}}],[\"即被修饰变量不可以被修改\",{\"1\":{\"6\":1,\"13\":1}}],[\"即指向第二个元素a\",{\"1\":{\"3\":1,\"10\":1}}],[\"定义常量\",{\"1\":{\"6\":1,\"13\":1}}],[\"6\",{\"0\":{\"6\":1,\"13\":1,\"30\":1}}],[\"问题\",{\"1\":{\"5\":1,\"12\":1}}],[\"语言一样的方式\",{\"1\":{\"5\":1,\"12\":1}}],[\"代码结构和作用\",{\"0\":{\"37\":1}}],[\"代码示例\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1}}],[\"代码的存在的link\",{\"1\":{\"5\":1,\"12\":1}}],[\"代码编译时不使用name\",{\"1\":{\"5\":1,\"12\":1}}],[\"代码link\",{\"1\":{\"5\":1,\"12\":1}}],[\"让c++\",{\"1\":{\"5\":1,\"12\":1}}],[\"这个操作是原子的\",{\"1\":{\"34\":1}}],[\"这是无锁编程的核心操作之一\",{\"1\":{\"34\":1}}],[\"这是为了允许父进程能够获取子进程的退出状态\",{\"1\":{\"19\":1}}],[\"这些指令能够确保在多个线程操作同一数据时不会产生竞争条件\",{\"1\":{\"28\":1}}],[\"这样就可以解决c代码调用c++\",{\"1\":{\"5\":1,\"12\":1}}],[\"这样\",{\"1\":{\"5\":1,\"12\":1}}],[\"这3者的区别\",{\"0\":{\"3\":1,\"10\":1}}],[\"函数中\",{\"1\":{\"37\":1}}],[\"函数\",{\"1\":{\"21\":1}}],[\"函数回收子进程的退出状态信息\",{\"1\":{\"19\":1}}],[\"函数时会失败\",{\"1\":{\"5\":1,\"12\":1}}],[\"函数名被修饰成\",{\"1\":{\"5\":1,\"12\":1}}],[\"函数return\",{\"1\":{\"1\":1,\"8\":1}}],[\"flag\",{\"1\":{\"30\":5}}],[\"fetch\",{\"1\":{\"28\":1}}],[\"false\",{\"1\":{\"27\":1,\"36\":2,\"37\":2}}],[\"final\",{\"1\":{\"28\":1}}],[\"finishes\",{\"1\":{\"23\":2}}],[\"first\",{\"1\":{\"23\":3}}],[\"found\",{\"1\":{\"39\":1}}],[\"for\",{\"1\":{\"25\":2,\"26\":1,\"27\":3,\"28\":3,\"29\":3,\"30\":3,\"31\":2,\"32\":2,\"36\":2,\"37\":2}}],[\"fork\",{\"1\":{\"21\":10}}],[\"foo\",{\"1\":{\"5\":2,\"12\":2,\"23\":5}}],[\"free\",{\"1\":{\"2\":1,\"9\":1,\"33\":1}}],[\"技术\",{\"1\":{\"5\":1,\"12\":1,\"21\":2}}],[\"为实现无锁编程提供了基础设施\",{\"1\":{\"35\":1}}],[\"为\",{\"1\":{\"21\":1}}],[\"为支持函数重载引入了name\",{\"1\":{\"5\":1,\"12\":1}}],[\"为数组的指针\",{\"1\":{\"3\":1,\"10\":1}}],[\"为数组名指向首元素地址即与\",{\"1\":{\"3\":1,\"10\":1}}],[\"currenthead\",{\"1\":{\"36\":4,\"37\":8}}],[\"currenttail\",{\"1\":{\"36\":3,\"37\":5}}],[\"clear\",{\"1\":{\"30\":1}}],[\"class\",{\"1\":{\"30\":1,\"36\":1,\"37\":1}}],[\"capacity\",{\"1\":{\"36\":7,\"37\":9}}],[\"cas\",{\"1\":{\"28\":1,\"34\":1,\"35\":1}}],[\"calls\",{\"1\":{\"23\":2}}],[\"chrono\",{\"1\":{\"27\":1,\"29\":1,\"30\":1}}],[\"cv\",{\"1\":{\"27\":6}}],[\"count\",{\"1\":{\"32\":1}}],[\"counting\",{\"1\":{\"29\":1}}],[\"counter\",{\"1\":{\"28\":3}}],[\"cout\",{\"1\":{\"23\":3,\"25\":1,\"26\":2,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":2,\"32\":2,\"36\":2,\"37\":2}}],[\"compare\",{\"1\":{\"28\":1,\"30\":1,\"34\":1}}],[\"completed\",{\"1\":{\"23\":1}}],[\"consumed\",{\"1\":{\"36\":1,\"37\":1}}],[\"consumer\",{\"1\":{\"36\":2,\"37\":3}}],[\"const\",{\"0\":{\"6\":1,\"13\":1},\"1\":{\"6\":1,\"13\":1,\"26\":1,\"36\":1,\"37\":1}}],[\"constexpr\",{\"1\":{\"4\":1,\"11\":1}}],[\"condition\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"concurrently\",{\"1\":{\"23\":1}}],[\"cpu\",{\"1\":{\"16\":2,\"17\":3,\"20\":1}}],[\"c++11\",{\"1\":{\"35\":1}}],[\"c++\",{\"0\":{\"35\":1},\"1\":{\"5\":1,\"12\":1,\"28\":1,\"34\":1}}],[\"c\",{\"0\":{\"5\":1,\"12\":1},\"1\":{\"5\":2,\"12\":2}}],[\"5\",{\"0\":{\"5\":1,\"12\":1,\"29\":1,\"38\":1}}],[\"宏没有类型安全检查\",{\"1\":{\"4\":1,\"11\":1}}],[\"宏用于定义常量和简单的代码片段\",{\"1\":{\"4\":1,\"11\":1}}],[\"宏与constexpr\",{\"0\":{\"4\":1,\"11\":1}}],[\"区别\",{\"0\":{\"4\":1,\"11\":1}}],[\"404\",{\"1\":{\"39\":1}}],[\"4\",{\"0\":{\"4\":1,\"11\":1,\"28\":1,\"37\":1}}],[\"地址值+sizeof\",{\"1\":{\"3\":2,\"10\":2}}],[\"是因为我们不需要同步其他内存操作\",{\"1\":{\"37\":1}}],[\"是一种在多线程环境中实现并发访问的技术\",{\"1\":{\"33\":1}}],[\"是在\",{\"1\":{\"19\":1}}],[\"是内存地址偏移一个元素的位置\",{\"1\":{\"3\":1,\"10\":1}}],[\"是c++\",{\"1\":{\"2\":1,\"9\":1}}],[\"是c语言标准库提供的一组用于动态申请释放内存的api\",{\"1\":{\"2\":1,\"9\":1}}],[\"和\",{\"1\":{\"3\":1,\"10\":1,\"37\":1,\"38\":1}}],[\"三者做运算时有差异\",{\"1\":{\"3\":1,\"10\":1}}],[\"且值相同\",{\"1\":{\"3\":1,\"10\":1}}],[\"与头部指针\",{\"1\":{\"37\":1}}],[\"与\",{\"0\":{\"3\":1,\"10\":1},\"1\":{\"3\":1,\"10\":1,\"37\":1}}],[\"0\",{\"0\":{\"3\":1,\"10\":1},\"1\":{\"3\":3,\"10\":3,\"21\":12,\"23\":3,\"25\":2,\"26\":1,\"27\":2,\"28\":4,\"29\":2,\"30\":2,\"31\":2,\"32\":2,\"36\":5,\"37\":6}}],[\"arrive\",{\"1\":{\"31\":1}}],[\"acquire\",{\"1\":{\"29\":2,\"30\":1,\"34\":1,\"36\":2,\"37\":4,\"38\":3}}],[\"add\",{\"1\":{\"28\":1}}],[\"atomic<size\",{\"1\":{\"36\":2}}],[\"atomic<int>\",{\"1\":{\"28\":1}}],[\"atomic\",{\"0\":{\"28\":1},\"1\":{\"28\":1,\"30\":2,\"35\":1}}],[\"all\",{\"1\":{\"27\":2}}],[\"auto\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1}}],[\"and\",{\"1\":{\"23\":2,\"28\":2,\"30\":3,\"31\":1,\"34\":1}}],[\"a+1\",{\"1\":{\"3\":2,\"10\":2}}],[\"a\",{\"0\":{\"3\":4,\"10\":4},\"1\":{\"3\":6,\"10\":6}}],[\"假设有数组\",{\"0\":{\"3\":1,\"10\":1}}],[\"3\",{\"0\":{\"3\":1,\"10\":1,\"27\":1,\"36\":1}}],[\"构造函数初始化队列的容量\",{\"1\":{\"37\":1}}],[\"构造函数\",{\"1\":{\"2\":1,\"9\":1}}],[\"++counter\",{\"1\":{\"28\":1}}],[\"++i\",{\"1\":{\"25\":1,\"27\":1,\"28\":2,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"36\":2,\"37\":2}}],[\"+1\",{\"1\":{\"3\":1,\"10\":1}}],[\"+\",{\"1\":{\"2\":2,\"9\":2,\"36\":2,\"37\":4}}],[\"==\",{\"1\":{\"21\":4,\"36\":2,\"37\":4}}],[\"=\",{\"1\":{\"2\":2,\"9\":2,\"21\":5,\"25\":2,\"27\":4,\"28\":3,\"29\":2,\"30\":3,\"31\":1,\"32\":1,\"36\":8,\"37\":12}}],[\"析构函数\",{\"1\":{\"2\":2,\"9\":2}}],[\"释放操作\",{\"1\":{\"29\":1}}],[\"释放内存的基础上还会额外调用构造\",{\"1\":{\"2\":1,\"9\":1}}],[\"释放对象的操作符\",{\"1\":{\"2\":1,\"9\":1}}],[\"在\",{\"1\":{\"37\":1}}],[\"在实际开发中\",{\"1\":{\"21\":1}}],[\"在此处执行需要守护的任务\",{\"1\":{\"21\":1}}],[\"在系统中\",{\"1\":{\"20\":1}}],[\"在预编译时期会被完整替换\",{\"1\":{\"4\":1,\"11\":1}}],[\"在申请\",{\"1\":{\"2\":1,\"9\":1}}],[\"在class中用于声明类成员或函数\",{\"1\":{\"1\":1,\"8\":1}}],[\"20\",{\"1\":{\"36\":2,\"37\":2}}],[\"2\",{\"0\":{\"2\":1,\"9\":1,\"26\":1,\"35\":1},\"1\":{\"26\":1}}],[\"延长变量的生命周期为整个程序的生命周期\",{\"1\":{\"1\":1,\"8\":1}}],[\"修饰除外\",{\"1\":{\"6\":1,\"13\":1}}],[\"修饰成员函数表示函数体不会修改类成员\",{\"1\":{\"6\":1,\"13\":1}}],[\"修饰局部变量\",{\"1\":{\"1\":1,\"8\":1}}],[\"修饰全局变量或函数\",{\"1\":{\"1\":1,\"8\":1}}],[\"限制作用范围\",{\"1\":{\"1\":1,\"8\":1}}],[\"关键字的作用\",{\"0\":{\"1\":1,\"6\":1,\"8\":1,\"13\":1}}],[\"1000\",{\"1\":{\"28\":1}}],[\"10\",{\"0\":{\"3\":1,\"10\":1},\"1\":{\"3\":1,\"10\":1,\"25\":2,\"27\":2,\"28\":2,\"29\":2,\"30\":2,\"31\":2,\"32\":2,\"36\":1,\"37\":2}}],[\"1\",{\"0\":{\"1\":1,\"8\":1,\"25\":1,\"34\":1},\"1\":{\"3\":1,\"10\":1,\"21\":2,\"26\":1,\"27\":1,\"29\":4,\"30\":1,\"31\":1,\"32\":1,\"36\":2,\"37\":4}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
