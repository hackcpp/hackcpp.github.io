const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":97,\"nextId\":97,\"documentIds\":{\"0\":\"0\",\"1\":\"0#c-相关的面-笔试题\",\"2\":\"0#基本的数据结构\",\"3\":\"0@1\",\"4\":\"1\",\"5\":\"1@0\",\"6\":\"2\",\"7\":\"2#数组\",\"8\":\"2#数组常用操作\",\"9\":\"2#初始化数组\",\"10\":\"2#访问元素\",\"11\":\"2#插入元素\",\"12\":\"2#删除元素\",\"13\":\"2#遍历数组\",\"14\":\"2#查找元素\",\"15\":\"2#扩容数组\",\"16\":\"2#数组的优点与局限性\",\"17\":\"2#数组典型应用\",\"18\":\"2#链表\",\"19\":\"2#链表常用操作\",\"20\":\"2#初始化链表\",\"21\":\"2#插入节点\",\"22\":\"2#删除节点\",\"23\":\"2#访问节点\",\"24\":\"2#查找节点\",\"25\":\"2#数组-vs-链表\",\"26\":\"2#常见链表类型\",\"27\":\"2#链表典型应用\",\"28\":\"2#列表\",\"29\":\"2#列表常用操作\",\"30\":\"2#初始化列表\",\"31\":\"2#访问元素-1\",\"32\":\"2#插入与删除元素\",\"33\":\"2#遍历列表\",\"34\":\"2#列表实现\",\"35\":\"2#重点回顾\",\"36\":\"2#q-a\",\"37\":\"2@0\",\"38\":\"2@1\",\"39\":\"3\",\"40\":\"3@0\",\"41\":\"4\",\"42\":\"4@0\",\"43\":\"5\",\"44\":\"5#设计模式\",\"45\":\"5#设计原则\",\"46\":\"5@0\",\"47\":\"5@1\",\"48\":\"6\",\"49\":\"6@0\",\"50\":\"6@1\",\"51\":\"7\",\"52\":\"7@0\",\"53\":\"7@1\",\"54\":\"8\",\"55\":\"8@0\",\"56\":\"9\",\"57\":\"9#_1-static-关键字的作用\",\"58\":\"9#_2-new-delete与malloc-new的区别\",\"59\":\"9#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"60\":\"9#_4-宏与constexpr-区别\",\"61\":\"9#_5-extern-c\",\"62\":\"9#_6-const-关键字的作用\",\"63\":\"9@0\",\"64\":\"9@1\",\"65\":\"10\",\"66\":\"10#进程状态\",\"67\":\"10#进程的基本状态\",\"68\":\"10#进程状态之间的转换\",\"69\":\"10#状态转换示意图\",\"70\":\"10#僵尸进程\",\"71\":\"10#僵尸进程的影响\",\"72\":\"10#如何避免产生僵尸进程\",\"73\":\"10@0\",\"74\":\"10@1\",\"75\":\"11\",\"76\":\"11#线程创建\",\"77\":\"11#线程同步机制\",\"78\":\"11#_1-互斥量-mutex\",\"79\":\"11#_2-读写锁-shared-mutex\",\"80\":\"11#_3-条件变量-condition-variable\",\"81\":\"11#_4-原子操作-atomic-operations\",\"82\":\"11#_5-信号量-semaphore\",\"83\":\"11#_6-自旋锁-spinlock\",\"84\":\"11#_7-屏障-barrier\",\"85\":\"11#_8-锁存器-latch\",\"86\":\"11#无锁编程\",\"87\":\"11#_1-基本概念\",\"88\":\"11#_2-c-中的原子操作\",\"89\":\"11#_3-使用原子变量实现无锁队列\",\"90\":\"11#_4-代码结构和作用\",\"91\":\"11#_5-内存顺序的选择\",\"92\":\"11@0\",\"93\":\"11@1\",\"94\":\"12\",\"95\":\"12@0\",\"96\":\"13\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[3,3],\"2\":[1,1],\"3\":[null,null,1],\"4\":[1],\"5\":[null,null,1],\"6\":[1],\"7\":[1,8],\"8\":[1],\"9\":[1,23],\"10\":[1,40],\"11\":[1,35],\"12\":[1,52],\"13\":[1,19],\"14\":[1,23],\"15\":[1,37],\"16\":[1,31],\"17\":[1,37],\"18\":[1,69],\"19\":[1],\"20\":[1,37],\"21\":[1,28],\"22\":[1,30],\"23\":[1,39],\"24\":[1,26],\"25\":[3,22],\"26\":[1,42],\"27\":[1,59],\"28\":[1,49],\"29\":[1],\"30\":[1,21],\"31\":[1,17],\"32\":[1,31],\"33\":[1,18],\"34\":[1,37],\"35\":[1,38],\"36\":[2,217],\"37\":[null,null,1],\"38\":[null,null,4],\"39\":[1],\"40\":[null,null,1],\"41\":[1],\"42\":[null,null,1],\"43\":[1],\"44\":[1,15],\"45\":[1,40],\"46\":[null,null,1],\"47\":[null,null,3],\"48\":[1],\"49\":[null,null,1],\"50\":[null,null,4],\"51\":[1],\"52\":[null,null,1],\"53\":[null,null,3],\"54\":[1],\"55\":[null,null,1],\"56\":[2],\"57\":[4,10],\"58\":[5,17],\"59\":[9,21],\"60\":[4,7],\"61\":[4,23],\"62\":[4,8],\"63\":[null,null,1],\"64\":[null,null,1],\"65\":[1],\"66\":[1],\"67\":[1,29],\"68\":[1,37],\"69\":[1],\"70\":[1,32],\"71\":[1,12],\"72\":[2,102],\"73\":[null,null,1],\"74\":[null,null,3],\"75\":[1],\"76\":[1,37],\"77\":[1],\"78\":[4,62],\"79\":[5,78],\"80\":[5,90],\"81\":[5,64],\"82\":[4,74],\"83\":[4,78],\"84\":[4,61],\"85\":[4,64],\"86\":[1,11],\"87\":[2,26],\"88\":[3,13],\"89\":[2,80],\"90\":[2,131],\"91\":[2,26],\"92\":[null,null,1],\"93\":[null,null,3],\"94\":[1],\"95\":[null,null,1],\"96\":[1,3]},\"averageFieldLength\":[1.7331317838306297,34.5690124663793,0.7742928895786322],\"storedFields\":{\"0\":{\"h\":\"首页\"},\"1\":{\"h\":\"c++ 相关的面/笔试题\",\"t\":[\"c++面试题\",\"线程编程\",\"进程编程\"]},\"2\":{\"h\":\"基本的数据结构\",\"t\":[\"数组与链表\"]},\"3\":{\"c\":[\"c++\"]},\"4\":{\"h\":\"数据结构\"},\"5\":{\"c\":[\"数据结构\"]},\"6\":{\"h\":\"数组与链表\"},\"7\":{\"h\":\"数组\",\"t\":[\"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。下图展示了数组的主要概念和存储方式。\",\"数组定义与存储方式\"]},\"8\":{\"h\":\"数组常用操作\"},\"9\":{\"h\":\"初始化数组\",\"t\":[\"我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 ：\",\"/* 初始化数组 */ // 存储在栈上 int arr[5]; int nums[5] = { 1, 3, 2, 5, 4 }; // 存储在堆上（需要手动释放空间） int* arr1 = new int[5]; int* nums1 = new int[5] { 1, 3, 2, 5, 4 };\"]},\"10\":{\"h\":\"访问元素\",\"t\":[\"数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问该元素。\",\"数组元素的内存地址计算\",\"观察上图，我们发现数组首个元素的索引为 $0$ ，这似乎有些反直觉，因为从 $1$ 开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是 0 ，因此它的索引为 0 是合理的。\",\"在数组中访问元素非常高效，我们可以在 O(1) 时间内随机访问数组中的任意一个元素。\",\"/* 随机访问元素 */ int randomAccess(int *nums, int size) { // 在区间 [0, size) 中随机抽取一个数字 int randomIndex = rand() % size; // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum; }\"]},\"11\":{\"h\":\"插入元素\",\"t\":[\"数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。\",\"数组插入元素示例\",\"值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。\",\"/* 在数组的索引 index 处插入元素 num */ void insert(int *nums, int size, int num, int index) { // 把索引 index 以及之后的所有元素向后移动一位 for (int i = size - 1; i > index; i--) { nums[i] = nums[i - 1]; } // 将 num 赋给 index 处的元素 nums[index] = num; }\"]},\"12\":{\"h\":\"删除元素\",\"t\":[\"同理，如下图所示，若想删除索引 $i$ 处的元素，则需要把索引 $i$ 之后的元素都向前移动一位。\",\"数组删除元素示例\",\"请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。\",\"/* 删除索引 index 处的元素 */ void remove(int *nums, int size, int index) { // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i < size - 1; i++) { nums[i] = nums[i + 1]; } }\",\"总的来看，数组的插入与删除操作有以下缺点。\",\"时间复杂度高：数组的插入和删除的平均时间复杂度均为 $O(n)$ ，其中 $n$ 为数组长度。\",\"丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。\",\"内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。\"]},\"13\":{\"h\":\"遍历数组\",\"t\":[\"在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：\",\"/* 遍历数组 */ void traverse(int *nums, int size) { int count = 0; // 通过索引遍历数组 for (int i = 0; i < size; i++) { count += nums[i]; } }\"]},\"14\":{\"h\":\"查找元素\",\"t\":[\"在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。\",\"因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。\",\"/* 在数组中查找指定元素 */ int find(int *nums, int size, int target) { for (int i = 0; i < size; i++) { if (nums[i] == target) return i; } return -1; }\"]},\"15\":{\"h\":\"扩容数组\",\"t\":[\"在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的。\",\"如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 $O(n)$ 的操作，在数组很大的情况下非常耗时。代码如下所示：\",\"/* 扩展数组长度 */ int *extend(int *nums, int size, int enlarge) { // 初始化一个扩展长度后的数组 int *res = new int[size + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i < size; i++) { res[i] = nums[i]; } // 释放内存 delete[] nums; // 返回扩展后的新数组 return res; }\"]},\"16\":{\"h\":\"数组的优点与局限性\",\"t\":[\"数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\",\"空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\",\"支持随机访问：数组允许在 $O(1)$ 时间内访问任何元素。\",\"缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\",\"连续空间存储是一把双刃剑，其存在以下局限性。\",\"插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\",\"长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\",\"空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\"]},\"17\":{\"h\":\"数组典型应用\",\"t\":[\"数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\",\"随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\",\"排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\",\"查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\",\"机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\",\"数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\"]},\"18\":{\"h\":\"链表\",\"t\":[\"内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。\",\"链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。\",\"链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。\",\"链表定义与存储方式\",\"观察上图，链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\",\"链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\",\"尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\",\"在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\",\"如以下代码所示，链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间。\",\"/* 链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向下一节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数 };\"]},\"19\":{\"h\":\"链表常用操作\"},\"20\":{\"h\":\"初始化链表\",\"t\":[\"建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点。\",\" /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */ // 初始化各个节点 ListNode* n0 = new ListNode(1); ListNode* n1 = new ListNode(3); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(5); ListNode* n4 = new ListNode(4); // 构建节点之间的引用 n0->next = n1; n1->next = n2; n2->next = n3; n3->next = n4;\",\"数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0 。\"]},\"21\":{\"h\":\"插入节点\",\"t\":[\"在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为 $O(1)$ 。\",\"相比之下，在数组中插入元素的时间复杂度为 $O(n)$ ，在大数据量下的效率较低。\",\"链表插入节点示例\",\"/* 在链表的节点 n0 之后插入节点 P */ void insert(ListNode *n0, ListNode *P) { ListNode *n1 = n0->next; P->next = n1; n0->next = P; }\"]},\"22\":{\"h\":\"删除节点\",\"t\":[\"如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。\",\"请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\",\"链表删除节点\",\"/* 删除链表的节点 n0 之后的首个节点 */ void remove(ListNode *n0) { if (n0->next == nullptr) return; // n0 -> P -> n1 ListNode *P = n0->next; ListNode *n1 = P->next; n0->next = n1; // 释放内存 delete P; }\"]},\"23\":{\"h\":\"访问节点\",\"t\":[\"在链表中访问节点的效率较低。如上一节所述，我们可以在 $O(1)$ 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 $i$ 个节点需要循环 $i - 1$ 轮，时间复杂度为 $O(n)$ 。\",\"/* 访问链表中索引为 index 的节点 */ ListNode *access(ListNode *head, int index) { for (int i = 0; i < index; i++) { if (head == nullptr) return nullptr; head = head->next; } return head; }\"]},\"24\":{\"h\":\"查找节点\",\"t\":[\"遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：\",\"/* 在链表中查找值为 target 的首个节点 */ int find(ListNode *head, int target) { int index = 0; while (head != nullptr) { if (head->val == target) return index; head = head->next; index++; } return -1; }\"]},\"25\":{\"h\":\"数组 vs. 链表\",\"t\":[\"下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。\",\"数组\",\"链表\",\"存储方式\",\"连续内存空间\",\"分散内存空间\",\"容量扩展\",\"长度不可变\",\"可灵活扩展\",\"内存效率\",\"元素占用内存少、但可能浪费空间\",\"元素占用内存多\",\"访问元素\",\"$O(1)$\",\"$O(n)$\",\"添加元素\",\"$O(n)$\",\"$O(1)$\",\"删除元素\",\"$O(n)$\",\"$O(1)$\"]},\"26\":{\"h\":\"常见链表类型\",\"t\":[\"如下图所示，常见的链表类型包括三种。\",\"单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\",\"环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\",\"双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\",\"/* 双向链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向后继节点的指针 ListNode *prev; // 指向前驱节点的指针 ListNode(int x) : val(x), next(nullptr), prev(nullptr) {} // 构造函数 };\",\"常见链表种类\"]},\"27\":{\"h\":\"链表典型应用\",\"t\":[\"单向链表通常用于实现栈、队列、哈希表和图等数据结构。\",\"栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。\",\"哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\",\"图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\",\"双向链表常用于需要快速查找前一个和后一个元素的场景。\",\"高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\",\"浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\",\"LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\",\"环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\",\"时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\",\"数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\"]},\"28\":{\"h\":\"列表\",\"t\":[\"列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。\",\"链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。\",\"数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。\",\"当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。\",\"为解决此问题，我们可以使用**动态数组（dynamic array）**来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\",\"实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。\"]},\"29\":{\"h\":\"列表常用操作\"},\"30\":{\"h\":\"初始化列表\",\"t\":[\"我们通常使用“无初始值”和“有初始值”这两种初始化方法：\",\"/* 初始化列表 */ // 需注意，C++ 中 vector 即是本文描述的 nums // 无初始值 vector<int> nums1; // 有初始值 vector<int> nums = { 1, 3, 2, 5, 4 };\"]},\"31\":{\"h\":\"访问元素\",\"t\":[\"列表本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。\",\" /* 访问元素 */ int num = nums[1]; // 访问索引 1 处的元素 /* 更新元素 */ nums[1] = 0; // 将索引 1 处的元素更新为 0\"]},\"32\":{\"h\":\"插入与删除元素\",\"t\":[\"相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 $O(1)$ ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。\",\"/* 清空列表 */ nums.clear(); /* 在尾部添加元素 */ nums.push_back(1); nums.push_back(3); nums.push_back(2); nums.push_back(5); nums.push_back(4); /* 在中间插入元素 */ nums.insert(nums.begin() + 3, 6); // 在索引 3 处插入数字 6 /* 删除元素 */ nums.erase(nums.begin() + 3); // 删除索引 3 处的元素\"]},\"33\":{\"h\":\"遍历列表\",\"t\":[\"与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。\",\" /* 通过索引遍历列表 */ int count = 0; for (int i = 0; i < nums.size(); i++) { count += nums[i]; } /* 直接遍历列表元素 */ count = 0; for (int num : nums) { count += num; }\"]},\"34\":{\"h\":\"列表实现\",\"t\":[\"许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。\",\"为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\",\"初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。\",\"数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\",\"扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。\"]},\"35\":{\"h\":\"重点回顾\",\"t\":[\"数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。\",\"数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。\",\"链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。\",\"列表是一种支持增删查改的元素有序集合，通常基于动态数组实现。它保留了数组的优势，同时可以灵活调整长度。\",\"列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。\",\"程序运行时，数据主要存储在内存中。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。\",\"缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。\",\"由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。\"]},\"36\":{\"h\":\"Q & A\",\"t\":[\"Q：数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？\",\"存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。\",\"分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。\",\"大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。\",\"灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。\",\"Q：为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？\",\"链表由节点组成，节点之间通过引用（指针）连接，各个节点可以存储不同类型的数据，例如 int、double、string、object 等。\",\"相对地，数组元素则必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节 和 8 字节 ，此时就不能用以下公式计算偏移量了，因为数组中包含了两种“元素长度”。\",\"# 元素内存地址 = 数组内存地址（首元素内存地址） + 元素长度 * 元素索引\",\"Q：删除节点 P 后，是否需要把 P.next 设为 None 呢？\",\"不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。\",\"从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。\",\"Q：在链表中插入和删除操作的时间复杂度是 $O(1)$ 。但是增删之前都需要 $O(n)$ 的时间查找元素，那为什么时间复杂度不是 $O(n)$ 呢？\",\"如果是先查找元素、再删除元素，时间复杂度确实是 $O(n)$ 。然而，链表的 $O(1)$ 增删的优势可以在其他应用上得到体现。例如，双向队列适合使用链表实现，我们维护一个指针变量始终指向头节点、尾节点，每次插入与删除操作都是 $O(1)$ 。\",\"Q：图“链表定义与存储方式”中，浅蓝色的存储节点指针是占用一块内存地址吗？还是和节点值各占一半呢？\",\"该示意图只是定性表示，定量表示需要根据具体情况进行分析。\",\"不同类型的节点值占用的空间是不同的，比如 int、long、double 和实例对象等。\",\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定，大多为 8 字节或 4 字节。\",\"Q：在列表末尾添加元素是否时时刻刻都为 $O(1)$ ？\",\"如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 $O(n)$ 。\",\"Q：“列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？\",\"这里的空间浪费主要有两方面含义：一方面，列表都会设定一个初始长度，我们不一定需要用这么多；另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 $\\\\times 1.5$ 。这样一来，也会出现很多空位，我们通常不能完全填满它们。\",\"Q：在 Python 中初始化 n = [1, 2, 3] 后，这 3 个元素的地址是相连的，但是初始化 m = [2, 1, 3] 会发现它们每个元素的 id 并不是连续的，而是分别跟 n 中的相同。这些元素的地址不连续，那么 m 还是数组吗？\",\"假如把列表元素换成链表节点 n = [n1, n2, n3, n4, n5] ，通常情况下这 5 个节点对象也分散存储在内存各处。然而，给定一个列表索引，我们仍然可以在 $O(1)$ 时间内获取节点内存地址，从而访问到对应的节点。这是因为数组中存储的是节点的引用，而非节点本身。\",\"与许多语言不同，Python 中的数字也被包装为对象，列表中存储的不是数字本身，而是对数字的引用。因此，我们会发现两个数组中的相同数字拥有同一个 id ，并且这些数字的内存地址无须连续。\",\"Q：C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？\",\"一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。\",\"空间开销：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以 std::list 通常比 std::vector 更占用空间。\",\"缓存不友好：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下，std::vector 的性能会更好。\",\"另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。\",\"Q：初始化列表 res = [0] * self.size() 操作，会导致 res 的每个元素引用相同的地址吗？\",\"不会。但二维数组会有这个问题，例如初始化二维列表 res = [[0]] * self.size() ，则多次引用了同一个列表 [0] 。\"]},\"37\":{\"c\":[\"数据结构\"]},\"38\":{\"c\":[\"c++\",\"线性结构\",\"数组\",\"链表\"]},\"39\":{\"h\":\"基础教程\"},\"40\":{\"c\":[\"教程\"]},\"41\":{\"h\":\"架构设计\"},\"42\":{\"c\":[\"架构设计\"]},\"43\":{\"h\":\"设计模式与设计原则\"},\"44\":{\"h\":\"设计模式\",\"t\":[\"设计模式是解决常见软件设计问题的通用解决方案。它们分为三大类：\",\"创建型模式：关注对象创建，如单例模式、工厂模式。\",\"结构型模式：关注对象组合，如适配器模式、代理模式。\",\"行为型模式：关注对象间通信，如观察者模式、策略模式。\"]},\"45\":{\"h\":\"设计原则\",\"t\":[\"设计原则是指导代码设计的基本准则，如：\",\"单一职责原则 (SRP)\",\"定义: 一个类应只有一个引起其变化的原因，即一个类只负责一项职责。\",\"目的: 提高代码的可维护性和可读性，减少类的复杂性。\",\"开闭原则 (OCP)\",\"定义: 软件实体应对扩展开放，对修改关闭。\",\"目的: 通过抽象和接口，允许添加新功能而无需修改现有代码，减少引入新 bug 的风险。\",\"里氏替换原则 (LSP)\",\"定义: 子类对象必须能够替换其父类对象且行为一致。\",\"目的: 保证继承层次的正确性，避免运行时错误。\",\"依赖倒置原则 (DIP)\",\"定义: 高层模块不应依赖于低层模块，二者都应该依赖于抽象；抽象不应依赖于细节，细节应该依赖于抽象。\",\"目的: 减少模块之间的耦合性，提高系统的灵活性和可扩展性。\",\"接口隔离原则 (ISP)\",\"定义: 不应强迫一个类依赖于它不需要的接口，接口应尽量细化。\",\"目的: 通过多个特定接口来代替单一的总接口，减少代码的复杂性，提高系统的灵活性。\"]},\"46\":{\"c\":[\"架构设计\"]},\"47\":{\"c\":[\"c++\",\"设计模式\",\"设计原则\"]},\"48\":{\"h\":\"观察者模式\"},\"49\":{\"c\":[\"架构设计\"]},\"50\":{\"c\":[\"c++\",\"设计模式\",\"观察者模式\",\"事件模式\"]},\"51\":{\"h\":\"策略模式\"},\"52\":{\"c\":[\"架构设计\"]},\"53\":{\"c\":[\"c++\",\"设计模式\",\"策略模式\"]},\"54\":{\"h\":\"面试集锦\"},\"55\":{\"c\":[\"面试题\"]},\"56\":{\"h\":\"c++ 基础\"},\"57\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"58\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"59\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"60\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"61\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"62\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"63\":{\"c\":[\"面试题\"]},\"64\":{\"c\":[\"c++\"]},\"65\":{\"h\":\"进程编程\"},\"66\":{\"h\":\"进程状态\"},\"67\":{\"h\":\"进程的基本状态\",\"t\":[\"新建（New）：\",\"进程正在被创建，还未进入准备就绪队列。\",\"就绪（Ready）：\",\"进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。\",\"运行（Running）：\",\"进程正在 CPU 上执行代码。\",\"阻塞（Blocked）：\",\"进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。\",\"终止（Terminated）：\",\"进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。\"]},\"68\":{\"h\":\"进程状态之间的转换\",\"t\":[\"进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：\",\"新建 → 就绪：\",\"当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。\",\"就绪 → 运行：\",\"调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。\",\"运行 → 就绪：\",\"如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。\",\"运行 → 阻塞：\",\"当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。\",\"阻塞 → 就绪：\",\"当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。\",\"运行 → 终止：\",\"当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。\"]},\"69\":{\"h\":\"状态转换示意图\"},\"70\":{\"h\":\"僵尸进程\",\"t\":[\"僵尸进程（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 wait() 或 waitpid() 函数回收子进程的退出状态信息，从而导致的进程状态。\",\"具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 wait() 或 waitpid() 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。\"]},\"71\":{\"h\":\"僵尸进程的影响\",\"t\":[\"资源占用：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。\",\"系统管理的麻烦：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。\"]},\"72\":{\"h\":\"如何避免产生僵尸进程？\",\"t\":[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：\",\"及时调用 wait() 或 waitpid()：\",\"父进程在适当的时机调用 wait() 或 waitpid() 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。\",\"pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 wait(NULL); // 等待子进程结束并回收资源 }\",\"使用 SIGCHLD 信号处理子进程的结束：\",\"当子进程结束时，父进程会收到 SIGCHLD 信号。父进程可以在信号处理程序中调用 wait() 或 waitpid() 以回收子进程的资源。\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> #include <signal.h> void sigchld_handler(int signum) { // 等待所有已终止的子进程 while (waitpid(-1, NULL, WNOHANG) > 0); } int main() { // 注册 SIGCHLD 信号处理程序 signal(SIGCHLD, sigchld_handler); pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 // 父进程继续执行其任务 pause(); // 等待信号（例如 SIGCHLD） } return 0; }\",\"将子进程的父进程设置为 init 进程（或 systemd）：\",\"如果父进程在子进程结束前退出，子进程会被 init 进程（PID 为 1 的进程）接管。init 进程会自动调用 wait() 回收子进程的资源，避免僵尸进程的产生。可以通过调用 fork() 后使父进程退出，子进程被 init 接管。\",\"pid_t pid = fork(); if (pid > 0) { // 父进程退出 exit(0); } // 子进程继续执行 // 此时子进程的父进程是 init 进程\",\"采用 double fork() 技术：\",\"父进程通过 fork() 创建一个子进程，子进程再 fork() 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 init 进程接管。\",\"pid_t pid = fork(); if (pid == 0) { // 第一个子进程 pid_t pid2 = fork(); if (pid2 == 0) { // 孙子进程 // 在此处执行需要守护的任务 exit(0); } else { // 第一个子进程退出 exit(0); } } else { // 父进程等待第一个子进程退出 wait(NULL); }\",\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 wait() 系列函数、处理 SIGCHLD 信号、使用 init 进程接管孤儿进程或采用 double fork() 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。\"]},\"73\":{\"c\":[\"面试题\"]},\"74\":{\"c\":[\"c++\",\"多进程\",\"进程通信\"]},\"75\":{\"h\":\"线程编程\"},\"76\":{\"h\":\"线程创建\",\"t\":[\"// thread example #include <iostream> // std::cout #include <thread> // std::thread void foo() { // do stuff... } void bar(int x) { // do stuff... } int main() { std::thread first (foo); // spawn new thread that calls foo() std::thread second (bar,0); // spawn new thread that calls bar(0) std::cout << \\\"main, foo and bar now execute concurrently...\\\\n\\\"; // synchronize threads: first.join(); // pauses until first finishes second.join(); // pauses until second finishes std::cout << \\\"foo and bar completed.\\\\n\\\"; return 0; }\"]},\"77\":{\"h\":\"线程同步机制\"},\"78\":{\"h\":\"1. 互斥量 (Mutex)\",\"t\":[\"实现原理：\",\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问。具体实现步骤如下：\",\"基本结构：\",\"互斥量有一个内部状态，通常用布尔值或整数表示（锁定或未锁定）。\",\"维护一个等待队列，用于保存等待锁的线程。\",\"锁定 (Lock)：\",\"当一个线程尝试锁定互斥量时，如果互斥量未锁定，则线程成功锁定，并将互斥量状态设置为锁定。\",\"如果互斥量已锁定，则该线程进入等待队列并挂起，直到互斥量被解锁。\",\"解锁 (Unlock)：\",\"当一个线程解锁互斥量时，如果等待队列中有其他线程，则唤醒一个线程，使其尝试重新锁定互斥量。\",\"如果没有线程在等待，则将互斥量状态设置为未锁定。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> std::mutex mtx; void print_thread_id(int id) { std::lock_guard<std::mutex> guard(mtx); // 自动加锁和解锁 std::cout << \\\"Thread #\\\" << id << std::endl; } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_thread_id, i); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"79\":{\"h\":\"2. 读写锁 (Shared Mutex)\",\"t\":[\"实现原理：\",\"读写锁允许多个线程同时读取，但在写入时只允许一个线程操作。其实现原理如下：\",\"基本结构：\",\"读写锁包含两个计数器：一个用于记录当前正在读取的线程数，另一个用于记录是否有写线程在等待。\",\"维护一个等待队列，用于保存等待的线程。\",\"读锁定 (Read Lock)：\",\"当一个线程请求读锁定时，如果没有写锁存在，则增加读计数器，线程继续执行。\",\"如果有写锁存在，则线程进入等待队列。\",\"写锁定 (Write Lock)：\",\"当一个线程请求写锁定时，如果没有读锁和写锁存在，则锁定成功。\",\"如果有读锁或写锁存在，则线程进入等待队列。\",\"解锁 (Unlock)：\",\"当读线程解锁时，减少读计数器，如果读计数器为0且有写线程在等待，则唤醒一个写线程。\",\"当写线程解锁时，如果有读线程在等待，则唤醒所有读线程；如果有写线程在等待，则唤醒一个写线程。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <shared_mutex> #include <vector> std::shared_mutex rw_mtx; std::vector<int> data; void reader() { std::shared_lock<std::shared_mutex> lock(rw_mtx); for (const auto& d : data) { std::cout << d << \\\" \\\"; } std::cout << std::endl; } void writer(int value) { std::unique_lock<std::shared_mutex> lock(rw_mtx); data.push_back(value); } int main() { std::thread t1(writer, 1); std::thread t2(reader); std::thread t3(writer, 2); std::thread t4(reader); t1.join(); t2.join(); t3.join(); t4.join(); return 0; }\"]},\"80\":{\"h\":\"3. 条件变量 (Condition Variable)\",\"t\":[\"实现原理：\",\"条件变量用于线程之间的等待和通知机制。其实现原理如下：\",\"基本结构：\",\"条件变量与一个互斥量和一个条件状态相关联。\",\"维护一个等待队列，用于保存等待条件的线程。\",\"等待 (Wait)：\",\"线程在等待条件变量时，需要持有相关的互斥量。\",\"线程将自己添加到等待队列，并释放互斥量，等待条件变量的通知。\",\"通知 (Notify)：\",\"当一个线程修改条件状态并调用 notify_one 或 notify_all 时，唤醒一个或所有等待队列中的线程。\",\"被唤醒的线程重新获得互斥量，检查条件状态，如果条件满足，线程继续执行；如果条件不满足，线程再次进入等待状态。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> std::mutex cv_mtx; std::condition_variable cv; bool ready = false; void print_id(int id) { std::unique_lock<std::mutex> lock(cv_mtx); cv.wait(lock, [] { return ready; }); // 等待 ready 变为 true std::cout << \\\"Thread #\\\" << id << std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard<std::mutex> lock(cv_mtx); ready = true; } cv.notify_all(); // 唤醒所有等待的线程 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_id, i); } std::thread t(set_ready); for (auto& th : threads) { th.join(); } t.join(); return 0; }\",\"使用场景：\",\"条件变量常用于线程之间的协调，例如在生产者-消费者模型中，生产者线程通知消费者线程有新数据可用，消费者线程等待该通知。\"]},\"81\":{\"h\":\"4. 原子操作 (Atomic Operations)\",\"t\":[\"实现原理：\",\"原子操作通过硬件支持的指令集实现，保证在并发环境下操作的不可分割性。其实现原理如下：\",\"硬件支持：\",\"原子操作依赖于硬件提供的原子指令，如 compare-and-swap (CAS)、fetch-and-add 等，这些指令能够确保在多个线程操作同一数据时不会产生竞争条件。\",\"内存模型：\",\"C++ 中的 std::atomic 提供了对不同内存模型的支持，确保在不同平台上实现一致的原子操作行为。\",\"无需锁定：\",\"原子操作直接操作共享变量，不需要加锁解锁，因此在高并发场景下具有更好的性能。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> std::atomic<int> counter(0); void increment() { for (int i = 0; i < 1000; ++i) { ++counter; // 原子操作 } } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(increment); } for (auto& th : threads) { th.join(); } std::cout << \\\"Final counter value: \\\" << counter << std::endl; return 0; }\",\"使用场景：\",\"原子操作适用于需要高效并发访问的场景，如计数器、标志位等，避免使用锁机制带来的开销。\"]},\"82\":{\"h\":\"5. 信号量 (Semaphore)\",\"t\":[\"实现原理：\",\"信号量是一种控制对共享资源访问的计数器，分为计数信号量和二进制信号量。其实现原理如下：\",\"计数器：\",\"信号量内部维护一个计数器，表示当前可用资源的数量。计数器初始值通常为资源的总量。\",\"P 操作 (等待操作)：\",\"当一个线程执行 P 操作（wait 或 acquire）时，计数器减 1。如果计数器值为正，线程继续执行；如果计数器值为零或负，线程进入等待队列，等待资源释放。\",\"V 操作 (释放操作)：\",\"当一个线程执行 V 操作（signal 或 release）时，计数器加 1。如果有线程在等待队列中，唤醒一个线程，使其继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <semaphore> std::counting_semaphore<1> sem(1); void worker(int id) { sem.acquire(); // P 操作 std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); sem.release(); // V 操作 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"信号量适用于控制对资源的并发访问数量，例如限制同时访问文件的线程数、实现生产者-消费者模型等。\"]},\"83\":{\"h\":\"6. 自旋锁 (Spinlock)\",\"t\":[\"实现原理：\",\"自旋锁是一种忙等待锁，线程在尝试获取锁时会反复检查锁的状态，而不会阻塞或挂起。其实现原理如下：\",\"忙等待：\",\"当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，线程将反复检查锁的状态，直到锁可用为止。\",\"自旋锁通常通过硬件的原子操作实现，如 test-and-set、compare-and-swap 等。\",\"解锁：\",\"当持有锁的线程释放自旋锁时，其他线程可以成功获取锁并继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> class Spinlock { std::atomic_flag flag = ATOMIC_FLAG_INIT; public: void lock() { while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待 } void unlock() { flag.clear(std::memory_order_release); } }; Spinlock spinlock; void worker(int id) { spinlock.lock(); std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); spinlock.unlock(); } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"自旋锁适用于锁定时间非常短的场景，例如在中断上下文或需要避免线程调度开销的情况下使用。\"]},\"84\":{\"h\":\"7. 屏障 (Barrier)\",\"t\":[\"实现原理：\",\"屏障用于同步一组线程，确保所有线程都到达某个同步点后才能继续执行。其实现原理如下：\",\"计数器：\",\"屏障内部维护一个计数器，表示已到达屏障的线程数量。每当一个线程到达屏障点时，计数器减 1。\",\"等待机制：\",\"当计数器达到零时，表示所有线程都已到达屏障点，屏障解除，所有等待的线程继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <barrier> #include <vector> std::barrier sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" is waiting\\\" << std::endl; sync_point.arrive_and_wait(); // 等待所有线程到达屏障点 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"屏障适用于并行计算中需要同步多个线程的场景，例如在每个计算步骤完成后同步所有线程。\"]},\"85\":{\"h\":\"8. 锁存器 (Latch)\",\"t\":[\"实现原理：\",\"锁存器类似于屏障，但只能使用一次，线程等待直到锁存器倒数到零。其实现原理如下：\",\"倒数计数器：\",\"锁存器内部维护一个倒数计数器，表示需要完成的任务数量。每次完成任务时，计数器减 1。\",\"等待机制：\",\"当计数器减为零时，所有等待的线程被唤醒，继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <latch> #include <vector> std::latch sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" has reached the latch point\\\" << std::endl; sync_point.count_down(); // 锁存器计数减少 sync_point.wait(); // 等待所有线程到达锁存器 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景，例如初始化任务完成后启动主任务。\"]},\"86\":{\"h\":\"无锁编程\",\"t\":[\"无锁编程（Lock-Free Programming）是一种在多线程环境中实现并发访问的技术，目的是避免传统锁机制（如互斥锁）带来的性能开销和死锁风险。无锁编程主要依赖于原子操作和内存序列模型，以确保在没有锁的情况下实现线程安全。\"]},\"87\":{\"h\":\"1. 基本概念\",\"t\":[\"原子操作：原子操作是不可分割的，多个线程对同一变量进行原子操作时，不会引起数据竞争。\",\"CAS (Compare-and-Swap)：这是无锁编程的核心操作之一，它检查一个变量是否有特定的值，如果是，则将其更改为新值。这个操作是原子的，即在执行时不会被其他线程打断。\",\"内存序列模型：C++ 提供了一组内存序列模型（如 memory_order_relaxed、memory_order_acquire、memory_order_release 等），以控制并发操作的顺序性。\"]},\"88\":{\"h\":\"2. C++ 中的原子操作\",\"t\":[\"C++11 引入了 std::atomic 模板类，为实现无锁编程提供了基础设施。它支持以下操作：\",\"原子加载和存储\",\"原子递增和递减\",\"原子交换\",\"原子比较并交换（CAS）\"]},\"89\":{\"h\":\"3. 使用原子变量实现无锁队列\",\"t\":[\"下面是一个简单的无锁单生产者单消费者队列的实现示例：\",\"#include <atomic> #include <iostream> #include <thread> #include <vector> template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; // 使用 memory_order_release 确保更新操作一定在取值之后 head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } private: T* buffer; size_t capacity; std::atomic<size_t> head; std::atomic<size_t> tail; }; int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\"]},\"90\":{\"h\":\"4. 代码结构和作用\",\"t\":[\"类定义与构造函数\",\"template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; }\",\"LockFreeQueue 类是一个泛型队列，使用模板参数 T 来定义队列元素的类型。\",\"构造函数初始化队列的容量 capacity，并将 head 和 tail 指针初始化为 0。\",\"队列使用一个动态分配的数组 buffer 来存储元素。\",\"enqueue 方法\",\"bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; }\",\"enqueue 方法用于将一个元素插入队列。\",\"tail.load(std::memory_order_relaxed)：原子地加载当前的尾部指针 tail 的值。使用 memory_order_relaxed 是因为我们不需要同步其他内存操作，仅仅读取尾部的值。\",\"nextTail = (currentTail + 1) % capacity：计算插入元素后的尾部指针值，使用取模操作来实现循环队列。\",\"if (nextTail == head.load(std::memory_order_acquire))：检查队列是否已满。如果 nextTail 与头部指针 head 相等，说明队列已满。\",\"buffer[currentTail] = item：将元素存储在当前尾部指针所指向的位置。\",\"tail.store(nextTail, std::memory_order_release)：将新的尾部指针存储到 tail，并使用 memory_order_release 以确保插入操作完成后，其他线程能正确地看到更新的尾部指针。\",\"dequeue 方法\",\"bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; head.store((currentHead + 1) % capacity, std::memory_order_release); return true; }\",\"dequeue 方法用于从队列中取出一个元素。\",\"currentHead = head.load(std::memory_order_relaxed)：原子地加载当前的头部指针 head 的值。\",\"if (currentHead == tail.load(std::memory_order_acquire))：检查队列是否为空。如果 head 与 tail 相等，说明队列为空。\",\"item = buffer[currentHead]：将头部指针所指向的元素存储到 item 中。\",\"head.store((currentHead + 1) % capacity, std::memory_order_release)：更新头部指针，指向下一个元素的位置，并使用 memory_order_release 以确保取出操作完成后，其他线程能正确地看到更新的头部指针。\",\"主函数中的生产者和消费者\",\"int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\",\"在 main 函数中，创建了一个 LockFreeQueue 对象 queue，容量为 10。\",\"生产者线程 producer 向队列中插入元素，使用 while (!queue.enqueue(i)) 检查插入操作是否成功。如果队列已满，线程会持续等待直到成功插入。\",\"消费者线程 consumer 从队列中取出元素，使用 while (!queue.dequeue(item)) 检查取出操作是否成功。如果队列为空，线程会持续等待直到成功取出元素。\",\"两个线程同时运行，生产者插入数据，消费者取出数据，并输出相应的信息。\",\"最后，通过 join() 等待线程完成，确保主线程在两个子线程结束后才退出。\"]},\"91\":{\"h\":\"5. 内存顺序的选择\",\"t\":[\"memory_order_relaxed：用于没有数据依赖的地方，只要求操作是原子的，不需要同步内存顺序。适用于 load 和 store，如 tail.load(std::memory_order_relaxed)。\",\"memory_order_acquire：用于加载操作，以确保加载的结果及其后续的操作不会被重排序到 acquire 之前。适用于检查队列是否满或空，如 head.load(std::memory_order_acquire)。\",\"memory_order_release：用于存储操作，以确保在此之前的所有操作不会被重排序到 release 之后。适用于更新指针操作，如 tail.store(nextTail, std::memory_order_release)。\"]},\"92\":{\"c\":[\"面试题\"]},\"93\":{\"c\":[\"c++\",\"多线程\",\"线程同步\"]},\"94\":{\"h\":\"副业搞钱\"},\"95\":{\"c\":[\"副业\"]},\"96\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"副业\",{\"2\":{\"95\":1}}],[\"副业搞钱\",{\"0\":{\"94\":1}}],[\"适用于更新指针操作\",{\"1\":{\"91\":1}}],[\"适用于检查队列是否满或空\",{\"1\":{\"91\":1}}],[\"适用于\",{\"1\":{\"91\":1}}],[\"最后\",{\"1\":{\"90\":1}}],[\"最后一个节点被称为\",{\"1\":{\"18\":1}}],[\"生产者插入数据\",{\"1\":{\"90\":1}}],[\"生产者线程\",{\"1\":{\"90\":1}}],[\"生产者线程通知消费者线程有新数据可用\",{\"1\":{\"80\":1}}],[\"向队列中插入元素\",{\"1\":{\"90\":1}}],[\"容量为\",{\"1\":{\"90\":1}}],[\"容量扩展\",{\"1\":{\"25\":1}}],[\"主函数中的生产者和消费者\",{\"1\":{\"90\":1}}],[\"主要有两个原因\",{\"1\":{\"36\":1}}],[\"说明队列为空\",{\"1\":{\"90\":1}}],[\"说明队列已满\",{\"1\":{\"90\":1}}],[\"检查取出操作是否成功\",{\"1\":{\"90\":1}}],[\"检查插入操作是否成功\",{\"1\":{\"90\":1}}],[\"检查队列是否为空\",{\"1\":{\"90\":1}}],[\"检查队列是否已满\",{\"1\":{\"90\":1}}],[\"检查条件状态\",{\"1\":{\"80\":1}}],[\"仅仅读取尾部的值\",{\"1\":{\"90\":1}}],[\"方法用于从队列中取出一个元素\",{\"1\":{\"90\":1}}],[\"方法用于将一个元素插入队列\",{\"1\":{\"90\":1}}],[\"方法\",{\"1\":{\"90\":2}}],[\"来存储元素\",{\"1\":{\"90\":1}}],[\"来定义队列元素的类型\",{\"1\":{\"90\":1}}],[\"来实现列表\",{\"1\":{\"28\":1}}],[\"启动消费者线程\",{\"1\":{\"89\":1,\"90\":1}}],[\"启动生产者线程\",{\"1\":{\"89\":1,\"90\":1}}],[\"~lockfreequeue\",{\"1\":{\"89\":1,\"90\":1}}],[\"模板类\",{\"1\":{\"88\":1}}],[\"引入了\",{\"1\":{\"88\":1}}],[\"引用记录了下一个节点的内存地址\",{\"1\":{\"18\":1}}],[\"引用\",{\"1\":{\"18\":3}}],[\"多线程\",{\"2\":{\"93\":1}}],[\"多个线程对同一变量进行原子操作时\",{\"1\":{\"87\":1}}],[\"多进程\",{\"2\":{\"74\":1}}],[\"带来的性能开销和死锁风险\",{\"1\":{\"86\":1}}],[\"继续执行\",{\"1\":{\"85\":1}}],[\"倒数计数器\",{\"1\":{\"85\":1}}],[\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景\",{\"1\":{\"85\":1}}],[\"锁存器计数减少\",{\"1\":{\"85\":1}}],[\"锁存器内部维护一个倒数计数器\",{\"1\":{\"85\":1}}],[\"锁存器类似于屏障\",{\"1\":{\"85\":1}}],[\"锁存器\",{\"0\":{\"85\":1}}],[\"锁定\",{\"1\":{\"78\":1}}],[\"锁定或未锁定\",{\"1\":{\"78\":1}}],[\"表示需要完成的任务数量\",{\"1\":{\"85\":1}}],[\"表示所有线程都已到达屏障点\",{\"1\":{\"84\":1}}],[\"表示已到达屏障的线程数量\",{\"1\":{\"84\":1}}],[\"表示当前可用资源的数量\",{\"1\":{\"82\":1}}],[\"确保主线程在两个子线程结束后才退出\",{\"1\":{\"90\":1}}],[\"确保更新操作一定在取值之后\",{\"1\":{\"89\":1}}],[\"确保所有线程都到达某个同步点后才能继续执行\",{\"1\":{\"84\":1}}],[\"确保在不同平台上实现一致的原子操作行为\",{\"1\":{\"81\":1}}],[\"屏障适用于并行计算中需要同步多个线程的场景\",{\"1\":{\"84\":1}}],[\"屏障解除\",{\"1\":{\"84\":1}}],[\"屏障内部维护一个计数器\",{\"1\":{\"84\":1}}],[\"屏障用于同步一组线程\",{\"1\":{\"84\":1}}],[\"屏障\",{\"0\":{\"84\":1}}],[\"7\",{\"0\":{\"84\":1}}],[\"忙等待\",{\"1\":{\"83\":1}}],[\"自旋等待\",{\"1\":{\"83\":1}}],[\"自旋锁适用于锁定时间非常短的场景\",{\"1\":{\"83\":1}}],[\"自旋锁通常通过硬件的原子操作实现\",{\"1\":{\"83\":1}}],[\"自旋锁是一种忙等待锁\",{\"1\":{\"83\":1}}],[\"自旋锁\",{\"0\":{\"83\":1}}],[\"自动加锁和解锁\",{\"1\":{\"78\":1}}],[\"计算插入元素后的尾部指针值\",{\"1\":{\"90\":1}}],[\"计算机不仅会加载它\",{\"1\":{\"16\":1}}],[\"计数器加\",{\"1\":{\"82\":1}}],[\"计数器减\",{\"1\":{\"82\":1,\"84\":1,\"85\":1}}],[\"计数器初始值通常为资源的总量\",{\"1\":{\"82\":1}}],[\"计数器\",{\"1\":{\"82\":1,\"84\":1}}],[\"标志位等\",{\"1\":{\"81\":1}}],[\"硬件支持\",{\"1\":{\"81\":1}}],[\"原子地加载当前的头部指针\",{\"1\":{\"90\":1}}],[\"原子地加载当前的尾部指针\",{\"1\":{\"90\":1}}],[\"原子比较并交换\",{\"1\":{\"88\":1}}],[\"原子交换\",{\"1\":{\"88\":1}}],[\"原子递增和递减\",{\"1\":{\"88\":1}}],[\"原子加载和存储\",{\"1\":{\"88\":1}}],[\"原子操作是不可分割的\",{\"1\":{\"87\":1}}],[\"原子操作适用于需要高效并发访问的场景\",{\"1\":{\"81\":1}}],[\"原子操作直接操作共享变量\",{\"1\":{\"81\":1}}],[\"原子操作依赖于硬件提供的原子指令\",{\"1\":{\"81\":1}}],[\"原子操作通过硬件支持的指令集实现\",{\"1\":{\"81\":1}}],[\"原子操作\",{\"0\":{\"81\":1},\"1\":{\"81\":1,\"87\":1}}],[\"原先末尾的元素变得\",{\"1\":{\"12\":1}}],[\"消费者取出数据\",{\"1\":{\"90\":1}}],[\"消费者线程\",{\"1\":{\"90\":1}}],[\"消费者线程等待该通知\",{\"1\":{\"80\":1}}],[\"消费者模型等\",{\"1\":{\"82\":1}}],[\"消费者模型中\",{\"1\":{\"80\":1}}],[\"唤醒一个线程\",{\"1\":{\"82\":1}}],[\"唤醒一个或所有等待队列中的线程\",{\"1\":{\"80\":1}}],[\"唤醒所有等待的线程\",{\"1\":{\"80\":1}}],[\"变为\",{\"1\":{\"80\":1}}],[\"条件变量常用于线程之间的协调\",{\"1\":{\"80\":1}}],[\"条件变量与一个互斥量和一个条件状态相关联\",{\"1\":{\"80\":1}}],[\"条件变量用于线程之间的等待和通知机制\",{\"1\":{\"80\":1}}],[\"条件变量\",{\"0\":{\"80\":1}}],[\"写锁定\",{\"1\":{\"79\":1}}],[\"读锁定\",{\"1\":{\"79\":1}}],[\"读写锁包含两个计数器\",{\"1\":{\"79\":1}}],[\"读写锁允许多个线程同时读取\",{\"1\":{\"79\":1}}],[\"读写锁\",{\"0\":{\"79\":1}}],[\"另一个用于记录是否有写线程在等待\",{\"1\":{\"79\":1}}],[\"另一方面\",{\"1\":{\"36\":2}}],[\"guard\",{\"1\":{\"78\":1}}],[\"guard<std\",{\"1\":{\"78\":1,\"80\":1}}],[\"go\",{\"1\":{\"18\":1}}],[\"使其继续执行\",{\"1\":{\"82\":1}}],[\"使其尝试重新锁定互斥量\",{\"1\":{\"78\":1}}],[\"使用取模操作来实现循环队列\",{\"1\":{\"90\":1}}],[\"使用模板参数\",{\"1\":{\"90\":1}}],[\"使用原子变量实现无锁队列\",{\"0\":{\"89\":1}}],[\"使用场景\",{\"1\":{\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"使用\",{\"1\":{\"72\":2,\"89\":1,\"90\":3}}],[\"解锁\",{\"1\":{\"78\":1,\"79\":1,\"83\":1}}],[\"维护一个等待队列\",{\"1\":{\"78\":1,\"79\":1,\"80\":1}}],[\"具体实现步骤如下\",{\"1\":{\"78\":1}}],[\"具体来说\",{\"1\":{\"70\":1}}],[\"互斥量有一个内部状态\",{\"1\":{\"78\":1}}],[\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问\",{\"1\":{\"78\":1}}],[\"互斥量\",{\"0\":{\"78\":1}}],[\"unique\",{\"1\":{\"79\":1,\"80\":1}}],[\"unix\",{\"1\":{\"70\":2}}],[\"unlock\",{\"1\":{\"78\":1,\"79\":1,\"83\":2}}],[\"until\",{\"1\":{\"76\":2}}],[\"join\",{\"1\":{\"76\":2,\"78\":1,\"79\":4,\"80\":2,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":2,\"90\":3}}],[\"java\",{\"1\":{\"18\":1,\"28\":1,\"34\":1}}],[\"选择适当的方法管理子进程的生命周期\",{\"1\":{\"72\":1}}],[\"选取一个合理的数组初始容量\",{\"1\":{\"34\":1}}],[\"系列函数\",{\"1\":{\"72\":1}}],[\"系统管理的麻烦\",{\"1\":{\"71\":1}}],[\"系统\",{\"1\":{\"70\":1}}],[\"系统将其从内存中清除\",{\"1\":{\"68\":1}}],[\"系统将其从内存中移除\",{\"1\":{\"67\":1}}],[\"系统会申请一块新的内存\",{\"1\":{\"36\":1}}],[\"系统可以利用这些信息来优化数据结构的操作效率\",{\"1\":{\"16\":1}}],[\"孙子进程\",{\"1\":{\"72\":1}}],[\"孙子进程则由\",{\"1\":{\"72\":1}}],[\"创建了一个\",{\"1\":{\"90\":1}}],[\"创建一个孙子进程\",{\"1\":{\"72\":1}}],[\"创建一个子进程\",{\"1\":{\"72\":1}}],[\"创建型模式\",{\"1\":{\"44\":1}}],[\"采用\",{\"1\":{\"72\":1}}],[\"回收子进程的资源\",{\"1\":{\"72\":1}}],[\"接管\",{\"1\":{\"72\":2}}],[\"接口应尽量细化\",{\"1\":{\"45\":1}}],[\"接口隔离原则\",{\"1\":{\"45\":1}}],[\"注册\",{\"1\":{\"72\":1}}],[\"has\",{\"1\":{\"85\":1}}],[\"handler\",{\"1\":{\"72\":2}}],[\"h>\",{\"1\":{\"72\":3}}],[\"head\",{\"1\":{\"23\":5,\"24\":5,\"89\":5,\"90\":11,\"91\":1}}],[\"信号量适用于控制对资源的并发访问数量\",{\"1\":{\"82\":1}}],[\"信号量内部维护一个计数器\",{\"1\":{\"82\":1}}],[\"信号量是一种控制对共享资源访问的计数器\",{\"1\":{\"82\":1}}],[\"信号量\",{\"0\":{\"82\":1}}],[\"信号处理程序\",{\"1\":{\"72\":1}}],[\"信号处理子进程的结束\",{\"1\":{\"72\":1}}],[\"信号\",{\"1\":{\"72\":2}}],[\"父进程等待第一个子进程退出\",{\"1\":{\"72\":1}}],[\"父进程只需等待子进程的退出状态\",{\"1\":{\"72\":1}}],[\"父进程通过\",{\"1\":{\"72\":1}}],[\"父进程退出\",{\"1\":{\"72\":1}}],[\"父进程继续执行其任务\",{\"1\":{\"72\":1}}],[\"父进程可以在信号处理程序中调用\",{\"1\":{\"72\":1}}],[\"父进程会收到\",{\"1\":{\"72\":1}}],[\"父进程代码\",{\"1\":{\"72\":2}}],[\"父进程在适当的时机调用\",{\"1\":{\"72\":1}}],[\"及时调用\",{\"1\":{\"72\":1}}],[\"避免使用锁机制带来的开销\",{\"1\":{\"81\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"72\":1}}],[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态\",{\"1\":{\"72\":1}}],[\"避免运行时错误\",{\"1\":{\"45\":1}}],[\"虽然僵尸进程不会占用内存或\",{\"1\":{\"71\":1}}],[\"获取子进程的退出状态后\",{\"1\":{\"70\":1}}],[\"获取并返回随机元素\",{\"1\":{\"10\":1}}],[\"仍然保留在系统中\",{\"1\":{\"70\":1}}],[\"仍然指向\",{\"1\":{\"22\":1}}],[\"都会被操作系统回收\",{\"1\":{\"70\":1}}],[\"都是一个指针代表一个内存\",{\"1\":{\"59\":1}}],[\"文件描述符等\",{\"1\":{\"70\":1}}],[\"working\",{\"1\":{\"82\":1,\"83\":1}}],[\"worker\",{\"1\":{\"82\":2,\"83\":2,\"84\":2,\"85\":2}}],[\"writer\",{\"1\":{\"79\":3}}],[\"write\",{\"1\":{\"79\":1}}],[\"wnohang\",{\"1\":{\"72\":1}}],[\"waiting\",{\"1\":{\"84\":1}}],[\"waitpid\",{\"1\":{\"70\":2,\"72\":4}}],[\"wait\",{\"1\":{\"70\":2,\"72\":8,\"80\":2,\"82\":1,\"84\":1,\"85\":1}}],[\"while\",{\"1\":{\"24\":1,\"72\":1,\"83\":1,\"89\":2,\"90\":4}}],[\"子进程再\",{\"1\":{\"72\":1}}],[\"子进程继续执行\",{\"1\":{\"72\":1}}],[\"子进程被\",{\"1\":{\"72\":1}}],[\"子进程会被\",{\"1\":{\"72\":1}}],[\"子进程代码\",{\"1\":{\"72\":2}}],[\"子进程终止后\",{\"1\":{\"70\":1}}],[\"子类对象必须能够替换其父类对象且行为一致\",{\"1\":{\"45\":1}}],[\"或\",{\"1\":{\"70\":2,\"72\":4,\"80\":1,\"82\":2}}],[\"或类\",{\"1\":{\"70\":1}}],[\"或者由于其他更高优先级的进程需要\",{\"1\":{\"68\":1}}],[\"zombie\",{\"1\":{\"70\":1}}],[\"zfooei\",{\"1\":{\"61\":1}}],[\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的\",{\"1\":{\"72\":1}}],[\"僵尸进程的影响\",{\"0\":{\"71\":1}}],[\"僵尸进程的进程描述符才会被完全清除\",{\"1\":{\"70\":1}}],[\"僵尸进程\",{\"0\":{\"70\":1},\"1\":{\"70\":1}}],[\"状态转换示意图\",{\"0\":{\"69\":1}}],[\"被唤醒的线程重新获得互斥量\",{\"1\":{\"80\":1}}],[\"被释放给其他就绪进程\",{\"1\":{\"68\":1}}],[\"被mutable\",{\"1\":{\"62\":1}}],[\"时\",{\"1\":{\"68\":1,\"80\":1,\"82\":2}}],[\"时间片轮转调度算法是一种常见的\",{\"1\":{\"27\":1}}],[\"时间片轮转调度算法\",{\"1\":{\"27\":1}}],[\"时间下访问数组中的任意元素\",{\"1\":{\"23\":1}}],[\"时间复杂度确实是\",{\"1\":{\"36\":1}}],[\"时间复杂度为\",{\"1\":{\"21\":1,\"23\":1,\"32\":1}}],[\"时间复杂度高\",{\"1\":{\"12\":1}}],[\"时间内获取节点内存地址\",{\"1\":{\"36\":1}}],[\"时间内访问和更新元素\",{\"1\":{\"31\":1}}],[\"时间内访问任何元素\",{\"1\":{\"16\":1}}],[\"时间内随机访问数组中的任意一个元素\",{\"1\":{\"10\":1}}],[\"调度器选择一个就绪的进程并将其分配给\",{\"1\":{\"68\":1}}],[\"调度算法\",{\"1\":{\"27\":1}}],[\"就会进入就绪状态\",{\"1\":{\"68\":1}}],[\"就绪\",{\"1\":{\"67\":1,\"68\":4}}],[\"→\",{\"1\":{\"68\":6}}],[\"终止\",{\"1\":{\"67\":1,\"68\":1}}],[\"发生\",{\"1\":{\"67\":1}}],[\"完成或资源可用\",{\"1\":{\"68\":1}}],[\"完成\",{\"1\":{\"67\":1}}],[\"正在等待某个事件\",{\"1\":{\"67\":1}}],[\"阻塞的进程会被移回就绪队列\",{\"1\":{\"68\":1}}],[\"阻塞\",{\"1\":{\"67\":1,\"68\":2}}],[\"运行\",{\"1\":{\"67\":1,\"68\":4}}],[\"资源占用\",{\"1\":{\"71\":1}}],[\"资源可用\",{\"1\":{\"67\":1}}],[\"资源\",{\"1\":{\"67\":1}}],[\"新建\",{\"1\":{\"67\":1,\"68\":1}}],[\"进程通信\",{\"2\":{\"74\":1}}],[\"进程接管孤儿进程或采用\",{\"1\":{\"72\":1}}],[\"进程接管\",{\"1\":{\"72\":1}}],[\"进程会自动调用\",{\"1\":{\"72\":1}}],[\"进程\",{\"1\":{\"72\":3}}],[\"进程表项的数量是有限的\",{\"1\":{\"71\":1}}],[\"进程进入终止状态\",{\"1\":{\"68\":1}}],[\"进程进入阻塞状态\",{\"1\":{\"68\":1}}],[\"进程进入运行状态\",{\"1\":{\"68\":1}}],[\"进程在其生命周期内可以在不同状态之间进行转换\",{\"1\":{\"68\":1}}],[\"进程已完成执行或因某种原因被强制终止\",{\"1\":{\"67\":1}}],[\"进程已经被创建并准备好执行\",{\"1\":{\"67\":1}}],[\"进程无法继续执行\",{\"1\":{\"67\":1}}],[\"进程正在\",{\"1\":{\"67\":1}}],[\"进程正在被创建\",{\"1\":{\"67\":1}}],[\"进程的基本状态\",{\"0\":{\"67\":1}}],[\"进程状态之间的转换\",{\"0\":{\"68\":1}}],[\"进程状态\",{\"0\":{\"66\":1}}],[\"进程编程\",{\"0\":{\"65\":1},\"1\":{\"1\":1}}],[\"问题\",{\"1\":{\"61\":1}}],[\"语言一样的方式\",{\"1\":{\"61\":1}}],[\"保证在并发环境下操作的不可分割性\",{\"1\":{\"81\":1}}],[\"保证继承层次的正确性\",{\"1\":{\"45\":1}}],[\"保持与c\",{\"1\":{\"61\":1}}],[\"让c++\",{\"1\":{\"61\":1}}],[\"函数中\",{\"1\":{\"90\":1}}],[\"函数\",{\"1\":{\"72\":1}}],[\"函数回收子进程的退出状态信息\",{\"1\":{\"70\":1}}],[\"函数时会失败\",{\"1\":{\"61\":1}}],[\"函数名被修饰成\",{\"1\":{\"61\":1}}],[\"函数return\",{\"1\":{\"57\":1}}],[\"技术\",{\"1\":{\"61\":1,\"72\":2}}],[\"用于存储操作\",{\"1\":{\"91\":1}}],[\"用于加载操作\",{\"1\":{\"91\":1}}],[\"用于没有数据依赖的地方\",{\"1\":{\"91\":1}}],[\"用于保存等待条件的线程\",{\"1\":{\"80\":1}}],[\"用于保存等待的线程\",{\"1\":{\"79\":1}}],[\"用于保存等待锁的线程\",{\"1\":{\"78\":1}}],[\"用于函数穿参数\",{\"1\":{\"62\":1}}],[\"用于记录列表当前元素数量\",{\"1\":{\"34\":1}}],[\"用来定义常量和函数\",{\"1\":{\"60\":1}}],[\"宏没有类型安全检查\",{\"1\":{\"60\":1}}],[\"宏用于定义常量和简单的代码片段\",{\"1\":{\"60\":1}}],[\"宏与constexpr\",{\"0\":{\"60\":1}}],[\"区别\",{\"0\":{\"60\":1}}],[\"地址值+sizeof\",{\"1\":{\"59\":2}}],[\"三者做运算时有差异\",{\"1\":{\"59\":1}}],[\"析构函数\",{\"1\":{\"58\":2}}],[\"释放操作\",{\"1\":{\"82\":1}}],[\"释放对象的操作符\",{\"1\":{\"58\":1}}],[\"释放内存的基础上还会额外调用构造\",{\"1\":{\"58\":1}}],[\"释放内存\",{\"1\":{\"15\":1,\"22\":1}}],[\"类是一个泛型队列\",{\"1\":{\"90\":1}}],[\"类定义与构造函数\",{\"1\":{\"90\":1}}],[\"类成员或函数可以直接通过类名访问无需创建对象\",{\"1\":{\"57\":1}}],[\"类似于双向链表\",{\"1\":{\"27\":1}}],[\"延长变量的生命周期为整个程序的生命周期\",{\"1\":{\"57\":1}}],[\"限制作用范围\",{\"1\":{\"57\":1}}],[\"修饰除外\",{\"1\":{\"62\":1}}],[\"修饰成员函数表示函数体不会修改类成员\",{\"1\":{\"62\":1}}],[\"修饰局部变量\",{\"1\":{\"57\":1}}],[\"修饰全局变量或函数\",{\"1\":{\"57\":1}}],[\"修改\",{\"1\":{\"28\":1}}],[\"关键字的作用\",{\"0\":{\"57\":1,\"62\":1}}],[\"关注对象间通信\",{\"1\":{\"44\":1}}],[\"关注对象组合\",{\"1\":{\"44\":1}}],[\"关注对象创建\",{\"1\":{\"44\":1}}],[\"面试题\",{\"2\":{\"55\":1,\"63\":1,\"73\":1,\"92\":1}}],[\"面试集锦\",{\"0\":{\"54\":1}}],[\"事件模式\",{\"2\":{\"50\":1}}],[\"观察者模式\",{\"0\":{\"48\":1},\"2\":{\"50\":1}}],[\"观察上图\",{\"1\":{\"10\":1,\"18\":1}}],[\"细节应该依赖于抽象\",{\"1\":{\"45\":1}}],[\"抽象不应依赖于细节\",{\"1\":{\"45\":1}}],[\"二者都应该依赖于抽象\",{\"1\":{\"45\":1}}],[\"二分查找等都主要在数组上进行\",{\"1\":{\"17\":1}}],[\"高层模块不应依赖于低层模块\",{\"1\":{\"45\":1}}],[\"高级数据结构\",{\"1\":{\"27\":1}}],[\"依赖倒置原则\",{\"1\":{\"45\":1}}],[\"依次访问所有节点\",{\"1\":{\"20\":1}}],[\"里氏替换原则\",{\"1\":{\"45\":1}}],[\"里面的\",{\"1\":{\"36\":1}}],[\"减少读计数器\",{\"1\":{\"79\":1}}],[\"减少代码的复杂性\",{\"1\":{\"45\":1}}],[\"减少模块之间的耦合性\",{\"1\":{\"45\":1}}],[\"减少引入新\",{\"1\":{\"45\":1}}],[\"减少类的复杂性\",{\"1\":{\"45\":1}}],[\"允许添加新功能而无需修改现有代码\",{\"1\":{\"45\":1}}],[\"软件实体应对扩展开放\",{\"1\":{\"45\":1}}],[\"提供了一组内存序列模型\",{\"1\":{\"87\":1}}],[\"提供了对不同内存模型的支持\",{\"1\":{\"81\":1}}],[\"提供快速数据访问\",{\"1\":{\"35\":1}}],[\"提高系统的灵活性\",{\"1\":{\"45\":1}}],[\"提高系统的灵活性和可扩展性\",{\"1\":{\"45\":1}}],[\"提高代码的可维护性和可读性\",{\"1\":{\"45\":1}}],[\"目的是避免传统锁机制\",{\"1\":{\"86\":1}}],[\"目的\",{\"1\":{\"45\":5}}],[\"定义常量\",{\"1\":{\"62\":1}}],[\"定义\",{\"1\":{\"45\":5}}],[\"定量表示需要根据具体情况进行分析\",{\"1\":{\"36\":1}}],[\"策略模式\",{\"0\":{\"51\":1},\"1\":{\"44\":1},\"2\":{\"53\":1}}],[\"行为型模式\",{\"1\":{\"44\":1}}],[\"代码结构和作用\",{\"0\":{\"90\":1}}],[\"代码示例\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"代码的存在的link\",{\"1\":{\"61\":1}}],[\"代码编译时不使用name\",{\"1\":{\"61\":1}}],[\"代码link\",{\"1\":{\"61\":1}}],[\"代码如下所示\",{\"1\":{\"15\":1,\"24\":1}}],[\"代理模式\",{\"1\":{\"44\":1}}],[\"结构型模式\",{\"1\":{\"44\":1}}],[\"工厂模式\",{\"1\":{\"44\":1}}],[\"设计原则是指导代码设计的基本准则\",{\"1\":{\"45\":1}}],[\"设计原则\",{\"0\":{\"45\":1},\"2\":{\"47\":1}}],[\"设计模式是解决常见软件设计问题的通用解决方案\",{\"1\":{\"44\":1}}],[\"设计模式\",{\"0\":{\"44\":1},\"2\":{\"47\":1,\"50\":1,\"53\":1}}],[\"设计模式与设计原则\",{\"0\":{\"43\":1}}],[\"设为\",{\"1\":{\"36\":1}}],[\"架构设计\",{\"0\":{\"41\":1},\"2\":{\"42\":1,\"46\":1,\"49\":1,\"52\":1}}],[\"教程\",{\"2\":{\"40\":1}}],[\"基本概念\",{\"0\":{\"87\":1}}],[\"基本结构\",{\"1\":{\"78\":1,\"79\":1,\"80\":1}}],[\"基本的数据结构\",{\"0\":{\"2\":1}}],[\"基础\",{\"0\":{\"56\":1}}],[\"基础教程\",{\"0\":{\"39\":1}}],[\"会导致\",{\"1\":{\"36\":1}}],[\"会发现它们每个元素的\",{\"1\":{\"36\":1}}],[\"操作或等待某个事件发生\",{\"1\":{\"68\":1}}],[\"操作\",{\"1\":{\"36\":1,\"82\":6}}],[\"必要使用链表的情况主要是二叉树和图\",{\"1\":{\"36\":1}}],[\"一个类应只有一个引起其变化的原因\",{\"1\":{\"45\":1}}],[\"一个用于记录当前正在读取的线程数\",{\"1\":{\"79\":1}}],[\"一个用于后一个元素\",{\"1\":{\"36\":1}}],[\"一个用于前一个元素\",{\"1\":{\"36\":1}}],[\"一般情况下\",{\"1\":{\"36\":1}}],[\"一方面\",{\"1\":{\"36\":2}}],[\"memory\",{\"1\":{\"83\":2,\"87\":3,\"89\":7,\"90\":15,\"91\":6}}],[\"mtx\",{\"1\":{\"78\":2,\"79\":3,\"80\":3}}],[\"mutex>\",{\"1\":{\"78\":1,\"79\":3,\"80\":2}}],[\"mutex\",{\"0\":{\"78\":1,\"79\":1},\"1\":{\"78\":1,\"79\":1,\"80\":1}}],[\"main\",{\"1\":{\"72\":1,\"76\":2,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":1,\"90\":2}}],[\"mangling\",{\"1\":{\"61\":2}}],[\"malloc\",{\"1\":{\"58\":2}}],[\"m\",{\"1\":{\"36\":2}}],[\"个节点对象也分散存储在内存各处\",{\"1\":{\"36\":1}}],[\"个节点需要循环\",{\"1\":{\"23\":1}}],[\"个元素的地址是相连的\",{\"1\":{\"36\":1}}],[\"长度\",{\"1\":{\"36\":1}}],[\"长度不可变的性质会导致列表的实用性降低\",{\"1\":{\"28\":1}}],[\"长度不可变\",{\"1\":{\"16\":1,\"25\":1}}],[\"该示意图只是定性表示\",{\"1\":{\"36\":1}}],[\"浅蓝色的存储节点指针是占用一块内存地址吗\",{\"1\":{\"36\":1}}],[\"双向队列适合使用链表实现\",{\"1\":{\"36\":1}}],[\"双向链表的特性使得这种操作变得简单\",{\"1\":{\"27\":1}}],[\"双向链表的节点定义同时包含指向后继节点\",{\"1\":{\"26\":1}}],[\"双向链表常用于需要快速查找前一个和后一个元素的场景\",{\"1\":{\"27\":1}}],[\"双向链表节点结构体\",{\"1\":{\"26\":1}}],[\"双向链表更具灵活性\",{\"1\":{\"26\":1}}],[\"双向链表记录了两个方向的引用\",{\"1\":{\"26\":1}}],[\"双向链表\",{\"1\":{\"26\":1,\"35\":1}}],[\"增删的优势可以在其他应用上得到体现\",{\"1\":{\"36\":1}}],[\"再删除元素\",{\"1\":{\"36\":1}}],[\"再将当前数组的所有元素依次移动至新数组\",{\"1\":{\"34\":1}}],[\"那为什么时间复杂度不是\",{\"1\":{\"36\":1}}],[\"那么\",{\"1\":{\"36\":1}}],[\"那么它会影响后继节点的内存回收\",{\"1\":{\"36\":1}}],[\"那么可以用数组存储\",{\"1\":{\"17\":1}}],[\"那么多余的空间就被浪费了\",{\"1\":{\"16\":1}}],[\"逻辑更加清晰\",{\"1\":{\"36\":1}}],[\"断开更加安全\",{\"1\":{\"36\":1}}],[\"不需要同步内存顺序\",{\"1\":{\"91\":1}}],[\"不需要加锁解锁\",{\"1\":{\"81\":1}}],[\"不应强迫一个类依赖于它不需要的接口\",{\"1\":{\"45\":1}}],[\"不会引起数据竞争\",{\"1\":{\"87\":1}}],[\"不会\",{\"1\":{\"36\":1}}],[\"不同类型的节点值占用的空间是不同的\",{\"1\":{\"36\":1}}],[\"不断开没有关系\",{\"1\":{\"36\":1}}],[\"不修改\",{\"1\":{\"36\":1}}],[\"做题\",{\"1\":{\"36\":1}}],[\"已经实现了双向链表\",{\"1\":{\"36\":1}}],[\"已经从链表中删除了\",{\"1\":{\"36\":1}}],[\"已经不再属于该链表了\",{\"1\":{\"22\":1}}],[\"从队列中取出元素\",{\"1\":{\"90\":1}}],[\"从标准库的角度看\",{\"1\":{\"36\":1}}],[\"从数据结构与算法\",{\"1\":{\"36\":1}}],[\"从头节点遍历到尾节点已经不会遇到\",{\"1\":{\"36\":1}}],[\"从该链表的角度看\",{\"1\":{\"36\":1}}],[\"从而防止僵尸进程的产生\",{\"1\":{\"72\":1}}],[\"从而导致的进程状态\",{\"1\":{\"70\":1}}],[\"从而导致以下不同点\",{\"1\":{\"36\":1}}],[\"从而访问到对应的节点\",{\"1\":{\"36\":1}}],[\"从而难以选择合适的列表长度\",{\"1\":{\"28\":1}}],[\"从而借助高速缓存来提升后续操作的执行速度\",{\"1\":{\"16\":1}}],[\"从而无法安全地扩展数组容量\",{\"1\":{\"15\":1}}],[\"从而直接访问该元素\",{\"1\":{\"10\":1}}],[\"呢\",{\"1\":{\"36\":2}}],[\"后使父进程退出\",{\"1\":{\"72\":1}}],[\"后变量不会释放\",{\"1\":{\"57\":1}}],[\"后\",{\"1\":{\"36\":2}}],[\"元素索引\",{\"1\":{\"36\":1}}],[\"元素内存地址\",{\"1\":{\"36\":1}}],[\"元素长度\",{\"1\":{\"36\":2}}],[\"元素占用内存多\",{\"1\":{\"25\":1}}],[\"元素占用内存少\",{\"1\":{\"25\":1}}],[\"8\",{\"0\":{\"85\":1},\"1\":{\"36\":2}}],[\"字节或\",{\"1\":{\"36\":1}}],[\"字节\",{\"1\":{\"36\":3}}],[\"单一职责原则\",{\"1\":{\"45\":1}}],[\"单个元素分别占用\",{\"1\":{\"36\":1}}],[\"单向链表通常用于实现栈\",{\"1\":{\"27\":1}}],[\"单向链表的节点包含值和指向下一节点的引用两项数据\",{\"1\":{\"26\":1}}],[\"单向链表\",{\"1\":{\"26\":1}}],[\"两个线程同时运行\",{\"1\":{\"90\":1}}],[\"两种类型\",{\"1\":{\"36\":1}}],[\"两者的特点呈现出互补的特性\",{\"1\":{\"35\":1}}],[\"连接\",{\"1\":{\"36\":1}}],[\"连续空间存储和分散空间存储\",{\"1\":{\"35\":1}}],[\"连续空间存储是一把双刃剑\",{\"1\":{\"16\":1}}],[\"连续内存空间\",{\"1\":{\"25\":1}}],[\"灵活性\",{\"1\":{\"36\":1}}],[\"大量僵尸进程可能会让系统管理者难以管理和监控系统状态\",{\"1\":{\"71\":1}}],[\"大多为\",{\"1\":{\"36\":1}}],[\"大多数编程语言会将数组元素初始化为\",{\"1\":{\"9\":1}}],[\"大小限制\",{\"1\":{\"36\":1}}],[\"更新头部指针\",{\"1\":{\"90\":1}}],[\"更新元素\",{\"1\":{\"31\":1}}],[\"更占用空间\",{\"1\":{\"36\":1}}],[\"更容易碎片化\",{\"1\":{\"36\":1}}],[\"栈和队列往往会使用编程语言提供的\",{\"1\":{\"36\":1}}],[\"栈和堆具有各自的特点\",{\"1\":{\"36\":1}}],[\"栈上的数组的大小需要在编译时确定\",{\"1\":{\"36\":1}}],[\"栈内存相对较小\",{\"1\":{\"36\":1}}],[\"栈是一块较小的内存\",{\"1\":{\"36\":1}}],[\"栈与队列\",{\"1\":{\"27\":1}}],[\"然后子进程立即退出\",{\"1\":{\"72\":1}}],[\"然后把原数组元素依次复制到新数组\",{\"1\":{\"15\":1}}],[\"然而\",{\"1\":{\"36\":3}}],[\"queue\",{\"1\":{\"36\":1,\"89\":5,\"90\":8}}],[\"q\",{\"0\":{\"36\":1},\"1\":{\"36\":10}}],[\"应根据具体需求和场景做出恰当选择\",{\"1\":{\"35\":1}}],[\"应被替换为\",{\"1\":{\"18\":1}}],[\"显著提升程序的执行效率\",{\"1\":{\"35\":1}}],[\"预取机制以及空间局部性和时间局部性等数据加载机制\",{\"1\":{\"35\":1}}],[\"缓存不友好\",{\"1\":{\"36\":1}}],[\"缓存通过缓存行\",{\"1\":{\"35\":1}}],[\"缓存局部性\",{\"1\":{\"16\":1}}],[\"同时可以灵活调整长度\",{\"1\":{\"35\":1}}],[\"同理\",{\"1\":{\"12\":1}}],[\"通知\",{\"1\":{\"80\":1}}],[\"通常用布尔值或整数表示\",{\"1\":{\"78\":1}}],[\"通常比\",{\"1\":{\"36\":1}}],[\"通常情况下这\",{\"1\":{\"36\":1}}],[\"通常基于动态数组实现\",{\"1\":{\"35\":1}}],[\"通过\",{\"1\":{\"90\":1}}],[\"通过及时调用\",{\"1\":{\"72\":1}}],[\"通过多个特定接口来代替单一的总接口\",{\"1\":{\"45\":1}}],[\"通过抽象和接口\",{\"1\":{\"45\":1}}],[\"通过索引遍历列表\",{\"1\":{\"33\":1}}],[\"通过索引遍历数组\",{\"1\":{\"13\":1}}],[\"通过引用指向\",{\"1\":{\"20\":1}}],[\"通过它可以从当前节点访问到下一个节点\",{\"1\":{\"18\":1}}],[\"占用内存较多\",{\"1\":{\"35\":1}}],[\"占用内存较少\",{\"1\":{\"35\":1}}],[\"实现生产者\",{\"1\":{\"82\":1}}],[\"实现原理\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"实现的基础\",{\"1\":{\"58\":1}}],[\"实现高效的节点插入与删除\",{\"1\":{\"35\":1}}],[\"实际上\",{\"1\":{\"28\":1}}],[\"且值相同\",{\"1\":{\"59\":1}}],[\"且可以灵活调整长度\",{\"1\":{\"35\":1}}],[\"且初始化后长度不可变\",{\"1\":{\"35\":1}}],[\"且元素类型相同\",{\"1\":{\"16\":1}}],[\"分为计数信号量和二进制信号量\",{\"1\":{\"82\":1}}],[\"分配了必要的资源后\",{\"1\":{\"68\":1}}],[\"分配由编译器自动完成\",{\"1\":{\"36\":1}}],[\"分配和释放效率\",{\"1\":{\"36\":1}}],[\"分别代表数据在计算机内存中的两种存储方式\",{\"1\":{\"35\":1}}],[\"分散内存空间\",{\"1\":{\"25\":1}}],[\"重点回顾\",{\"0\":{\"35\":1}}],[\"倍\",{\"1\":{\"34\":1}}],[\"先根据扩容倍数创建一个更大的数组\",{\"1\":{\"34\":1}}],[\"根据此变量\",{\"1\":{\"34\":1}}],[\"根据索引实现随机抽样\",{\"1\":{\"17\":1}}],[\"声明一个变量\",{\"1\":{\"34\":1}}],[\"作为初始容量\",{\"1\":{\"34\":1}}],[\"初始容量\",{\"1\":{\"34\":1}}],[\"初始化列表\",{\"0\":{\"30\":1},\"1\":{\"30\":1,\"36\":1}}],[\"初始化各个节点\",{\"1\":{\"20\":1}}],[\"初始化完成后\",{\"1\":{\"20\":1}}],[\"初始化链表\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"初始化一个扩展长度后的数组\",{\"1\":{\"15\":1}}],[\"初始化数组\",{\"0\":{\"9\":1},\"1\":{\"9\":1}}],[\"包含退出状态信息等\",{\"1\":{\"70\":1}}],[\"包含元素\",{\"1\":{\"20\":1}}],[\"包括以下三个重点设计\",{\"1\":{\"34\":1}}],[\"感兴趣的读者可以查阅源码进行学习\",{\"1\":{\"34\":1}}],[\"各个节点可以存储不同类型的数据\",{\"1\":{\"36\":1}}],[\"各个节点通过\",{\"1\":{\"18\":1}}],[\"各个参数的设定也非常考究\",{\"1\":{\"34\":1}}],[\"许多编程语言内置了列表\",{\"1\":{\"34\":1}}],[\"许多编程语言中的标准库提供的列表是基于动态数组实现的\",{\"1\":{\"28\":1}}],[\"直到锁可用为止\",{\"1\":{\"83\":1}}],[\"直到互斥量被解锁\",{\"1\":{\"78\":1}}],[\"直接遍历列表元素\",{\"1\":{\"33\":1}}],[\"直至找到目标节点\",{\"1\":{\"23\":1}}],[\"与头部指针\",{\"1\":{\"90\":1}}],[\"与\",{\"0\":{\"59\":1},\"1\":{\"59\":1,\"90\":1}}],[\"与许多语言不同\",{\"1\":{\"36\":1}}],[\"与数组一样\",{\"1\":{\"33\":1}}],[\"与单向链表相比\",{\"1\":{\"26\":1}}],[\"6\",{\"0\":{\"62\":1,\"83\":1},\"1\":{\"32\":2}}],[\"清空列表\",{\"1\":{\"32\":1}}],[\"效率很高\",{\"1\":{\"31\":1}}],[\"需要持有相关的互斥量\",{\"1\":{\"80\":1}}],[\"需要手动释放空间\",{\"1\":{\"9\":1}}],[\"需注意\",{\"1\":{\"30\":1}}],[\"有初始值\",{\"1\":{\"30\":2}}],[\"视为等同的概念\",{\"1\":{\"28\":1}}],[\"视频播放器中\",{\"1\":{\"27\":1}}],[\"dequeue\",{\"1\":{\"89\":2,\"90\":5}}],[\"delete是c++语言标准库提供的一组用于动态创建\",{\"1\":{\"58\":1}}],[\"delete与malloc\",{\"0\":{\"58\":1}}],[\"delete\",{\"1\":{\"15\":1,\"22\":1,\"58\":1,\"89\":1,\"90\":1}}],[\"d\",{\"1\":{\"79\":2}}],[\"data\",{\"1\":{\"79\":3}}],[\"down\",{\"1\":{\"85\":1}}],[\"do\",{\"1\":{\"76\":2}}],[\"double\",{\"1\":{\"36\":2,\"72\":2}}],[\"dip\",{\"1\":{\"45\":1}}],[\"dynamic\",{\"1\":{\"28\":1}}],[\"动态数组\",{\"1\":{\"28\":2}}],[\"为实现无锁编程提供了基础设施\",{\"1\":{\"88\":1}}],[\"为支持函数重载引入了name\",{\"1\":{\"61\":1}}],[\"为数组的指针\",{\"1\":{\"59\":1}}],[\"为数组名指向首元素地址即与\",{\"1\":{\"59\":1}}],[\"为数组长度\",{\"1\":{\"12\":1}}],[\"为了防止频繁扩容\",{\"1\":{\"36\":1}}],[\"为了加深对列表工作原理的理解\",{\"1\":{\"34\":1}}],[\"为什么数组要求相同类型的元素\",{\"1\":{\"36\":1}}],[\"为\",{\"1\":{\"35\":1,\"72\":1}}],[\"为解决此问题\",{\"1\":{\"28\":1}}],[\"并输出相应的信息\",{\"1\":{\"90\":1}}],[\"并使用\",{\"1\":{\"90\":2}}],[\"并释放互斥量\",{\"1\":{\"80\":1}}],[\"并将\",{\"1\":{\"90\":1}}],[\"并将互斥量状态设置为锁定\",{\"1\":{\"78\":1}}],[\"并将原列表的所有元素搬运过去\",{\"1\":{\"36\":1}}],[\"并且这些数字的内存地址无须连续\",{\"1\":{\"36\":1}}],[\"并且可以在程序运行过程中进行动态扩容\",{\"1\":{\"28\":1}}],[\"并且可以灵活动态扩容\",{\"1\":{\"28\":1}}],[\"并不是连续的\",{\"1\":{\"36\":1}}],[\"并随着元素插入和删除实时更新\",{\"1\":{\"34\":1}}],[\"并生成一个随机序列\",{\"1\":{\"17\":1}}],[\"添加\",{\"1\":{\"28\":1}}],[\"添加元素\",{\"1\":{\"25\":1}}],[\"支持元素访问\",{\"1\":{\"28\":1}}],[\"支持随机访问\",{\"1\":{\"16\":1}}],[\"以确保在此之前的所有操作不会被重排序到\",{\"1\":{\"91\":1}}],[\"以确保在没有锁的情况下实现线程安全\",{\"1\":{\"86\":1}}],[\"以确保加载的结果及其后续的操作不会被重排序到\",{\"1\":{\"91\":1}}],[\"以确保取出操作完成后\",{\"1\":{\"90\":1}}],[\"以确保插入操作完成后\",{\"1\":{\"90\":1}}],[\"以控制并发操作的顺序性\",{\"1\":{\"87\":1}}],[\"以回收子进程的资源\",{\"1\":{\"72\":1}}],[\"以获取并处理子进程的退出状态\",{\"1\":{\"72\":1}}],[\"以下是几种常用的方法\",{\"1\":{\"72\":1}}],[\"以下是常见的状态转换路径\",{\"1\":{\"68\":1}}],[\"以便实现无缝播放\",{\"1\":{\"27\":1}}],[\"以及判断是否需要扩容\",{\"1\":{\"34\":1}}],[\"以及支持快速添加和删除节点\",{\"1\":{\"27\":1}}],[\"以及之后的所有元素向后移动一位\",{\"1\":{\"11\":1}}],[\"算法中\",{\"1\":{\"27\":1}}],[\"算法\",{\"1\":{\"27\":1}}],[\"latch\",{\"0\":{\"85\":1},\"1\":{\"85\":2}}],[\"load\",{\"1\":{\"89\":4,\"90\":8,\"91\":3}}],[\"lockfreequeue<int>\",{\"1\":{\"89\":1,\"90\":1}}],[\"lockfreequeue\",{\"1\":{\"89\":2,\"90\":4}}],[\"lock<std\",{\"1\":{\"79\":2,\"80\":1}}],[\"lock\",{\"1\":{\"78\":2,\"79\":4,\"80\":4,\"83\":2,\"86\":1}}],[\"long\",{\"1\":{\"36\":2}}],[\"lsp\",{\"1\":{\"45\":1}}],[\"lru\",{\"1\":{\"27\":2}}],[\"linux\",{\"1\":{\"70\":1}}],[\"linked\",{\"1\":{\"18\":1}}],[\"listnode\",{\"1\":{\"18\":4,\"20\":10,\"21\":3,\"22\":3,\"23\":2,\"24\":1,\"26\":4}}],[\"list\",{\"1\":{\"18\":1,\"28\":3,\"36\":3}}],[\"浏览器需要知道用户访问过的前一个和后一个网页\",{\"1\":{\"27\":1}}],[\"浏览器历史\",{\"1\":{\"27\":1}}],[\"树中\",{\"1\":{\"27\":1}}],[\"buffer\",{\"1\":{\"89\":5,\"90\":7}}],[\"bug\",{\"1\":{\"45\":1}}],[\"bool\",{\"1\":{\"80\":1,\"89\":2,\"90\":2}}],[\"barrier\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"bar\",{\"1\":{\"76\":5}}],[\"back\",{\"1\":{\"32\":5,\"79\":1,\"84\":1,\"85\":1}}],[\"blocked\",{\"1\":{\"67\":1}}],[\"begin\",{\"1\":{\"32\":2}}],[\"b\",{\"1\":{\"27\":1}}],[\"邻接表是表示图的一种常用方式\",{\"1\":{\"27\":1}}],[\"所有等待的线程被唤醒\",{\"1\":{\"85\":1}}],[\"所有等待的线程继续执行\",{\"1\":{\"84\":1}}],[\"所有冲突的元素都会被放到一个链表中\",{\"1\":{\"27\":1}}],[\"所以\",{\"1\":{\"36\":1}}],[\"所以上述查找操作被称为\",{\"1\":{\"14\":1}}],[\"所以我们无须特意去修改它\",{\"1\":{\"12\":1}}],[\"链式地址是解决哈希冲突的主流方案之一\",{\"1\":{\"27\":1}}],[\"链表由节点组成\",{\"1\":{\"36\":1}}],[\"链表通过更改引用\",{\"1\":{\"35\":1}}],[\"链表天然可以看作一个列表\",{\"1\":{\"28\":1}}],[\"链表中的每个元素都代表与该顶点相连的其他顶点\",{\"1\":{\"27\":1}}],[\"链表典型应用\",{\"0\":{\"27\":1}}],[\"链表则不然\",{\"1\":{\"23\":1}}],[\"链表删除节点\",{\"1\":{\"22\":1}}],[\"链表插入节点示例\",{\"1\":{\"21\":1}}],[\"链表常用操作\",{\"0\":{\"19\":1}}],[\"链表比数组占用更多的内存空间\",{\"1\":{\"18\":1}}],[\"链表节点结构体\",{\"1\":{\"18\":1}}],[\"链表节点\",{\"1\":{\"18\":1}}],[\"链表的\",{\"1\":{\"36\":1}}],[\"链表的首个节点被称为\",{\"1\":{\"18\":1}}],[\"链表的组成单位是节点\",{\"1\":{\"18\":1}}],[\"链表的设计使得各个节点可以分散存储在内存各处\",{\"1\":{\"18\":1}}],[\"链表定义与存储方式\",{\"1\":{\"18\":1,\"36\":1}}],[\"链表\",{\"0\":{\"18\":1,\"25\":1},\"1\":{\"18\":1,\"25\":1},\"2\":{\"38\":1}}],[\"上执行代码\",{\"1\":{\"67\":1}}],[\"上一个节点\",{\"1\":{\"26\":1}}],[\"上述\",{\"1\":{\"18\":1}}],[\"任意节点都可以视作头节点\",{\"1\":{\"26\":1}}],[\"环形链表常用于需要周期性操作的场景\",{\"1\":{\"27\":1}}],[\"环形链表\",{\"1\":{\"26\":1,\"35\":1}}],[\"即在执行时不会被其他线程打断\",{\"1\":{\"87\":1}}],[\"即进程描述符\",{\"1\":{\"71\":1}}],[\"即进程控制块\",{\"1\":{\"70\":1}}],[\"即被修饰变量不可以被修改\",{\"1\":{\"62\":1}}],[\"即指向第二个元素a\",{\"1\":{\"59\":1}}],[\"即一个类只负责一项职责\",{\"1\":{\"45\":1}}],[\"即是本文描述的\",{\"1\":{\"30\":1}}],[\"即前面介绍的普通链表\",{\"1\":{\"26\":1}}],[\"即可\",{\"1\":{\"21\":1,\"22\":1}}],[\"常见的链表类型包括单向链表\",{\"1\":{\"35\":1}}],[\"常见的链表类型包括三种\",{\"1\":{\"26\":1}}],[\"常见链表种类\",{\"1\":{\"26\":1}}],[\"常见链表类型\",{\"0\":{\"26\":1}}],[\"可能会导致系统无法创建新进程\",{\"1\":{\"71\":1}}],[\"可以有效避免僵尸进程的产生\",{\"1\":{\"72\":1}}],[\"可以通过调用\",{\"1\":{\"72\":1}}],[\"可以取代宏的功能\",{\"1\":{\"60\":1}}],[\"可以在代码中动态分配\",{\"1\":{\"36\":1}}],[\"可以朝两个方向遍历链表\",{\"1\":{\"26\":1}}],[\"可以使用数组作为查找表\",{\"1\":{\"17\":1}}],[\"可灵活扩展\",{\"1\":{\"25\":1}}],[\"由于数据不是连续存放的\",{\"1\":{\"36\":1}}],[\"由于数组具有更高的缓存命中率\",{\"1\":{\"35\":1}}],[\"由于数组的长度不可变\",{\"1\":{\"12\":1}}],[\"由于数组的长度是固定的\",{\"1\":{\"11\":1}}],[\"由于每个元素需要两个额外的指针\",{\"1\":{\"36\":1}}],[\"由于它们采用两种相反的存储策略\",{\"1\":{\"25\":1}}],[\"下面是一个简单的无锁单生产者单消费者队列的实现示例\",{\"1\":{\"89\":1}}],[\"下一个节点\",{\"1\":{\"26\":1}}],[\"下表总结了数组和链表的各项特点并对比了操作效率\",{\"1\":{\"25\":1}}],[\"下图展示了数组的主要概念和存储方式\",{\"1\":{\"7\":1}}],[\"此时子进程的父进程是\",{\"1\":{\"72\":1}}],[\"此时节点\",{\"1\":{\"36\":1}}],[\"此时就不能用以下公式计算偏移量了\",{\"1\":{\"36\":1}}],[\"此时链表的灵活性优势就体现出来了\",{\"1\":{\"18\":1}}],[\"此过程也属于线性查找\",{\"1\":{\"24\":1}}],[\"输出该节点在链表中的索引\",{\"1\":{\"24\":1}}],[\"遍历列表\",{\"0\":{\"33\":1}}],[\"遍历链表\",{\"1\":{\"24\":1}}],[\"遍历数组\",{\"0\":{\"13\":1},\"1\":{\"13\":1}}],[\"轮\",{\"1\":{\"23\":1}}],[\"也会出现很多空位\",{\"1\":{\"36\":1}}],[\"也就是说\",{\"1\":{\"23\":1}}],[\"也可以\",{\"1\":{\"36\":1}}],[\"也可以直接遍历各元素\",{\"1\":{\"33\":1}}],[\"也可以直接遍历获取数组中的每个元素\",{\"1\":{\"13\":1}}],[\"也可能会使用环形链表\",{\"1\":{\"27\":1}}],[\"也可用于实现各种复杂数据结构\",{\"1\":{\"17\":1}}],[\"逐个向后遍历\",{\"1\":{\"23\":1}}],[\"程序运行时\",{\"1\":{\"35\":1}}],[\"程序需要从头节点出发\",{\"1\":{\"23\":1}}],[\"程序难以保证数组之后的内存空间是可用的\",{\"1\":{\"15\":1}}],[\"访问索引\",{\"1\":{\"31\":1}}],[\"访问链表中索引为\",{\"1\":{\"23\":1}}],[\"访问链表的第\",{\"1\":{\"23\":1}}],[\"访问节点\",{\"0\":{\"23\":1}}],[\"访问元素\",{\"0\":{\"10\":1,\"31\":1},\"1\":{\"25\":1,\"31\":1}}],[\"尽管在删除操作完成后节点\",{\"1\":{\"22\":1}}],[\"只要求操作是原子的\",{\"1\":{\"91\":1}}],[\"只要保证程序的逻辑是正确的就行\",{\"1\":{\"36\":1}}],[\"只可以在当前文件访问\",{\"1\":{\"57\":1}}],[\"只需改变一个节点的引用\",{\"1\":{\"22\":1}}],[\"只用前面一部分\",{\"1\":{\"12\":1}}],[\"point\",{\"1\":{\"84\":2,\"85\":4}}],[\"public\",{\"1\":{\"83\":1,\"89\":1,\"90\":1}}],[\"push\",{\"1\":{\"32\":5,\"79\":1}}],[\"pauses\",{\"1\":{\"76\":2}}],[\"pause\",{\"1\":{\"72\":1}}],[\"pid2\",{\"1\":{\"72\":2}}],[\"pid\",{\"1\":{\"72\":14}}],[\"private\",{\"1\":{\"89\":1}}],[\"print\",{\"1\":{\"78\":2,\"80\":2}}],[\"produced\",{\"1\":{\"89\":1,\"90\":1}}],[\"producer\",{\"1\":{\"89\":2,\"90\":3}}],[\"programming\",{\"1\":{\"86\":1}}],[\"proceeding\",{\"1\":{\"84\":1,\"85\":1}}],[\"process\",{\"1\":{\"70\":1}}],[\"prev\",{\"1\":{\"26\":2}}],[\"p\",{\"1\":{\"21\":5,\"22\":7,\"36\":6,\"82\":3}}],[\"python\",{\"1\":{\"18\":1,\"28\":1,\"34\":1,\"36\":2}}],[\"之前\",{\"1\":{\"91\":1}}],[\"之间插入一个新节点\",{\"1\":{\"21\":1}}],[\"之后\",{\"1\":{\"91\":1}}],[\"之后插入节点\",{\"1\":{\"21\":1}}],[\"之后的首个节点\",{\"1\":{\"22\":1}}],[\"之后的所有元素向前移动一位\",{\"1\":{\"12\":1}}],[\"之后的元素都向前移动一位\",{\"1\":{\"12\":1}}],[\"之后再把元素赋值给该索引\",{\"1\":{\"11\":1}}],[\"假如把列表元素换成链表节点\",{\"1\":{\"36\":1}}],[\"假如我们想实现字符到\",{\"1\":{\"17\":1}}],[\"假设有数组\",{\"0\":{\"59\":1}}],[\"假设被删除节点未被正常回收\",{\"1\":{\"36\":1}}],[\"假设我们想在相邻的两个节点\",{\"1\":{\"21\":1}}],[\"比如\",{\"1\":{\"36\":2}}],[\"比如在音频\",{\"1\":{\"27\":1}}],[\"比如在红黑树\",{\"1\":{\"27\":1}}],[\"比如操作系统的资源调度\",{\"1\":{\"27\":1}}],[\"比如以上代码中的链表可记作链表\",{\"1\":{\"20\":1}}],[\"比如数组\",{\"1\":{\"20\":1}}],[\"而不会阻塞或挂起\",{\"1\":{\"83\":1}}],[\"而constexpr有\",{\"1\":{\"60\":1}}],[\"而非链表\",{\"1\":{\"36\":1}}],[\"而非节点本身\",{\"1\":{\"36\":1}}],[\"而只在必要时才使用链表\",{\"1\":{\"36\":1}}],[\"而是对数字的引用\",{\"1\":{\"36\":1}}],[\"而是分别跟\",{\"1\":{\"36\":1}}],[\"而在链表中却没有强调相同类型呢\",{\"1\":{\"36\":1}}],[\"而堆上的数组的大小可以在运行时动态确定\",{\"1\":{\"36\":1}}],[\"而堆内存相对更大\",{\"1\":{\"36\":1}}],[\"而链表则在内存使用上更加灵活\",{\"1\":{\"35\":1}}],[\"而链表是由多个独立的节点对象组成的\",{\"1\":{\"20\":1}}],[\"而当数组非常大时\",{\"1\":{\"18\":1}}],[\"等待线程完成\",{\"1\":{\"90\":1}}],[\"等待所有线程到达锁存器\",{\"1\":{\"85\":1}}],[\"等待所有线程到达屏障点\",{\"1\":{\"84\":1}}],[\"等待所有已终止的子进程\",{\"1\":{\"72\":1}}],[\"等待机制\",{\"1\":{\"84\":1,\"85\":1}}],[\"等待操作\",{\"1\":{\"82\":1}}],[\"等待条件变量的通知\",{\"1\":{\"80\":1}}],[\"等待\",{\"1\":{\"80\":2,\"89\":2,\"90\":2}}],[\"等待信号\",{\"1\":{\"72\":1}}],[\"等待子进程结束并回收资源\",{\"1\":{\"72\":1}}],[\"等待再次被调度\",{\"1\":{\"68\":1}}],[\"等待资源释放\",{\"1\":{\"82\":1}}],[\"等待资源\",{\"1\":{\"68\":1}}],[\"等待下一次调度\",{\"1\":{\"68\":1}}],[\"等待调度器的调度\",{\"1\":{\"68\":1}}],[\"等待被调度器分配\",{\"1\":{\"67\":1}}],[\"等\",{\"1\":{\"20\":1,\"28\":1,\"34\":1,\"36\":1,\"81\":1,\"83\":1,\"87\":1}}],[\"等支持指针的语言中\",{\"1\":{\"18\":1}}],[\"构建节点之间的引用\",{\"1\":{\"20\":1}}],[\"构造函数初始化队列的容量\",{\"1\":{\"90\":1}}],[\"构造函数\",{\"1\":{\"18\":1,\"26\":1,\"58\":1}}],[\"第一个子进程退出\",{\"1\":{\"72\":1}}],[\"第一个子进程\",{\"1\":{\"72\":1}}],[\"第一步是初始化各个节点对象\",{\"1\":{\"20\":1}}],[\"第二步是构建节点之间的引用关系\",{\"1\":{\"20\":1}}],[\"建立链表分为两步\",{\"1\":{\"20\":1}}],[\"x\",{\"1\":{\"18\":2,\"26\":2,\"76\":1}}],[\"指向下一个元素的位置\",{\"1\":{\"90\":1}}],[\"指向下一节点的指针\",{\"1\":{\"18\":1}}],[\"指向哪里都不会对该链表产生影响\",{\"1\":{\"36\":1}}],[\"指向前驱节点的指针\",{\"1\":{\"26\":1}}],[\"指向后继节点的指针\",{\"1\":{\"26\":1}}],[\"指针初始化为\",{\"1\":{\"90\":1}}],[\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定\",{\"1\":{\"36\":1}}],[\"指针\",{\"1\":{\"18\":2,\"21\":1,\"22\":1,\"26\":1,\"35\":1,\"36\":1}}],[\"节点之间通过引用\",{\"1\":{\"36\":1}}],[\"节点值\",{\"1\":{\"18\":1,\"26\":1}}],[\"节点的\",{\"1\":{\"18\":1}}],[\"v\",{\"1\":{\"82\":3}}],[\"variable>\",{\"1\":{\"80\":1}}],[\"variable\",{\"0\":{\"80\":1},\"1\":{\"80\":1}}],[\"value\",{\"1\":{\"79\":2,\"81\":1}}],[\"val\",{\"1\":{\"18\":2,\"26\":2}}],[\"vector<std\",{\"1\":{\"84\":1,\"85\":1}}],[\"vector<int>\",{\"1\":{\"30\":2,\"79\":1}}],[\"vector\",{\"1\":{\"28\":1,\"30\":1,\"36\":2}}],[\"vs\",{\"0\":{\"25\":1}}],[\"void\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"21\":1,\"22\":1,\"72\":1,\"76\":2,\"78\":1,\"79\":2,\"80\":2,\"81\":1,\"82\":1,\"83\":3,\"84\":1,\"85\":1}}],[\"spinlock\",{\"0\":{\"83\":1},\"1\":{\"83\":5}}],[\"spawn\",{\"1\":{\"76\":2}}],[\"swap\",{\"1\":{\"81\":1,\"83\":1,\"87\":1}}],[\"sleep\",{\"1\":{\"80\":1,\"82\":1,\"83\":1}}],[\"shared\",{\"0\":{\"79\":1},\"1\":{\"79\":4}}],[\"sync\",{\"1\":{\"84\":2,\"85\":3}}],[\"synchronize\",{\"1\":{\"76\":1}}],[\"systemd\",{\"1\":{\"72\":1}}],[\"sem\",{\"1\":{\"82\":3}}],[\"semaphore<1>\",{\"1\":{\"82\":1}}],[\"semaphore\",{\"0\":{\"82\":1}}],[\"set\",{\"1\":{\"80\":2,\"83\":2}}],[\"seconds\",{\"1\":{\"80\":1,\"82\":1,\"83\":1}}],[\"second\",{\"1\":{\"76\":3}}],[\"self\",{\"1\":{\"36\":2}}],[\"signal\",{\"1\":{\"72\":1,\"82\":1}}],[\"signum\",{\"1\":{\"72\":1}}],[\"sigchld\",{\"1\":{\"72\":8}}],[\"size\",{\"1\":{\"10\":3,\"11\":2,\"12\":2,\"13\":2,\"14\":2,\"15\":3,\"33\":1,\"34\":1,\"36\":2,\"89\":5,\"90\":4}}],[\"srp\",{\"1\":{\"45\":1}}],[\"store\",{\"1\":{\"89\":2,\"90\":4,\"91\":2}}],[\"stuff\",{\"1\":{\"76\":2}}],[\"static\",{\"0\":{\"57\":1}}],[\"stack\",{\"1\":{\"36\":1}}],[\"std\",{\"1\":{\"36\":5,\"76\":6,\"78\":6,\"79\":11,\"80\":11,\"81\":6,\"82\":7,\"83\":9,\"84\":6,\"85\":6,\"88\":1,\"89\":14,\"90\":18,\"91\":3}}],[\"stl\",{\"1\":{\"36\":1}}],[\"string\",{\"1\":{\"36\":1}}],[\"struct\",{\"1\":{\"18\":1,\"26\":1}}],[\"还未进入准备就绪队列\",{\"1\":{\"67\":1}}],[\"还是数组吗\",{\"1\":{\"36\":1}}],[\"还是和节点值各占一半呢\",{\"1\":{\"36\":1}}],[\"还需额外保存一个引用\",{\"1\":{\"18\":1}}],[\"还会缓存其周围的其他数据\",{\"1\":{\"16\":1}}],[\"除了包含值\",{\"1\":{\"18\":1}}],[\"中初始化\",{\"1\":{\"36\":1}}],[\"中\",{\"1\":{\"30\":1,\"36\":1,\"70\":1,\"90\":1}}],[\"中的原子操作\",{\"0\":{\"88\":1}}],[\"中的数字也被包装为对象\",{\"1\":{\"36\":1}}],[\"中的相同\",{\"1\":{\"36\":1}}],[\"中的\",{\"1\":{\"28\":4,\"81\":1}}],[\"中分别被记为\",{\"1\":{\"18\":1}}],[\"中随机抽取一个数字\",{\"1\":{\"10\":1}}],[\"它支持以下操作\",{\"1\":{\"88\":1}}],[\"它检查一个变量是否有特定的值\",{\"1\":{\"87\":1}}],[\"它的所有资源\",{\"1\":{\"70\":1}}],[\"它保留了数组的优势\",{\"1\":{\"35\":1}}],[\"它继承了数组的各项优点\",{\"1\":{\"28\":1}}],[\"它表示元素的有序集合\",{\"1\":{\"28\":1}}],[\"它表现的特性为先进先出\",{\"1\":{\"27\":1}}],[\"它表现的特性为先进后出\",{\"1\":{\"27\":1}}],[\"它需要对一组进程进行循环\",{\"1\":{\"27\":1}}],[\"它在\",{\"1\":{\"18\":1}}],[\"它们分为三大类\",{\"1\":{\"44\":1}}],[\"它们的实现比较复杂\",{\"1\":{\"34\":1}}],[\"它们的内存地址无须连续\",{\"1\":{\"18\":1}}],[\"它们之间没有空间再存放任何数据\",{\"1\":{\"11\":1}}],[\"尾节点指向空\",{\"1\":{\"26\":1}}],[\"尾节点指向的是\",{\"1\":{\"18\":1}}],[\"尾节点\",{\"1\":{\"18\":1,\"36\":1}}],[\"头节点\",{\"1\":{\"18\":1}}],[\"和实例对象等\",{\"1\":{\"36\":1}}],[\"和前驱节点\",{\"1\":{\"26\":1}}],[\"和\",{\"1\":{\"18\":3,\"20\":1,\"21\":1,\"28\":2,\"30\":1,\"36\":3,\"59\":1,\"90\":1,\"91\":1}}],[\"和指向下一节点的\",{\"1\":{\"18\":1}}],[\"和某个元素的索引\",{\"1\":{\"10\":1}}],[\"值\",{\"1\":{\"18\":1}}],[\"值得注意的是\",{\"1\":{\"11\":1}}],[\"每次完成任务时\",{\"1\":{\"85\":1}}],[\"每次插入与删除操作都是\",{\"1\":{\"36\":1}}],[\"每当一个线程到达屏障点时\",{\"1\":{\"84\":1}}],[\"每个进程被赋予一个时间片\",{\"1\":{\"27\":1}}],[\"每个节点都包含两项数据\",{\"1\":{\"18\":1}}],[\"每轮判断元素值是否匹配\",{\"1\":{\"14\":1}}],[\"对于保持系统的稳定性和资源利用率至关重要\",{\"1\":{\"72\":1}}],[\"对修改关闭\",{\"1\":{\"45\":1}}],[\"对缓存的利用率较低\",{\"1\":{\"36\":1}}],[\"对时间效率和空间效率是否有影响\",{\"1\":{\"36\":1}}],[\"对应队列\",{\"1\":{\"27\":1}}],[\"对应栈\",{\"1\":{\"27\":1}}],[\"对应的元素存放在数组中的对应位置\",{\"1\":{\"17\":1}}],[\"对象\",{\"1\":{\"18\":1,\"90\":1}}],[\"相等\",{\"1\":{\"90\":2}}],[\"相同\",{\"1\":{\"59\":1}}],[\"相对地\",{\"1\":{\"36\":1}}],[\"相较于数组\",{\"1\":{\"32\":1}}],[\"相较于单向链表\",{\"1\":{\"26\":1}}],[\"相比之下\",{\"1\":{\"21\":1}}],[\"相连接\",{\"1\":{\"18\":1}}],[\"相关的面\",{\"0\":{\"1\":1}}],[\"存储方式\",{\"1\":{\"25\":1}}],[\"存储数组的内存空间必须是连续的\",{\"1\":{\"18\":1}}],[\"存储在堆上\",{\"1\":{\"9\":1}}],[\"存储在栈上和堆上的数组都被存储在连续内存空间内\",{\"1\":{\"36\":1}}],[\"存储在栈上\",{\"1\":{\"9\":1}}],[\"空\",{\"1\":{\"18\":1}}],[\"空闲的内存空间可能散落在内存各处\",{\"1\":{\"18\":1}}],[\"空间开销\",{\"1\":{\"36\":1}}],[\"空间浪费\",{\"1\":{\"16\":1}}],[\"空间效率高\",{\"1\":{\"16\":1}}],[\"内存顺序的选择\",{\"0\":{\"91\":1}}],[\"内存序列模型\",{\"1\":{\"87\":1}}],[\"内存模型\",{\"1\":{\"81\":1}}],[\"内存地址偏移一个数组的位置\",{\"1\":{\"59\":1}}],[\"内存效率\",{\"1\":{\"25\":1}}],[\"内存可能无法提供如此大的连续空间\",{\"1\":{\"18\":1}}],[\"内存空间是所有程序的公共资源\",{\"1\":{\"18\":1}}],[\"内存浪费\",{\"1\":{\"12\":1}}],[\"图\",{\"1\":{\"27\":1,\"36\":1}}],[\"图的邻接矩阵表示实际上是一个二维数组\",{\"1\":{\"17\":1}}],[\"图等数据结构\",{\"1\":{\"17\":1}}],[\"例如在每个计算步骤完成后同步所有线程\",{\"1\":{\"84\":1}}],[\"例如在中断上下文或需要避免线程调度开销的情况下使用\",{\"1\":{\"83\":1}}],[\"例如在生产者\",{\"1\":{\"80\":1}}],[\"例如限制同时访问文件的线程数\",{\"1\":{\"82\":1}}],[\"例如初始化任务完成后启动主任务\",{\"1\":{\"85\":1}}],[\"例如初始化二维列表\",{\"1\":{\"36\":1}}],[\"例如初始容量\",{\"1\":{\"34\":1}}],[\"例如\",{\"1\":{\"17\":1,\"28\":1,\"34\":1,\"36\":3,\"72\":1}}],[\"堆的大小一般受限于可用内存\",{\"1\":{\"36\":1}}],[\"堆上的分配和释放操作通常比栈上的慢\",{\"1\":{\"36\":1}}],[\"堆\",{\"1\":{\"17\":1}}],[\"哈希表和图等数据结构\",{\"1\":{\"27\":1}}],[\"哈希表\",{\"1\":{\"17\":1,\"27\":1}}],[\"队列使用一个动态分配的数组\",{\"1\":{\"90\":1}}],[\"队列为空\",{\"1\":{\"89\":1,\"90\":1}}],[\"队列已满\",{\"1\":{\"89\":1,\"90\":1}}],[\"队列\",{\"1\":{\"17\":1,\"27\":1}}],[\"张量之间的线性代数运算\",{\"1\":{\"17\":1}}],[\"矩阵\",{\"1\":{\"17\":1}}],[\"神经网络中大量使用了向量\",{\"1\":{\"17\":1}}],[\"机器学习\",{\"1\":{\"17\":1}}],[\"码值作为索引\",{\"1\":{\"17\":1}}],[\"码的映射\",{\"1\":{\"17\":1}}],[\"则将其更改为新值\",{\"1\":{\"87\":1}}],[\"则将互斥量状态设置为未锁定\",{\"1\":{\"78\":1}}],[\"则唤醒所有读线程\",{\"1\":{\"79\":1}}],[\"则唤醒一个写线程\",{\"1\":{\"79\":2}}],[\"则唤醒一个线程\",{\"1\":{\"78\":1}}],[\"则锁定成功\",{\"1\":{\"79\":1}}],[\"则线程进入等待队列\",{\"1\":{\"79\":2}}],[\"则线程成功锁定\",{\"1\":{\"78\":1}}],[\"则增加读计数器\",{\"1\":{\"79\":1}}],[\"则该线程进入等待队列并挂起\",{\"1\":{\"78\":1}}],[\"则该进程被挂起并返回到就绪队列中\",{\"1\":{\"68\":1}}],[\"则多次引用了同一个列表\",{\"1\":{\"36\":1}}],[\"则会造成内存空间浪费\",{\"1\":{\"28\":1}}],[\"则很可能无法满足使用需求\",{\"1\":{\"28\":1}}],[\"则得到一个环形链表\",{\"1\":{\"26\":1}}],[\"则只需改变两个节点引用\",{\"1\":{\"21\":1}}],[\"则可以将字符的\",{\"1\":{\"17\":1}}],[\"则需重新建立一个更大的数组\",{\"1\":{\"15\":1}}],[\"则需要先扩容列表再添加\",{\"1\":{\"36\":1}}],[\"则需要进行扩容\",{\"1\":{\"34\":1}}],[\"则需要把索引\",{\"1\":{\"12\":1}}],[\"则需要将该元素之后的所有元素都向后移动一位\",{\"1\":{\"11\":1}}],[\"acquire\",{\"1\":{\"82\":2,\"83\":1,\"87\":1,\"89\":2,\"90\":4,\"91\":3}}],[\"access\",{\"1\":{\"23\":1}}],[\"add\",{\"1\":{\"81\":1}}],[\"atomic<size\",{\"1\":{\"89\":2}}],[\"atomic<int>\",{\"1\":{\"81\":1}}],[\"atomic\",{\"0\":{\"81\":1},\"1\":{\"81\":1,\"83\":2,\"88\":1}}],[\"all\",{\"1\":{\"80\":2}}],[\"auto\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"and\",{\"1\":{\"76\":2,\"81\":2,\"83\":3,\"84\":1,\"87\":1}}],[\"a+1\",{\"1\":{\"59\":2}}],[\"a\",{\"0\":{\"36\":1,\"59\":4},\"1\":{\"59\":6}}],[\"ascii\",{\"1\":{\"17\":2}}],[\"arrive\",{\"1\":{\"84\":1}}],[\"arr1\",{\"1\":{\"9\":1}}],[\"arr\",{\"1\":{\"9\":1}}],[\"arraylist\",{\"1\":{\"28\":1}}],[\"array\",{\"1\":{\"7\":1,\"28\":1}}],[\"查找其中值为\",{\"1\":{\"24\":1}}],[\"查找节点\",{\"0\":{\"24\":1}}],[\"查找表\",{\"1\":{\"17\":1}}],[\"查找元素\",{\"0\":{\"14\":1}}],[\"归并排序\",{\"1\":{\"17\":1}}],[\"快速排序\",{\"1\":{\"17\":1}}],[\"排序和搜索\",{\"1\":{\"17\":1}}],[\"随机访问\",{\"1\":{\"17\":1}}],[\"随机访问元素\",{\"1\":{\"10\":1}}],[\"既频繁应用在各类算法之中\",{\"1\":{\"17\":1}}],[\"开闭原则\",{\"1\":{\"45\":1}}],[\"开销很大\",{\"1\":{\"16\":1}}],[\"开始计数会更自然\",{\"1\":{\"10\":1}}],[\"当计数器减为零时\",{\"1\":{\"85\":1}}],[\"当计数器达到零时\",{\"1\":{\"84\":1}}],[\"当持有锁的线程释放自旋锁时\",{\"1\":{\"83\":1}}],[\"当写线程解锁时\",{\"1\":{\"79\":1}}],[\"当读线程解锁时\",{\"1\":{\"79\":1}}],[\"当一个线程尝试获取自旋锁时\",{\"1\":{\"83\":1}}],[\"当一个线程尝试锁定互斥量时\",{\"1\":{\"78\":1}}],[\"当一个线程执行\",{\"1\":{\"82\":2}}],[\"当一个线程修改条件状态并调用\",{\"1\":{\"80\":1}}],[\"当一个线程请求写锁定时\",{\"1\":{\"79\":1}}],[\"当一个线程请求读锁定时\",{\"1\":{\"79\":1}}],[\"当一个线程解锁互斥量时\",{\"1\":{\"78\":1}}],[\"当一个子进程结束时\",{\"1\":{\"70\":1}}],[\"当子进程结束时\",{\"1\":{\"72\":1}}],[\"当父进程调用\",{\"1\":{\"70\":1}}],[\"当等待的事件发生\",{\"1\":{\"68\":1}}],[\"当进程完成其任务或被强制终止时\",{\"1\":{\"68\":1}}],[\"当进程执行\",{\"1\":{\"68\":1}}],[\"当进程创建完成\",{\"1\":{\"68\":1}}],[\"当使用数组实现列表时\",{\"1\":{\"28\":1}}],[\"当时间片用完时\",{\"1\":{\"27\":1}}],[\"当用户点击前进或后退按钮时\",{\"1\":{\"27\":1}}],[\"当插入操作在链表的一端进行\",{\"1\":{\"27\":1}}],[\"当插入和删除操作都在链表的一端进行时\",{\"1\":{\"27\":1}}],[\"当需要快速查找一个元素或其对应关系时\",{\"1\":{\"17\":1}}],[\"当数组中元素较多时\",{\"1\":{\"16\":1}}],[\"当访问数组元素时\",{\"1\":{\"16\":1}}],[\"插入节点\",{\"0\":{\"21\":1}}],[\"插入与删除元素\",{\"0\":{\"32\":1}}],[\"插入与删除操作需要移动大量的元素\",{\"1\":{\"16\":1}}],[\"插入与删除效率低\",{\"1\":{\"16\":1}}],[\"插入元素\",{\"0\":{\"11\":1}}],[\"返回扩展后的新数组\",{\"1\":{\"15\":1}}],[\"emplace\",{\"1\":{\"84\":1,\"85\":1}}],[\"enqueue\",{\"1\":{\"89\":2,\"90\":5}}],[\"endl\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":2,\"85\":2,\"89\":2,\"90\":2}}],[\"enlarge\",{\"1\":{\"15\":2}}],[\"else\",{\"1\":{\"72\":4}}],[\"execute\",{\"1\":{\"76\":1}}],[\"example\",{\"1\":{\"76\":1}}],[\"exit\",{\"1\":{\"72\":5}}],[\"extern\",{\"0\":{\"61\":1},\"1\":{\"61\":1}}],[\"extend\",{\"1\":{\"15\":1}}],[\"erase\",{\"1\":{\"32\":1}}],[\"扩容一般会乘以一个系数\",{\"1\":{\"36\":1}}],[\"扩容倍数所占的内存吗\",{\"1\":{\"36\":1}}],[\"扩容倍数等\",{\"1\":{\"34\":1}}],[\"扩容机制\",{\"1\":{\"34\":1}}],[\"扩容数组需要将所有数据复制到新数组\",{\"1\":{\"16\":1}}],[\"扩容数组\",{\"0\":{\"15\":1}}],[\"扩展数组长度\",{\"1\":{\"15\":1}}],[\"tail\",{\"1\":{\"89\":5,\"90\":11,\"91\":2}}],[\"target\",{\"1\":{\"14\":2,\"24\":4}}],[\"t>\",{\"1\":{\"89\":3,\"90\":1}}],[\"template\",{\"1\":{\"89\":1,\"90\":1}}],[\"test\",{\"1\":{\"83\":2}}],[\"terminated\",{\"1\":{\"67\":1}}],[\"true\",{\"1\":{\"80\":2,\"89\":2,\"90\":2}}],[\"traverse\",{\"1\":{\"13\":1}}],[\"t4\",{\"1\":{\"79\":2}}],[\"t3\",{\"1\":{\"79\":2}}],[\"t2\",{\"1\":{\"79\":2}}],[\"t1\",{\"1\":{\"79\":2}}],[\"the\",{\"1\":{\"85\":1}}],[\"this\",{\"1\":{\"80\":1,\"82\":1,\"83\":1}}],[\"th\",{\"1\":{\"78\":2,\"80\":2,\"81\":2,\"82\":2,\"83\":2,\"84\":2,\"85\":2}}],[\"that\",{\"1\":{\"76\":2}}],[\"thread>\",{\"1\":{\"84\":1,\"85\":1}}],[\"threads\",{\"1\":{\"76\":1,\"78\":3,\"80\":3,\"81\":3,\"82\":3,\"83\":3,\"84\":3,\"85\":3}}],[\"thread\",{\"1\":{\"76\":6,\"78\":5,\"79\":4,\"80\":5,\"81\":2,\"82\":4,\"83\":4,\"84\":2,\"85\":2,\"89\":2,\"90\":2}}],[\"t\",{\"1\":{\"72\":5,\"80\":2,\"89\":9,\"90\":8}}],[\"times\",{\"1\":{\"36\":1}}],[\"flag\",{\"1\":{\"83\":5}}],[\"fetch\",{\"1\":{\"81\":1}}],[\"false\",{\"1\":{\"80\":1,\"89\":2,\"90\":2}}],[\"final\",{\"1\":{\"81\":1}}],[\"finishes\",{\"1\":{\"76\":2}}],[\"find\",{\"1\":{\"14\":1,\"24\":1}}],[\"first\",{\"1\":{\"76\":3}}],[\"found\",{\"1\":{\"96\":1}}],[\"foo\",{\"1\":{\"61\":2,\"76\":5}}],[\"fork\",{\"1\":{\"72\":10}}],[\"for\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":2,\"78\":2,\"79\":1,\"80\":3,\"81\":3,\"82\":3,\"83\":3,\"84\":2,\"85\":2,\"89\":2,\"90\":2}}],[\"free\",{\"1\":{\"58\":1,\"86\":1}}],[\"线程同步\",{\"2\":{\"93\":1}}],[\"线程同步机制\",{\"0\":{\"77\":1}}],[\"线程会持续等待直到成功取出元素\",{\"1\":{\"90\":1}}],[\"线程会持续等待直到成功插入\",{\"1\":{\"90\":1}}],[\"线程等待直到锁存器倒数到零\",{\"1\":{\"85\":1}}],[\"线程将反复检查锁的状态\",{\"1\":{\"83\":1}}],[\"线程将自己添加到等待队列\",{\"1\":{\"80\":1}}],[\"线程在尝试获取锁时会反复检查锁的状态\",{\"1\":{\"83\":1}}],[\"线程在等待条件变量时\",{\"1\":{\"80\":1}}],[\"线程进入等待队列\",{\"1\":{\"82\":1}}],[\"线程再次进入等待状态\",{\"1\":{\"80\":1}}],[\"线程继续执行\",{\"1\":{\"79\":1,\"80\":1,\"82\":1}}],[\"线程创建\",{\"0\":{\"76\":1}}],[\"线程编程\",{\"0\":{\"75\":1},\"1\":{\"1\":1}}],[\"线性结构\",{\"2\":{\"38\":1}}],[\"线性查找\",{\"1\":{\"14\":1}}],[\"若插入元素时列表容量已满\",{\"1\":{\"34\":1}}],[\"若长度过大\",{\"1\":{\"28\":1}}],[\"若长度过小\",{\"1\":{\"28\":1}}],[\"若匹配则输出对应索引\",{\"1\":{\"14\":1}}],[\"若想删除索引\",{\"1\":{\"12\":1}}],[\"currenthead\",{\"1\":{\"89\":4,\"90\":8}}],[\"currenttail\",{\"1\":{\"89\":3,\"90\":5}}],[\"class\",{\"1\":{\"83\":1,\"89\":1,\"90\":1}}],[\"clear\",{\"1\":{\"32\":1,\"83\":1}}],[\"capacity\",{\"1\":{\"89\":7,\"90\":9}}],[\"cas\",{\"1\":{\"81\":1,\"87\":1,\"88\":1}}],[\"calls\",{\"1\":{\"76\":2}}],[\"chrono\",{\"1\":{\"80\":1,\"82\":1,\"83\":1}}],[\"cv\",{\"1\":{\"80\":6}}],[\"compare\",{\"1\":{\"81\":1,\"83\":1,\"87\":1}}],[\"completed\",{\"1\":{\"76\":1}}],[\"consumed\",{\"1\":{\"89\":1,\"90\":1}}],[\"consumer\",{\"1\":{\"89\":2,\"90\":3}}],[\"const\",{\"0\":{\"62\":1},\"1\":{\"62\":1,\"79\":1,\"89\":1,\"90\":1}}],[\"constexpr\",{\"1\":{\"60\":1}}],[\"condition\",{\"0\":{\"80\":1},\"1\":{\"80\":1}}],[\"concurrently\",{\"1\":{\"76\":1}}],[\"cout\",{\"1\":{\"76\":3,\"78\":1,\"79\":2,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":2,\"85\":2,\"89\":2,\"90\":2}}],[\"counting\",{\"1\":{\"82\":1}}],[\"counter\",{\"1\":{\"81\":3}}],[\"count\",{\"1\":{\"13\":2,\"33\":4,\"85\":1}}],[\"cpu\",{\"1\":{\"27\":2,\"35\":1,\"67\":2,\"68\":3,\"71\":1}}],[\"c\",{\"0\":{\"61\":1},\"1\":{\"18\":1,\"28\":1,\"61\":2}}],[\"c++11\",{\"1\":{\"88\":1}}],[\"c++面试题\",{\"1\":{\"1\":1}}],[\"c++\",{\"0\":{\"1\":1,\"56\":1,\"88\":1},\"1\":{\"18\":2,\"28\":1,\"30\":1,\"34\":1,\"36\":1,\"61\":1,\"81\":1,\"87\":1},\"2\":{\"3\":1,\"38\":1,\"47\":1,\"50\":1,\"53\":1,\"64\":1,\"74\":1,\"93\":1}}],[\"但只能使用一次\",{\"1\":{\"85\":1}}],[\"但在写入时只允许一个线程操作\",{\"1\":{\"79\":1}}],[\"但它会占用一个进程表项\",{\"1\":{\"71\":1}}],[\"但它的进程描述符\",{\"1\":{\"70\":1}}],[\"但二维数组会有这个问题\",{\"1\":{\"36\":1}}],[\"但好像一些算法书上不怎么直接使用它\",{\"1\":{\"36\":1}}],[\"但是初始化\",{\"1\":{\"36\":1}}],[\"但是增删之前都需要\",{\"1\":{\"36\":1}}],[\"但可能导致部分内存空间浪费\",{\"1\":{\"35\":1,\"36\":1}}],[\"但可能浪费空间\",{\"1\":{\"25\":1}}],[\"但节点访问效率低\",{\"1\":{\"35\":1}}],[\"但插入和删除元素效率低\",{\"1\":{\"35\":1}}],[\"但插入和删除元素的效率仍与数组相同\",{\"1\":{\"32\":1}}],[\"但由于其长度不可变\",{\"1\":{\"28\":1}}],[\"但相应地也需要占用更多的内存空间\",{\"1\":{\"26\":1}}],[\"但实际上遍历此链表已经无法访问到\",{\"1\":{\"22\":1}}],[\"但这样做会造成部分内存空间浪费\",{\"1\":{\"12\":1}}],[\"但从地址计算公式的角度看\",{\"1\":{\"10\":1}}],[\"的值\",{\"1\":{\"90\":2}}],[\"的进程\",{\"1\":{\"72\":1}}],[\"的风险\",{\"1\":{\"45\":1}}],[\"的每个元素引用相同的地址吗\",{\"1\":{\"36\":1}}],[\"的性能会更好\",{\"1\":{\"36\":1}}],[\"的时间查找元素\",{\"1\":{\"36\":1}}],[\"的角度看\",{\"1\":{\"36\":1}}],[\"的引用\",{\"1\":{\"26\":1}}],[\"的首个节点\",{\"1\":{\"24\":1}}],[\"的节点\",{\"1\":{\"23\":1,\"24\":1}}],[\"的操作\",{\"1\":{\"15\":1}}],[\"的\",{\"1\":{\"12\":1}}],[\"超出数组长度范围的元素会丢失\",{\"1\":{\"12\":1}}],[\"其他线程能正确地看到更新的头部指针\",{\"1\":{\"90\":1}}],[\"其他线程能正确地看到更新的尾部指针\",{\"1\":{\"90\":1}}],[\"其他线程可以成功获取锁并继续执行\",{\"1\":{\"83\":1}}],[\"其实现原理如下\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"其父进程没有及时调用\",{\"1\":{\"70\":1}}],[\"其支持元素增删查改操作\",{\"1\":{\"28\":1}}],[\"其存在以下局限性\",{\"1\":{\"16\":1}}],[\"其中a\",{\"1\":{\"59\":1}}],[\"其中图的每个顶点都与一个链表相关联\",{\"1\":{\"27\":1}}],[\"其中的每个元素都是一个节点对象\",{\"1\":{\"18\":1}}],[\"其中\",{\"1\":{\"12\":1}}],[\"其将相同类型的元素存储在连续的内存空间中\",{\"1\":{\"7\":1}}],[\"总的来看\",{\"1\":{\"12\":1}}],[\"++counter\",{\"1\":{\"81\":1}}],[\"++i\",{\"1\":{\"78\":1,\"80\":1,\"81\":2,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":2,\"90\":2}}],[\"+1\",{\"1\":{\"59\":1}}],[\"+=\",{\"1\":{\"13\":1,\"33\":2}}],[\"+\",{\"1\":{\"12\":1,\"15\":1,\"32\":2,\"36\":1,\"58\":2,\"89\":2,\"90\":4}}],[\"<typename\",{\"1\":{\"89\":1,\"90\":1}}],[\"<thread>\",{\"1\":{\"76\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":1}}],[\"<latch>\",{\"1\":{\"85\":1}}],[\"<barrier>\",{\"1\":{\"84\":1}}],[\"<atomic>\",{\"1\":{\"81\":1,\"83\":1,\"89\":1}}],[\"<condition\",{\"1\":{\"80\":1}}],[\"<vector>\",{\"1\":{\"79\":1,\"84\":1,\"85\":1,\"89\":1}}],[\"<mutex>\",{\"1\":{\"78\":1,\"80\":1}}],[\"<<\",{\"1\":{\"76\":2,\"78\":3,\"79\":3,\"80\":3,\"81\":3,\"82\":4,\"83\":4,\"84\":8,\"85\":8,\"89\":6,\"90\":6}}],[\"<semaphore>\",{\"1\":{\"82\":1}}],[\"<shared\",{\"1\":{\"79\":1}}],[\"<signal\",{\"1\":{\"72\":1}}],[\"<sys\",{\"1\":{\"72\":1}}],[\"<unistd\",{\"1\":{\"72\":1}}],[\"<iostream>\",{\"1\":{\"72\":1,\"76\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":1}}],[\"<\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":1,\"78\":1,\"80\":1,\"81\":2,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":2,\"90\":2}}],[\"删除和遍历等操作\",{\"1\":{\"28\":1}}],[\"删除操作在链表的另一端进行\",{\"1\":{\"27\":1}}],[\"删除链表的节点\",{\"1\":{\"22\":1}}],[\"删除节点\",{\"0\":{\"22\":1},\"1\":{\"36\":1}}],[\"删除索引\",{\"1\":{\"12\":1,\"32\":1}}],[\"删除元素完成后\",{\"1\":{\"12\":1}}],[\"删除元素\",{\"0\":{\"12\":1},\"1\":{\"25\":1,\"32\":1}}],[\"了\",{\"1\":{\"12\":1,\"36\":1}}],[\"无锁编程主要依赖于原子操作和内存序列模型\",{\"1\":{\"86\":1}}],[\"无锁编程\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"无需锁定\",{\"1\":{\"81\":1}}],[\"无须使用者考虑容量限制的问题\",{\"1\":{\"28\":1}}],[\"无须额外的结构开销\",{\"1\":{\"16\":1}}],[\"无意义\",{\"1\":{\"12\":2}}],[\"无初始值\",{\"1\":{\"9\":1,\"30\":2}}],[\"请注意\",{\"1\":{\"12\":1,\"22\":1}}],[\"处理\",{\"1\":{\"72\":1}}],[\"处插入数字\",{\"1\":{\"32\":1}}],[\"处插入元素\",{\"1\":{\"11\":1}}],[\"处的元素更新为\",{\"1\":{\"31\":1}}],[\"处的元素\",{\"1\":{\"11\":1,\"12\":2,\"31\":1,\"32\":1}}],[\"赋给\",{\"1\":{\"11\":1}}],[\"将头部指针所指向的元素存储到\",{\"1\":{\"90\":1}}],[\"将新的尾部指针存储到\",{\"1\":{\"90\":1}}],[\"将元素存储在当前尾部指针所指向的位置\",{\"1\":{\"90\":1}}],[\"将子进程的父进程设置为\",{\"1\":{\"72\":1}}],[\"将重载函数重新命名成唯一的标识符\",{\"1\":{\"61\":1}}],[\"将索引\",{\"1\":{\"31\":1}}],[\"将切换到下一个进程\",{\"1\":{\"27\":1}}],[\"将最后一个节点称为尾节点\",{\"1\":{\"26\":1}}],[\"将原数组中的所有元素复制到新数组\",{\"1\":{\"15\":1}}],[\"将\",{\"1\":{\"11\":1}}],[\">val\",{\"1\":{\"24\":1}}],[\">next\",{\"1\":{\"20\":4,\"21\":3,\"22\":4,\"23\":1,\"24\":1}}],[\">\",{\"1\":{\"11\":1,\"20\":4,\"22\":2,\"72\":2}}],[\"item\",{\"1\":{\"89\":7,\"90\":11}}],[\"is\",{\"1\":{\"82\":1,\"83\":1,\"84\":2,\"85\":1}}],[\"isp\",{\"1\":{\"45\":1}}],[\"id\",{\"1\":{\"36\":2,\"78\":4,\"80\":4,\"82\":2,\"83\":2,\"84\":3,\"85\":3}}],[\"if\",{\"1\":{\"14\":1,\"22\":1,\"23\":1,\"24\":1,\"72\":5,\"89\":2,\"90\":4}}],[\"i++\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":1}}],[\"i\",{\"1\":{\"11\":5,\"12\":4,\"13\":3,\"14\":4,\"15\":4,\"23\":2,\"33\":3,\"67\":1,\"68\":2,\"78\":4,\"80\":4,\"81\":5,\"82\":4,\"83\":4,\"84\":3,\"85\":3,\"89\":6,\"90\":7}}],[\"increment\",{\"1\":{\"81\":2}}],[\"include\",{\"1\":{\"72\":4,\"76\":2,\"78\":3,\"79\":4,\"80\":4,\"81\":3,\"82\":3,\"83\":3,\"84\":4,\"85\":4,\"89\":4}}],[\"init\",{\"1\":{\"72\":7,\"83\":1}}],[\"insert\",{\"1\":{\"11\":1,\"21\":1,\"32\":1}}],[\"int\",{\"0\":{\"59\":1},\"1\":{\"9\":6,\"10\":5,\"11\":5,\"12\":4,\"13\":4,\"14\":5,\"15\":7,\"18\":2,\"23\":2,\"24\":3,\"26\":2,\"31\":1,\"33\":3,\"36\":3,\"59\":2,\"61\":1,\"72\":2,\"76\":2,\"78\":3,\"79\":2,\"80\":3,\"81\":3,\"82\":3,\"83\":3,\"84\":3,\"85\":3,\"89\":4,\"90\":4}}],[\"index++\",{\"1\":{\"24\":1}}],[\"index\",{\"1\":{\"7\":1,\"11\":6,\"12\":4,\"23\":3,\"24\":2}}],[\"把索引\",{\"1\":{\"11\":1,\"12\":1}}],[\"章节中讨论\",{\"1\":{\"11\":1}}],[\"列表中存储的不是数字本身\",{\"1\":{\"36\":1}}],[\"列表都会设定一个初始长度\",{\"1\":{\"36\":1}}],[\"列表的出现极大地提高了数组的实用性\",{\"1\":{\"36\":1}}],[\"列表的出现大幅提高了数组的实用性\",{\"1\":{\"35\":1}}],[\"列表是一种支持增删查改的元素有序集合\",{\"1\":{\"35\":1}}],[\"列表实现\",{\"0\":{\"34\":1}}],[\"列表可以根据索引遍历\",{\"1\":{\"33\":1}}],[\"列表可以自由地添加与删除元素\",{\"1\":{\"32\":1}}],[\"列表可以基于链表或数组实现\",{\"1\":{\"28\":1}}],[\"列表本质上是数组\",{\"1\":{\"31\":1}}],[\"列表常用操作\",{\"0\":{\"29\":1}}],[\"列表\",{\"0\":{\"28\":1},\"1\":{\"11\":1,\"28\":2}}],[\"丢失的末尾元素都是\",{\"1\":{\"12\":1}}],[\"丢失元素\",{\"1\":{\"12\":1}}],[\"丢失\",{\"1\":{\"11\":1}}],[\"如互斥锁\",{\"1\":{\"86\":1}}],[\"如计数器\",{\"1\":{\"81\":1}}],[\"如何避免产生僵尸进程\",{\"0\":{\"72\":1}}],[\"如内存\",{\"1\":{\"70\":1}}],[\"如等待信号\",{\"1\":{\"68\":1}}],[\"如void\",{\"1\":{\"61\":1}}],[\"如\",{\"1\":{\"45\":1,\"67\":1,\"68\":1,\"70\":1,\"81\":1,\"83\":1,\"87\":1,\"91\":3}}],[\"如观察者模式\",{\"1\":{\"44\":1}}],[\"如适配器模式\",{\"1\":{\"44\":1}}],[\"如单例模式\",{\"1\":{\"44\":1}}],[\"如上一节所述\",{\"1\":{\"23\":1}}],[\"如以下代码所示\",{\"1\":{\"18\":1}}],[\"如果\",{\"1\":{\"90\":2}}],[\"如果队列为空\",{\"1\":{\"89\":1,\"90\":2}}],[\"如果队列已满\",{\"1\":{\"89\":1,\"90\":2}}],[\"如果是\",{\"1\":{\"87\":1}}],[\"如果是先查找元素\",{\"1\":{\"36\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"83\":1}}],[\"如果计数器值为零或负\",{\"1\":{\"82\":1}}],[\"如果计数器值为正\",{\"1\":{\"82\":1}}],[\"如果条件不满足\",{\"1\":{\"80\":1}}],[\"如果条件满足\",{\"1\":{\"80\":1}}],[\"如果读计数器为0且有写线程在等待\",{\"1\":{\"79\":1}}],[\"如果有线程在等待队列中\",{\"1\":{\"82\":1}}],[\"如果有写线程在等待\",{\"1\":{\"79\":1}}],[\"如果有写锁存在\",{\"1\":{\"79\":1}}],[\"如果有读线程在等待\",{\"1\":{\"79\":1}}],[\"如果有读锁或写锁存在\",{\"1\":{\"79\":1}}],[\"如果有大量僵尸进程存在\",{\"1\":{\"71\":1}}],[\"如果没有读锁和写锁存在\",{\"1\":{\"79\":1}}],[\"如果没有写锁存在\",{\"1\":{\"79\":1}}],[\"如果没有线程在等待\",{\"1\":{\"78\":1}}],[\"如果等待队列中有其他线程\",{\"1\":{\"78\":1}}],[\"如果互斥量已锁定\",{\"1\":{\"78\":1}}],[\"如果互斥量未锁定\",{\"1\":{\"78\":1}}],[\"如果父进程在子进程结束前退出\",{\"1\":{\"72\":1}}],[\"如果运行中的进程的时间片耗尽\",{\"1\":{\"68\":1}}],[\"如果添加元素时超出列表长度\",{\"1\":{\"36\":1}}],[\"如果不断开\",{\"1\":{\"36\":1}}],[\"如果我们令单向链表的尾节点指向头节点\",{\"1\":{\"26\":1}}],[\"如果我们想随机抽取一些样本\",{\"1\":{\"17\":1}}],[\"如果我们希望扩容数组\",{\"1\":{\"15\":1}}],[\"如果数组分配的大小超过实际所需\",{\"1\":{\"16\":1}}],[\"如果想在数组中间插入一个元素\",{\"1\":{\"11\":1}}],[\"如下图所示\",{\"1\":{\"11\":1,\"12\":1,\"21\":1,\"22\":1,\"26\":1}}],[\"紧挨着的\",{\"1\":{\"11\":1}}],[\"rw\",{\"1\":{\"79\":3}}],[\"running\",{\"1\":{\"67\":1}}],[\"rust\",{\"1\":{\"18\":1}}],[\"raii\",{\"1\":{\"58\":1}}],[\"rand\",{\"1\":{\"10\":1}}],[\"randomnum\",{\"1\":{\"10\":2}}],[\"randomindex\",{\"1\":{\"10\":2}}],[\"randomaccess\",{\"1\":{\"10\":1}}],[\"relaxed\",{\"1\":{\"87\":1,\"89\":2,\"90\":5,\"91\":2}}],[\"release\",{\"1\":{\"82\":2,\"83\":1,\"87\":1,\"89\":3,\"90\":6,\"91\":3}}],[\"reached\",{\"1\":{\"85\":1}}],[\"reader\",{\"1\":{\"79\":3}}],[\"read\",{\"1\":{\"79\":1}}],[\"ready\",{\"1\":{\"67\":1,\"80\":6}}],[\"res\",{\"1\":{\"15\":3,\"36\":3}}],[\"remove\",{\"1\":{\"12\":1,\"22\":1}}],[\"return\",{\"1\":{\"10\":1,\"14\":2,\"15\":1,\"22\":1,\"23\":2,\"24\":2,\"72\":1,\"76\":1,\"78\":1,\"79\":1,\"80\":2,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"89\":5,\"90\":5}}],[\"order\",{\"1\":{\"83\":2,\"87\":3,\"89\":7,\"90\":15,\"91\":6}}],[\"operations\",{\"0\":{\"81\":1}}],[\"one\",{\"1\":{\"80\":1}}],[\"ocp\",{\"1\":{\"45\":1}}],[\"object\",{\"1\":{\"36\":1}}],[\"o\",{\"1\":{\"10\":1,\"31\":1,\"32\":1,\"67\":1,\"68\":2}}],[\"在实际开发中\",{\"1\":{\"72\":1}}],[\"在此处执行需要守护的任务\",{\"1\":{\"72\":1}}],[\"在系统中\",{\"1\":{\"71\":1}}],[\"在预编译时期会被完整替换\",{\"1\":{\"60\":1}}],[\"在申请\",{\"1\":{\"58\":1}}],[\"在class中用于声明类成员或函数\",{\"1\":{\"57\":1}}],[\"在列表末尾添加元素是否时时刻刻都为\",{\"1\":{\"36\":1}}],[\"在列表尾部添加元素的时间复杂度为\",{\"1\":{\"32\":1}}],[\"在选择数据结构时\",{\"1\":{\"35\":1}}],[\"在本示例中\",{\"1\":{\"34\":2}}],[\"在索引\",{\"1\":{\"32\":1}}],[\"在中间插入元素\",{\"1\":{\"32\":1}}],[\"在尾部添加元素\",{\"1\":{\"32\":1}}],[\"在接下来的讨论中\",{\"1\":{\"28\":1}}],[\"在某些数据缓冲区的实现中\",{\"1\":{\"27\":1}}],[\"在操作系统中\",{\"1\":{\"27\":1}}],[\"在缓存淘汰\",{\"1\":{\"27\":1}}],[\"在网页浏览器中\",{\"1\":{\"27\":1}}],[\"在该方案中\",{\"1\":{\"27\":1}}],[\"在环形链表中\",{\"1\":{\"26\":1}}],[\"在链表中插入和删除操作的时间复杂度是\",{\"1\":{\"36\":1}}],[\"在链表中插入节点非常容易\",{\"1\":{\"21\":1}}],[\"在链表中查找值为\",{\"1\":{\"24\":1}}],[\"在链表中访问节点的效率较低\",{\"1\":{\"23\":1}}],[\"在链表中删除节点也非常方便\",{\"1\":{\"22\":1}}],[\"在链表的节点\",{\"1\":{\"21\":1}}],[\"在大数据量下的效率较低\",{\"1\":{\"21\":1}}],[\"在大多数编程语言中\",{\"1\":{\"13\":1}}],[\"在\",{\"1\":{\"18\":1,\"36\":1,\"90\":1}}],[\"在一个复杂的系统运行环境下\",{\"1\":{\"18\":1}}],[\"在复杂的系统环境中\",{\"1\":{\"15\":1}}],[\"在数组很大的情况下非常耗时\",{\"1\":{\"15\":1}}],[\"在数组中插入元素的时间复杂度为\",{\"1\":{\"21\":1}}],[\"在数组中查找指定元素\",{\"1\":{\"14\":1}}],[\"在数组中查找指定元素需要遍历数组\",{\"1\":{\"14\":1}}],[\"在数组中访问元素非常高效\",{\"1\":{\"10\":1}}],[\"在数组的索引\",{\"1\":{\"11\":1}}],[\"在区间\",{\"1\":{\"10\":1}}],[\"在未指定初始值的情况下\",{\"1\":{\"9\":1}}],[\"是因为我们不需要同步其他内存操作\",{\"1\":{\"90\":1}}],[\"是在\",{\"1\":{\"70\":1}}],[\"是内存地址偏移一个元素的位置\",{\"1\":{\"59\":1}}],[\"是c++\",{\"1\":{\"58\":1}}],[\"是c语言标准库提供的一组用于动态申请释放内存的api\",{\"1\":{\"58\":1}}],[\"是不是因为有什么局限性呢\",{\"1\":{\"36\":1}}],[\"是否需要把\",{\"1\":{\"36\":1}}],[\"是一种在多线程环境中实现并发访问的技术\",{\"1\":{\"86\":1}}],[\"是一种线性数据结构\",{\"1\":{\"7\":1,\"18\":1}}],[\"是一个抽象的数据结构概念\",{\"1\":{\"28\":1}}],[\"是合理的\",{\"1\":{\"10\":1}}],[\"因为数组中包含了两种\",{\"1\":{\"36\":1}}],[\"因为数组是线性数据结构\",{\"1\":{\"14\":1}}],[\"因为从\",{\"1\":{\"10\":1}}],[\"因此堆更加适合存储大型数组\",{\"1\":{\"36\":1}}],[\"因此\",{\"1\":{\"36\":3}}],[\"因此它通常比链表更高效\",{\"1\":{\"35\":1}}],[\"因此它的索引为\",{\"1\":{\"10\":1}}],[\"因此可以在\",{\"1\":{\"31\":1}}],[\"因此只能看作一个具有长度限制的列表\",{\"1\":{\"28\":1}}],[\"因此各种性质和操作效率也呈现对立的特点\",{\"1\":{\"25\":1}}],[\"因此在高并发场景下具有更好的性能\",{\"1\":{\"81\":1}}],[\"因此在相同数据量下\",{\"1\":{\"18\":1}}],[\"因此在大多数编程语言中\",{\"1\":{\"15\":1}}],[\"因此在插入元素后\",{\"1\":{\"12\":1}}],[\"因此插入一个元素必定会导致数组尾部元素\",{\"1\":{\"11\":1}}],[\"索引本质上是内存地址的偏移量\",{\"1\":{\"10\":1}}],[\"$i\",{\"1\":{\"23\":1}}],[\"$i$\",{\"1\":{\"12\":2,\"23\":1}}],[\"$n$\",{\"1\":{\"12\":1}}],[\"$\",{\"1\":{\"12\":1,\"15\":1,\"16\":1,\"21\":2,\"23\":2,\"25\":6,\"32\":1,\"36\":10}}],[\"$o\",{\"1\":{\"12\":1,\"15\":1,\"16\":1,\"21\":2,\"23\":2,\"25\":6,\"32\":1,\"36\":9}}],[\"$1$\",{\"1\":{\"10\":1}}],[\"$0$\",{\"1\":{\"10\":1}}],[\"这个操作是原子的\",{\"1\":{\"87\":1}}],[\"这3者的区别\",{\"0\":{\"59\":1}}],[\"这些指令能够确保在多个线程操作同一数据时不会产生竞争条件\",{\"1\":{\"81\":1}}],[\"这些元素的地址不连续\",{\"1\":{\"36\":1}}],[\"这些数据都是以数组的形式构建的\",{\"1\":{\"17\":1}}],[\"这\",{\"1\":{\"36\":1}}],[\"这里的空间浪费主要有两方面含义\",{\"1\":{\"36\":1}}],[\"这里的空间浪费是指额外增加的变量如容量\",{\"1\":{\"36\":1}}],[\"这时候时间复杂度就会是\",{\"1\":{\"36\":1}}],[\"这时候使用双向链表就非常合适\",{\"1\":{\"27\":1}}],[\"这样就可以解决c代码调用c++\",{\"1\":{\"61\":1}}],[\"这样\",{\"1\":{\"61\":1}}],[\"这样一来\",{\"1\":{\"36\":1}}],[\"这样才能通过计算偏移量来获取对应元素位置\",{\"1\":{\"36\":1}}],[\"这样在插入数据时\",{\"1\":{\"12\":1}}],[\"这两种初始化方法\",{\"1\":{\"30\":1}}],[\"这是无锁编程的核心操作之一\",{\"1\":{\"87\":1}}],[\"这是为了允许父进程能够获取子进程的退出状态\",{\"1\":{\"70\":1}}],[\"这是因为数组中存储的是节点的引用\",{\"1\":{\"36\":1}}],[\"这是因为我们通常无法事先确定需要存储多少数据\",{\"1\":{\"28\":1}}],[\"这是一个\",{\"1\":{\"15\":1}}],[\"这种循环操作可以通过环形链表来实现\",{\"1\":{\"27\":1}}],[\"这种做法包含丰富的先验信息\",{\"1\":{\"16\":1}}],[\"这可以通过在节点中保存一个指向父节点的引用来实现\",{\"1\":{\"27\":1}}],[\"这意味着节点\",{\"1\":{\"36\":1}}],[\"这意味着\",{\"1\":{\"22\":1}}],[\"这意味着计算数组元素的内存地址非常容易\",{\"1\":{\"10\":1}}],[\"这似乎有些反直觉\",{\"1\":{\"10\":1}}],[\"首尾相接\",{\"1\":{\"26\":1}}],[\"首个元素的地址偏移量是\",{\"1\":{\"10\":1}}],[\"首元素内存地址\",{\"1\":{\"10\":1,\"36\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"给定一个列表索引\",{\"1\":{\"36\":1}}],[\"给定数组内存地址\",{\"1\":{\"10\":1}}],[\"给定初始值\",{\"1\":{\"9\":1}}],[\"n5\",{\"1\":{\"36\":1}}],[\"n4\",{\"1\":{\"20\":2,\"36\":1}}],[\"n3\",{\"1\":{\"20\":3,\"36\":1}}],[\"n2\",{\"1\":{\"20\":3,\"36\":1}}],[\"n1\",{\"1\":{\"20\":3,\"21\":3,\"22\":4,\"36\":1}}],[\"n0\",{\"1\":{\"20\":3,\"21\":5,\"22\":6}}],[\"nexttail\",{\"1\":{\"89\":3,\"90\":7,\"91\":1}}],[\"next\",{\"1\":{\"18\":2,\"20\":1,\"26\":2,\"36\":2}}],[\"new的区别\",{\"0\":{\"58\":1}}],[\"new\",{\"0\":{\"58\":1},\"1\":{\"9\":2,\"15\":1,\"20\":5,\"58\":3,\"67\":1,\"76\":2,\"89\":1,\"90\":1}}],[\"not\",{\"1\":{\"96\":1}}],[\"notify\",{\"1\":{\"80\":4}}],[\"now\",{\"1\":{\"76\":1}}],[\"none\",{\"1\":{\"18\":1,\"26\":1,\"36\":1}}],[\"node\",{\"1\":{\"18\":1}}],[\"nullptr\",{\"1\":{\"18\":2,\"22\":1,\"23\":2,\"24\":1,\"26\":2}}],[\"null\",{\"1\":{\"18\":1,\"72\":3}}],[\"num\",{\"1\":{\"11\":4,\"31\":1,\"33\":2}}],[\"nums1\",{\"1\":{\"9\":1,\"30\":1}}],[\"nums\",{\"1\":{\"9\":1,\"10\":2,\"11\":4,\"12\":3,\"13\":2,\"14\":2,\"15\":3,\"20\":3,\"30\":2,\"31\":2,\"32\":10,\"33\":3}}],[\"n\",{\"1\":{\"12\":1,\"15\":1,\"21\":1,\"23\":1,\"25\":3,\"32\":1,\"36\":7,\"76\":2}}],[\"404\",{\"1\":{\"96\":1}}],[\"4\",{\"0\":{\"60\":1,\"81\":1,\"90\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":1,\"36\":2}}],[\"20\",{\"1\":{\"89\":2,\"90\":2}}],[\"2\",{\"0\":{\"58\":1,\"79\":1,\"88\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":1,\"34\":1,\"36\":2,\"79\":1}}],[\"3\",{\"0\":{\"59\":1,\"80\":1,\"89\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":5,\"36\":3}}],[\"1000\",{\"1\":{\"81\":1}}],[\"10\",{\"0\":{\"59\":1},\"1\":{\"34\":1,\"59\":1,\"78\":2,\"80\":2,\"81\":2,\"82\":2,\"83\":2,\"84\":2,\"85\":2,\"89\":1,\"90\":2}}],[\"1$\",{\"1\":{\"23\":1}}],[\"1\",{\"0\":{\"57\":1,\"78\":1,\"87\":1},\"1\":{\"9\":2,\"10\":1,\"11\":2,\"12\":2,\"14\":1,\"16\":1,\"20\":3,\"21\":1,\"23\":1,\"24\":1,\"25\":3,\"30\":1,\"31\":5,\"32\":2,\"36\":8,\"59\":1,\"72\":2,\"79\":1,\"80\":1,\"82\":4,\"83\":1,\"84\":1,\"85\":1,\"89\":2,\"90\":4}}],[\"==\",{\"1\":{\"14\":1,\"22\":1,\"23\":1,\"24\":1,\"72\":4,\"89\":2,\"90\":4}}],[\"=\",{\"1\":{\"9\":3,\"10\":2,\"11\":3,\"12\":2,\"13\":2,\"14\":1,\"15\":3,\"20\":9,\"21\":3,\"22\":3,\"23\":2,\"24\":3,\"30\":1,\"31\":2,\"33\":3,\"36\":6,\"58\":2,\"72\":5,\"78\":2,\"80\":4,\"81\":3,\"82\":2,\"83\":3,\"84\":1,\"85\":1,\"89\":8,\"90\":12}}],[\"5$\",{\"1\":{\"36\":1}}],[\"5\",{\"0\":{\"61\":1,\"82\":1,\"91\":1},\"1\":{\"9\":6,\"20\":2,\"30\":1,\"32\":1,\"36\":1}}],[\"0\",{\"0\":{\"59\":1},\"1\":{\"9\":1,\"10\":3,\"13\":2,\"14\":1,\"15\":1,\"20\":1,\"23\":1,\"24\":1,\"31\":2,\"33\":3,\"36\":3,\"59\":3,\"72\":12,\"76\":3,\"78\":2,\"79\":1,\"80\":2,\"81\":4,\"82\":2,\"83\":2,\"84\":2,\"85\":2,\"89\":5,\"90\":6}}],[\"我们往往更青睐使用数组实现算法\",{\"1\":{\"36\":1}}],[\"我们会发现两个数组中的相同数字拥有同一个\",{\"1\":{\"36\":1}}],[\"我们仍然可以在\",{\"1\":{\"36\":1}}],[\"我们不一定需要用这么多\",{\"1\":{\"36\":1}}],[\"我们维护一个指针变量始终指向头节点\",{\"1\":{\"36\":1}}],[\"我们规定每次将数组扩容至之前的\",{\"1\":{\"34\":1}}],[\"我们选择\",{\"1\":{\"34\":1}}],[\"我们尝试实现一个简易版列表\",{\"1\":{\"34\":1}}],[\"我们通常不能完全填满它们\",{\"1\":{\"36\":1}}],[\"我们通常使用\",{\"1\":{\"30\":1}}],[\"我们通常将头节点当作链表的代称\",{\"1\":{\"20\":1}}],[\"我们需要快速找到最近最少使用的数据\",{\"1\":{\"27\":1}}],[\"我们需要访问节点的父节点\",{\"1\":{\"27\":1}}],[\"我们就可以从链表的头节点出发\",{\"1\":{\"20\":1}}],[\"我们知道\",{\"1\":{\"18\":1}}],[\"我们既可以通过索引遍历数组\",{\"1\":{\"13\":1}}],[\"我们将把\",{\"1\":{\"28\":1}}],[\"我们将首个节点称为头节点\",{\"1\":{\"26\":1}}],[\"我们将这个问题的解决方案留在\",{\"1\":{\"11\":1}}],[\"我们将元素在数组中的位置称为该元素的索引\",{\"1\":{\"7\":1}}],[\"我们发现数组首个元素的索引为\",{\"1\":{\"10\":1}}],[\"我们可以定位列表尾部\",{\"1\":{\"34\":1}}],[\"我们可以使用\",{\"1\":{\"28\":1}}],[\"我们可以使用下图所示的公式计算得到该元素的内存地址\",{\"1\":{\"10\":1}}],[\"我们可以初始化一个比较长的数组\",{\"1\":{\"12\":1}}],[\"我们可以在\",{\"1\":{\"10\":1,\"23\":1}}],[\"我们可以根据需求选用数组的两种初始化方式\",{\"1\":{\"9\":1}}],[\"数量记录\",{\"1\":{\"34\":1}}],[\"数据操作效率基本一致\",{\"1\":{\"36\":1}}],[\"数据主要存储在内存中\",{\"1\":{\"35\":1}}],[\"数据流可能会被分成多个缓冲块并放入一个环形链表\",{\"1\":{\"27\":1}}],[\"数据缓冲区\",{\"1\":{\"27\":1}}],[\"数据结构实现\",{\"1\":{\"17\":1}}],[\"数据结构\",{\"0\":{\"4\":1},\"2\":{\"5\":1,\"37\":1}}],[\"数组内存地址\",{\"1\":{\"36\":1}}],[\"数组同时包含\",{\"1\":{\"36\":1}}],[\"数组存储在栈上和存储在堆上\",{\"1\":{\"36\":1}}],[\"数组存储在连续的内存空间内\",{\"1\":{\"16\":1}}],[\"数组可提供更高的内存空间效率\",{\"1\":{\"35\":1}}],[\"数组可以用于实现栈\",{\"1\":{\"17\":1}}],[\"数组支持随机访问\",{\"1\":{\"35\":1}}],[\"数组和链表是两种基本的数据结构\",{\"1\":{\"35\":1}}],[\"数组也支持元素增删查改\",{\"1\":{\"28\":1}}],[\"数组整体是一个变量\",{\"1\":{\"20\":1}}],[\"数组是神经网络编程中最常使用的数据结构\",{\"1\":{\"17\":1}}],[\"数组是排序和搜索算法最常用的数据结构\",{\"1\":{\"17\":1}}],[\"数组是一种基础且常见的数据结构\",{\"1\":{\"17\":1}}],[\"数组典型应用\",{\"0\":{\"17\":1}}],[\"数组在初始化后长度就固定了\",{\"1\":{\"16\":1}}],[\"数组允许在\",{\"1\":{\"16\":1}}],[\"数组为数据分配了连续的内存块\",{\"1\":{\"16\":1}}],[\"数组的优点与局限性\",{\"0\":{\"16\":1}}],[\"数组的长度是不可变的\",{\"1\":{\"15\":1}}],[\"数组的插入和删除的平均时间复杂度均为\",{\"1\":{\"12\":1}}],[\"数组的插入与删除操作有以下缺点\",{\"1\":{\"12\":1}}],[\"数组删除元素示例\",{\"1\":{\"12\":1}}],[\"数组插入元素示例\",{\"1\":{\"11\":1}}],[\"数组元素则必须是相同类型的\",{\"1\":{\"36\":1}}],[\"数组元素在内存中是\",{\"1\":{\"11\":1}}],[\"数组元素的内存地址计算\",{\"1\":{\"10\":1}}],[\"数组元素被存储在连续的内存空间中\",{\"1\":{\"10\":1}}],[\"数组常用操作\",{\"0\":{\"8\":1}}],[\"数组定义与存储方式\",{\"1\":{\"7\":1}}],[\"数组\",{\"0\":{\"7\":1,\"25\":1},\"1\":{\"7\":1,\"25\":1},\"2\":{\"38\":1}}],[\"数组与链表\",{\"0\":{\"6\":1},\"1\":{\"2\":1}}],[\"笔试题\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
