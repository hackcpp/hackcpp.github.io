const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":204,\"nextId\":204,\"documentIds\":{\"0\":\"0\",\"1\":\"0#面试集锦\",\"2\":\"0#数据结构\",\"3\":\"0#架构设计\",\"4\":\"0@1\",\"5\":\"1\",\"6\":\"1#入门推荐\",\"7\":\"1#进阶推荐\",\"8\":\"1@0\",\"9\":\"2\",\"10\":\"2#数组\",\"11\":\"2#数组常用操作\",\"12\":\"2#初始化数组\",\"13\":\"2#访问元素\",\"14\":\"2#插入元素\",\"15\":\"2#删除元素\",\"16\":\"2#遍历数组\",\"17\":\"2#查找元素\",\"18\":\"2#扩容数组\",\"19\":\"2#数组的优点与局限性\",\"20\":\"2#数组典型应用\",\"21\":\"2#链表\",\"22\":\"2#链表常用操作\",\"23\":\"2#初始化链表\",\"24\":\"2#插入节点\",\"25\":\"2#删除节点\",\"26\":\"2#访问节点\",\"27\":\"2#查找节点\",\"28\":\"2#数组-vs-链表\",\"29\":\"2#常见链表类型\",\"30\":\"2#链表典型应用\",\"31\":\"2#列表\",\"32\":\"2#列表常用操作\",\"33\":\"2#初始化列表\",\"34\":\"2#访问元素-1\",\"35\":\"2#插入与删除元素\",\"36\":\"2#遍历列表\",\"37\":\"2#列表实现\",\"38\":\"2#重点回顾\",\"39\":\"2#q-a\",\"40\":\"2@0\",\"41\":\"2@1\",\"42\":\"3\",\"43\":\"3#队列\",\"44\":\"3#队列常用操作\",\"45\":\"3#队列实现\",\"46\":\"3#基于链表的实现\",\"47\":\"3#基于数组的实现\",\"48\":\"3#队列典型应用\",\"49\":\"3#栈\",\"50\":\"3#栈的常用操作\",\"51\":\"3#栈的实现\",\"52\":\"3#基于链表的实现-1\",\"53\":\"3#基于数组的实现-1\",\"54\":\"3#两种实现对比\",\"55\":\"3#栈的典型应用\",\"56\":\"3#重点回顾\",\"57\":\"3#q-a\",\"58\":\"3@0\",\"59\":\"3@1\",\"60\":\"4\",\"61\":\"4#哈希表\",\"62\":\"4#哈希表常用操作\",\"63\":\"4#哈希表简单实现\",\"64\":\"4#哈希冲突与扩容\",\"65\":\"4#哈希冲突\",\"66\":\"4#链式地址\",\"67\":\"4#开放寻址\",\"68\":\"4#线性探测\",\"69\":\"4#平方探测\",\"70\":\"4#多次哈希\",\"71\":\"4#编程语言的选择\",\"72\":\"4#哈希算法\",\"73\":\"4#哈希算法的目标\",\"74\":\"4#哈希算法的设计\",\"75\":\"4#常见哈希算法\",\"76\":\"4#数据结构的哈希值\",\"77\":\"4#重点回顾\",\"78\":\"4#q-a\",\"79\":\"4@0\",\"80\":\"4@1\",\"81\":\"5\",\"82\":\"5#二叉树\",\"83\":\"5#二叉树常见术语\",\"84\":\"5#二叉树基本操作\",\"85\":\"5#初始化二叉树\",\"86\":\"5#插入与删除节点\",\"87\":\"5#常见二叉树类型\",\"88\":\"5#完美二叉树\",\"89\":\"5#完全二叉树\",\"90\":\"5#平衡二叉树\",\"91\":\"5#二叉树的退化\",\"92\":\"5#二叉搜索树\",\"93\":\"5#二叉搜索树的操作\",\"94\":\"5#查找节点\",\"95\":\"5#插入节点\",\"96\":\"5#删除节点\",\"97\":\"5#中序遍历有序\",\"98\":\"5#二叉搜索树的效率\",\"99\":\"5#二叉搜索树常见应用\",\"100\":\"5#avl-树\",\"101\":\"5#avl-树常见术语\",\"102\":\"5#节点高度\",\"103\":\"5#节点平衡因子\",\"104\":\"5#avl-树旋转\",\"105\":\"5#右旋\",\"106\":\"5#左旋\",\"107\":\"5#先左旋后右旋\",\"108\":\"5#先右旋后左旋\",\"109\":\"5#旋转的选择\",\"110\":\"5#avl-树常用操作\",\"111\":\"5#插入节点-1\",\"112\":\"5#删除节点-1\",\"113\":\"5#查找节点-1\",\"114\":\"5#avl-树典型应用\",\"115\":\"5#重点回顾\",\"116\":\"5#q-a\",\"117\":\"5@0\",\"118\":\"5@1\",\"119\":\"6\",\"120\":\"6@0\",\"121\":\"7\",\"122\":\"7#设计模式\",\"123\":\"7#设计原则\",\"124\":\"7#关于架构设计的一点思考\",\"125\":\"7@0\",\"126\":\"7@1\",\"127\":\"8\",\"128\":\"8@0\",\"129\":\"8@1\",\"130\":\"9\",\"131\":\"9#组成部分\",\"132\":\"9#例子\",\"133\":\"9@0\",\"134\":\"9@1\",\"135\":\"10\",\"136\":\"10@0\",\"137\":\"11\",\"138\":\"11#_1-static-关键字的作用\",\"139\":\"11#_2-new-delete与malloc-new的区别\",\"140\":\"11#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"141\":\"11#_4-宏与constexpr-区别\",\"142\":\"11#_5-extern-c\",\"143\":\"11#_6-const-关键字的作用\",\"144\":\"11@0\",\"145\":\"11@1\",\"146\":\"12\",\"147\":\"12#进程状态\",\"148\":\"12#进程的基本状态\",\"149\":\"12#进程状态之间的转换\",\"150\":\"12#状态转换示意图\",\"151\":\"12#僵尸进程\",\"152\":\"12#僵尸进程的影响\",\"153\":\"12#如何避免产生僵尸进程\",\"154\":\"12@0\",\"155\":\"12@1\",\"156\":\"13\",\"157\":\"13#如何创建线程\",\"158\":\"13#线程同步机制\",\"159\":\"13#_1-互斥量-mutex\",\"160\":\"13#_2-读写锁-shared-mutex\",\"161\":\"13#_3-条件变量-condition-variable\",\"162\":\"13#_4-原子操作-atomic-operations\",\"163\":\"13#_5-信号量-semaphore\",\"164\":\"13#_6-自旋锁-spinlock\",\"165\":\"13#_7-屏障-barrier\",\"166\":\"13#_8-锁存器-latch\",\"167\":\"13#死锁\",\"168\":\"13#无锁编程\",\"169\":\"13#_1-基本概念\",\"170\":\"13#_2-c-中的原子操作\",\"171\":\"13#_3-使用原子变量实现无锁队列\",\"172\":\"13#_4-代码结构和作用\",\"173\":\"13#_5-内存顺序-memory-order\",\"174\":\"13@0\",\"175\":\"13@1\",\"176\":\"14\",\"177\":\"14#新增线程编程相关模块\",\"178\":\"14#std-thread相关\",\"179\":\"14#std-mutex相关\",\"180\":\"14#std-lock相关\",\"181\":\"14#std-atomic相关\",\"182\":\"14#std-call-once相关\",\"183\":\"14#std-condition-variable相关\",\"184\":\"14#std-future相关\",\"185\":\"14#async相关\",\"186\":\"14#性能优化\",\"187\":\"14#内存管理-智能指针\",\"188\":\"14#右值引用和移动语义\",\"189\":\"14#容器新增-操作减少内存拷贝和移动\",\"190\":\"14#语法糖\",\"191\":\"14#可变模块参数\",\"192\":\"14#auto-自动推导\",\"193\":\"14#for-range-容器遍历\",\"194\":\"14#lamada-匿名函数\",\"195\":\"14#enum\",\"196\":\"14@0\",\"197\":\"14@1\",\"198\":\"15\",\"199\":\"15@0\",\"200\":\"16\",\"201\":\"16@0\",\"202\":\"17\",\"203\":\"18\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,10],\"1\":[1,3],\"2\":[1,3],\"3\":[1,3],\"4\":[null,null,1],\"5\":[1,6],\"6\":[1,17],\"7\":[1,25],\"8\":[null,null,1],\"9\":[1],\"10\":[1,8],\"11\":[1],\"12\":[1,23],\"13\":[1,38],\"14\":[1,35],\"15\":[1,49],\"16\":[1,19],\"17\":[1,23],\"18\":[1,36],\"19\":[1,30],\"20\":[1,37],\"21\":[1,69],\"22\":[1],\"23\":[1,37],\"24\":[1,27],\"25\":[1,30],\"26\":[1,36],\"27\":[1,26],\"28\":[3,22],\"29\":[1,42],\"30\":[1,59],\"31\":[1,49],\"32\":[1],\"33\":[1,21],\"34\":[1,17],\"35\":[1,29],\"36\":[1,18],\"37\":[1,37],\"38\":[1,38],\"39\":[2,215],\"40\":[null,null,1],\"41\":[null,null,4],\"42\":[1],\"43\":[1,17],\"44\":[1,34],\"45\":[1,6],\"46\":[1,78],\"47\":[1,127],\"48\":[1,15],\"49\":[1,21],\"50\":[1,45],\"51\":[1,13],\"52\":[1,73],\"53\":[1,49],\"54\":[1,56],\"55\":[1,16],\"56\":[1,21],\"57\":[2,55],\"58\":[null,null,1],\"59\":[null,null,3],\"60\":[1],\"61\":[1,54],\"62\":[1,54],\"63\":[1,117],\"64\":[1,75],\"65\":[1,27],\"66\":[1,152],\"67\":[1,12],\"68\":[1,186],\"69\":[1,26],\"70\":[1,32],\"71\":[1,29],\"72\":[1,35],\"73\":[1,60],\"74\":[1,110],\"75\":[1,61],\"76\":[1,95],\"77\":[1,70],\"78\":[2,85],\"79\":[null,null,1],\"80\":[null,null,3],\"81\":[1],\"82\":[1,58],\"83\":[1,50],\"84\":[1],\"85\":[1,23],\"86\":[1,26],\"87\":[1],\"88\":[1,21],\"89\":[1,9],\"90\":[1,7],\"91\":[1,40],\"92\":[1,15],\"93\":[1,6],\"94\":[1,59],\"95\":[1,72],\"96\":[1,102],\"97\":[1,25],\"98\":[1,28],\"99\":[1,8],\"100\":[3,50],\"101\":[2,10],\"102\":[1,44],\"103\":[1,33],\"104\":[2,24],\"105\":[1,53],\"106\":[1,46],\"107\":[1,11],\"108\":[1,10],\"109\":[1,56],\"110\":[2],\"111\":[1,42],\"112\":[1,45],\"113\":[1,4],\"114\":[2,12],\"115\":[1,60],\"116\":[2,138],\"117\":[null,null,1],\"118\":[null,null,1],\"119\":[1],\"120\":[null,null,1],\"121\":[1],\"122\":[1,16],\"123\":[1,40],\"124\":[1,17],\"125\":[null,null,1],\"126\":[null,null,3],\"127\":[1],\"128\":[null,null,1],\"129\":[null,null,4],\"130\":[1,9],\"131\":[1,8],\"132\":[1,9],\"133\":[null,null,1],\"134\":[null,null,3],\"135\":[1],\"136\":[null,null,1],\"137\":[2],\"138\":[4,10],\"139\":[5,17],\"140\":[9,21],\"141\":[4,7],\"142\":[4,23],\"143\":[4,8],\"144\":[null,null,1],\"145\":[null,null,1],\"146\":[1],\"147\":[1],\"148\":[1,29],\"149\":[1,37],\"150\":[1],\"151\":[1,32],\"152\":[1,12],\"153\":[2,102],\"154\":[null,null,1],\"155\":[null,null,3],\"156\":[1],\"157\":[2,71],\"158\":[1],\"159\":[1,62],\"160\":[1,78],\"161\":[1,90],\"162\":[1,64],\"163\":[1,74],\"164\":[4,78],\"165\":[1,61],\"166\":[1,64],\"167\":[1,32],\"168\":[1,11],\"169\":[2,26],\"170\":[3,13],\"171\":[2,80],\"172\":[2,131],\"173\":[1,26],\"174\":[null,null,1],\"175\":[null,null,3],\"176\":[2],\"177\":[1,14],\"178\":[2,94],\"179\":[2,53],\"180\":[2,55],\"181\":[2,32],\"182\":[3,31],\"183\":[3,50],\"184\":[2,74],\"185\":[1,111],\"186\":[1],\"187\":[1,25],\"188\":[1,47],\"189\":[2,54],\"190\":[1],\"191\":[1,20],\"192\":[1,17],\"193\":[1,20],\"194\":[1,6],\"195\":[1,33],\"196\":[null,null,1],\"197\":[null,null,3],\"198\":[1],\"199\":[null,null,1],\"200\":[1],\"201\":[null,null,1],\"202\":[1,3],\"203\":[1]},\"averageFieldLength\":[1.305445328057517,40.607351276795946,0.6349297667719312],\"storedFields\":{\"0\":{\"h\":\"首页\",\"t\":[\"本站是一个面向 c++ 程序员的知识库，主要包含一些基本的 c++ 面试题和数据结构算法。其目的在于帮助想学习 c++ 编程同学，掌握一些基本的算法和数据结构。主要有以下几部分：\"]},\"1\":{\"h\":\"面试集锦\",\"t\":[\"c++面试题\",\"线程编程\",\"进程编程\"]},\"2\":{\"h\":\"数据结构\",\"t\":[\"数组与链表\",\"队列与栈\",\"哈希表\"]},\"3\":{\"h\":\"架构设计\",\"t\":[\"设计原则\",\"观察者模式\",\"策略模式\"]},\"4\":{\"c\":[\"c++\"]},\"5\":{\"h\":\"书籍推荐\",\"t\":[\"推荐几本C++书籍，从入门，到进阶，到实战，一网打尽。\"]},\"6\":{\"h\":\"入门推荐\",\"t\":[\"C++ Primer\",\"前些年这本书可以说是C++入门必备，C++基础知识介绍的非常全面，缺点也很明显。。。就是是书太厚了-_-||\",\"C++20高级编程\",\"C++基础、C++进阶、C++20各种新特性、C++实战经验，本书都有涉及，内容丰富且有条理有深度，唯一的缺点，就是有点厚。\"]},\"7\":{\"h\":\"进阶推荐\",\"t\":[\"C++程序设计 进阶篇\",\"C++之父大作，关于C++，应该没谁比C++之父更有发言权吧，不过这本书我更推荐有一定基础，想提升C++达到进阶水平的朋友学习。\",\"Effective Modern C++\",\"本书介绍的多是C++11的新特性，如果C++98的朋友想进阶到C++11，推荐学习这本书。\",\"C++ Core Guidelines解析\",\"它的前身C++之父的很多心得经验的博客，英文不错的朋友可以直接看原文，国内有大佬把它翻译成了中文书籍，内容质量很高，推荐阅读。\",\"深入理解计算机系统\",\"C++不能只学习语言本身，还需要对操作系统有深刻的理解，操作系统我只推荐这一本书。\"]},\"8\":{\"c\":[\"书籍\"]},\"9\":{\"h\":\"数组与链表\"},\"10\":{\"h\":\"数组\",\"t\":[\"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。下图展示了数组的主要概念和存储方式。\",\"数组定义与存储方式\"]},\"11\":{\"h\":\"数组常用操作\"},\"12\":{\"h\":\"初始化数组\",\"t\":[\"我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 ：\",\"/* 初始化数组 */ // 存储在栈上 int arr[5]; int nums[5] = { 1, 3, 2, 5, 4 }; // 存储在堆上（需要手动释放空间） int* arr1 = new int[5]; int* nums1 = new int[5] { 1, 3, 2, 5, 4 };\"]},\"13\":{\"h\":\"访问元素\",\"t\":[\"数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问该元素。\",\"数组元素的内存地址计算\",\"观察上图，我们发现数组首个元素的索引为 0 ，这似乎有些反直觉，因为从 1 开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是 0 ，因此它的索引为 0 是合理的。\",\"在数组中访问元素非常高效，我们可以在 O(1) 时间内随机访问数组中的任意一个元素。\",\"/* 随机访问元素 */ int randomAccess(int *nums, int size) { // 在区间 [0, size) 中随机抽取一个数字 int randomIndex = rand() % size; // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum; }\"]},\"14\":{\"h\":\"插入元素\",\"t\":[\"数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。\",\"数组插入元素示例\",\"值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。\",\"/* 在数组的索引 index 处插入元素 num */ void insert(int *nums, int size, int num, int index) { // 把索引 index 以及之后的所有元素向后移动一位 for (int i = size - 1; i > index; i--) { nums[i] = nums[i - 1]; } // 将 num 赋给 index 处的元素 nums[index] = num; }\"]},\"15\":{\"h\":\"删除元素\",\"t\":[\"同理，如下图所示，若想删除索引 i 处的元素，则需要把索引 i 之后的元素都向前移动一位。\",\"数组删除元素示例\",\"请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。\",\"/* 删除索引 index 处的元素 */ void remove(int *nums, int size, int index) { // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i < size - 1; i++) { nums[i] = nums[i + 1]; } }\",\"总的来看，数组的插入与删除操作有以下缺点。\",\"时间复杂度高：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n 为数组长度。\",\"丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。\",\"内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。\"]},\"16\":{\"h\":\"遍历数组\",\"t\":[\"在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：\",\"/* 遍历数组 */ void traverse(int *nums, int size) { int count = 0; // 通过索引遍历数组 for (int i = 0; i < size; i++) { count += nums[i]; } }\"]},\"17\":{\"h\":\"查找元素\",\"t\":[\"在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。\",\"因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。\",\"/* 在数组中查找指定元素 */ int find(int *nums, int size, int target) { for (int i = 0; i < size; i++) { if (nums[i] == target) return i; } return -1; }\"]},\"18\":{\"h\":\"扩容数组\",\"t\":[\"在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的。\",\"如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。代码如下所示：\",\"/* 扩展数组长度 */ int *extend(int *nums, int size, int enlarge) { // 初始化一个扩展长度后的数组 int *res = new int[size + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i < size; i++) { res[i] = nums[i]; } // 释放内存 delete[] nums; // 返回扩展后的新数组 return res; }\"]},\"19\":{\"h\":\"数组的优点与局限性\",\"t\":[\"数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\",\"空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\",\"支持随机访问：数组允许在 O(1) 时间内访问任何元素。\",\"缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\",\"连续空间存储是一把双刃剑，其存在以下局限性。\",\"插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\",\"长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\",\"空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\"]},\"20\":{\"h\":\"数组典型应用\",\"t\":[\"数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\",\"随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\",\"排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\",\"查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\",\"机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\",\"数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\"]},\"21\":{\"h\":\"链表\",\"t\":[\"内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。\",\"链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。\",\"链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。\",\"链表定义与存储方式\",\"观察上图，链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\",\"链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\",\"尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\",\"在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\",\"如以下代码所示，链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间。\",\"/* 链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向下一节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数 };\"]},\"22\":{\"h\":\"链表常用操作\"},\"23\":{\"h\":\"初始化链表\",\"t\":[\"建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点。\",\" /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */ // 初始化各个节点 ListNode* n0 = new ListNode(1); ListNode* n1 = new ListNode(3); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(5); ListNode* n4 = new ListNode(4); // 构建节点之间的引用 n0->next = n1; n1->next = n2; n2->next = n3; n3->next = n4;\",\"数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0 。\"]},\"24\":{\"h\":\"插入节点\",\"t\":[\"在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为 O(1)。\",\"相比之下，在数组中插入元素的时间复杂度为 O(n) ，在大数据量下的效率较低。\",\"链表插入节点示例\",\"/* 在链表的节点 n0 之后插入节点 P */ void insert(ListNode *n0, ListNode *P) { ListNode *n1 = n0->next; P->next = n1; n0->next = P; }\"]},\"25\":{\"h\":\"删除节点\",\"t\":[\"如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。\",\"请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\",\"链表删除节点\",\"/* 删除链表的节点 n0 之后的首个节点 */ void remove(ListNode *n0) { if (n0->next == nullptr) return; // n0 -> P -> n1 ListNode *P = n0->next; ListNode *n1 = P->next; n0->next = n1; // 释放内存 delete P; }\"]},\"26\":{\"h\":\"访问节点\",\"t\":[\"在链表中访问节点的效率较低。如上一节所述，我们可以在 O(1) 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i 个节点需要循环 i−1 轮，时间复杂度为 O(n) 。\",\"/* 访问链表中索引为 index 的节点 */ ListNode *access(ListNode *head, int index) { for (int i = 0; i < index; i++) { if (head == nullptr) return nullptr; head = head->next; } return head; }\"]},\"27\":{\"h\":\"查找节点\",\"t\":[\"遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：\",\"/* 在链表中查找值为 target 的首个节点 */ int find(ListNode *head, int target) { int index = 0; while (head != nullptr) { if (head->val == target) return index; head = head->next; index++; } return -1; }\"]},\"28\":{\"h\":\"数组 vs. 链表\",\"t\":[\"下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。\",\"数组\",\"链表\",\"存储方式\",\"连续内存空间\",\"分散内存空间\",\"容量扩展\",\"长度不可变\",\"可灵活扩展\",\"内存效率\",\"元素占用内存少、但可能浪费空间\",\"元素占用内存多\",\"访问元素\",\"O(1)\",\"O(n)\",\"添加元素\",\"O(n)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(1)\"]},\"29\":{\"h\":\"常见链表类型\",\"t\":[\"如下图所示，常见的链表类型包括三种。\",\"单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\",\"环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\",\"双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\",\"/* 双向链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向后继节点的指针 ListNode *prev; // 指向前驱节点的指针 ListNode(int x) : val(x), next(nullptr), prev(nullptr) {} // 构造函数 };\",\"常见链表种类\"]},\"30\":{\"h\":\"链表典型应用\",\"t\":[\"单向链表通常用于实现栈、队列、哈希表和图等数据结构。\",\"栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。\",\"哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\",\"图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\",\"双向链表常用于需要快速查找前一个和后一个元素的场景。\",\"高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\",\"浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\",\"LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\",\"环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\",\"时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\",\"数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\"]},\"31\":{\"h\":\"列表\",\"t\":[\"列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。\",\"链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。\",\"数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。\",\"当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。\",\"为解决此问题，我们可以使用**动态数组（dynamic array）**来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\",\"实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。\"]},\"32\":{\"h\":\"列表常用操作\"},\"33\":{\"h\":\"初始化列表\",\"t\":[\"我们通常使用“无初始值”和“有初始值”这两种初始化方法：\",\"/* 初始化列表 */ // 需注意，C++ 中 vector 即是本文描述的 nums // 无初始值 vector<int> nums1; // 有初始值 vector<int> nums = { 1, 3, 2, 5, 4 };\"]},\"34\":{\"h\":\"访问元素\",\"t\":[\"列表本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。\",\" /* 访问元素 */ int num = nums[1]; // 访问索引 1 处的元素 /* 更新元素 */ nums[1] = 0; // 将索引 1 处的元素更新为 0\"]},\"35\":{\"h\":\"插入与删除元素\",\"t\":[\"相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。\",\"/* 清空列表 */ nums.clear(); /* 在尾部添加元素 */ nums.push_back(1); nums.push_back(3); nums.push_back(2); nums.push_back(5); nums.push_back(4); /* 在中间插入元素 */ nums.insert(nums.begin() + 3, 6); // 在索引 3 处插入数字 6 /* 删除元素 */ nums.erase(nums.begin() + 3); // 删除索引 3 处的元素\"]},\"36\":{\"h\":\"遍历列表\",\"t\":[\"与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。\",\" /* 通过索引遍历列表 */ int count = 0; for (int i = 0; i < nums.size(); i++) { count += nums[i]; } /* 直接遍历列表元素 */ count = 0; for (int num : nums) { count += num; }\"]},\"37\":{\"h\":\"列表实现\",\"t\":[\"许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。\",\"为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\",\"初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。\",\"数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\",\"扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。\"]},\"38\":{\"h\":\"重点回顾\",\"t\":[\"数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。\",\"数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。\",\"链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。\",\"列表是一种支持增删查改的元素有序集合，通常基于动态数组实现。它保留了数组的优势，同时可以灵活调整长度。\",\"列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。\",\"程序运行时，数据主要存储在内存中。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。\",\"缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。\",\"由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。\"]},\"39\":{\"h\":\"Q & A\",\"t\":[\"Q：数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？\",\"存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。\",\"分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。\",\"大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。\",\"灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。\",\"Q：为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？\",\"链表由节点组成，节点之间通过引用（指针）连接，各个节点可以存储不同类型的数据，例如 int、double、string、object 等。\",\"相对地，数组元素则必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节 和 8 字节 ，此时就不能用以下公式计算偏移量了，因为数组中包含了两种“元素长度”。\",\"# 元素内存地址 = 数组内存地址（首元素内存地址） + 元素长度 * 元素索引\",\"Q：删除节点 P 后，是否需要把 P.next 设为 None 呢？\",\"不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。\",\"从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。\",\"Q：在链表中插入和删除操作的时间复杂度是 O(1) 。但是增删之前都需要 O(n) 的时间查找元素，那为什么时间复杂度不是 O(n) 呢？\",\"如果是先查找元素、再删除元素，时间复杂度确实是 O(n) 。然而，链表的 O(1) 增删的优势可以在其他应用上得到体现。例如，双向队列适合使用链表实现，我们维护一个指针变量始终指向头节点、尾节点，每次插入与删除操作都是 O(1) 。\",\"Q：图“链表定义与存储方式”中，浅蓝色的存储节点指针是占用一块内存地址吗？还是和节点值各占一半呢？\",\"该示意图只是定性表示，定量表示需要根据具体情况进行分析。\",\"不同类型的节点值占用的空间是不同的，比如 int、long、double 和实例对象等。\",\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定，大多为 8 字节或 4 字节。\",\"Q：在列表末尾添加元素是否时时刻刻都为 O(1) ？\",\"如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 O(n) 。\",\"Q：“列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？\",\"这里的空间浪费主要有两方面含义：一方面，列表都会设定一个初始长度，我们不一定需要用这么多；另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 ×1.5 。这样一来，也会出现很多空位，我们通常不能完全填满它们。\",\"Q：在 Python 中初始化 n = [1, 2, 3] 后，这 3 个元素的地址是相连的，但是初始化 m = [2, 1, 3] 会发现它们每个元素的 id 并不是连续的，而是分别跟 n 中的相同。这些元素的地址不连续，那么 m 还是数组吗？\",\"假如把列表元素换成链表节点 n = [n1, n2, n3, n4, n5] ，通常情况下这 5 个节点对象也分散存储在内存各处。然而，给定一个列表索引，我们仍然可以在 O(1) 时间内获取节点内存地址，从而访问到对应的节点。这是因为数组中存储的是节点的引用，而非节点本身。\",\"与许多语言不同，Python 中的数字也被包装为对象，列表中存储的不是数字本身，而是对数字的引用。因此，我们会发现两个数组中的相同数字拥有同一个 id ，并且这些数字的内存地址无须连续。\",\"Q：C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？\",\"一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。\",\"空间开销：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以 std::list 通常比 std::vector 更占用空间。\",\"缓存不友好：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下，std::vector 的性能会更好。\",\"另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。\",\"Q：初始化列表 res = [0] * self.size() 操作，会导致 res 的每个元素引用相同的地址吗？\",\"不会。但二维数组会有这个问题，例如初始化二维列表 res = [[0]] * self.size() ，则多次引用了同一个列表 [0] 。\"]},\"40\":{\"c\":[\"数据结构\"]},\"41\":{\"c\":[\"c++\",\"线性结构\",\"数组\",\"链表\"]},\"42\":{\"h\":\"队列和栈\"},\"43\":{\"h\":\"队列\",\"t\":[\"队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\",\"如下图所示，我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。\",\"队列的先入先出规则\"]},\"44\":{\"h\":\"队列常用操作\",\"t\":[\"队列的常见操作如下表所示。需要注意的是，不同编程语言的方法名称可能会有所不同。我们在此采用与栈相同的方法命名。\",\"方法名\",\"描述\",\"时间复杂度\",\"push()\",\"元素入队，即将元素添加至队尾\",\"O(1)\",\"pop()\",\"队首元素出队\",\"O(1)\",\"peek()\",\"访问队首元素\",\"O(1)\",\"我们可以直接使用编程语言中现成的队列类：\",\" /* 初始化队列 */ queue<int> queue; /* 元素入队 */ queue.push(1); queue.push(3); queue.push(2); queue.push(5); queue.push(4); /* 访问队首元素 */ int front = queue.front(); /* 元素出队 */ queue.pop(); /* 获取队列的长度 */ int size = queue.size(); /* 判断队列是否为空 */ bool empty = queue.empty();\"]},\"45\":{\"h\":\"队列实现\",\"t\":[\"为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素，链表和数组都符合要求。\"]},\"46\":{\"h\":\"基于链表的实现\",\"t\":[\"如下图所示，我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。\",\"基于链表实现队列的入队出队操作\",\"linkedlist_queue_push\",\"linkedlist_queue_pop\",\"以下是用链表实现队列的代码：\",\"/* 基于链表实现的队列 */ class LinkedListQueue { private: ListNode *front, *rear; // 头节点 front ，尾节点 rear int queSize; public: LinkedListQueue() { front = nullptr; rear = nullptr; queSize = 0; } ~LinkedListQueue() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(front); } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return queSize == 0; } /* 入队 */ void push(int num) { // 在尾节点后添加 num ListNode *node = new ListNode(num); // 如果队列为空，则令头、尾节点都指向该节点 if (front == nullptr) { front = node; rear = node; } // 如果队列不为空，则将该节点添加到尾节点后 else { rear->next = node; rear = node; } queSize++; } /* 出队 */ int pop() { int num = peek(); // 删除头节点 ListNode *tmp = front; front = front->next; // 释放内存 delete tmp; queSize--; return num; } /* 访问队首元素 */ int peek() { if (size() == 0) throw out_of_range(\\\"队列为空\\\"); return front->val; } /* 将链表转化为 Vector 并返回 */ vector<int> toVector() { ListNode *node = front; vector<int> res(size()); for (int i = 0; i < res.size(); i++) { res[i] = node->val; node = node->next; } return res; } };\"]},\"47\":{\"h\":\"基于数组的实现\",\"t\":[\"在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。\",\"我们可以使用一个变量 front 指向队首元素的索引，并维护一个变量 size 用于记录队列长度。定义 rear = front + size ，这个公式计算出的 rear 指向队尾元素之后的下一个位置。\",\"基于此设计，数组中包含元素的有效区间为 [front, rear - 1]，各种操作的实现方法如下图所示。\",\"入队操作：将输入元素赋值给 rear 索引处，并将 size 增加 1 。\",\"出队操作：只需将 front 增加 1 ，并将 size 减少 1 。\",\"可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1) 。\",\"你可能会发现一个问题：在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。\",\"对于环形数组，我们需要让 front 或 rear 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示：\",\"/* 基于环形数组实现的队列 */ class ArrayQueue { private: int *nums; // 用于存储队列元素的数组 int front; // 队首指针，指向队首元素 int queSize; // 队列长度 int queCapacity; // 队列容量 public: ArrayQueue(int capacity) { // 初始化数组 nums = new int[capacity]; queCapacity = capacity; front = queSize = 0; } ~ArrayQueue() { delete[] nums; } /* 获取队列的容量 */ int capacity() { return queCapacity; } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return size() == 0; } /* 入队 */ void push(int num) { if (queSize == queCapacity) { cout << \\\"队列已满\\\" << endl; return; } // 计算队尾指针，指向队尾索引 + 1 // 通过取余操作实现 rear 越过数组尾部后回到头部 int rear = (front + queSize) % queCapacity; // 将 num 添加至队尾 nums[rear] = num; queSize++; } /* 出队 */ int pop() { int num = peek(); // 队首指针向后移动一位，若越过尾部，则返回到数组头部 front = (front + 1) % queCapacity; queSize--; return num; } /* 访问队首元素 */ int peek() { if (isEmpty()) throw out_of_range(\\\"队列为空\\\"); return nums[front]; } /* 将数组转化为 Vector 并返回 */ vector<int> toVector() { // 仅转换有效长度范围内的列表元素 vector<int> arr(queSize); for (int i = 0, j = front; i < queSize; i++, j++) { arr[i] = nums[j % queCapacity]; } return arr; } };\",\"以上实现的队列仍然具有局限性：其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的读者可以尝试自行实现。\",\"两种实现的对比结论与栈一致，在此不再赘述。\"]},\"48\":{\"h\":\"队列典型应用\",\"t\":[\"淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。\",\"各类待办事项。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。\"]},\"49\":{\"h\":\"栈\",\"t\":[\"栈（stack）是一种遵循先入后出逻辑的线性数据结构。\",\"我们可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。我们将盘子替换为各种类型的元素（如整数、字符、对象等），就得到了栈这种数据结构。\",\"如下图所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。\",\"栈的先入后出规则\"]},\"50\":{\"h\":\"栈的常用操作\",\"t\":[\"栈的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。在此，我们以常见的 push()、pop()、peek() 命名为例。\",\"方法\",\"描述\",\"时间复杂度\",\"push()\",\"元素入栈（添加至栈顶）\",\"O(1)\",\"pop()\",\"栈顶元素出栈\",\"O(1)\",\"peek()\",\"访问栈顶元素\",\"O(1)\",\"通常情况下，我们可以直接使用编程语言内置的栈类。然而，某些语言可能没有专门提供栈类，这时我们可以将该语言的“数组”或“链表”当作栈来使用，并在程序逻辑上忽略与栈无关的操作。\",\" /* 初始化栈 */ stack<int> stack; /* 元素入栈 */ stack.push(1); stack.push(3); stack.push(2); stack.push(5); stack.push(4); /* 访问栈顶元素 */ int top = stack.top(); /* 元素出栈 */ stack.pop(); // 无返回值 /* 获取栈的长度 */ int size = stack.size(); /* 判断是否为空 */ bool empty = stack.empty();\"]},\"51\":{\"h\":\"栈的实现\",\"t\":[\"为了深入了解栈的运行机制，我们来尝试自己实现一个栈类。\",\"栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素。然而，数组和链表都可以在任意位置添加和删除元素，因此栈可以视为一种受限制的数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。\"]},\"52\":{\"h\":\"基于链表的实现\",\"t\":[\"使用链表实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。\",\"如下图所示，对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。\",\"基于链表实现栈的入栈出栈操作\",\"linkedlist_stack_push\",\"linkedlist_stack_pop\",\"以下是基于链表实现栈的示例代码：\",\"/* 基于链表实现的栈 */ class LinkedListStack { private: ListNode *stackTop; // 将头节点作为栈顶 int stkSize; // 栈的长度 public: LinkedListStack() { stackTop = nullptr; stkSize = 0; } ~LinkedListStack() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(stackTop); } /* 获取栈的长度 */ int size() { return stkSize; } /* 判断栈是否为空 */ bool isEmpty() { return size() == 0; } /* 入栈 */ void push(int num) { ListNode *node = new ListNode(num); node->next = stackTop; stackTop = node; stkSize++; } /* 出栈 */ int pop() { int num = top(); ListNode *tmp = stackTop; stackTop = stackTop->next; // 释放内存 delete tmp; stkSize--; return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stackTop->val; } /* 将 List 转化为 Array 并返回 */ vector<int> toVector() { ListNode *node = stackTop; vector<int> res(size()); for (int i = res.size() - 1; i >= 0; i--) { res[i] = node->val; node = node->next; } return res; } };\"]},\"53\":{\"h\":\"基于数组的实现\",\"t\":[\"使用数组实现栈时，我们可以将数组的尾部作为栈顶。如下图所示，入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为 O(1) 。\",\"基于数组实现栈的入栈出栈操作\",\"array_stack_push\",\"array_stack_pop\",\"由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。以下为示例代码：\",\"/* 基于数组实现的栈 */ class ArrayStack { private: vector<int> stack; public: /* 获取栈的长度 */ int size() { return stack.size(); } /* 判断栈是否为空 */ bool isEmpty() { return stack.size() == 0; } /* 入栈 */ void push(int num) { stack.push_back(num); } /* 出栈 */ int pop() { int num = top(); stack.pop_back(); return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stack.back(); } /* 返回 Vector */ vector<int> toVector() { return stack; } };\"]},\"54\":{\"h\":\"两种实现对比\",\"t\":[\"支持操作\",\"两种实现都支持栈定义中的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到。\",\"时间效率\",\"在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为 O(n) 。\",\"在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。\",\"综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double ，我们可以得出以下结论。\",\"基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。\",\"基于链表实现的栈可以提供更加稳定的效率表现。\",\"空间效率\",\"在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费。\",\"然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。\",\"综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。\"]},\"55\":{\"h\":\"栈的典型应用\",\"t\":[\"浏览器中的后退与前进、软件中的撤销与反撤销。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。\",\"程序内存管理。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。\"]},\"56\":{\"h\":\"重点回顾\",\"t\":[\"栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。\",\"在时间效率方面，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 O(n) 。相比之下，栈的链表实现具有更为稳定的效率表现。\",\"在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。\",\"队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。\",\"双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。\"]},\"57\":{\"h\":\"Q & A\",\"t\":[\"Q：浏览器的前进后退是否是双向链表实现？\",\"浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便地实现一些额外操作，这个在“双向队列”章节有提到。\",\"Q：在出栈后，是否需要释放出栈节点的内存？\",\"如果后续仍需要使用弹出节点，则不需要释放内存。若之后不需要用到，Java 和 Python 等语言拥有自动垃圾回收机制，因此不需要手动释放内存；在 C 和 C++ 中需要手动释放内存。\",\"Q：双向队列像是两个栈拼接在了一起，它的用途是什么？\",\"双向队列就像是栈和队列的组合或两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。\",\"Q：撤销（undo）和反撤销（redo）具体是如何实现的？\",\"使用两个栈，栈 A 用于撤销，栈 B 用于反撤销。\",\"每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。\",\"当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。\",\"当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。\"]},\"58\":{\"c\":[\"数据结构\"]},\"59\":{\"c\":[\"c++\",\"栈\",\"队列\"]},\"60\":{\"h\":\"哈希表\"},\"61\":{\"h\":\"哈希表\",\"t\":[\"哈希表（hash table），又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在 O(1) 时间内获取对应的值 value 。\",\"如下图所示，给定 n 个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。\",\"哈希表的抽象表示\",\"除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。\",\"添加元素：仅需将元素添加至数组（链表）的尾部即可，使用 O(1) 时间。\",\"查询元素：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 O(n) 时间。\",\"删除元素：需要先查询到元素，再从数组（链表）中删除，使用 O(n) 时间。\",\"数组\",\"链表\",\"哈希表\",\"查找元素\",\"O(n)\",\"O(n)\",\"O(1)\",\"添加元素\",\"O(1)\",\"O(1)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(n)\",\"O(1)\",\"观察发现，在哈希表中进行增删查改的时间复杂度都是 O(1) ，非常高效。\"]},\"62\":{\"h\":\"哈希表常用操作\",\"t\":[\"哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对等，示例代码如下：\",\" /* 初始化哈希表 */ unordered_map<int, string> map; /* 添加操作 */ // 在哈希表中添加键值对 (key, value) map[12836] = \\\"小哈\\\"; map[15937] = \\\"小啰\\\"; map[16750] = \\\"小算\\\"; map[13276] = \\\"小法\\\"; map[10583] = \\\"小鸭\\\"; /* 查询操作 */ // 向哈希表中输入键 key ，得到值 value string name = map[15937]; /* 删除操作 */ // 在哈希表中删除键值对 (key, value) map.erase(10583);\",\"哈希表有三种常用的遍历方式：遍历键值对、遍历键和遍历值。示例代码如下：\",\" /* 遍历哈希表 */ // 遍历键值对 key->value for (auto kv: map) { cout << kv.first << \\\" -> \\\" << kv.second << endl; } // 使用迭代器遍历 key->value for (auto iter = map.begin(); iter != map.end(); iter++) { cout << iter->first << \\\"->\\\" << iter->second << endl; }\"]},\"63\":{\"h\":\"哈希表简单实现\",\"t\":[\"我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。\",\"那么，如何基于 key 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置。\",\"输入一个 key ，哈希函数的计算过程分为以下两步。\",\"通过某种哈希算法 hash() 计算得到哈希值。\",\"将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。\",\"index = hash(key) % capacity\",\"随后，我们就可以利用 index 在哈希表中访问对应的桶，从而获取 value 。\",\"设数组长度 capacity = 100、哈希算法 hash(key) = key ，易得哈希函数为 key % 100 。下图以 key 学号和 value 姓名为例，展示了哈希函数的工作原理。\",\"哈希函数工作原理\",\"以下代码实现了一个简单哈希表。其中，我们将 key 和 value 封装成一个类 Pair ，以表示键值对。\",\"/* 键值对 */ struct Pair { public: int key; string val; Pair(int key, string val) { this->key = key; this->val = val; } }; /* 基于数组实现的哈希表 */ class ArrayHashMap { private: vector<Pair *> buckets; public: ArrayHashMap() { // 初始化数组，包含 100 个桶 buckets = vector<Pair *>(100); } ~ArrayHashMap() { // 释放内存 for (const auto &bucket : buckets) { delete bucket; } buckets.clear(); } /* 哈希函数 */ int hashFunc(int key) { int index = key % 100; return index; } /* 查询操作 */ string get(int key) { int index = hashFunc(key); Pair *pair = buckets[index]; if (pair == nullptr) return \\\"\\\"; return pair->val; } /* 添加操作 */ void put(int key, string val) { Pair *pair = new Pair(key, val); int index = hashFunc(key); buckets[index] = pair; } /* 删除操作 */ void remove(int key) { int index = hashFunc(key); // 释放内存并置为 nullptr delete buckets[index]; buckets[index] = nullptr; } /* 获取所有键值对 */ vector<Pair *> pairSet() { vector<Pair *> pairSet; for (Pair *pair : buckets) { if (pair != nullptr) { pairSet.push_back(pair); } } return pairSet; } /* 获取所有键 */ vector<int> keySet() { vector<int> keySet; for (Pair *pair : buckets) { if (pair != nullptr) { keySet.push_back(pair->key); } } return keySet; } /* 获取所有值 */ vector<string> valueSet() { vector<string> valueSet; for (Pair *pair : buckets) { if (pair != nullptr) { valueSet.push_back(pair->val); } } return valueSet; } /* 打印哈希表 */ void print() { for (Pair *kv : pairSet()) { cout << kv->key << \\\" -> \\\" << kv->val << endl; } } };\"]},\"64\":{\"h\":\"哈希冲突与扩容\",\"t\":[\"从本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。\",\"对于上述示例中的哈希函数，当输入的 key 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：\",\"12836 % 100 = 36 20336 % 100 = 36\",\"如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为哈希冲突（hash collision）。\",\"哈希冲突示例\",\"容易想到，哈希表容量 n 越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。\",\"如下图所示，扩容前键值对 (136, A) 和 (236, D) 发生冲突，扩容后冲突消失。\",\"哈希表扩容\",\"类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\",\"负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表扩容至原先的 2 倍。\"]},\"65\":{\"h\":\"哈希冲突\",\"t\":[\"通常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。\",\"哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。\",\"改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\",\"仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\",\"哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。\"]},\"66\":{\"h\":\"链式地址\",\"t\":[\"在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。下图展示了一个链式地址哈希表的例子。\",\"链式地址哈希表\",\"基于链式地址实现的哈希表的操作方法发生了以下变化。\",\"查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对。\",\"添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\",\"删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\",\"链式地址存在以下局限性。\",\"占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。\",\"查询效率降低：因为需要线性遍历链表来查找对应元素。\",\"以下代码给出了链式地址哈希表的简单实现，需要注意两点。\",\"使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。\",\"以下实现包含哈希表扩容方法。当负载因子超过 32​ 时，我们将哈希表扩容至原先的 2 倍。\",\"/* 链式地址哈希表 */ class HashMapChaining { private: int size; // 键值对数量 int capacity; // 哈希表容量 double loadThres; // 触发扩容的负载因子阈值 int extendRatio; // 扩容倍数 vector<vector<Pair *>> buckets; // 桶数组 public: /* 构造方法 */ HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) { buckets.resize(capacity); } /* 析构方法 */ ~HashMapChaining() { for (auto &bucket : buckets) { for (Pair *pair : bucket) { // 释放内存 delete pair; } } } /* 哈希函数 */ int hashFunc(int key) { return key % capacity; } /* 负载因子 */ double loadFactor() { return (double)size / (double)capacity; } /* 查询操作 */ string get(int key) { int index = hashFunc(key); // 遍历桶，若找到 key ，则返回对应 val for (Pair *pair : buckets[index]) { if (pair->key == key) { return pair->val; } } // 若未找到 key ，则返回空字符串 return \\\"\\\"; } /* 添加操作 */ void put(int key, string val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor() > loadThres) { extend(); } int index = hashFunc(key); // 遍历桶，若遇到指定 key ，则更新对应 val 并返回 for (Pair *pair : buckets[index]) { if (pair->key == key) { pair->val = val; return; } } // 若无该 key ，则将键值对添加至尾部 buckets[index].push_back(new Pair(key, val)); size++; } /* 删除操作 */ void remove(int key) { int index = hashFunc(key); auto &bucket = buckets[index]; // 遍历桶，从中删除键值对 for (int i = 0; i < bucket.size(); i++) { if (bucket[i]->key == key) { Pair *tmp = bucket[i]; bucket.erase(bucket.begin() + i); // 从中删除键值对 delete tmp; // 释放内存 size--; return; } } } /* 扩容哈希表 */ void extend() { // 暂存原哈希表 vector<vector<Pair *>> bucketsTmp = buckets; // 初始化扩容后的新哈希表 capacity *= extendRatio; buckets.clear(); buckets.resize(capacity); size = 0; // 将键值对从原哈希表搬运至新哈希表 for (auto &bucket : bucketsTmp) { for (Pair *pair : bucket) { put(pair->key, pair->val); // 释放内存 delete pair; } } } /* 打印哈希表 */ void print() { for (auto &bucket : buckets) { cout << \\\"[\\\"; for (Pair *pair : bucket) { cout << pair->key << \\\" -> \\\" << pair->val << \\\", \\\"; } cout << \\\"]\\\\n\\\"; } } };\",\"值得注意的是，当链表很长时，查询效率 O(n) 很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至 O(logn) 。\"]},\"67\":{\"h\":\"开放寻址\",\"t\":[\"开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\",\"下面以线性探测为例，介绍开放寻址哈希表的工作机制。\"]},\"68\":{\"h\":\"线性探测\",\"t\":[\"线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。\",\"插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。\",\"查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。\",\"下图展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 key 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。\",\"开放寻址（线性探测）哈希表的键值对分布\",\"然而，线性探测容易产生“聚集现象”。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。\",\"值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如下图所示。\",\"在开放寻址中删除元素导致的查询问题\",\"为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。\",\"然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素。\",\"为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。\",\"以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。\",\" /* 开放寻址哈希表 */ class HashMapOpenAddressing { private: int size; // 键值对数量 int capacity = 4; // 哈希表容量 const double loadThres = 2.0 / 3.0; // 触发扩容的负载因子阈值 const int extendRatio = 2; // 扩容倍数 vector<Pair *> buckets; // 桶数组 Pair *TOMBSTONE = new Pair(-1, \\\"-1\\\"); // 删除标记 public: /* 构造方法 */ HashMapOpenAddressing() : size(0), buckets(capacity, nullptr) { } /* 析构方法 */ ~HashMapOpenAddressing() { for (Pair *pair : buckets) { if (pair != nullptr && pair != TOMBSTONE) { delete pair; } } delete TOMBSTONE; } /* 哈希函数 */ int hashFunc(int key) { return key % capacity; } /* 负载因子 */ double loadFactor() { return (double)size / capacity; } /* 搜索 key 对应的桶索引 */ int findBucket(int key) { int index = hashFunc(key); int firstTombstone = -1; // 线性探测，当遇到空桶时跳出 while (buckets[index] != nullptr) { // 若遇到 key ，返回对应的桶索引 if (buckets[index]->key == key) { // 若之前遇到了删除标记，则将键值对移动至该索引处 if (firstTombstone != -1) { buckets[firstTombstone] = buckets[index]; buckets[index] = TOMBSTONE; return firstTombstone; // 返回移动后的桶索引 } return index; // 返回桶索引 } // 记录遇到的首个删除标记 if (firstTombstone == -1 && buckets[index] == TOMBSTONE) { firstTombstone = index; } // 计算桶索引，越过尾部则返回头部 index = (index + 1) % capacity; } // 若 key 不存在，则返回添加点的索引 return firstTombstone == -1 ? index : firstTombstone; } /* 查询操作 */ string get(int key) { // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则返回对应 val if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { return buckets[index]->val; } // 若键值对不存在，则返回空字符串 return \\\"\\\"; } /* 添加操作 */ void put(int key, string val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor() > loadThres) { extend(); } // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则覆盖 val 并返回 if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { buckets[index]->val = val; return; } // 若键值对不存在，则添加该键值对 buckets[index] = new Pair(key, val); size++; } /* 删除操作 */ void remove(int key) { // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则用删除标记覆盖它 if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { delete buckets[index]; buckets[index] = TOMBSTONE; size--; } } /* 扩容哈希表 */ void extend() { // 暂存原哈希表 vector<Pair *> bucketsTmp = buckets; // 初始化扩容后的新哈希表 capacity *= extendRatio; buckets = vector<Pair *>(capacity, nullptr); size = 0; // 将键值对从原哈希表搬运至新哈希表 for (Pair *pair : bucketsTmp) { if (pair != nullptr && pair != TOMBSTONE) { put(pair->key, pair->val); delete pair; } } } /* 打印哈希表 */ void print() { for (Pair *pair : buckets) { if (pair == nullptr) { cout << \\\"nullptr\\\" << endl; } else if (pair == TOMBSTONE) { cout << \\\"TOMBSTONE\\\" << endl; } else { cout << pair->key << \\\" -> \\\" << pair->val << endl; } } } };\"]},\"69\":{\"h\":\"平方探测\",\"t\":[\"平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。\",\"平方探测主要具有以下优势。\",\"平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。\",\"平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。\",\"然而，平方探测并不是完美的。\",\"仍然存在聚集现象，即某些位置比其他位置更容易被占用。\",\"由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。\"]},\"70\":{\"h\":\"多次哈希\",\"t\":[\"顾名思义，多次哈希方法使用多个哈希函数 f1​(x)、f2​(x)、f3​(x)、… 进行探测。\",\"插入元素：若哈希函数 f1​(x) 出现冲突，则尝试 f2​(x) ，以此类推，直到找到空位后插入元素。\",\"查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None 。\",\"与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。\",\"相关信息\",\"请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。\"]},\"71\":{\"h\":\"编程语言的选择\",\"t\":[\"各种编程语言采取了不同的哈希表实现策略，下面举几个例子。\",\"Python 采用开放寻址。字典 dict 使用伪随机数进行探测。\",\"Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。\",\"Go 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。\"]},\"72\":{\"h\":\"哈希算法\",\"t\":[\"前两节介绍了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生。\",\"如果哈希冲突过于频繁，哈希表的性能则会急剧劣化。如下图所示，对于链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都存储到同一个桶中，时间复杂度退化至 O(n) 。\",\"哈希冲突的最佳情况与最差情况\",\"键值对的分布情况由哈希函数决定。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：\",\"index = hash(key) % capacity\",\"观察以上公式，当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值，进而决定了键值对在哈希表中的分布情况。\",\"这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法 hash() 的设计上。\"]},\"73\":{\"h\":\"哈希算法的目标\",\"t\":[\"为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。\",\"确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。\",\"效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。\",\"均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。\",\"实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。\",\"密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。\",\"数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。\",\"对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。\",\"单向性：无法通过哈希值反推出关于输入数据的任何信息。\",\"抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同。\",\"雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化。\",\"请注意，“均匀分布”与“抗碰撞性”是两个独立的概念，满足均匀分布不一定满足抗碰撞性。例如，在随机输入 key 下，哈希函数 key % 100 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的 key 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 key ，从而破解密码。\"]},\"74\":{\"h\":\"哈希算法的设计\",\"t\":[\"哈希算法的设计是一个需要考虑许多因素的复杂问题。然而对于某些要求不高的场景，我们也能设计一些简单的哈希算法。\",\"加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。\",\"乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。\",\"异或哈希：将输入数据的每个元素通过异或操作累积到一个哈希值中。\",\"旋转哈希：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。\",\"/* 旋转哈希 */ int rotHash(string key) { long long hash = 0; const int MODULUS = 1000000007; for (unsigned char c : key) { hash = ((hash << 4) ^ (hash >> 28) ^ (int)c) % MODULUS; } return (int)hash; }\",\"观察发现，每种哈希算法的最后一步都是对大质数 1000000007 取模，以确保哈希值在合适的范围内。值得思考的是，为什么要强调对质数取模，或者说对合数取模的弊端是什么？这是一个有趣的问题。\",\"先抛出结论：使用大质数作为模数，可以最大化地保证哈希值的均匀分布。因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突。\",\"举个例子，假设我们选择合数 9 作为模数，它可以被 3 整除，那么所有可以被 3 整除的 key 都会被映射到 0、3、6 这三个哈希值。\",\"moduluskeyhash​=9={0,3,6,9,12,15,18,21,24,27,30,33,…}={0,3,6,0,3,6,0,3,6,0,3,6,…}​\",\"如果输入 key 恰好满足这种等差数列的数据分布，那么哈希值就会出现聚堆，从而加重哈希冲突。现在，假设将 modulus 替换为质数 13 ，由于 key 和 modulus 之间不存在公约数，因此输出的哈希值的均匀性会明显提升。\",\"moduluskeyhash​=13={0,3,6,9,12,15,18,21,24,27,30,33,…}={0,3,6,9,12,2,5,8,11,1,4,7,…}​\",\"值得说明的是，如果能够保证 key 是随机均匀分布的，那么选择质数或者合数作为模数都可以，它们都能输出均匀分布的哈希值。而当 key 的分布存在某种周期性时，对合数取模更容易出现聚集现象。\",\"总而言之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性模式，提升哈希算法的稳健性。\"]},\"75\":{\"h\":\"常见哈希算法\",\"t\":[\"不难发现，以上介绍的简单哈希算法都比较“脆弱”，远远没有达到哈希算法的设计目标。例如，由于加法和异或满足交换律，因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串，这可能会加剧哈希冲突，并引起一些安全问题。\",\"在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2 和 SHA-3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。\",\"近一个世纪以来，哈希算法处在不断升级与优化的过程中。一部分研究人员努力提升哈希算法的性能，另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题。下表展示了在实际应用中常见的哈希算法。\",\"MD5 和 SHA-1 已多次被成功攻击，因此它们被各类安全应用弃用。\",\"SHA-2 系列中的 SHA-256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常用在各类安全应用与协议中。\",\"SHA-3 相较 SHA-2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA-2 系列。\",\"MD5\",\"SHA-1\",\"SHA-2\",\"SHA-3\",\"推出时间\",\"1992\",\"1995\",\"2002\",\"2008\",\"输出长度\",\"128 bit\",\"160 bit\",\"256/512 bit\",\"224/256/384/512 bit\",\"哈希冲突\",\"较多\",\"较多\",\"很少\",\"很少\",\"安全等级\",\"低，已被成功攻击\",\"低，已被成功攻击\",\"高\",\"高\",\"应用\",\"已被弃用，仍用于数据完整性检查\",\"已被弃用\",\"加密货币交易验证、数字签名等\",\"可用于替代 SHA-2\"]},\"76\":{\"h\":\"数据结构的哈希值\",\"t\":[\"我们知道，哈希表的 key 可以是整数、小数或字符串等数据类型。编程语言通常会为这些数据类型提供内置的哈希算法，用于计算哈希表中的桶索引。以 Python 为例，我们可以调用 hash() 函数来计算各种数据类型的哈希值。\",\"整数和布尔量的哈希值就是其本身。\",\"浮点数和字符串的哈希值计算较为复杂，有兴趣的读者请自行学习。\",\"元组的哈希值是对其中每一个元素进行哈希，然后将这些哈希值组合起来，得到单一的哈希值。\",\"对象的哈希值基于其内存地址生成。通过重写对象的哈希方法，可实现基于内容生成哈希值。\",\"相关信息\",\"请注意，不同编程语言的内置哈希值计算函数的定义和方法不同。\",\" int num = 3; size_t hashNum = hash<int>()(num); // 整数 3 的哈希值为 3 bool bol = true; size_t hashBol = hash<bool>()(bol); // 布尔量 1 的哈希值为 1 double dec = 3.14159; size_t hashDec = hash<double>()(dec); // 小数 3.14159 的哈希值为 4614256650576692846 string str = \\\"Hello 算法\\\"; size_t hashStr = hash<string>()(str); // 字符串“Hello 算法”的哈希值为 15466937326284535026 // 在 C++ 中，内置 std:hash() 仅提供基本数据类型的哈希值计算 // 数组、对象的哈希值计算需要自行实现\",\"在许多编程语言中，只有不可变对象才可作为哈希表的 key 。假如我们将列表（动态数组）作为 key ，当列表的内容发生变化时，它的哈希值也随之改变，我们就无法在哈希表中查询到原先的 value 了。\",\"虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。这是因为对象的哈希值通常是基于内存地址生成的，即使对象的内容发生了变化，但它的内存地址不变，哈希值仍然是不变的。\",\"细心的你可能发现在不同控制台中运行程序时，输出的哈希值是不同的。这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。\"]},\"77\":{\"h\":\"重点回顾\",\"t\":[\"输入 key ，哈希表能够在 O(1) 时间内查询到 value ，效率非常高。\",\"常见的哈希表操作包括查询、添加键值对、删除键值对和遍历哈希表等。\",\"哈希函数将 key 映射为数组索引，从而访问对应桶并获取 value 。\",\"两个不同的 key 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为哈希冲突。\",\"哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。\",\"负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。\",\"链式地址通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以通过进一步将链表转换为红黑树来提高效率。\",\"开放寻址通过多次探测来处理哈希冲突。线性探测使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。\",\"不同编程语言采取了不同的哈希表实现。例如，Java 的 HashMap 使用链式地址，而 Python 的 Dict 采用开放寻址。\",\"在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。\",\"哈希算法通常采用大质数作为模数，以最大化地保证哈希值均匀分布，减少哈希冲突。\",\"常见的哈希算法包括 MD5、SHA-1、SHA-2 和 SHA-3 等。MD5 常用于校验文件完整性，SHA-2 常用于安全应用与协议。\",\"编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。\"]},\"78\":{\"h\":\"Q & A\",\"t\":[\"Q：哈希表的时间复杂度在什么情况下是 O(n) ？\",\"当哈希冲突比较严重时，哈希表的时间复杂度会退化至 O(n) 。当哈希函数设计得比较好、容量设置比较合理、冲突比较平均时，时间复杂度是 O(1) 。我们使用编程语言内置的哈希表时，通常认为时间复杂度是 O(1) 。\",\"Q：为什么不使用哈希函数 f(x)=x 呢？这样就不会有冲突了。\",\"在 f(x)=x 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而，输入空间通常远大于输出空间（数组长度），因此哈希函数的最后一步往往是对数组长度取模。换句话说，哈希表的目标是将一个较大的状态空间映射到一个较小的空间，并提供 O(1) 的查询效率。\",\"Q：哈希表底层实现是数组、链表、二叉树，但为什么效率可以比它们更高呢？\",\"首先，哈希表的时间效率变高，但空间效率变低了。哈希表有相当一部分内存未使用。\",\"其次，只是在特定使用场景下时间效率变高了。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，那么通常比哈希表更快。这是因为哈希函数计算需要开销，时间复杂度的常数项更大。\",\"最后，哈希表的时间复杂度可能发生劣化。例如在链式地址中，我们采取在链表或红黑树中执行查找操作，仍然有退化至 O(n) 时间的风险。\",\"Q：多次哈希有不能直接删除元素的缺陷吗？标记为已删除的空间还能再次使用吗？\",\"多次哈希是开放寻址的一种，开放寻址法都有不能直接删除元素的缺陷，需要通过标记删除。标记为已删除的空间可以再次使用。当将新元素插入哈希表，并且通过哈希函数找到标记为已删除的位置时，该位置可以被新元素使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。\",\"Q：为什么在线性探测中，查找元素的时候会出现哈希冲突呢？\",\"查找的时候通过哈希函数找到对应的桶和键值对，发现 key 不匹配，这就代表有哈希冲突。因此，线性探测法会根据预先设定的步长依次向下查找，直至找到正确的键值对或无法找到跳出为止。\",\"Q：为什么哈希表扩容能够缓解哈希冲突？\",\"哈希函数的最后一步往往是对数组长度 n 取模（取余），让输出值落在数组索引范围内；在扩容后，数组长度 n 发生变化，而 key 对应的索引也可能发生变化。原先落在同一个桶的多个 key ，在扩容后可能会被分配到多个桶中，从而实现哈希冲突的缓解。\"]},\"79\":{\"c\":[\"数据结构\"]},\"80\":{\"c\":[\"c++\",\"hash\",\"哈希表\"]},\"81\":{\"h\":\"二叉树\"},\"82\":{\"h\":\"二叉树\",\"t\":[\"二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。\",\" /* 二叉树节点结构体 */ struct TreeNode { int val; // 节点值 TreeNode *left; // 左子节点指针 TreeNode *right; // 右子节点指针 TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\",\"每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\",\"在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。如下图所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。\",\"父节点、子节点、子树\"]},\"83\":{\"h\":\"二叉树常见术语\",\"t\":[\"二叉树的常用术语如下图所示。\",\"根节点（root node）：位于二叉树顶层的节点，没有父节点。\",\"叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。\",\"边（edge）：连接两个节点的线段，即节点引用（指针）。\",\"节点所在的层（level）：从顶至底递增，根节点所在层为 1 。\",\"节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\",\"二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。\",\"节点的深度（depth）：从根节点到该节点所经过的边的数量。\",\"节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。\",\"二叉树的常用术语\",\"相关信息\",\"请注意，我们通常将“高度”和“深度”定义为“经过的边的数量”，但有些题目或教材可能会将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要加 1 。\"]},\"84\":{\"h\":\"二叉树基本操作\"},\"85\":{\"h\":\"初始化二叉树\",\"t\":[\"与链表类似，首先初始化节点，然后构建引用（指针）。\",\" /* 初始化二叉树 */ // 初始化节点 TreeNode* n1 = new TreeNode(1); TreeNode* n2 = new TreeNode(2); TreeNode* n3 = new TreeNode(3); TreeNode* n4 = new TreeNode(4); TreeNode* n5 = new TreeNode(5); // 构建节点之间的引用（指针） n1->left = n2; n1->right = n3; n2->left = n4; n2->right = n5;\"]},\"86\":{\"h\":\"插入与删除节点\",\"t\":[\"与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例。\",\"在二叉树中插入与删除节点\",\" /* 插入与删除节点 */ TreeNode* P = new TreeNode(0); // 在 n1 -> n2 中间插入节点 P n1->left = P; P->left = n2; // 删除节点 P n1->left = n2;\",\"相关信息\",\"需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除通常是由一套操作配合完成的，以实现有实际意义的操作。\"]},\"87\":{\"h\":\"常见二叉树类型\"},\"88\":{\"h\":\"完美二叉树\",\"t\":[\"如下图所示，完美二叉树（perfect binary tree）所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树的高度为 h ，则节点总数为 2h+1−1 ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。\",\"相关信息\",\"请注意，在中文社区中，完美二叉树常被称为满二叉树。 \",\"完美二叉树\"]},\"89\":{\"h\":\"完全二叉树\",\"t\":[\"如下图所示，完全二叉树（complete binary tree）只有最底层的节点未被填满，且最底层节点尽量靠左填充。请注意，完美二叉树也是一棵完全二叉树。\",\"完全二叉树\"]},\"90\":{\"h\":\"平衡二叉树\",\"t\":[\"如下图所示，平衡二叉树（balanced binary tree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\",\"平衡二叉树\"]},\"91\":{\"h\":\"二叉树的退化\",\"t\":[\"下图展示了二叉树的理想结构与退化结构。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\",\"完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\",\"链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n) 。\",\"二叉树的最佳结构与最差结构\",\"如下表所示，在最佳结构和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大值或极小值。\",\"完美二叉树\",\"链表\",\"第 i 层的节点数量\",\"2i−1\",\"1\",\"高度为 h 的树的叶节点数量\",\"2h\",\"1\",\"高度为 h 的树的节点总数\",\"2h+1−1\",\"h+1\",\"节点总数为 n 的树的高度\",\"log2​(n+1)−1\",\"n−1\"]},\"92\":{\"h\":\"二叉搜索树\",\"t\":[\"如下图所示，二叉搜索树（binary search tree）满足以下条件。\",\"对于根节点，左子树中所有节点的值 < 根节点的值 < 右子树中所有节点的值。\",\"任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。\",\"二叉搜索树\"]},\"93\":{\"h\":\"二叉搜索树的操作\",\"t\":[\"我们将二叉搜索树封装为一个类 BinarySearchTree ，并声明一个成员变量 root ，指向树的根节点。\"]},\"94\":{\"h\":\"查找节点\",\"t\":[\"给定目标节点值 num ，可以根据二叉搜索树的性质来查找。如下图所示，我们声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系。\",\"若 cur.val < num ，说明目标节点在 cur 的右子树中，因此执行 cur = cur.right 。\",\"若 cur.val > num ，说明目标节点在 cur 的左子树中，因此执行 cur = cur.left 。\",\"若 cur.val = num ，说明找到目标节点，跳出循环并返回该节点。\",\"二叉搜索树查找节点示例\",\"bst_search_step2\",\"bst_search_step3\",\"bst_search_step4\",\"二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 O(logn) 时间。示例代码如下：\",\"/* 查找节点 */ TreeNode *search(int num) { TreeNode *cur = root; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 目标节点在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 目标节点在 cur 的左子树中 else if (cur->val > num) cur = cur->left; // 找到目标节点，跳出循环 else break; } // 返回目标节点 return cur; }\"]},\"95\":{\"h\":\"插入节点\",\"t\":[\"给定一个待插入元素 num ，为了保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，插入操作流程如下图所示。\",\"查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。\",\"在该位置插入节点：初始化节点 num ，将该节点置于 None 的位置。\",\"在二叉搜索树中插入节点\",\"在代码实现中，需要注意以下两点。\",\"二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。\",\"为了实现插入节点，我们需要借助节点 pre 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。\",\"/* 插入节点 */ void insert(int num) { // 若树为空，则初始化根节点 if (root == nullptr) { root = new TreeNode(num); return; } TreeNode *cur = root, *pre = nullptr; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 找到重复节点，直接返回 if (cur->val == num) return; pre = cur; // 插入位置在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 插入位置在 cur 的左子树中 else cur = cur->left; } // 插入节点 TreeNode *node = new TreeNode(num); if (pre->val < num) pre->right = node; else pre->left = node; }\",\"与查找节点相同，插入节点使用 O(logn) 时间。\"]},\"96\":{\"h\":\"删除节点\",\"t\":[\"先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 < 根节点 < 右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。\",\"如下图所示，当待删除节点的度为 0 时，表示该节点是叶节点，可以直接删除。\",\"在二叉搜索树中删除节点（度为 0 ）\",\"如下图所示，当待删除节点的度为 1 时，将待删除节点替换为其子节点即可。\",\"在二叉搜索树中删除节点（度为 1 ）\",\"当待删除节点的度为 2 时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，因此这个节点可以是右子树的最小节点或左子树的最大节点。\",\"假设我们选择右子树的最小节点（中序遍历的下一个节点），则删除操作流程如下图所示。\",\"找到待删除节点在“中序遍历序列”中的下一个节点，记为 tmp 。\",\"用 tmp 的值覆盖待删除节点的值，并在树中递归删除节点 tmp 。\",\"在二叉搜索树中删除节点（度为 2 ）\",\"bst_remove_case3_step2\",\"bst_remove_case3_step3\",\"bst_remove_case3_step4\",\"删除节点操作同样使用 O(logn) 时间，其中查找待删除节点需要 O(logn) 时间，获取中序遍历后继节点需要 O(logn) 时间。示例代码如下：\",\" /* 删除节点 */ void remove(int num) { // 若树为空，直接提前返回 if (root == nullptr) return; TreeNode *cur = root, *pre = nullptr; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 找到待删除节点，跳出循环 if (cur->val == num) break; pre = cur; // 待删除节点在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 待删除节点在 cur 的左子树中 else cur = cur->left; } // 若无待删除节点，则直接返回 if (cur == nullptr) return; // 子节点数量 = 0 or 1 if (cur->left == nullptr || cur->right == nullptr) { // 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点 TreeNode *child = cur->left != nullptr ? cur->left : cur->right; // 删除节点 cur if (cur != root) { if (pre->left == cur) pre->left = child; else pre->right = child; } else { // 若删除节点为根节点，则重新指定根节点 root = child; } // 释放内存 delete cur; } // 子节点数量 = 2 else { // 获取中序遍历中 cur 的下一个节点 TreeNode *tmp = cur->right; while (tmp->left != nullptr) { tmp = tmp->left; } int tmpVal = tmp->val; // 递归删除节点 tmp remove(tmp->val); // 用 tmp 覆盖 cur cur->val = tmpVal; } }\"]},\"97\":{\"h\":\"中序遍历有序\",\"t\":[\"如下图所示，二叉树的中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 < 根节点 < 右子节点”的大小关系。\",\"这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：二叉搜索树的中序遍历序列是升序的。\",\"利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 O(n) 时间，无须进行额外的排序操作，非常高效。\",\"二叉搜索树的中序遍历序列\"]},\"98\":{\"h\":\"二叉搜索树的效率\",\"t\":[\"给定一组数据，我们考虑使用数组或二叉搜索树存储。观察下表，二叉搜索树的各项操作的时间复杂度都是对数阶，具有稳定且高效的性能。只有在高频添加、低频查找删除数据的场景下，数组比二叉搜索树的效率更高。\",\"无序数组\",\"二叉搜索树\",\"查找元素\",\"O(n)\",\"O(logn)\",\"插入元素\",\"O(1)\",\"O(logn)\",\"删除元素\",\"O(n)\",\"O(logn)\",\"在理想情况下，二叉搜索树是“平衡”的，这样就可以在 logn 轮循环内查找任意节点。\",\"然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为下图所示的链表，这时各种操作的时间复杂度也会退化为 O(n) 。\",\"二叉搜索树退化\"]},\"99\":{\"h\":\"二叉搜索树常见应用\",\"t\":[\"用作系统中的多级索引，实现高效的查找、插入、删除操作。\",\"作为某些搜索算法的底层数据结构。\",\"用于存储数据流，以保持其有序状态。\"]},\"100\":{\"h\":\"AVL 树 *\",\"t\":[\"在“二叉搜索树”章节中我们提到，在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从 O(logn) 劣化为 O(n) 。\",\"如下图所示，经过两次删除节点操作，这棵二叉搜索树便会退化为链表。\",\"AVL 树在删除节点后发生退化\",\"再例如，在下图所示的完美二叉树中插入两个节点后，树将严重向左倾斜，查找操作的时间复杂度也随之劣化。\",\"AVL 树在插入节点后发生退化\",\"1962 年 G. M. Adelson-Velsky 和 E. M. Landis 在论文“An algorithm for the organization of information”中提出了 AVL 树。论文中详细描述了一系列操作，确保在持续添加和删除节点后，AVL 树不会退化，从而使得各种操作的时间复杂度保持在 O(logn) 级别。换句话说，在需要频繁进行增删查改操作的场景中，AVL 树能始终保持高效的数据操作性能，具有很好的应用价值。\"]},\"101\":{\"h\":\"AVL 树常见术语\",\"t\":[\"AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树（balanced binary search tree）。\"]},\"102\":{\"h\":\"节点高度\",\"t\":[\"由于 AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 height 变量：\",\" /* AVL 树节点类 */ struct TreeNode { int val{}; // 节点值 int height = 0; // 节点高度 TreeNode *left{}; // 左子节点 TreeNode *right{}; // 右子节点 TreeNode() = default; explicit TreeNode(int x) : val(x){} };\",\"“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为 0 ，而空节点的高度为 −1 。我们将创建两个工具函数，分别用于获取和更新节点的高度：\",\" /* 更新节点高度 */ void updateHeight(TreeNode *node) { // 节点高度等于最高子树高度 + 1 node->height = max(height(node->left), height(node->right)) + 1; }\"]},\"103\":{\"h\":\"节点平衡因子\",\"t\":[\"节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 。我们同样将获取节点平衡因子的功能封装成函数，方便后续使用：\",\" /* 获取平衡因子 */ int balanceFactor(TreeNode *node) { // 空节点平衡因子为 0 if (node == nullptr) return 0; // 节点平衡因子 = 左子树高度 - 右子树高度 return height(node->left) - height(node->right); }\",\"相关信息\",\"设平衡因子为 f ，则一棵 AVL 树的任意节点的平衡因子皆满足 −1≤f≤1 。\"]},\"104\":{\"h\":\"AVL 树旋转\",\"t\":[\"AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。\",\"我们将平衡因子绝对值 >1 的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。下面详细介绍这些旋转操作。\"]},\"105\":{\"h\":\"右旋\",\"t\":[\"如下图所示，节点下方为平衡因子。从底至顶看，二叉树中首个失衡节点是“节点 3”。我们关注以该失衡节点为根节点的子树，将该节点记为 node ，其左子节点记为 child ，执行“右旋”操作。完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质。\",\"右旋操作步骤\",\"avltree_right_rotate_step2\",\"avltree_right_rotate_step3\",\"avltree_right_rotate_step4\",\"如下图所示，当节点 child 有右子节点（记为 grand_child ）时，需要在右旋中添加一步：将 grand_child 作为 node 的左子节点。\",\"有 grand_child 的右旋操作\",\"“向右旋转”是一种形象化的说法，实际上需要通过修改节点指针来实现，代码如下所示：\",\" /* 右旋操作 */ TreeNode *rightRotate(TreeNode *node) { TreeNode *child = node->left; TreeNode *grandChild = child->right; // 以 child 为原点，将 node 向右旋转 child->right = node; node->left = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; }\"]},\"106\":{\"h\":\"左旋\",\"t\":[\"相应地，如果考虑上述失衡二叉树的“镜像”，则需要执行下图所示的“左旋”操作。\",\"左旋操作\",\"同理，如下图所示，当节点 child 有左子节点（记为 grand_child ）时，需要在左旋中添加一步：将 grand_child 作为 node 的右子节点。\",\"有 grand_child 的左旋操作\",\"可以观察到，右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的。基于对称性，我们只需将右旋的实现代码中的所有的 left 替换为 right ，将所有的 right 替换为 left ，即可得到左旋的实现代码：\",\" /* 左旋操作 */ TreeNode *leftRotate(TreeNode *node) { TreeNode *child = node->right; TreeNode *grandChild = child->left; // 以 child 为原点，将 node 向左旋转 child->left = node; node->right = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; }\"]},\"107\":{\"h\":\"先左旋后右旋\",\"t\":[\"对于下图中的失衡节点 3 ，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对 child 执行“左旋”，再对 node 执行“右旋”。\",\"先左旋后右旋\"]},\"108\":{\"h\":\"先右旋后左旋\",\"t\":[\"如下图所示，对于上述失衡二叉树的镜像情况，需要先对 child 执行“右旋”，再对 node 执行“左旋”。\",\"先右旋后左旋\"]},\"109\":{\"h\":\"旋转的选择\",\"t\":[\"下图展示的四种失衡情况与上述案例逐个对应，分别需要采用右旋、先左旋后右旋、先右旋后左旋、左旋的操作。\",\"AVL 树的四种旋转情况\",\"如下表所示，我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于上图中的哪种情况。\",\"失衡节点的平衡因子\",\"子节点的平衡因子\",\"应采用的旋转方法\",\">1 （左偏树）\",\"≥0\",\"右旋\",\">1 （左偏树）\",\"<0\",\"先左旋后右旋\",\"<−1 （右偏树）\",\"≤0\",\"左旋\",\"<−1 （右偏树）\",\">0\",\"先右旋后左旋\",\"为了便于使用，我们将旋转操作封装成一个函数。有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡。代码如下所示：\",\"/* 执行旋转操作，使该子树重新恢复平衡 */ TreeNode *rotate(TreeNode *node) { // 获取节点 node 的平衡因子 int _balanceFactor = balanceFactor(node); // 左偏树 if (_balanceFactor > 1) { if (balanceFactor(node->left) >= 0) { // 右旋 return rightRotate(node); } else { // 先左旋后右旋 node->left = leftRotate(node->left); return rightRotate(node); } } // 右偏树 if (_balanceFactor < -1) { if (balanceFactor(node->right) <= 0) { // 左旋 return leftRotate(node); } else { // 先右旋后左旋 node->right = rightRotate(node->right); return leftRotate(node); } } // 平衡树，无须旋转，直接返回 return node; }\"]},\"110\":{\"h\":\"AVL 树常用操作\"},\"111\":{\"h\":\"插入节点\",\"t\":[\"AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\" /* 递归插入节点（辅助方法） */ TreeNode *insertHelper(TreeNode *node, int val) { if (node == nullptr) return new TreeNode(val); /* 1. 查找插入位置并插入节点 */ if (val < node->val) node->left = insertHelper(node->left, val); else if (val > node->val) node->right = insertHelper(node->right, val); else return node; // 重复节点不插入，直接返回 updateHeight(node); // 更新节点高度 /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; }\"]},\"112\":{\"h\":\"删除节点\",\"t\":[\"类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\" /* 递归删除节点（辅助方法） */ TreeNode *removeHelper(TreeNode *node, int val) { if (node == nullptr) return nullptr; /* 1. 查找节点并删除 */ if (val < node->val) node->left = removeHelper(node->left, val); else if (val > node->val) node->right = removeHelper(node->right, val); else { if (node->left == nullptr || node->right == nullptr) { TreeNode *child = node->left != nullptr ? node->left : node->right; // 子节点数量 = 0 ，直接删除 node 并返回 if (child == nullptr) { delete node; return nullptr; } // 子节点数量 = 1 ，直接删除 node else { delete node; node = child; } } else { // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点 TreeNode *temp = node->right; while (temp->left != nullptr) { temp = temp->left; } int tempVal = temp->val; node->right = removeHelper(node->right, temp->val); node->val = tempVal; } } updateHeight(node); // 更新节点高度 /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; }\"]},\"113\":{\"h\":\"查找节点\",\"t\":[\"AVL 树的节点查找操作与二叉搜索树一致，在此不再赘述。\"]},\"114\":{\"h\":\"AVL 树典型应用\",\"t\":[\"组织和存储大型数据，适用于高频查找、低频增删的场景。\",\"用于构建数据库中的索引系统。\",\"红黑树也是一种常见的平衡二叉搜索树。相较于 AVL 树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高。\"]},\"115\":{\"h\":\"重点回顾\",\"t\":[\"二叉树是一种非线性数据结构，体现“一分为二”的分治逻辑。每个二叉树节点包含一个值以及两个指针，分别指向其左子节点和右子节点。\",\"对于二叉树中的某个节点，其左（右）子节点及其以下形成的树被称为该节点的左（右）子树。\",\"二叉树的相关术语包括根节点、叶节点、层、度、边、高度和深度等。\",\"二叉树的初始化、节点插入和节点删除操作与链表操作方法类似。\",\"常见的二叉树类型有完美二叉树、完全二叉树、完满二叉树和平衡二叉树。完美二叉树是最理想的状态，而链表是退化后的最差状态。\",\"二叉树可以用数组表示，方法是将节点值和空位按层序遍历顺序排列，并根据父节点与子节点之间的索引映射关系来实现指针。\",\"二叉树的层序遍历是一种广度优先搜索方法，它体现了“一圈一圈向外扩展”的逐层遍历方式，通常通过队列来实现。\",\"前序、中序、后序遍历皆属于深度优先搜索，它们体现了“先走到尽头，再回溯继续”的遍历方式，通常使用递归来实现。\",\"二叉搜索树是一种高效的元素查找数据结构，其查找、插入和删除操作的时间复杂度均为 O(logn) 。当二叉搜索树退化为链表时，各项时间复杂度会劣化至 O(n) 。\",\"AVL 树，也称平衡二叉搜索树，它通过旋转操作确保在不断插入和删除节点后树仍然保持平衡。\",\"AVL 树的旋转操作包括右旋、左旋、先右旋再左旋、先左旋再右旋。在插入或删除节点后，AVL 树会从底向顶执行旋转操作，使树重新恢复平衡。\"]},\"116\":{\"h\":\"Q & A\",\"t\":[\"Q：对于只有一个节点的二叉树，树的高度和根节点的深度都是 0 吗？\",\"是的，因为高度和深度通常定义为“经过的边的数量”。\",\"Q：二叉树中的插入与删除一般由一套操作配合完成，这里的“一套操作”指什么呢？可以理解为资源的子节点的资源释放吗？\",\"拿二叉搜索树来举例，删除节点操作要分三种情况处理，其中每种情况都需要进行多个步骤的节点操作。\",\"Q：为什么 DFS 遍历二叉树有前、中、后三种顺序，分别有什么用呢？\",\"与顺序和逆序遍历数组类似，前序、中序、后序遍历是三种二叉树遍历方法，我们可以使用它们得到一个特定顺序的遍历结果。例如在二叉搜索树中，由于节点大小满足 左子节点值 < 根节点值 < 右子节点值 ，因此我们只要按照“左 → 根 → 右”的优先级遍历树，就可以获得有序的节点序列。\",\"Q：右旋操作是处理失衡节点 node、child、grand_child 之间的关系，那 node 的父节点和 node 原来的连接不需要维护吗？右旋操作后岂不是断掉了？\",\"我们需要从递归的视角来看这个问题。右旋操作 right_rotate(root) 传入的是子树的根节点，最终 return child 返回旋转之后的子树的根节点。子树的根节点和其父节点的连接是在该函数返回后完成的，不属于右旋操作的维护范围。\",\"Q：在 C++ 中，函数被划分到 private 和 public 中，这方面有什么考量吗？为什么要将 height() 函数和 updateHeight() 函数分别放在 public 和 private 中呢？\",\"主要看方法的使用范围，如果方法只在类内部使用，那么就设计为 private 。例如，用户单独调用 updateHeight() 是没有意义的，它只是插入、删除操作中的一步。而 height() 是访问节点高度，类似于 vector.size() ，因此设置成 public 以便使用。\",\"Q：如何从一组输入数据构建一棵二叉搜索树？根节点的选择是不是很重要？\",\"是的，构建树的方法已在二叉搜索树代码中的 build_tree() 方法中给出。至于根节点的选择，我们通常会将输入数据排序，然后将中点元素作为根节点，再递归地构建左右子树。这样做可以最大程度保证树的平衡性。\",\"Q：在 Java 中，字符串对比是否一定要用 equals() 方法？\",\"在 Java 中，对于基本数据类型，== 用于对比两个变量的值是否相等。对于引用类型，两种符号的工作原理是不同的。\",\"== ：用来比较两个变量是否指向同一个对象，即它们在内存中的位置是否相同。\",\"equals()：用来对比两个对象的值是否相等。\",\"因此，如果要对比值，我们应该使用 equals() 。然而，通过 String a = \\\"hi\\\"; String b = \\\"hi\\\"; 初始化的字符串都存储在字符串常量池中，它们指向同一个对象，因此也可以用 a == b 来比较两个字符串的内容。\",\"Q：广度优先遍历到最底层之前，队列中的节点数量是 2h 吗？\",\"是的，例如高度 h=2 的满二叉树，其节点总数 n=7 ，则底层节点数量 4=2h=(n+1)/2 。\"]},\"117\":{\"c\":[\"数据结构\"]},\"118\":{\"c\":[\"c++\"]},\"119\":{\"h\":\"数据结构\"},\"120\":{\"c\":[\"数据结构\"]},\"121\":{\"h\":\"设计原则\"},\"122\":{\"h\":\"设计模式\",\"t\":[\"设计模式是解决常见软件设计问题的通用解决方案。它们分为三大类：\",\"创建型模式：关注对象创建，如单例模式、工厂模式。\",\"结构型模式：关注对象组合，如适装饰器模式、代理模式，组合模式。\",\"行为型模式：关注对象间通信，如观察者模式、策略模式。\"]},\"123\":{\"h\":\"设计原则\",\"t\":[\"设计原则是指导代码设计的基本准则，如：\",\"单一职责原则 (SRP)\",\"定义: 一个类应只有一个引起其变化的原因，即一个类只负责一项职责。\",\"目的: 提高代码的可维护性和可读性，减少类的复杂性。\",\"开闭原则 (OCP)\",\"定义: 软件实体应对扩展开放，对修改关闭。\",\"目的: 通过抽象和接口，允许添加新功能而无需修改现有代码，减少引入新 bug 的风险。\",\"里氏替换原则 (LSP)\",\"定义: 子类对象必须能够替换其父类对象且行为一致。\",\"目的: 保证继承层次的正确性，避免运行时错误。\",\"依赖倒置原则 (DIP)\",\"定义: 高层模块不应依赖于低层模块，二者都应该依赖于抽象；抽象不应依赖于细节，细节应该依赖于抽象。\",\"目的: 减少模块之间的耦合性，提高系统的灵活性和可扩展性。\",\"接口隔离原则 (ISP)\",\"定义: 不应强迫一个类依赖于它不需要的接口，接口应尽量细化。\",\"目的: 通过多个特定接口来代替单一的总接口，减少代码的复杂性，提高系统的灵活性。\"]},\"124\":{\"h\":\"关于架构设计的一点思考\",\"t\":[\"减少耦合\",\"通过添加抽象接口层，将调用模块与实现模块进行隔离，降低耦合性。调用模块只依赖抽象接口，进行业务逻辑的实现，实现模块基于抽象接口实现具体的底层细节。\",\"单一职责\",\"一个模块只实现其功能的最小集，对外提供尽可能少的接口，接口应尽量细化。\",\"隔离变化/稳定\",\"找出系统中可预计的变化，将其隔离到相同的模块。系统需求变动导致的修改尽可能的不会扩散的稳定的模块。\"]},\"125\":{\"c\":[\"架构设计\"]},\"126\":{\"c\":[\"c++\",\"设计模式\",\"设计原则\"]},\"127\":{\"h\":\"观察者模式\"},\"128\":{\"c\":[\"架构设计\"]},\"129\":{\"c\":[\"c++\",\"设计模式\",\"观察者模式\",\"事件模式\"]},\"130\":{\"h\":\"策略模式\",\"t\":[\"策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装在独立的策略类中，使得它们可以互相替换。策略模式使得算法的变化不会影响到使用算法的客户类。\"]},\"131\":{\"h\":\"组成部分\",\"t\":[\"策略接口：定义算法的通用接口。\",\"具体策略类：实现策略接口的不同算法。\",\"上下文类：持有一个策略对象，并在运行时决定使用哪种策略。\"]},\"132\":{\"h\":\"例子\",\"t\":[\"假设我们有一个水果计价系统，需要计算不同水果的价格。可以通过策略模式将计算逻辑封装成独立的策略类，这样可以动态选择合适的计算策略。\",\"在使用策略模式时，可以轻松更改折扣策略，而无需修改订单类的代码，从而提高了代码的可扩展性和维护性。\"]},\"133\":{\"c\":[\"架构设计\"]},\"134\":{\"c\":[\"c++\",\"设计模式\",\"策略模式\"]},\"135\":{\"h\":\"架构设计\"},\"136\":{\"c\":[\"架构设计\"]},\"137\":{\"h\":\"c++ 基础\"},\"138\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"139\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"140\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"141\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"142\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"143\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"144\":{\"c\":[\"面试题\"]},\"145\":{\"c\":[\"c++\"]},\"146\":{\"h\":\"进程编程\"},\"147\":{\"h\":\"进程状态\"},\"148\":{\"h\":\"进程的基本状态\",\"t\":[\"新建（New）：\",\"进程正在被创建，还未进入准备就绪队列。\",\"就绪（Ready）：\",\"进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。\",\"运行（Running）：\",\"进程正在 CPU 上执行代码。\",\"阻塞（Blocked）：\",\"进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。\",\"终止（Terminated）：\",\"进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。\"]},\"149\":{\"h\":\"进程状态之间的转换\",\"t\":[\"进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：\",\"新建 → 就绪：\",\"当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。\",\"就绪 → 运行：\",\"调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。\",\"运行 → 就绪：\",\"如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。\",\"运行 → 阻塞：\",\"当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。\",\"阻塞 → 就绪：\",\"当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。\",\"运行 → 终止：\",\"当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。\"]},\"150\":{\"h\":\"状态转换示意图\"},\"151\":{\"h\":\"僵尸进程\",\"t\":[\"僵尸进程（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 wait() 或 waitpid() 函数回收子进程的退出状态信息，从而导致的进程状态。\",\"具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 wait() 或 waitpid() 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。\"]},\"152\":{\"h\":\"僵尸进程的影响\",\"t\":[\"资源占用：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。\",\"系统管理的麻烦：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。\"]},\"153\":{\"h\":\"如何避免产生僵尸进程？\",\"t\":[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：\",\"及时调用 wait() 或 waitpid()：\",\"父进程在适当的时机调用 wait() 或 waitpid() 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。\",\"pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 wait(NULL); // 等待子进程结束并回收资源 }\",\"使用 SIGCHLD 信号处理子进程的结束：\",\"当子进程结束时，父进程会收到 SIGCHLD 信号。父进程可以在信号处理程序中调用 wait() 或 waitpid() 以回收子进程的资源。\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> #include <signal.h> void sigchld_handler(int signum) { // 等待所有已终止的子进程 while (waitpid(-1, NULL, WNOHANG) > 0); } int main() { // 注册 SIGCHLD 信号处理程序 signal(SIGCHLD, sigchld_handler); pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 // 父进程继续执行其任务 pause(); // 等待信号（例如 SIGCHLD） } return 0; }\",\"将子进程的父进程设置为 init 进程（或 systemd）：\",\"如果父进程在子进程结束前退出，子进程会被 init 进程（PID 为 1 的进程）接管。init 进程会自动调用 wait() 回收子进程的资源，避免僵尸进程的产生。可以通过调用 fork() 后使父进程退出，子进程被 init 接管。\",\"pid_t pid = fork(); if (pid > 0) { // 父进程退出 exit(0); } // 子进程继续执行 // 此时子进程的父进程是 init 进程\",\"采用 double fork() 技术：\",\"父进程通过 fork() 创建一个子进程，子进程再 fork() 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 init 进程接管。\",\"pid_t pid = fork(); if (pid == 0) { // 第一个子进程 pid_t pid2 = fork(); if (pid2 == 0) { // 孙子进程 // 在此处执行需要守护的任务 exit(0); } else { // 第一个子进程退出 exit(0); } } else { // 父进程等待第一个子进程退出 wait(NULL); }\",\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 wait() 系列函数、处理 SIGCHLD 信号、使用 init 进程接管孤儿进程或采用 double fork() 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。\"]},\"154\":{\"c\":[\"面试题\"]},\"155\":{\"c\":[\"c++\",\"多进程\",\"进程通信\"]},\"156\":{\"h\":\"线程编程\"},\"157\":{\"h\":\"如何创建线程？\",\"t\":[\"C++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：\",\"// thread example #include <iostream> // std::cout #include <thread> // std::thread void foo() { // do stuff... } void bar(int x) { // do stuff... } int main() { std::thread first (foo); // spawn new thread that calls foo() std::thread second (bar,0); // spawn new thread that calls bar(0) std::cout << \\\"main, foo and bar now execute concurrently...\\\\n\\\"; // synchronize threads: first.join(); // pauses until first finishes second.join(); // pauses until second finishes std::cout << \\\"foo and bar completed.\\\\n\\\"; return 0; }\",\"上述代码中，函数 foo() 和 bar(0) 分别运行在线程对象 first 和 second 中，从刚创建对象开始就会新建一个线程用于执行函数，调用 join() 函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的 detach() 函数，表示将线程和线程对象分离，新的线程与主线程没有任何关联，线程资源在任务结束后会由操作系统自动回收。\",\"如果没有调用 join() 或者 detach() 函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生crash，这里有两种解决办法，一个是调用 join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用 detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完成。\"]},\"158\":{\"h\":\"线程同步机制\"},\"159\":{\"h\":\"\",\"t\":[\"实现原理：\",\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问。具体实现步骤如下：\",\"基本结构：\",\"互斥量有一个内部状态，通常用布尔值或整数表示（锁定或未锁定）。\",\"维护一个等待队列，用于保存等待锁的线程。\",\"锁定 (Lock)：\",\"当一个线程尝试锁定互斥量时，如果互斥量未锁定，则线程成功锁定，并将互斥量状态设置为锁定。\",\"如果互斥量已锁定，则该线程进入等待队列并挂起，直到互斥量被解锁。\",\"解锁 (Unlock)：\",\"当一个线程解锁互斥量时，如果等待队列中有其他线程，则唤醒一个线程，使其尝试重新锁定互斥量。\",\"如果没有线程在等待，则将互斥量状态设置为未锁定。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> std::mutex mtx; void print_thread_id(int id) { std::lock_guard<std::mutex> guard(mtx); // 自动加锁和解锁 std::cout << \\\"Thread #\\\" << id << std::endl; } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_thread_id, i); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"160\":{\"h\":\"\",\"t\":[\"实现原理：\",\"读写锁允许多个线程同时读取，但在写入时只允许一个线程操作。其实现原理如下：\",\"基本结构：\",\"读写锁包含两个计数器：一个用于记录当前正在读取的线程数，另一个用于记录是否有写线程在等待。\",\"维护一个等待队列，用于保存等待的线程。\",\"读锁定 (Read Lock)：\",\"当一个线程请求读锁定时，如果没有写锁存在，则增加读计数器，线程继续执行。\",\"如果有写锁存在，则线程进入等待队列。\",\"写锁定 (Write Lock)：\",\"当一个线程请求写锁定时，如果没有读锁和写锁存在，则锁定成功。\",\"如果有读锁或写锁存在，则线程进入等待队列。\",\"解锁 (Unlock)：\",\"当读线程解锁时，减少读计数器，如果读计数器为0且有写线程在等待，则唤醒一个写线程。\",\"当写线程解锁时，如果有读线程在等待，则唤醒所有读线程；如果有写线程在等待，则唤醒一个写线程。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <shared_mutex> #include <vector> std::shared_mutex rw_mtx; std::vector<int> data; void reader() { std::shared_lock<std::shared_mutex> lock(rw_mtx); for (const auto& d : data) { std::cout << d << \\\" \\\"; } std::cout << std::endl; } void writer(int value) { std::unique_lock<std::shared_mutex> lock(rw_mtx); data.push_back(value); } int main() { std::thread t1(writer, 1); std::thread t2(reader); std::thread t3(writer, 2); std::thread t4(reader); t1.join(); t2.join(); t3.join(); t4.join(); return 0; }\"]},\"161\":{\"h\":\"\",\"t\":[\"实现原理：\",\"条件变量用于线程之间的等待和通知机制。其实现原理如下：\",\"基本结构：\",\"条件变量与一个互斥量和一个条件状态相关联。\",\"维护一个等待队列，用于保存等待条件的线程。\",\"等待 (Wait)：\",\"线程在等待条件变量时，需要持有相关的互斥量。\",\"线程将自己添加到等待队列，并释放互斥量，等待条件变量的通知。\",\"通知 (Notify)：\",\"当一个线程修改条件状态并调用 notify_one 或 notify_all 时，唤醒一个或所有等待队列中的线程。\",\"被唤醒的线程重新获得互斥量，检查条件状态，如果条件满足，线程继续执行；如果条件不满足，线程再次进入等待状态。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> std::mutex cv_mtx; std::condition_variable cv; bool ready = false; void print_id(int id) { std::unique_lock<std::mutex> lock(cv_mtx); cv.wait(lock, [] { return ready; }); // 等待 ready 变为 true std::cout << \\\"Thread #\\\" << id << std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard<std::mutex> lock(cv_mtx); ready = true; } cv.notify_all(); // 唤醒所有等待的线程 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_id, i); } std::thread t(set_ready); for (auto& th : threads) { th.join(); } t.join(); return 0; }\",\"使用场景：\",\"条件变量常用于线程之间的协调，例如在生产者-消费者模型中，生产者线程通知消费者线程有新数据可用，消费者线程等待该通知。\"]},\"162\":{\"h\":\"\",\"t\":[\"实现原理：\",\"原子操作通过硬件支持的指令集实现，保证在并发环境下操作的不可分割性。其实现原理如下：\",\"硬件支持：\",\"原子操作依赖于硬件提供的原子指令，如 compare-and-swap (CAS)、fetch-and-add 等，这些指令能够确保在多个线程操作同一数据时不会产生竞争条件。\",\"内存模型：\",\"C++ 中的 std::atomic 提供了对不同内存模型的支持，确保在不同平台上实现一致的原子操作行为。\",\"无需锁定：\",\"原子操作直接操作共享变量，不需要加锁解锁，因此在高并发场景下具有更好的性能。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> std::atomic<int> counter(0); void increment() { for (int i = 0; i < 1000; ++i) { ++counter; // 原子操作 } } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(increment); } for (auto& th : threads) { th.join(); } std::cout << \\\"Final counter value: \\\" << counter << std::endl; return 0; }\",\"使用场景：\",\"原子操作适用于需要高效并发访问的场景，如计数器、标志位等，避免使用锁机制带来的开销。\"]},\"163\":{\"h\":\"\",\"t\":[\"实现原理：\",\"信号量是一种控制对共享资源访问的计数器，分为计数信号量和二进制信号量。其实现原理如下：\",\"计数器：\",\"信号量内部维护一个计数器，表示当前可用资源的数量。计数器初始值通常为资源的总量。\",\"P 操作 (等待操作)：\",\"当一个线程执行 P 操作（wait 或 acquire）时，计数器减 1。如果计数器值为正，线程继续执行；如果计数器值为零或负，线程进入等待队列，等待资源释放。\",\"V 操作 (释放操作)：\",\"当一个线程执行 V 操作（signal 或 release）时，计数器加 1。如果有线程在等待队列中，唤醒一个线程，使其继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <semaphore> std::counting_semaphore<1> sem(1); void worker(int id) { sem.acquire(); // P 操作 std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); sem.release(); // V 操作 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"信号量适用于控制对资源的并发访问数量，例如限制同时访问文件的线程数、实现生产者-消费者模型等。\"]},\"164\":{\"h\":\"6. 自旋锁 (Spinlock)\",\"t\":[\"实现原理：\",\"自旋锁是一种忙等待锁，线程在尝试获取锁时会反复检查锁的状态，而不会阻塞或挂起。其实现原理如下：\",\"忙等待：\",\"当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，线程将反复检查锁的状态，直到锁可用为止。\",\"自旋锁通常通过硬件的原子操作实现，如 test-and-set、compare-and-swap 等。\",\"解锁：\",\"当持有锁的线程释放自旋锁时，其他线程可以成功获取锁并继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> class Spinlock { std::atomic_flag flag = ATOMIC_FLAG_INIT; public: void lock() { while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待 } void unlock() { flag.clear(std::memory_order_release); } }; Spinlock spinlock; void worker(int id) { spinlock.lock(); std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); spinlock.unlock(); } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"自旋锁适用于锁定时间非常短的场景，例如在中断上下文或需要避免线程调度开销的情况下使用。\"]},\"165\":{\"h\":\"\",\"t\":[\"实现原理：\",\"屏障用于同步一组线程，确保所有线程都到达某个同步点后才能继续执行。其实现原理如下：\",\"计数器：\",\"屏障内部维护一个计数器，表示已到达屏障的线程数量。每当一个线程到达屏障点时，计数器减 1。\",\"等待机制：\",\"当计数器达到零时，表示所有线程都已到达屏障点，屏障解除，所有等待的线程继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <barrier> #include <vector> std::barrier sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" is waiting\\\" << std::endl; sync_point.arrive_and_wait(); // 等待所有线程到达屏障点 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"屏障适用于并行计算中需要同步多个线程的场景，例如在每个计算步骤完成后同步所有线程。\"]},\"166\":{\"h\":\"\",\"t\":[\"实现原理：\",\"锁存器类似于屏障，但只能使用一次，线程等待直到锁存器倒数到零。其实现原理如下：\",\"倒数计数器：\",\"锁存器内部维护一个倒数计数器，表示需要完成的任务数量。每次完成任务时，计数器减 1。\",\"等待机制：\",\"当计数器减为零时，所有等待的线程被唤醒，继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <latch> #include <vector> std::latch sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" has reached the latch point\\\" << std::endl; sync_point.count_down(); // 锁存器计数减少 sync_point.wait(); // 等待所有线程到达锁存器 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景，例如初始化任务完成后启动主任务。\"]},\"167\":{\"h\":\"死锁\",\"t\":[\"死锁的四个条件(循环等待不可抢占的互斥资源):\",\"禁止抢占(no preemption)：系统资源不能被强制从一个进程(线程)中退出，已经获得的资源在未使用完之前不能被抢占。\",\"等待和保持(hold and wait)：一个进程(线程)因请求资源阻塞时，对已获得的资源保持不放。\",\"互斥(mutual exclusion)：资源只能同时分配给一个进程(线程)，无法多个进程(线程)共享。\",\"循环等待(circular waiting)：一系列进程(线程)互相持有其他进程(线程)所需要的资源。\",\"死锁问题的排查\",\"参考 1\",\"参考 2\"]},\"168\":{\"h\":\"无锁编程\",\"t\":[\"无锁编程（Lock-Free Programming）是一种在多线程环境中实现并发访问的技术，目的是避免传统锁机制（如互斥锁）带来的性能开销和死锁风险。无锁编程主要依赖于原子操作和内存序列模型，以确保在没有锁的情况下实现线程安全。\"]},\"169\":{\"h\":\"1. 基本概念\",\"t\":[\"原子操作：原子操作是不可分割的，多个线程对同一变量进行原子操作时，不会引起数据竞争。\",\"CAS (Compare-and-Swap)：这是无锁编程的核心操作之一，它检查一个变量是否有特定的值，如果是，则将其更改为新值。这个操作是原子的，即在执行时不会被其他线程打断。\",\"内存序列模型：C++ 提供了一组内存序列模型（如 memory_order_relaxed、memory_order_acquire、memory_order_release 等），以控制并发操作的顺序性。\"]},\"170\":{\"h\":\"2. C++ 中的原子操作\",\"t\":[\"C++11 引入了 std::atomic 模板类，为实现无锁编程提供了基础设施。它支持以下操作：\",\"原子加载和存储\",\"原子递增和递减\",\"原子交换\",\"原子比较并交换（CAS）\"]},\"171\":{\"h\":\"3. 使用原子变量实现无锁队列\",\"t\":[\"下面是一个简单的无锁单生产者单消费者队列的实现示例：\",\"#include <atomic> #include <iostream> #include <thread> #include <vector> template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; // 使用 memory_order_release 确保更新操作一定在取值之后 head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } private: T* buffer; size_t capacity; std::atomic<size_t> head; std::atomic<size_t> tail; }; int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\"]},\"172\":{\"h\":\"4. 代码结构和作用\",\"t\":[\"类定义与构造函数\",\"template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; }\",\"LockFreeQueue 类是一个泛型队列，使用模板参数 T 来定义队列元素的类型。\",\"构造函数初始化队列的容量 capacity，并将 head 和 tail 指针初始化为 0。\",\"队列使用一个动态分配的数组 buffer 来存储元素。\",\"enqueue 方法\",\"bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; }\",\"enqueue 方法用于将一个元素插入队列。\",\"tail.load(std::memory_order_relaxed)：原子地加载当前的尾部指针 tail 的值。使用 memory_order_relaxed 是因为我们不需要同步其他内存操作，仅仅读取尾部的值。\",\"nextTail = (currentTail + 1) % capacity：计算插入元素后的尾部指针值，使用取模操作来实现循环队列。\",\"if (nextTail == head.load(std::memory_order_acquire))：检查队列是否已满。如果 nextTail 与头部指针 head 相等，说明队列已满。\",\"buffer[currentTail] = item：将元素存储在当前尾部指针所指向的位置。\",\"tail.store(nextTail, std::memory_order_release)：将新的尾部指针存储到 tail，并使用 memory_order_release 以确保插入操作完成后，其他线程能正确地看到更新的尾部指针。\",\"dequeue 方法\",\"bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; head.store((currentHead + 1) % capacity, std::memory_order_release); return true; }\",\"dequeue 方法用于从队列中取出一个元素。\",\"currentHead = head.load(std::memory_order_relaxed)：原子地加载当前的头部指针 head 的值。\",\"if (currentHead == tail.load(std::memory_order_acquire))：检查队列是否为空。如果 head 与 tail 相等，说明队列为空。\",\"item = buffer[currentHead]：将头部指针所指向的元素存储到 item 中。\",\"head.store((currentHead + 1) % capacity, std::memory_order_release)：更新头部指针，指向下一个元素的位置，并使用 memory_order_release 以确保取出操作完成后，其他线程能正确地看到更新的头部指针。\",\"主函数中的生产者和消费者\",\"int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\",\"在 main 函数中，创建了一个 LockFreeQueue 对象 queue，容量为 10。\",\"生产者线程 producer 向队列中插入元素，使用 while (!queue.enqueue(i)) 检查插入操作是否成功。如果队列已满，线程会持续等待直到成功插入。\",\"消费者线程 consumer 从队列中取出元素，使用 while (!queue.dequeue(item)) 检查取出操作是否成功。如果队列为空，线程会持续等待直到成功取出元素。\",\"两个线程同时运行，生产者插入数据，消费者取出数据，并输出相应的信息。\",\"最后，通过 join() 等待线程完成，确保主线程在两个子线程结束后才退出。\"]},\"173\":{\"h\":\"\",\"t\":[\"memory_order_relaxed：用于没有数据依赖的地方，只要求操作是原子的，不需要同步内存顺序。适用于 load 和 store，如 tail.load(std::memory_order_relaxed)。\",\"memory_order_acquire：用于加载操作，以确保加载的结果及其后续的操作不会被重排序到 acquire 之前。适用于检查队列是否满或空，如 head.load(std::memory_order_acquire)。\",\"memory_order_release：用于存储操作，以确保在此之前的所有操作不会被重排序到 release 之后。适用于更新指针操作，如 tail.store(nextTail, std::memory_order_release)。\"]},\"174\":{\"c\":[\"面试题\"]},\"175\":{\"c\":[\"c++\",\"多线程\",\"线程同步\"]},\"176\":{\"h\":\"c++11 新特性\"},\"177\":{\"h\":\"新增线程编程相关模块\",\"t\":[\"相关信息\",\"c++11关于并发引入了好多好东西，这里按照如下顺序介绍：\",\"std::thread相关\",\"std::mutex相关\",\"std::lock相关\",\"std::atomic相关\",\"std::call_once相关\",\"std::condition_variable相关\",\"std::future相关\",\"async相关\"]},\"178\":{\"h\":\"std::thread相关\",\"t\":[\"c++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：\",\"#include <iostream> #include <thread> using namespace std; int main() { auto func = []() { for (int i = 0; i < 10; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread t(func); if (t.joinable()) { t.detach(); } auto func1 = [](int k) { for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread tt(func1, 20); if (tt.joinable()) { // 检查线程可否被join tt.join(); } return 0; }\",\"上述代码中，函数func和func1运行在线程对象t和tt中，从刚创建对象开始就会新建一个线程用于执行函数，调用join函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的detach函数，表示将线程和线程对象分离。\",\"如果没有调用join或者detach函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完。\",\"这里可以对thread进行封装，避免没有调用join或者detach可导致程序出错的情况出现：\",\"class ThreadGuard { public: enum class DesAction { join, detach }; ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){}; ~ThreadGuard() { if (t_.joinable()) { if (action_ == DesAction::join) { t_.join(); } else { t_.detach(); } } } ThreadGuard(ThreadGuard&&) = default; ThreadGuard& operator=(ThreadGuard&&) = default; std::thread& get() { return t_; } private: std::thread t_; DesAction action_; }; int main() { ThreadGuard t(std::thread([]() { for (int i = 0; i < 10; ++i) { std::cout << \\\"thread guard \\\" << i << \\\" \\\"; } std::cout << std::endl;}), ThreadGuard::DesAction::join); return 0; }\",\"c++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能\",\"std::thread t(func); cout << \\\"当前线程ID \\\" << t.get_id() << endl; cout << \\\"当前cpu个数 \\\" << std::thread::hardware_concurrency() << endl; auto handle = t.native_handle();// handle可用于pthread相关操作 std::this_thread::sleep_for(std::chrono::seconds(1));\"]},\"179\":{\"h\":\"std::mutex相关\",\"t\":[\"std::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。\",\"mutex分为四种：\",\"std::mutex：独占的互斥量，不能递归使用，不带超时功能\",\"std::recursive_mutex：递归互斥量，可重入，不带超时功能\",\"std::timed_mutex：带超时的互斥量，不能递归\",\"std::recursive_timed_mutex：带超时的互斥量，可以递归使用\",\"拿一个std::mutex和std::timed_mutex举例吧，别的都是类似的使用方式：\",\"std::mutex: #include <iostream> #include <mutex> #include <thread> using namespace std; std::mutex mutex_; int main() { auto func1 = [](int k) { mutex_.lock(); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; mutex_.unlock(); }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; } std::timed_mutex: #include <iostream> #include <mutex> #include <thread> #include <chrono> using namespace std; std::timed_mutex timed_mutex_; int main() { auto func1 = [](int k) { timed_mutex_.try_lock_for(std::chrono::milliseconds(200)); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; timed_mutex_.unlock(); }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"180\":{\"h\":\"std::lock相关\",\"t\":[\"这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。\",\"c++11主要有std::lock_guard和std::unique_lock两种方式，使用方式都类似，如下：\",\"#include <iostream> #include <mutex> #include <thread> #include <chrono> using namespace std; std::mutex mutex_; int main() { auto func1 = [](int k) { // std::lock_guard<std::mutex> lock(mutex_); std::unique_lock<std::mutex> lock(mutex_); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; }\",\"std::lock_gurad相比于std::unique_lock更加轻量级，少了一些成员函数，std::unique_lock类有unlock函数，可以手动释放锁，所以条件变量都配合std::unique_lock使用，而不是std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力，具体关于条件变量后面会讲到。\"]},\"181\":{\"h\":\"std::atomic相关\",\"t\":[\"c++11提供了原子类型 std::atomic<T>，理论上这个T可以是任意类型，但是我平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就不需要使用std::mutex来保护该变量啦。看一个计数器的代码：\",\"struct OriginCounter { // 普通的计数器 int count; std::mutex mutex_; void add() { std::lock_guard<std::mutex> lock(mutex_); ++count; } void sub() { std::lock_guard<std::mutex> lock(mutex_); --count; } int get() { std::lock_guard<std::mutex> lock(mutex_); return count; } }; struct NewCounter { // 使用原子变量的计数器 std::atomic<int> count; void add() { ++count; // count.store(++count);这种方式也可以 } void sub() { --count; // count.store(--count); } int get() { return count.load(); } };\"]},\"182\":{\"h\":\"std::call_once相关\",\"t\":[\"c++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码吧：\",\"std::once_flag onceflag; void CallOnce() { std::call_once(onceflag, []() { cout << \\\"call once\\\" << endl; }); } int main() { std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(CallOnce); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"183\":{\"h\":\"std::condition_variable相关\",\"t\":[\"条件变量是c++11引入的一种同步机制，它可以阻塞一个线程或者个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的std::unique_lock。\",\"这里使用条件变量实现一个CountDownLatch：\",\"class CountDownLatch { public: explicit CountDownLatch(uint32_t count) : count_(count); void CountDown() { std::unique_lock<std::mutex> lock(mutex_); --count_; if (count_ == 0) { cv_.notify_all(); } } void Await(uint32_t time_ms = 0) { std::unique_lock<std::mutex> lock(mutex_); while (count_ > 0) { if (time_ms > 0) { cv_.wait_for(lock, std::chrono::milliseconds(time_ms)); } else { cv_.wait(lock); } } } uint32_t GetCount() const { std::unique_lock<std::mutex> lock(mutex_); return count_; } private: std::condition_variable cv_; mutable std::mutex mutex_; uint32_t count_ = 0; };\",\"关于条件变量其实还涉及到通知丢失和虚假唤醒问题，因为不是本文的主题，这里暂不介绍，大家有需要可以留言。\"]},\"184\":{\"h\":\"std::future相关\",\"t\":[\"c++11关于异步操作提供了future相关的类，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高级些，std::future作为异步结果的传输通道，通过get()可以很方便的获取线程函数的返回值，std::promise用来包装一个值，将数据和future绑定起来，而std::packaged_task则用来包装一个调用对象，将函数和future绑定起来，方便异步调用。而std::future是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。\",\"std::promise与std::future配合使用\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; void func(std::future<int>& fut) { int x = fut.get(); cout << \\\"value: \\\" << x << endl; } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(func, std::ref(fut)); prom.set_value(144); t.join(); return 0; }\",\"std::packaged_task与std::future配合使用\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; int func(int in) { return in + 1; } int main() { std::packaged_task<int(int)> task(func); std::future<int> fut = task.get_future(); std::thread(std::move(task), 5).detach(); cout << \\\"result \\\" << fut.get() << endl; return 0; }\",\"三者之间的关系:\",\"std::future用于访问异步操作的结果，而std::promise和std::packaged_task在future高一层，它们内部都有一个future;\",\"promise包装的是一个值，packaged_task包装的是一个函数，当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。\"]},\"185\":{\"h\":\"async相关\",\"t\":[\"async是比future，packaged_task，promise更高级的东西，它是基于任务的异步操作，通过async可以直接创建异步的任务，返回的结果会保存在future中，不需要像packaged_task和promise那么麻烦，关于线程操作应该优先使用async，看一段使用代码：\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; int func(int in) { return in + 1; } int main() { auto res = std::async(func, 5); // res.wait(); cout << res.get() << endl; // 阻塞直到函数返回 return 0; }\",\"async具体语法如下：\",\"async(std::launch::async | std::launch::deferred, func, args...);\",\"第一个参数是创建策略：\",\"std::launch::async表示任务执行在另一线程\",\"std::launch::deferred表示延迟执行任务，调用get或者wait时才会执行，不会创建线程，惰性执行在当前线程。\",\"如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。\",\"若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：\",\"std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f() std::async(std::launch::async, []{ g(); }); // f() 完成前不开始\",\"注意：关于async启动策略这里网上和各种书籍介绍的五花八门，这里会以cppreference为主。\",\"• 有时候我们如果想真正执行异步操作可以对async进行封装，强制使用std::launch::async策略来调用async。\",\"template <typename F, typename... Args> inline auto ReallyAsync(F&& f, Args&&... params) { return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...); }\",\"总结\",\"std::thread使线程的创建变得非常简单，还可以获取线程id等信息。\",\"std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。\",\"std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。\",\"std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量\",\"std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。\",\"std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。\",\"std::future用于异步调用的包装和返回值。\",\"async更方便的实现了异步调用，异步调用优先使用async取代创建线程。\"]},\"186\":{\"h\":\"性能优化\"},\"187\":{\"h\":\"\",\"t\":[\"相关信息\",\"智能指针是为没有垃圾回收机制的语言解决可能的内存泄露问题的利器，但是在实际应用中使用智能指针有一些需要注意的地方，好在这些问题都可以解决。\",\"shared_ptr 和 unqi_ptr 使用时如何选择：如果希望只有一个智能指针管理资源或者管理数组，可以用 uniq_ptr；如果希望多个智能指针管理同一个资源，可以用 shared_ptr。\",\"weak_ptr 是 shared_ptr 的助手，只是监视 shared_ptr 管理的资源是否被释放，本身并不操作或者管理资源。用于解决 shared_ptr 循环引用和返回 this 指针的问题\",\"智能指针线程安全\",\"std::shared_ptr\",\"std::unqi_ptr\",\"std::weak_ptr\"]},\"188\":{\"h\":\"和\",\"t\":[\"移动构造函数 + std::move: 减少内存拷贝\",\"#include <iostream> using namespace std; struct A { A(){cout<<\\\"construct\\\"<<endl;} A(const A& a){cout<<\\\"copy construct\\\" <<endl;} ~A(){cout<<\\\"destruct\\\"<<endl;} }; A GetA(){ return A();} int main() { /* 在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA（）函数内部创建的对象返回后构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了 */ A a = GetA(); /* 通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构 */ //A&& a = GetA(); return 0; }\",\"[root@centos7 c++]# g++ test.cpp [root@centos7 c++]# ./a.out construct destruct [root@centos7 c++]# g++ test.cpp -fno-elide-constructors [root@centos7 c++]# ./a.out construct copy construct destruct copy construct destruct destruct [root@centos7 c++]# g++ test.cpp -fno-elide-constructors [root@centos7 c++]# ./a.out construct copy construct destruct destruct\"]},\"189\":{\"h\":\"容器新增 操作减少内存拷贝和移动\",\"t\":[\"#include <vector> #include <map> #include <string> #include <iostream> using namespace std; struct Complicated { int year; std::string name; Complicated(int a, string c):year(a),name(c) { cout<<\\\"is constucted\\\"<<endl; } Complicated(const Complicated&other):year(other.year),name(std::move(other.name)) { cout<<\\\"is moved\\\"<<endl; } }; int main() { std::map<int, Complicated> m; int anInt = 4; std::string aString = \\\"C++\\\"; cout<<\\\"—insert--\\\"<<endl; m.insert(std::make_pair(4, Complicated(anInt, aString))); cout<<\\\"—emplace--\\\"<<endl; // should be easier for the optimizer m.emplace(4, Complicated(anInt, aString)); cout<<\\\"--emplace_back--\\\"<<endl; vector<Complicated> v; v.emplace_back(anInt, aString); cout<<\\\"--push_back--\\\"<<endl; v.push_back(Complicated(anInt, aString)); return 0; }\",\"[root@centos7 c++]# ./a.out —insert-- is constucted is moved is moved —emplace-- is constucted is moved --emplace_back-- is constucted --push_back-- is constucted is moved is moved\"]},\"190\":{\"h\":\"语法糖\"},\"191\":{\"h\":\"\",\"t\":[\" template<class... Types> void f(Types... args); f(); // OK: args contains no arguments f(1); // OK: args contains one argument: int f(2, 1.0); // OK: args contains two arguments: int and double\"]},\"192\":{\"h\":\"\",\"t\":[\" auto x = 5; // OK: x has type int const auto *v = &x, u = 6; // OK: v has type const int*, u has type const int static auto y = 0.0; // OK: y has type double\"]},\"193\":{\"h\":\"\",\"t\":[\" std::vector<int> v = {0, 1, 2, 3, 4, 5}; for (const int& i : v) // access by const reference std::cout << i << ' ';\"]},\"194\":{\"h\":\"\",\"t\":[\"auto f = [&](int)->void{}; f();\"]},\"195\":{\"h\":\"\",\"t\":[\"#include <iostream> int main() { enum class Color { red, green = 20, blue }; Color r = Color::blue; switch(r) { case Color::red : std::cout << \\\"red\\\\n\\\"; break; case Color::green: std::cout << \\\"green\\\\n\\\"; break; case Color::blue : std::cout << \\\"blue\\\\n\\\"; break; } // int n = r; // error: no implicit conversion from scoped enum to int int n = static_cast<int>(r); // OK, n = 21 std::cout << n << '\\\\n'; // prints 21 }\"]},\"196\":{\"c\":[\"面试题\"]},\"197\":{\"c\":[\"c++11\",\"多线程\",\"线程同步\"]},\"198\":{\"h\":\"面试集锦\"},\"199\":{\"c\":[\"面试题\"]},\"200\":{\"h\":\"副业搞钱\"},\"201\":{\"c\":[\"副业\"]},\"202\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"203\":{\"h\":\"Books\"}},\"dirtCount\":0,\"index\":[[\"副业\",{\"2\":{\"201\":1}}],[\"副业搞钱\",{\"0\":{\"200\":1}}],[\"y\",{\"1\":{\"192\":2}}],[\"year\",{\"1\":{\"189\":4}}],[\"语法糖\",{\"0\":{\"190\":1}}],[\"语言一样的方式\",{\"1\":{\"142\":1}}],[\"比之前少了一次拷贝构造和一次析构\",{\"1\":{\"188\":1}}],[\"比如链表节点\",{\"1\":{\"76\":1}}],[\"比如\",{\"1\":{\"39\":2,\"65\":1}}],[\"比如在音频\",{\"1\":{\"30\":1}}],[\"比如在红黑树\",{\"1\":{\"30\":1}}],[\"比如操作系统的资源调度\",{\"1\":{\"30\":1}}],[\"比如以上代码中的链表可记作链表\",{\"1\":{\"23\":1}}],[\"比如数组\",{\"1\":{\"23\":1}}],[\"拷贝构造函数调用了两次\",{\"1\":{\"188\":1}}],[\"移动构造函数\",{\"1\":{\"188\":1}}],[\"智能指针线程安全\",{\"1\":{\"187\":1}}],[\"智能指针是为没有垃圾回收机制的语言解决可能的内存泄露问题的利器\",{\"1\":{\"187\":1}}],[\"管理的资源是否被释放\",{\"1\":{\"187\":1}}],[\"好在这些问题都可以解决\",{\"1\":{\"187\":1}}],[\"性能优化\",{\"0\":{\"186\":1}}],[\"异步调用优先使用async取代创建线程\",{\"1\":{\"185\":1}}],[\"异或哈希\",{\"1\":{\"74\":1}}],[\"强制使用std\",{\"1\":{\"185\":1}}],[\"注意\",{\"1\":{\"185\":1}}],[\"注册\",{\"1\":{\"153\":1}}],[\"临时量的析构函数等待\",{\"1\":{\"185\":1}}],[\"未被移动或绑定到引用\",{\"1\":{\"185\":1}}],[\"获得的\",{\"1\":{\"185\":1}}],[\"获取thread\",{\"1\":{\"178\":1}}],[\"获取子进程的退出状态后\",{\"1\":{\"151\":1}}],[\"获取节点\",{\"1\":{\"109\":1}}],[\"获取平衡因子\",{\"1\":{\"103\":1}}],[\"获取中序遍历中\",{\"1\":{\"96\":1}}],[\"获取中序遍历后继节点需要\",{\"1\":{\"96\":1}}],[\"获取所有值\",{\"1\":{\"63\":1}}],[\"获取所有键\",{\"1\":{\"63\":1}}],[\"获取所有键值对\",{\"1\":{\"63\":1}}],[\"获取栈的长度\",{\"1\":{\"50\":1,\"52\":1,\"53\":1}}],[\"获取队列的容量\",{\"1\":{\"47\":1}}],[\"获取队列的长度\",{\"1\":{\"44\":1,\"46\":1,\"47\":1}}],[\"获取并返回随机元素\",{\"1\":{\"13\":1}}],[\"惰性执行在当前线程\",{\"1\":{\"185\":1}}],[\"|\",{\"1\":{\"185\":1}}],[\"||\",{\"1\":{\"6\":1,\"96\":1,\"112\":1}}],[\"看一段使用代码\",{\"1\":{\"185\":1}}],[\"看一个计数器的代码\",{\"1\":{\"181\":1}}],[\"普通的计数器\",{\"1\":{\"181\":1}}],[\"别的还真的没用过\",{\"1\":{\"181\":1}}],[\"别的都是类似的使用方式\",{\"1\":{\"179\":1}}],[\"少了一些成员函数\",{\"1\":{\"180\":1}}],[\"防止线程由于编码失误导致一直持有锁\",{\"1\":{\"180\":1}}],[\"防止频繁扩容\",{\"1\":{\"64\":1}}],[\"拿一个std\",{\"1\":{\"179\":1}}],[\"拿二叉搜索树来举例\",{\"1\":{\"116\":1}}],[\"带超时的互斥量\",{\"1\":{\"179\":2}}],[\"带来的性能开销和死锁风险\",{\"1\":{\"168\":1}}],[\"独占的互斥量\",{\"1\":{\"179\":1}}],[\"适用于更新指针操作\",{\"1\":{\"173\":1}}],[\"适用于检查队列是否满或空\",{\"1\":{\"173\":1}}],[\"适用于\",{\"1\":{\"173\":1}}],[\"适用于高频查找\",{\"1\":{\"114\":1}}],[\"生产者插入数据\",{\"1\":{\"172\":1}}],[\"生产者线程\",{\"1\":{\"172\":1}}],[\"生产者线程通知消费者线程有新数据可用\",{\"1\":{\"161\":1}}],[\"主函数中的生产者和消费者\",{\"1\":{\"172\":1}}],[\"主要看方法的使用范围\",{\"1\":{\"116\":1}}],[\"主要有std\",{\"1\":{\"184\":1}}],[\"主要有两个原因\",{\"1\":{\"39\":1}}],[\"主要有以下几部分\",{\"1\":{\"0\":1}}],[\"主要包含一些基本的\",{\"1\":{\"0\":1}}],[\"检查线程可否被join\",{\"1\":{\"178\":1}}],[\"检查取出操作是否成功\",{\"1\":{\"172\":1}}],[\"检查插入操作是否成功\",{\"1\":{\"172\":1}}],[\"检查队列是否为空\",{\"1\":{\"172\":1}}],[\"检查队列是否已满\",{\"1\":{\"172\":1}}],[\"检查条件状态\",{\"1\":{\"161\":1}}],[\"启动消费者线程\",{\"1\":{\"171\":1,\"172\":1}}],[\"启动生产者线程\",{\"1\":{\"171\":1,\"172\":1}}],[\"模板类\",{\"1\":{\"170\":1}}],[\"引入了\",{\"1\":{\"170\":1}}],[\"引用记录了下一个节点的内存地址\",{\"1\":{\"21\":1}}],[\"引用\",{\"1\":{\"21\":3}}],[\"参考\",{\"1\":{\"167\":2}}],[\"互相持有其他进程\",{\"1\":{\"167\":1}}],[\"互斥\",{\"1\":{\"167\":1}}],[\"互斥量可以独占\",{\"1\":{\"185\":1}}],[\"互斥量有一个内部状态\",{\"1\":{\"159\":1}}],[\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问\",{\"1\":{\"159\":1}}],[\"共享\",{\"1\":{\"167\":1}}],[\"禁止抢占\",{\"1\":{\"167\":1}}],[\"死锁问题的排查\",{\"1\":{\"167\":1}}],[\"死锁的四个条件\",{\"1\":{\"167\":1}}],[\"死锁\",{\"0\":{\"167\":1}}],[\"继续执行\",{\"1\":{\"166\":1}}],[\"倒数计数器\",{\"1\":{\"166\":1}}],[\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景\",{\"1\":{\"166\":1}}],[\"锁存器计数减少\",{\"1\":{\"166\":1}}],[\"锁存器内部维护一个倒数计数器\",{\"1\":{\"166\":1}}],[\"锁存器类似于屏障\",{\"1\":{\"166\":1}}],[\"锁定\",{\"1\":{\"159\":1}}],[\"锁定或未锁定\",{\"1\":{\"159\":1}}],[\"屏障适用于并行计算中需要同步多个线程的场景\",{\"1\":{\"165\":1}}],[\"屏障解除\",{\"1\":{\"165\":1}}],[\"屏障内部维护一个计数器\",{\"1\":{\"165\":1}}],[\"屏障用于同步一组线程\",{\"1\":{\"165\":1}}],[\"屏蔽\",{\"1\":{\"51\":1}}],[\"忙等待\",{\"1\":{\"164\":1}}],[\"计数器加\",{\"1\":{\"163\":1}}],[\"计数器减\",{\"1\":{\"163\":1,\"165\":1,\"166\":1}}],[\"计数器初始值通常为资源的总量\",{\"1\":{\"163\":1}}],[\"计数器\",{\"1\":{\"163\":1,\"165\":1}}],[\"计算插入元素后的尾部指针值\",{\"1\":{\"172\":1}}],[\"计算效率更高\",{\"1\":{\"75\":1}}],[\"计算开销越小\",{\"1\":{\"73\":1}}],[\"计算哈希值的过程应该足够快\",{\"1\":{\"73\":1}}],[\"计算桶索引\",{\"1\":{\"68\":1}}],[\"计算得到哈希值\",{\"1\":{\"63\":1}}],[\"计算队尾指针\",{\"1\":{\"47\":1}}],[\"计算机不仅会加载它\",{\"1\":{\"19\":1}}],[\"标志位等\",{\"1\":{\"162\":1}}],[\"标记为已删除的空间可以再次使用\",{\"1\":{\"78\":1}}],[\"标记为已删除的空间还能再次使用吗\",{\"1\":{\"78\":1}}],[\"硬件支持\",{\"1\":{\"162\":1}}],[\"消费者取出数据\",{\"1\":{\"172\":1}}],[\"消费者线程\",{\"1\":{\"172\":1}}],[\"消费者线程等待该通知\",{\"1\":{\"161\":1}}],[\"消费者模型等\",{\"1\":{\"163\":1}}],[\"消费者模型中\",{\"1\":{\"161\":1}}],[\"唤醒一个线程\",{\"1\":{\"163\":1}}],[\"唤醒一个或所有等待队列中的线程\",{\"1\":{\"161\":1}}],[\"唤醒所有等待的线程\",{\"1\":{\"161\":1}}],[\"变为\",{\"1\":{\"161\":1}}],[\"变量\",{\"1\":{\"102\":1}}],[\"条件变量需要和锁配合使用\",{\"1\":{\"183\":1}}],[\"条件变量是c++11引入的一种同步机制\",{\"1\":{\"183\":1}}],[\"条件变量常用于线程之间的协调\",{\"1\":{\"161\":1}}],[\"条件变量与一个互斥量和一个条件状态相关联\",{\"1\":{\"161\":1}}],[\"条件变量用于线程之间的等待和通知机制\",{\"1\":{\"161\":1}}],[\"写锁定\",{\"1\":{\"160\":1}}],[\"读锁定\",{\"1\":{\"160\":1}}],[\"读写锁包含两个计数器\",{\"1\":{\"160\":1}}],[\"读写锁允许多个线程同时读取\",{\"1\":{\"160\":1}}],[\"解锁\",{\"1\":{\"159\":1,\"160\":1,\"164\":1}}],[\"解释器在每次启动时\",{\"1\":{\"76\":1}}],[\"维护一个等待队列\",{\"1\":{\"159\":1,\"160\":1,\"161\":1}}],[\"新增线程编程相关模块\",{\"0\":{\"177\":1}}],[\"新特性\",{\"0\":{\"176\":1}}],[\"新的线程与主线程没有任何关联\",{\"1\":{\"157\":1}}],[\"新建\",{\"1\":{\"148\":1,\"149\":1}}],[\"表示需要完成的任务数量\",{\"1\":{\"166\":1}}],[\"表示所有线程都已到达屏障点\",{\"1\":{\"165\":1}}],[\"表示已到达屏障的线程数量\",{\"1\":{\"165\":1}}],[\"表示当前可用资源的数量\",{\"1\":{\"163\":1}}],[\"表示将线程和线程对象分离\",{\"1\":{\"157\":1,\"178\":1}}],[\"表示该节点是叶节点\",{\"1\":{\"96\":1}}],[\"选择适当的方法管理子进程的生命周期\",{\"1\":{\"153\":1}}],[\"选取一个合理的数组初始容量\",{\"1\":{\"37\":1}}],[\"孙子进程\",{\"1\":{\"153\":1}}],[\"孙子进程则由\",{\"1\":{\"153\":1}}],[\"创建了一个\",{\"1\":{\"172\":1}}],[\"创建一个孙子进程\",{\"1\":{\"153\":1}}],[\"创建一个子进程\",{\"1\":{\"153\":1}}],[\"创建型模式\",{\"1\":{\"122\":1}}],[\"信号量适用于控制对资源的并发访问数量\",{\"1\":{\"163\":1}}],[\"信号量内部维护一个计数器\",{\"1\":{\"163\":1}}],[\"信号量是一种控制对共享资源访问的计数器\",{\"1\":{\"163\":1}}],[\"信号处理程序\",{\"1\":{\"153\":1}}],[\"信号处理子进程的结束\",{\"1\":{\"153\":1}}],[\"信号\",{\"1\":{\"153\":2}}],[\"父进程等待第一个子进程退出\",{\"1\":{\"153\":1}}],[\"父进程只需等待子进程的退出状态\",{\"1\":{\"153\":1}}],[\"父进程通过\",{\"1\":{\"153\":1}}],[\"父进程退出\",{\"1\":{\"153\":1}}],[\"父进程继续执行其任务\",{\"1\":{\"153\":1}}],[\"父进程可以在信号处理程序中调用\",{\"1\":{\"153\":1}}],[\"父进程会收到\",{\"1\":{\"153\":1}}],[\"父进程代码\",{\"1\":{\"153\":2}}],[\"父进程在适当的时机调用\",{\"1\":{\"153\":1}}],[\"父节点\",{\"1\":{\"82\":1}}],[\"及时调用\",{\"1\":{\"153\":1}}],[\"及其以下节点形成的树\",{\"1\":{\"82\":2}}],[\"避免一直阻塞等锁\",{\"1\":{\"185\":1}}],[\"避免没有调用join或者detach可导致程序出错的情况出现\",{\"1\":{\"178\":1}}],[\"避免使用锁机制带来的开销\",{\"1\":{\"162\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"153\":1}}],[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态\",{\"1\":{\"153\":1}}],[\"避免运行时错误\",{\"1\":{\"123\":1}}],[\"虽然僵尸进程不会占用内存或\",{\"1\":{\"152\":1}}],[\"虽然自定义对象\",{\"1\":{\"76\":1}}],[\"文件描述符等\",{\"1\":{\"151\":1}}],[\"weak\",{\"1\":{\"187\":2}}],[\"working\",{\"1\":{\"163\":1,\"164\":1}}],[\"worker\",{\"1\":{\"163\":2,\"164\":2,\"165\":2,\"166\":2}}],[\"writer\",{\"1\":{\"160\":3}}],[\"write\",{\"1\":{\"160\":1}}],[\"wnohang\",{\"1\":{\"153\":1}}],[\"waiting\",{\"1\":{\"165\":1,\"167\":1}}],[\"waitpid\",{\"1\":{\"151\":2,\"153\":4}}],[\"wait\",{\"1\":{\"151\":2,\"153\":8,\"161\":2,\"163\":1,\"165\":1,\"166\":1,\"167\":1,\"183\":2,\"185\":1}}],[\"while\",{\"1\":{\"27\":1,\"68\":1,\"94\":1,\"95\":1,\"96\":2,\"112\":1,\"153\":1,\"164\":1,\"171\":2,\"172\":4,\"183\":1}}],[\"zombie\",{\"1\":{\"151\":1}}],[\"zfooei\",{\"1\":{\"142\":1}}],[\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的\",{\"1\":{\"153\":1}}],[\"僵尸进程的影响\",{\"0\":{\"152\":1}}],[\"僵尸进程的进程描述符才会被完全清除\",{\"1\":{\"151\":1}}],[\"僵尸进程\",{\"0\":{\"151\":1},\"1\":{\"151\":1}}],[\"状态转换示意图\",{\"0\":{\"150\":1}}],[\"终止\",{\"1\":{\"148\":1,\"149\":1}}],[\"正在等待某个事件\",{\"1\":{\"148\":1}}],[\"阻塞直到函数返回\",{\"1\":{\"185\":1}}],[\"阻塞的进程会被移回就绪队列\",{\"1\":{\"149\":1}}],[\"阻塞\",{\"1\":{\"148\":1,\"149\":2}}],[\"运行\",{\"1\":{\"148\":1,\"149\":4}}],[\"资源只能同时分配给一个进程\",{\"1\":{\"167\":1}}],[\"资源占用\",{\"1\":{\"152\":1}}],[\"资源可用\",{\"1\":{\"148\":1}}],[\"资源\",{\"1\":{\"148\":1}}],[\"被唤醒的线程重新获得互斥量\",{\"1\":{\"161\":1}}],[\"被释放给其他就绪进程\",{\"1\":{\"149\":1}}],[\"被mutable\",{\"1\":{\"143\":1}}],[\"被分配到同一个桶中的概率就越低\",{\"1\":{\"64\":1}}],[\"问题\",{\"1\":{\"142\":1}}],[\"让临时右值的生命周期延长了\",{\"1\":{\"188\":1}}],[\"让c++\",{\"1\":{\"142\":1}}],[\"让输出值落在数组索引范围内\",{\"1\":{\"78\":1}}],[\"技术\",{\"1\":{\"142\":1,\"153\":2}}],[\"宏没有类型安全检查\",{\"1\":{\"141\":1}}],[\"宏用于定义常量和简单的代码片段\",{\"1\":{\"141\":1}}],[\"宏与constexpr\",{\"0\":{\"141\":1}}],[\"区别\",{\"0\":{\"141\":1}}],[\"地址值+sizeof\",{\"1\":{\"140\":2}}],[\"三者之间的关系\",{\"1\":{\"184\":1}}],[\"三者做运算时有差异\",{\"1\":{\"140\":1}}],[\"三种情况\",{\"1\":{\"96\":1}}],[\"析构函数\",{\"1\":{\"139\":2}}],[\"析构方法\",{\"1\":{\"66\":1,\"68\":1}}],[\"释放操作\",{\"1\":{\"163\":1}}],[\"释放对象的操作符\",{\"1\":{\"139\":1}}],[\"释放内存的基础上还会额外调用构造\",{\"1\":{\"139\":1}}],[\"释放内存并置为\",{\"1\":{\"63\":1}}],[\"释放内存\",{\"1\":{\"18\":1,\"25\":1,\"46\":2,\"52\":2,\"63\":1,\"66\":3,\"96\":1}}],[\"类是一个泛型队列\",{\"1\":{\"172\":1}}],[\"类定义与构造函数\",{\"1\":{\"172\":1}}],[\"类成员或函数可以直接通过类名访问无需创建对象\",{\"1\":{\"138\":1}}],[\"类似地\",{\"1\":{\"112\":1}}],[\"类似于\",{\"1\":{\"116\":1}}],[\"类似于数组扩容\",{\"1\":{\"64\":1}}],[\"类似于双向链表\",{\"1\":{\"30\":1}}],[\"延长变量的生命周期为整个程序的生命周期\",{\"1\":{\"138\":1}}],[\"限制作用范围\",{\"1\":{\"138\":1}}],[\"修饰除外\",{\"1\":{\"143\":1}}],[\"修饰成员函数表示函数体不会修改类成员\",{\"1\":{\"143\":1}}],[\"修饰局部变量\",{\"1\":{\"138\":1}}],[\"修饰全局变量或函数\",{\"1\":{\"138\":1}}],[\"修改\",{\"1\":{\"31\":1}}],[\"基本概念\",{\"0\":{\"169\":1}}],[\"基本结构\",{\"1\":{\"159\":1,\"160\":1,\"161\":1}}],[\"基础\",{\"0\":{\"137\":1}}],[\"基于对称性\",{\"1\":{\"106\":1}}],[\"基于链式地址实现的哈希表的操作方法发生了以下变化\",{\"1\":{\"66\":1}}],[\"基于链表实现的栈可以提供更加稳定的效率表现\",{\"1\":{\"54\":1}}],[\"基于链表实现的栈\",{\"1\":{\"52\":1}}],[\"基于链表实现的队列\",{\"1\":{\"46\":1}}],[\"基于链表实现栈的入栈出栈操作\",{\"1\":{\"52\":1}}],[\"基于链表实现队列的入队出队操作\",{\"1\":{\"46\":1}}],[\"基于链表的实现\",{\"0\":{\"46\":1,\"52\":1}}],[\"基于数组实现的哈希表\",{\"1\":{\"63\":1}}],[\"基于数组实现的栈可能造成一定的空间浪费\",{\"1\":{\"54\":1}}],[\"基于数组实现的栈在触发扩容时效率会降低\",{\"1\":{\"54\":1}}],[\"基于数组实现的栈\",{\"1\":{\"53\":1}}],[\"基于数组实现栈的入栈出栈操作\",{\"1\":{\"53\":1}}],[\"基于数组的实现\",{\"0\":{\"47\":1,\"53\":1}}],[\"基于环形数组实现的队列\",{\"1\":{\"47\":1}}],[\"基于此设计\",{\"1\":{\"47\":1}}],[\"例子\",{\"0\":{\"132\":1}}],[\"例如限制同时访问文件的线程数\",{\"1\":{\"163\":1}}],[\"例如高度\",{\"1\":{\"116\":1}}],[\"例如在每个计算步骤完成后同步所有线程\",{\"1\":{\"165\":1}}],[\"例如在中断上下文或需要避免线程调度开销的情况下使用\",{\"1\":{\"164\":1}}],[\"例如在生产者\",{\"1\":{\"161\":1}}],[\"例如在二叉搜索树中\",{\"1\":{\"116\":1}}],[\"例如在链式地址中\",{\"1\":{\"78\":1}}],[\"例如在\",{\"1\":{\"64\":1}}],[\"例如打印机的任务队列\",{\"1\":{\"48\":1}}],[\"例如初始化任务完成后启动主任务\",{\"1\":{\"166\":1}}],[\"例如初始化二维列表\",{\"1\":{\"39\":1}}],[\"例如初始容量\",{\"1\":{\"37\":1}}],[\"例如\",{\"1\":{\"20\":1,\"31\":1,\"37\":1,\"39\":3,\"54\":2,\"64\":1,\"73\":1,\"75\":2,\"77\":1,\"116\":1,\"153\":1}}],[\"持有一个策略对象\",{\"1\":{\"131\":1}}],[\"策略接口\",{\"1\":{\"131\":1}}],[\"策略模式使得算法的变化不会影响到使用算法的客户类\",{\"1\":{\"130\":1}}],[\"策略模式\",{\"0\":{\"130\":1},\"1\":{\"3\":1,\"122\":1,\"130\":1},\"2\":{\"134\":1}}],[\"事件模式\",{\"2\":{\"129\":1}}],[\"找出系统中可预计的变化\",{\"1\":{\"124\":1}}],[\"找到待删除节点\",{\"1\":{\"96\":1}}],[\"找到待删除节点在\",{\"1\":{\"96\":1}}],[\"找到重复节点\",{\"1\":{\"95\":1}}],[\"找到目标节点\",{\"1\":{\"94\":1}}],[\"稳定\",{\"1\":{\"124\":1}}],[\"隔离变化\",{\"1\":{\"124\":1}}],[\"调用get或者wait时才会执行\",{\"1\":{\"185\":1}}],[\"调用join函数将会阻塞主线程\",{\"1\":{\"178\":1}}],[\"调用\",{\"1\":{\"157\":1}}],[\"调用模块只依赖抽象接口\",{\"1\":{\"124\":1}}],[\"调度器选择一个就绪的进程并将其分配给\",{\"1\":{\"149\":1}}],[\"调度算法\",{\"1\":{\"30\":1}}],[\"降低耦合性\",{\"1\":{\"124\":1}}],[\"细节应该依赖于抽象\",{\"1\":{\"123\":1}}],[\"细心的你可能发现在不同控制台中运行程序时\",{\"1\":{\"76\":1}}],[\"抽象不应依赖于细节\",{\"1\":{\"123\":1}}],[\"依赖倒置原则\",{\"1\":{\"123\":1}}],[\"依次访问所有节点\",{\"1\":{\"23\":1}}],[\"保证在并发环境下操作的不可分割性\",{\"1\":{\"162\":1}}],[\"保证线程函数的生命周期和线程对象的生命周期相同\",{\"1\":{\"157\":1,\"178\":1}}],[\"保证继承层次的正确性\",{\"1\":{\"123\":1}}],[\"保持与c\",{\"1\":{\"142\":1}}],[\"保存上一轮循环的节点\",{\"1\":{\"95\":1}}],[\"里氏替换原则\",{\"1\":{\"123\":1}}],[\"里面的\",{\"1\":{\"39\":1}}],[\"允许添加新功能而无需修改现有代码\",{\"1\":{\"123\":1}}],[\"软件实体应对扩展开放\",{\"1\":{\"123\":1}}],[\"软件中的撤销与反撤销\",{\"1\":{\"55\":1}}],[\"目的是避免传统锁机制\",{\"1\":{\"168\":1}}],[\"目的\",{\"1\":{\"123\":5}}],[\"目标节点在\",{\"1\":{\"94\":2}}],[\"行为型模式\",{\"1\":{\"122\":1}}],[\"组成部分\",{\"0\":{\"131\":1}}],[\"组合模式\",{\"1\":{\"122\":1}}],[\"组织和存储大型数据\",{\"1\":{\"114\":1}}],[\"结构型模式\",{\"1\":{\"122\":1}}],[\"工厂模式\",{\"1\":{\"122\":1}}],[\"关键字的作用\",{\"0\":{\"138\":1,\"143\":1}}],[\"关于async启动策略这里网上和各种书籍介绍的五花八门\",{\"1\":{\"185\":1}}],[\"关于线程操作应该优先使用async\",{\"1\":{\"185\":1}}],[\"关于条件变量其实还涉及到通知丢失和虚假唤醒问题\",{\"1\":{\"183\":1}}],[\"关于架构设计的一点思考\",{\"0\":{\"124\":1}}],[\"关于c++\",{\"1\":{\"7\":1}}],[\"关注对象间通信\",{\"1\":{\"122\":1}}],[\"关注对象组合\",{\"1\":{\"122\":1}}],[\"关注对象创建\",{\"1\":{\"122\":1}}],[\"广度优先遍历到最底层之前\",{\"1\":{\"116\":1}}],[\"至于根节点的选择\",{\"1\":{\"116\":1}}],[\"函数内部创建的对象返回后构造一个临时对象产生的\",{\"1\":{\"188\":1}}],[\"函数func和func1运行在线程对象t和tt中\",{\"1\":{\"178\":1}}],[\"函数中\",{\"1\":{\"172\":1}}],[\"函数将会阻塞主线程\",{\"1\":{\"157\":1}}],[\"函数\",{\"1\":{\"153\":1,\"157\":3}}],[\"函数回收子进程的退出状态信息\",{\"1\":{\"151\":1}}],[\"函数时会失败\",{\"1\":{\"142\":1}}],[\"函数名被修饰成\",{\"1\":{\"142\":1}}],[\"函数return\",{\"1\":{\"138\":1}}],[\"函数分别放在\",{\"1\":{\"116\":1}}],[\"函数和\",{\"1\":{\"116\":1}}],[\"函数被划分到\",{\"1\":{\"116\":1}}],[\"函数来计算各种数据类型的哈希值\",{\"1\":{\"76\":1}}],[\"传入的是子树的根节点\",{\"1\":{\"116\":1}}],[\"原因在于右值引用绑定了右值\",{\"1\":{\"188\":1}}],[\"原子地加载当前的头部指针\",{\"1\":{\"172\":1}}],[\"原子地加载当前的尾部指针\",{\"1\":{\"172\":1}}],[\"原子比较并交换\",{\"1\":{\"170\":1}}],[\"原子交换\",{\"1\":{\"170\":1}}],[\"原子递增和递减\",{\"1\":{\"170\":1}}],[\"原子加载和存储\",{\"1\":{\"170\":1}}],[\"原子操作是不可分割的\",{\"1\":{\"169\":1}}],[\"原子操作适用于需要高效并发访问的场景\",{\"1\":{\"162\":1}}],[\"原子操作\",{\"1\":{\"162\":1,\"169\":1}}],[\"原子操作直接操作共享变量\",{\"1\":{\"162\":1}}],[\"原子操作依赖于硬件提供的原子指令\",{\"1\":{\"162\":1}}],[\"原子操作通过硬件支持的指令集实现\",{\"1\":{\"162\":1}}],[\"原来的连接不需要维护吗\",{\"1\":{\"116\":1}}],[\"原先落在同一个桶的多个\",{\"1\":{\"78\":1}}],[\"原先末尾的元素变得\",{\"1\":{\"15\":1}}],[\"吗\",{\"1\":{\"116\":2}}],[\"层\",{\"1\":{\"115\":1}}],[\"层的节点数量\",{\"1\":{\"91\":1}}],[\"体现\",{\"1\":{\"115\":1}}],[\"体现了\",{\"1\":{\"82\":1}}],[\"重复节点不插入\",{\"1\":{\"111\":1}}],[\"重点回顾\",{\"0\":{\"38\":1,\"56\":1,\"77\":1,\"115\":1}}],[\"辅助方法\",{\"1\":{\"111\":1,\"112\":1}}],[\"递归互斥量\",{\"1\":{\"179\":1}}],[\"递归插入节点\",{\"1\":{\"111\":1}}],[\"递归删除节点\",{\"1\":{\"96\":1,\"112\":1}}],[\"唯一的区别在于\",{\"1\":{\"111\":1}}],[\"唯一的缺点\",{\"1\":{\"6\":1}}],[\"≤0\",{\"1\":{\"109\":1}}],[\"≥0\",{\"1\":{\"109\":1}}],[\"替换为\",{\"1\":{\"106\":2}}],[\"替换为质数\",{\"1\":{\"74\":1}}],[\"镜像\",{\"1\":{\"106\":1}}],[\"失衡节点的平衡因子\",{\"1\":{\"109\":1}}],[\"失衡节点\",{\"1\":{\"104\":1}}],[\"旋转的选择\",{\"0\":{\"109\":1}}],[\"旋转操作分为四种\",{\"1\":{\"104\":1}}],[\"旋转操作既能保持\",{\"1\":{\"104\":1}}],[\"旋转\",{\"1\":{\"104\":1}}],[\"旋转哈希\",{\"1\":{\"74\":2}}],[\"方便异步调用\",{\"1\":{\"184\":1}}],[\"方便后续使用\",{\"1\":{\"103\":1}}],[\"方法用于从队列中取出一个元素\",{\"1\":{\"172\":1}}],[\"方法用于将一个元素插入队列\",{\"1\":{\"172\":1}}],[\"方法中给出\",{\"1\":{\"116\":1}}],[\"方法是将节点值和空位按层序遍历顺序排列\",{\"1\":{\"115\":1}}],[\"方法\",{\"1\":{\"50\":1,\"116\":1,\"172\":2}}],[\"方法名\",{\"1\":{\"44\":1}}],[\"u\",{\"1\":{\"192\":2}}],[\"uint32\",{\"1\":{\"183\":4}}],[\"using\",{\"1\":{\"178\":1,\"179\":2,\"180\":1,\"184\":2,\"185\":1,\"188\":1,\"189\":1}}],[\"updateheight\",{\"1\":{\"102\":1,\"105\":2,\"106\":2,\"111\":1,\"112\":1,\"116\":2}}],[\"unqi\",{\"1\":{\"187\":2}}],[\"uniq\",{\"1\":{\"187\":1}}],[\"unique\",{\"1\":{\"160\":1,\"161\":1,\"180\":5,\"183\":4,\"185\":1}}],[\"unix\",{\"1\":{\"151\":2}}],[\"unlock\",{\"1\":{\"159\":1,\"160\":1,\"164\":2,\"179\":2}}],[\"until\",{\"1\":{\"157\":2}}],[\"unsigned\",{\"1\":{\"74\":1}}],[\"unordered\",{\"1\":{\"62\":1}}],[\"undo\",{\"1\":{\"57\":1}}],[\"级别\",{\"1\":{\"100\":1}}],[\"确保主线程在两个子线程结束后才退出\",{\"1\":{\"172\":1}}],[\"确保更新操作一定在取值之后\",{\"1\":{\"171\":1}}],[\"确保所有线程都到达某个同步点后才能继续执行\",{\"1\":{\"165\":1}}],[\"确保在不同平台上实现一致的原子操作行为\",{\"1\":{\"162\":1}}],[\"确保在持续添加和删除节点后\",{\"1\":{\"100\":1}}],[\"确定性\",{\"1\":{\"73\":1}}],[\"论文中详细描述了一系列操作\",{\"1\":{\"100\":1}}],[\"年\",{\"1\":{\"100\":1}}],[\"劣化为\",{\"1\":{\"100\":1}}],[\"利用中序遍历升序的性质\",{\"1\":{\"97\":1}}],[\"利用乘法的不相关性\",{\"1\":{\"74\":1}}],[\"右偏树\",{\"1\":{\"109\":3}}],[\"右旋和左旋操作在逻辑上是镜像对称的\",{\"1\":{\"106\":1}}],[\"右旋操作后岂不是断掉了\",{\"1\":{\"116\":1}}],[\"右旋操作是处理失衡节点\",{\"1\":{\"116\":1}}],[\"右旋操作\",{\"1\":{\"105\":1,\"116\":1}}],[\"右旋操作步骤\",{\"1\":{\"105\":1}}],[\"右旋\",{\"0\":{\"105\":1},\"1\":{\"104\":1,\"105\":1,\"107\":1,\"108\":1,\"109\":2}}],[\"右\",{\"1\":{\"97\":1,\"115\":2,\"116\":1}}],[\"右子节点值\",{\"1\":{\"116\":1}}],[\"右子节点\",{\"1\":{\"97\":1,\"102\":1}}],[\"右子节点指针\",{\"1\":{\"82\":1}}],[\"右子树高度\",{\"1\":{\"103\":1}}],[\"右子树\",{\"1\":{\"95\":1,\"96\":2}}],[\"右子树也是二叉搜索树\",{\"1\":{\"92\":1}}],[\"右子树中所有节点的值\",{\"1\":{\"92\":1}}],[\"右子树是\",{\"1\":{\"82\":1}}],[\"→\",{\"1\":{\"97\":2,\"116\":2,\"149\":6}}],[\"左偏树\",{\"1\":{\"109\":3}}],[\"左旋的操作\",{\"1\":{\"109\":1}}],[\"左旋操作\",{\"1\":{\"106\":2}}],[\"左旋\",{\"0\":{\"106\":1},\"1\":{\"104\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":2,\"115\":1}}],[\"左\",{\"1\":{\"97\":1,\"116\":1}}],[\"左子树高度\",{\"1\":{\"103\":1}}],[\"左子树\",{\"1\":{\"95\":1,\"96\":2}}],[\"左子树中所有节点的值\",{\"1\":{\"92\":1}}],[\"左子树是\",{\"1\":{\"82\":1}}],[\"左子节点值\",{\"1\":{\"116\":1}}],[\"左子节点\",{\"1\":{\"97\":1,\"102\":1}}],[\"左子节点指针\",{\"1\":{\"82\":1}}],[\"左子节点引用和右子节点引用\",{\"1\":{\"82\":1}}],[\"覆盖\",{\"1\":{\"96\":1}}],[\"待删除节点在\",{\"1\":{\"96\":2}}],[\"用来定义常量和函数\",{\"1\":{\"141\":1}}],[\"用来对比两个对象的值是否相等\",{\"1\":{\"116\":1}}],[\"用来比较两个变量是否指向同一个对象\",{\"1\":{\"116\":1}}],[\"用户单独调用\",{\"1\":{\"116\":1}}],[\"用作系统中的多级索引\",{\"1\":{\"99\":1}}],[\"用\",{\"1\":{\"96\":2}}],[\"用于解决\",{\"1\":{\"187\":1}}],[\"用于保存多线程同时操作的共享数据\",{\"1\":{\"179\":1}}],[\"用于保存等待条件的线程\",{\"1\":{\"161\":1}}],[\"用于保存等待的线程\",{\"1\":{\"160\":1}}],[\"用于保存等待锁的线程\",{\"1\":{\"159\":1}}],[\"用于加载操作\",{\"1\":{\"173\":1}}],[\"用于没有数据依赖的地方\",{\"1\":{\"173\":1}}],[\"用于函数穿参数\",{\"1\":{\"143\":1}}],[\"用于对比两个变量的值是否相等\",{\"1\":{\"116\":1}}],[\"用于构建数据库中的索引系统\",{\"1\":{\"114\":1}}],[\"用于存储操作\",{\"1\":{\"173\":1}}],[\"用于存储数据流\",{\"1\":{\"99\":1}}],[\"用于存储队列元素的数组\",{\"1\":{\"47\":1}}],[\"用于计算哈希表中的桶索引\",{\"1\":{\"76\":1,\"77\":1}}],[\"用于衡量哈希冲突的严重程度\",{\"1\":{\"64\":1}}],[\"用于反撤销\",{\"1\":{\"57\":1}}],[\"用于撤销\",{\"1\":{\"57\":1}}],[\"用于记录函数的上下文信息\",{\"1\":{\"55\":1}}],[\"用于记录队列长度\",{\"1\":{\"47\":1}}],[\"用于记录列表当前元素数量\",{\"1\":{\"37\":1}}],[\"记为\",{\"1\":{\"96\":1,\"105\":1,\"106\":1}}],[\"记录遇到的首个删除标记\",{\"1\":{\"68\":1}}],[\"度\",{\"1\":{\"115\":1}}],[\"度为\",{\"1\":{\"96\":3}}],[\"度的取值范围是\",{\"1\":{\"83\":1}}],[\"执行旋转操作\",{\"1\":{\"109\":1,\"111\":1,\"112\":1}}],[\"执行\",{\"1\":{\"105\":1,\"107\":2,\"108\":2}}],[\"执行对应的删除节点操作\",{\"1\":{\"96\":1}}],[\"执行扩容\",{\"1\":{\"66\":1,\"68\":1}}],[\"否则将违反其定义\",{\"1\":{\"95\":1}}],[\"跳出循环\",{\"1\":{\"94\":1,\"96\":1}}],[\"跳出循环并返回该节点\",{\"1\":{\"94\":1}}],[\"循环引用和返回\",{\"1\":{\"187\":1}}],[\"循环等待\",{\"1\":{\"167\":1}}],[\"循环等待不可抢占的互斥资源\",{\"1\":{\"167\":1}}],[\"循环查找\",{\"1\":{\"94\":1,\"95\":1,\"96\":1}}],[\"循环次数最多为二叉树的高度\",{\"1\":{\"94\":1}}],[\"循环比较节点值\",{\"1\":{\"94\":1}}],[\"满足以下条件\",{\"1\":{\"92\":1}}],[\"满足均匀分布不一定满足抗碰撞性\",{\"1\":{\"73\":1}}],[\"−1≤f≤1\",{\"1\":{\"103\":1}}],[\"−1\",{\"1\":{\"91\":1,\"102\":1}}],[\"达到\",{\"1\":{\"91\":1}}],[\"达到最佳查询效率\",{\"1\":{\"72\":1}}],[\"平衡树\",{\"1\":{\"109\":1}}],[\"平衡\",{\"1\":{\"98\":1}}],[\"平衡二叉树\",{\"0\":{\"90\":1},\"1\":{\"90\":2,\"104\":1}}],[\"平方探测和多次哈希\",{\"1\":{\"70\":1}}],[\"平方探测和多次哈希等\",{\"1\":{\"67\":1}}],[\"平方探测也可能无法访问到它\",{\"1\":{\"69\":1}}],[\"平方探测可能不会探测整个哈希表\",{\"1\":{\"69\":1}}],[\"平方探测并不是完美的\",{\"1\":{\"69\":1}}],[\"平方探测会跳过更大的距离来寻找空位置\",{\"1\":{\"69\":1}}],[\"平方探测通过跳过探测次数平方的距离\",{\"1\":{\"69\":1}}],[\"平方探测主要具有以下优势\",{\"1\":{\"69\":1}}],[\"平方探测不是简单地跳过一个固定的步数\",{\"1\":{\"69\":1}}],[\"平方探测与线性探测类似\",{\"1\":{\"69\":1}}],[\"平方探测\",{\"0\":{\"69\":1}}],[\"完成前不开始\",{\"1\":{\"185\":1}}],[\"完成或资源可用\",{\"1\":{\"149\":1}}],[\"完成\",{\"1\":{\"148\":1}}],[\"完成右旋后\",{\"1\":{\"105\":1}}],[\"完满二叉树和平衡二叉树\",{\"1\":{\"115\":1}}],[\"完全二叉树\",{\"0\":{\"89\":1},\"1\":{\"89\":2,\"115\":1}}],[\"完美二叉树是最理想的状态\",{\"1\":{\"115\":1}}],[\"完美二叉树是理想情况\",{\"1\":{\"91\":1}}],[\"完美二叉树也是一棵完全二叉树\",{\"1\":{\"89\":1}}],[\"完美二叉树常被称为满二叉树\",{\"1\":{\"88\":1}}],[\"完美二叉树\",{\"0\":{\"88\":1},\"1\":{\"88\":2,\"91\":2}}],[\"呈现标准的指数级关系\",{\"1\":{\"88\":1}}],[\"经过两次删除节点操作\",{\"1\":{\"100\":1}}],[\"经过的节点的数量\",{\"1\":{\"83\":1}}],[\"经过的边的数量\",{\"1\":{\"83\":1,\"116\":1}}],[\"经过哈希函数得到桶索引\",{\"1\":{\"66\":1}}],[\"深度\",{\"1\":{\"83\":1}}],[\"深入理解计算机系统\",{\"1\":{\"7\":1}}],[\"边\",{\"1\":{\"83\":1,\"102\":1,\"115\":1}}],[\"没有子节点的节点\",{\"1\":{\"83\":1}}],[\"没有父节点\",{\"1\":{\"83\":1}}],[\"叶节点的高度为\",{\"1\":{\"102\":1}}],[\"叶节点的度为\",{\"1\":{\"88\":1}}],[\"叶节点\",{\"1\":{\"83\":1,\"115\":1}}],[\"位于二叉树顶层的节点\",{\"1\":{\"83\":1}}],[\"根\",{\"1\":{\"97\":1,\"116\":1}}],[\"根节点的选择是不是很重要\",{\"1\":{\"116\":1}}],[\"根节点的值\",{\"1\":{\"92\":1}}],[\"根节点值\",{\"1\":{\"116\":1}}],[\"根节点所在层为\",{\"1\":{\"83\":1}}],[\"根节点\",{\"1\":{\"83\":1,\"95\":1,\"96\":2,\"97\":1}}],[\"根据节点失衡情况的不同\",{\"1\":{\"104\":1}}],[\"根据当前节点值和\",{\"1\":{\"95\":1}}],[\"根据此哈希函数\",{\"1\":{\"68\":1}}],[\"根据此变量\",{\"1\":{\"37\":1}}],[\"根据哈希函数的结果访问链表头部\",{\"1\":{\"66\":1}}],[\"根据索引实现随机抽样\",{\"1\":{\"20\":1}}],[\"子进程再\",{\"1\":{\"153\":1}}],[\"子进程继续执行\",{\"1\":{\"153\":1}}],[\"子进程被\",{\"1\":{\"153\":1}}],[\"子进程会被\",{\"1\":{\"153\":1}}],[\"子进程代码\",{\"1\":{\"153\":2}}],[\"子进程终止后\",{\"1\":{\"151\":1}}],[\"子类对象必须能够替换其父类对象且行为一致\",{\"1\":{\"123\":1}}],[\"子树的根节点和其父节点的连接是在该函数返回后完成的\",{\"1\":{\"116\":1}}],[\"子树恢复平衡\",{\"1\":{\"105\":1}}],[\"子树\",{\"1\":{\"82\":1,\"115\":1}}],[\"子节点及其以下形成的树被称为该节点的左\",{\"1\":{\"115\":1}}],[\"子节点的平衡因子\",{\"1\":{\"109\":1}}],[\"子节点数量\",{\"1\":{\"96\":2,\"112\":3}}],[\"子节点\",{\"1\":{\"82\":1}}],[\"祖先\",{\"1\":{\"82\":1}}],[\"发生\",{\"1\":{\"148\":1}}],[\"发生变化\",{\"1\":{\"78\":1}}],[\"发生冲突\",{\"1\":{\"64\":1}}],[\"发现\",{\"1\":{\"78\":1}}],[\"又能保证哈希表的空间使用率\",{\"1\":{\"78\":1}}],[\"又称散列表\",{\"1\":{\"61\":1}}],[\"二者都应该依赖于抽象\",{\"1\":{\"123\":1}}],[\"二叉搜索树可能退化为链表\",{\"1\":{\"100\":1}}],[\"二叉搜索树常见应用\",{\"0\":{\"99\":1}}],[\"二叉搜索树退化\",{\"1\":{\"98\":1}}],[\"二叉搜索树是一种高效的元素查找数据结构\",{\"1\":{\"115\":1}}],[\"二叉搜索树是\",{\"1\":{\"98\":1}}],[\"二叉搜索树不允许存在重复节点\",{\"1\":{\"95\":1}}],[\"二叉搜索树的各项操作的时间复杂度都是对数阶\",{\"1\":{\"98\":1}}],[\"二叉搜索树的效率\",{\"0\":{\"98\":1}}],[\"二叉搜索树的中序遍历序列\",{\"1\":{\"97\":1}}],[\"二叉搜索树的中序遍历序列是升序的\",{\"1\":{\"97\":1}}],[\"二叉搜索树的\",{\"1\":{\"96\":1}}],[\"二叉搜索树的查找操作与二分查找算法的工作原理一致\",{\"1\":{\"94\":1}}],[\"二叉搜索树的操作\",{\"0\":{\"93\":1}}],[\"二叉搜索树查找节点示例\",{\"1\":{\"94\":1}}],[\"二叉搜索树\",{\"0\":{\"92\":1},\"1\":{\"92\":2,\"98\":1,\"100\":1,\"104\":1}}],[\"二叉树中的插入与删除一般由一套操作配合完成\",{\"1\":{\"116\":1}}],[\"二叉树中首个失衡节点是\",{\"1\":{\"105\":1}}],[\"二叉树可以用数组表示\",{\"1\":{\"115\":1}}],[\"二叉树是一种非线性数据结构\",{\"1\":{\"115\":1}}],[\"二叉树退化为\",{\"1\":{\"91\":1}}],[\"二叉树基本操作\",{\"0\":{\"84\":1}}],[\"二叉树的层序遍历是一种广度优先搜索方法\",{\"1\":{\"115\":1}}],[\"二叉树的初始化\",{\"1\":{\"115\":1}}],[\"二叉树的相关术语包括根节点\",{\"1\":{\"115\":1}}],[\"二叉树的中序遍历遵循\",{\"1\":{\"97\":1}}],[\"二叉树的叶节点数量\",{\"1\":{\"91\":1}}],[\"二叉树的最佳结构与最差结构\",{\"1\":{\"91\":1}}],[\"二叉树的退化\",{\"0\":{\"91\":1}}],[\"二叉树的常用术语\",{\"1\":{\"83\":1}}],[\"二叉树的常用术语如下图所示\",{\"1\":{\"83\":1}}],[\"二叉树的高度\",{\"1\":{\"83\":1}}],[\"二叉树的基本单元是节点\",{\"1\":{\"82\":1}}],[\"二叉树常见术语\",{\"0\":{\"83\":1}}],[\"二叉树节点结构体\",{\"1\":{\"82\":1}}],[\"二叉树\",{\"0\":{\"81\":1,\"82\":1},\"1\":{\"78\":1,\"82\":1}}],[\"二分查找等都主要在数组上进行\",{\"1\":{\"20\":1}}],[\"冲突比较平均时\",{\"1\":{\"78\":1}}],[\"冲突就越少\",{\"1\":{\"64\":1}}],[\"缺点是不能删除元素\",{\"1\":{\"77\":1}}],[\"缺点也很明显\",{\"1\":{\"6\":1}}],[\"常用于安全应用与协议\",{\"1\":{\"77\":1}}],[\"常用于校验文件完整性\",{\"1\":{\"77\":1}}],[\"常用作触发哈希表扩容的条件\",{\"1\":{\"77\":1}}],[\"常见二叉树类型\",{\"0\":{\"87\":1}}],[\"常见的二叉树类型有完美二叉树\",{\"1\":{\"115\":1}}],[\"常见的哈希算法包括\",{\"1\":{\"77\":1}}],[\"常见的哈希表操作包括查询\",{\"1\":{\"77\":1}}],[\"常见的链表类型包括单向链表\",{\"1\":{\"38\":1}}],[\"常见的链表类型包括三种\",{\"1\":{\"29\":1}}],[\"常见哈希算法\",{\"0\":{\"75\":1}}],[\"常见链表种类\",{\"1\":{\"29\":1}}],[\"常见链表类型\",{\"0\":{\"29\":1}}],[\"反映了自然界中常见的细胞分裂现象\",{\"1\":{\"88\":1}}],[\"反映了哈希冲突的严重程度\",{\"1\":{\"77\":1}}],[\"反撤销\",{\"1\":{\"57\":1}}],[\"导致查询结果出错\",{\"1\":{\"77\":1}}],[\"导致该次入栈操作的时间复杂度变为\",{\"1\":{\"54\":1}}],[\"映射为数组索引\",{\"1\":{\"77\":1}}],[\"攻击\",{\"1\":{\"76\":1}}],[\"布尔量\",{\"1\":{\"76\":1}}],[\"得到单一的哈希值\",{\"1\":{\"76\":1}}],[\"得到值\",{\"1\":{\"62\":1}}],[\"元组的哈希值是对其中每一个元素进行哈希\",{\"1\":{\"76\":1}}],[\"元素会被移动至距离理想位置\",{\"1\":{\"68\":1}}],[\"元素出栈\",{\"1\":{\"50\":1}}],[\"元素出队\",{\"1\":{\"44\":1}}],[\"元素入栈\",{\"1\":{\"50\":2}}],[\"元素入队\",{\"1\":{\"44\":2}}],[\"元素索引\",{\"1\":{\"39\":1}}],[\"元素内存地址\",{\"1\":{\"39\":1}}],[\"元素长度\",{\"1\":{\"39\":2}}],[\"元素占用内存多\",{\"1\":{\"28\":1}}],[\"元素占用内存少\",{\"1\":{\"28\":1}}],[\"浮点数和字符串的哈希值计算较为复杂\",{\"1\":{\"76\":1}}],[\"整形有这种原子变量已经足够方便\",{\"1\":{\"181\":1}}],[\"整数\",{\"1\":{\"76\":1}}],[\"整数和布尔量的哈希值就是其本身\",{\"1\":{\"76\":1}}],[\"整除的\",{\"1\":{\"74\":1}}],[\"整除\",{\"1\":{\"74\":1}}],[\"加密货币交易验证\",{\"1\":{\"75\":1}}],[\"加法哈希\",{\"1\":{\"74\":1}}],[\"低频增删的场景\",{\"1\":{\"114\":1}}],[\"低频查找删除数据的场景下\",{\"1\":{\"98\":1}}],[\"低\",{\"1\":{\"75\":2}}],[\"安全等级\",{\"1\":{\"75\":1}}],[\"很少\",{\"1\":{\"75\":2}}],[\"很差\",{\"1\":{\"66\":1}}],[\"较多\",{\"1\":{\"75\":2}}],[\"推出时间\",{\"1\":{\"75\":1}}],[\"推荐阅读\",{\"1\":{\"7\":1}}],[\"推荐学习这本书\",{\"1\":{\"7\":1}}],[\"推荐几本c++书籍\",{\"1\":{\"5\":1}}],[\"仍用于数据完整性检查\",{\"1\":{\"75\":1}}],[\"仍未出现成功的攻击案例\",{\"1\":{\"75\":1}}],[\"仍然保留在系统中\",{\"1\":{\"151\":1}}],[\"仍然有退化至\",{\"1\":{\"78\":1}}],[\"仍然存在聚集现象\",{\"1\":{\"69\":1}}],[\"仍然指向\",{\"1\":{\"25\":1}}],[\"系列函数\",{\"1\":{\"153\":1}}],[\"系列\",{\"1\":{\"75\":1}}],[\"系列中的\",{\"1\":{\"75\":1}}],[\"系统资源不能被强制从一个进程\",{\"1\":{\"167\":1}}],[\"系统管理的麻烦\",{\"1\":{\"152\":1}}],[\"系统\",{\"1\":{\"151\":1}}],[\"系统将其从内存中清除\",{\"1\":{\"149\":1}}],[\"系统将其从内存中移除\",{\"1\":{\"148\":1}}],[\"系统需求变动导致的修改尽可能的不会扩散的稳定的模块\",{\"1\":{\"124\":1}}],[\"系统通常不会直接存储用户的明文密码\",{\"1\":{\"73\":1}}],[\"系统都会在栈顶添加一个栈帧\",{\"1\":{\"55\":1}}],[\"系统会对输入的密码计算哈希值\",{\"1\":{\"73\":1}}],[\"系统会将哈希表扩容至原先的\",{\"1\":{\"64\":1}}],[\"系统会为列表分配\",{\"1\":{\"54\":1}}],[\"系统会申请一块新的内存\",{\"1\":{\"39\":1}}],[\"系统随后会根据顺序处理队列中的订单\",{\"1\":{\"48\":1}}],[\"系统可以利用这些信息来优化数据结构的操作效率\",{\"1\":{\"19\":1}}],[\"已被弃用\",{\"1\":{\"75\":2}}],[\"已被成功攻击\",{\"1\":{\"75\":2}}],[\"已多次被成功攻击\",{\"1\":{\"75\":1}}],[\"已经获得的资源在未使用完之前不能被抢占\",{\"1\":{\"167\":1}}],[\"已经实现了双向链表\",{\"1\":{\"39\":1}}],[\"已经从链表中删除了\",{\"1\":{\"39\":1}}],[\"已经不再属于该链表了\",{\"1\":{\"25\":1}}],[\"另一次是在main函数中构造a对象产生的\",{\"1\":{\"188\":1}}],[\"另一个用于记录是否有写线程在等待\",{\"1\":{\"160\":1}}],[\"另一个是调用detach\",{\"1\":{\"178\":1}}],[\"另一个是调用\",{\"1\":{\"157\":1}}],[\"另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题\",{\"1\":{\"75\":1}}],[\"另一方面\",{\"1\":{\"39\":2}}],[\"近一个世纪以来\",{\"1\":{\"75\":1}}],[\"远远没有达到哈希算法的设计目标\",{\"1\":{\"75\":1}}],[\"脆弱\",{\"1\":{\"75\":1}}],[\"提供了一组内存序列模型\",{\"1\":{\"169\":1}}],[\"提供了对不同内存模型的支持\",{\"1\":{\"162\":1}}],[\"提供快速数据访问\",{\"1\":{\"38\":1}}],[\"提高系统的灵活性\",{\"1\":{\"123\":1}}],[\"提高系统的灵活性和可扩展性\",{\"1\":{\"123\":1}}],[\"提高代码的可维护性和可读性\",{\"1\":{\"123\":1}}],[\"提升哈希算法的安全性\",{\"1\":{\"76\":1}}],[\"提升哈希算法的稳健性\",{\"1\":{\"74\":1}}],[\"总结\",{\"1\":{\"185\":1}}],[\"总是会优先遍历下一个最小节点\",{\"1\":{\"97\":1}}],[\"总而言之\",{\"1\":{\"74\":1}}],[\"总的来看\",{\"1\":{\"15\":1}}],[\"7\",{\"1\":{\"74\":1}}],[\"75\",{\"1\":{\"64\":1}}],[\"现在\",{\"1\":{\"74\":1}}],[\"恰好满足这种等差数列的数据分布\",{\"1\":{\"74\":1}}],[\"​\",{\"1\":{\"74\":2}}],[\"作为某些搜索算法的底层数据结构\",{\"1\":{\"99\":1}}],[\"作为\",{\"1\":{\"76\":1,\"105\":1,\"106\":1}}],[\"作为模数\",{\"1\":{\"74\":1}}],[\"作为初始容量\",{\"1\":{\"37\":1}}],[\"举个例子\",{\"1\":{\"74\":1}}],[\"^\",{\"1\":{\"74\":2}}],[\"乘法哈希\",{\"1\":{\"74\":1}}],[\"雪崩效应\",{\"1\":{\"73\":1}}],[\"抗碰撞性\",{\"1\":{\"73\":2}}],[\"接管\",{\"1\":{\"153\":2}}],[\"接口应尽量细化\",{\"1\":{\"123\":1,\"124\":1}}],[\"接口隔离原则\",{\"1\":{\"123\":1}}],[\"接收方可以重新计算接收到的数据的哈希值\",{\"1\":{\"73\":1}}],[\"接着遍历链表以查找目标节点并将其删除\",{\"1\":{\"66\":1}}],[\"密码存储\",{\"1\":{\"73\":1}}],[\"均匀分布\",{\"1\":{\"73\":2}}],[\"效率非常高\",{\"1\":{\"77\":1}}],[\"效率高\",{\"1\":{\"73\":1}}],[\"效率很高\",{\"1\":{\"34\":1}}],[\"既快又稳\",{\"1\":{\"73\":1}}],[\"既频繁应用在各类算法之中\",{\"1\":{\"20\":1}}],[\"决定了输出值\",{\"1\":{\"72\":1}}],[\"固定时\",{\"1\":{\"72\":1}}],[\"回收子进程的资源\",{\"1\":{\"153\":1}}],[\"回忆哈希函数的计算步骤\",{\"1\":{\"72\":1}}],[\"回到头部继续遍历\",{\"1\":{\"68\":1}}],[\"理论上这个t可以是任意类型\",{\"1\":{\"181\":1}}],[\"理论上一定存在\",{\"1\":{\"64\":1}}],[\"理想情况下键值对均匀分布在各个桶中\",{\"1\":{\"72\":1}}],[\"前序\",{\"1\":{\"115\":1,\"116\":1}}],[\"前两节介绍了哈希表的工作原理和哈希冲突的处理方法\",{\"1\":{\"72\":1}}],[\"前些年这本书可以说是c++入门必备\",{\"1\":{\"6\":1}}],[\"超出容量则连接一个溢出桶\",{\"1\":{\"71\":1}}],[\"超出数组长度范围的元素会丢失\",{\"1\":{\"15\":1}}],[\"规定每个桶最多存储\",{\"1\":{\"71\":1}}],[\"规定队尾仅可添加节点\",{\"1\":{\"46\":1}}],[\"自旋等待\",{\"1\":{\"164\":1}}],[\"自旋锁适用于锁定时间非常短的场景\",{\"1\":{\"164\":1}}],[\"自旋锁通常通过硬件的原子操作实现\",{\"1\":{\"164\":1}}],[\"自旋锁是一种忙等待锁\",{\"1\":{\"164\":1}}],[\"自旋锁\",{\"0\":{\"164\":1}}],[\"自动加锁和解锁\",{\"1\":{\"159\":1}}],[\"自底向上执行旋转操作\",{\"1\":{\"111\":1}}],[\"自\",{\"1\":{\"71\":1}}],[\"采用\",{\"1\":{\"153\":1}}],[\"采用链式地址\",{\"1\":{\"71\":2}}],[\"采用开放寻址\",{\"1\":{\"71\":1,\"77\":1}}],[\"说明队列为空\",{\"1\":{\"172\":1}}],[\"说明队列已满\",{\"1\":{\"172\":1}}],[\"说明找到目标节点\",{\"1\":{\"94\":1}}],[\"说明目标节点在\",{\"1\":{\"94\":2}}],[\"说明目标元素不在哈希表中\",{\"1\":{\"68\":1}}],[\"说明哈希表中不存在该元素\",{\"1\":{\"70\":1}}],[\"试图缓解线性探测的聚集效应\",{\"1\":{\"69\":1}}],[\"步\",{\"1\":{\"69\":1}}],[\"步长通常为\",{\"1\":{\"68\":1}}],[\"9\",{\"1\":{\"69\":1,\"74\":4}}],[\"搜索\",{\"1\":{\"68\":4}}],[\"搜索时间也会增加\",{\"1\":{\"68\":1}}],[\"探测次数的平方\",{\"1\":{\"69\":1}}],[\"探测起始点\",{\"1\":{\"68\":1}}],[\"探测方式主要包括线性探测\",{\"1\":{\"67\":1}}],[\"交换位置\",{\"1\":{\"68\":1}}],[\"考虑在线性探测中记录遇到的首个\",{\"1\":{\"68\":1}}],[\"才能找到目标元素\",{\"1\":{\"68\":1}}],[\"才执行扩容操作\",{\"1\":{\"65\":1}}],[\"懒删除可能会加速哈希表的性能退化\",{\"1\":{\"68\":1}}],[\"机制\",{\"1\":{\"68\":1}}],[\"机器学习\",{\"1\":{\"20\":1}}],[\"最终\",{\"1\":{\"116\":1}}],[\"最终导致增删查改操作效率劣化\",{\"1\":{\"68\":1}}],[\"最差情况下所有键值对都存储到同一个桶中\",{\"1\":{\"72\":1}}],[\"最后\",{\"1\":{\"78\":1,\"172\":1}}],[\"最后两位相同的\",{\"1\":{\"68\":1}}],[\"最后一个节点被称为\",{\"1\":{\"21\":1}}],[\"形成恶性循环\",{\"1\":{\"68\":1}}],[\"聚集现象\",{\"1\":{\"68\":1}}],[\"都是一个指针代表一个内存\",{\"1\":{\"140\":1}}],[\"都是每轮排除一半情况\",{\"1\":{\"94\":1}}],[\"都是开放寻址的常见策略之一\",{\"1\":{\"69\":1}}],[\"都会被操作系统回收\",{\"1\":{\"151\":1}}],[\"都会被映射到\",{\"1\":{\"74\":1}}],[\"都会被映射到相同的桶\",{\"1\":{\"68\":1}}],[\"都会为字符串哈希函数加入一个随机的盐\",{\"1\":{\"76\":1}}],[\"都可以放置键值对\",{\"1\":{\"68\":1}}],[\"都代表空桶\",{\"1\":{\"68\":1}}],[\"都在向右移动\",{\"1\":{\"47\":1}}],[\"介绍开放寻址哈希表的工作机制\",{\"1\":{\"67\":1}}],[\"来存储元素\",{\"1\":{\"172\":1}}],[\"来定义队列元素的类型\",{\"1\":{\"172\":1}}],[\"来比较两个字符串的内容\",{\"1\":{\"116\":1}}],[\"来确定失衡节点属于上图中的哪种情况\",{\"1\":{\"109\":1}}],[\"来标记这个桶\",{\"1\":{\"68\":1}}],[\"来处理哈希冲突\",{\"1\":{\"67\":1}}],[\"来实现\",{\"1\":{\"47\":1}}],[\"来实现列表\",{\"1\":{\"31\":1}}],[\"多线程\",{\"2\":{\"175\":1,\"197\":1}}],[\"多进程\",{\"2\":{\"155\":1}}],[\"多次哈希是开放寻址的一种\",{\"1\":{\"78\":1}}],[\"多次哈希有不能直接删除元素的缺陷吗\",{\"1\":{\"78\":1}}],[\"多次哈希使用多个哈希函数进行探测\",{\"1\":{\"77\":1}}],[\"多次哈希方法不易产生聚集\",{\"1\":{\"70\":1}}],[\"多次哈希方法使用多个哈希函数\",{\"1\":{\"70\":1}}],[\"多次哈希\",{\"0\":{\"70\":1}}],[\"多次探测\",{\"1\":{\"67\":1}}],[\"多个线程对同一变量进行原子操作时\",{\"1\":{\"169\":1}}],[\"多个\",{\"1\":{\"64\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"64\":1}}],[\"红黑树的平衡条件更宽松\",{\"1\":{\"114\":1}}],[\"红黑树也是一种常见的平衡二叉搜索树\",{\"1\":{\"114\":1}}],[\"红黑树\",{\"1\":{\"66\":1}}],[\"树会从底向顶执行旋转操作\",{\"1\":{\"115\":1}}],[\"树典型应用\",{\"0\":{\"114\":1}}],[\"树常用操作\",{\"0\":{\"110\":1}}],[\"树常见术语\",{\"0\":{\"101\":1}}],[\"树旋转\",{\"0\":{\"104\":1}}],[\"树的高度和根节点的深度都是\",{\"1\":{\"116\":1}}],[\"树的旋转操作包括右旋\",{\"1\":{\"115\":1}}],[\"树的节点查找操作与二叉搜索树一致\",{\"1\":{\"113\":1}}],[\"树的节点插入操作与二叉搜索树在主体上类似\",{\"1\":{\"111\":1}}],[\"树的四种旋转情况\",{\"1\":{\"109\":1}}],[\"树的特点在于\",{\"1\":{\"104\":1}}],[\"树的任意节点的平衡因子皆满足\",{\"1\":{\"103\":1}}],[\"树的相关操作需要获取节点高度\",{\"1\":{\"102\":1}}],[\"树节点类\",{\"1\":{\"102\":1}}],[\"树既是二叉搜索树\",{\"1\":{\"101\":1}}],[\"树能始终保持高效的数据操作性能\",{\"1\":{\"100\":1}}],[\"树不会退化\",{\"1\":{\"100\":1}}],[\"树在插入节点后发生退化\",{\"1\":{\"100\":1}}],[\"树在删除节点后发生退化\",{\"1\":{\"100\":1}}],[\"树将严重向左倾斜\",{\"1\":{\"100\":1}}],[\"树\",{\"0\":{\"100\":1},\"1\":{\"66\":1,\"100\":1,\"114\":1,\"115\":1}}],[\"树中插入节点后\",{\"1\":{\"111\":1}}],[\"树中\",{\"1\":{\"30\":1}}],[\"暂存原哈希表\",{\"1\":{\"66\":1,\"68\":1}}],[\"桶数组\",{\"1\":{\"66\":1,\"68\":1}}],[\"触发扩容的负载因子阈值\",{\"1\":{\"66\":1,\"68\":1}}],[\"代码结构和作用\",{\"0\":{\"172\":1}}],[\"代码示例\",{\"1\":{\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1}}],[\"代码的存在的link\",{\"1\":{\"142\":1}}],[\"代码编译时不使用name\",{\"1\":{\"142\":1}}],[\"代码link\",{\"1\":{\"142\":1}}],[\"代码如下所示\",{\"1\":{\"18\":1,\"27\":1,\"47\":1,\"105\":1,\"109\":1,\"111\":1,\"112\":1}}],[\"代理模式\",{\"1\":{\"122\":1}}],[\"代表\",{\"1\":{\"82\":1}}],[\"代替链表\",{\"1\":{\"66\":1}}],[\"占用空间增大\",{\"1\":{\"66\":1}}],[\"占用内存较多\",{\"1\":{\"38\":1}}],[\"占用内存较少\",{\"1\":{\"38\":1}}],[\"改良哈希表数据结构\",{\"1\":{\"65\":1}}],[\"改变\",{\"1\":{\"64\":1}}],[\"严重影响哈希表的可用性\",{\"1\":{\"65\":1}}],[\"负载因子定义为哈希表中元素数量除以桶数量\",{\"1\":{\"77\":1}}],[\"负载因子\",{\"1\":{\"64\":1,\"66\":1,\"68\":1}}],[\"编程语言通常会为数据类型提供内置哈希算法\",{\"1\":{\"77\":1}}],[\"编程语言通常会为这些数据类型提供内置的哈希算法\",{\"1\":{\"76\":1}}],[\"编程语言通常会预留足够大的哈希表容量\",{\"1\":{\"64\":1}}],[\"编程语言的选择\",{\"0\":{\"71\":1}}],[\"编程同学\",{\"1\":{\"0\":1}}],[\"非常耗时\",{\"1\":{\"64\":1}}],[\"非常高效\",{\"1\":{\"61\":1,\"97\":1}}],[\"越过叶节点后跳出\",{\"1\":{\"94\":1,\"95\":1,\"96\":1}}],[\"越过尾部则返回头部\",{\"1\":{\"68\":1}}],[\"越过数组尾部后回到头部\",{\"1\":{\"47\":1}}],[\"越大\",{\"1\":{\"64\":1}}],[\"容器新增\",{\"0\":{\"189\":1}}],[\"容量为\",{\"1\":{\"172\":1}}],[\"容量设置比较合理\",{\"1\":{\"78\":1}}],[\"容量扩展\",{\"1\":{\"28\":1}}],[\"容易想到\",{\"1\":{\"64\":1}}],[\"打印哈希表\",{\"1\":{\"63\":1,\"66\":1,\"68\":1}}],[\"键值对的分布情况由哈希函数决定\",{\"1\":{\"72\":1}}],[\"键值对数量\",{\"1\":{\"66\":1,\"68\":1}}],[\"键值对\",{\"1\":{\"63\":1,\"66\":1}}],[\"封装成一个类\",{\"1\":{\"63\":1}}],[\"展示了哈希函数的工作原理\",{\"1\":{\"63\":1}}],[\"易得哈希函数为\",{\"1\":{\"63\":1}}],[\"随着\",{\"1\":{\"68\":1}}],[\"随后\",{\"1\":{\"63\":1}}],[\"随机访问\",{\"1\":{\"20\":1}}],[\"随机访问元素\",{\"1\":{\"13\":1}}],[\"取余\",{\"1\":{\"78\":1}}],[\"取余操作\",{\"1\":{\"47\":1}}],[\"取模\",{\"1\":{\"63\":1,\"74\":1,\"78\":1}}],[\"哈希值仍然是不变的\",{\"1\":{\"76\":1}}],[\"哈希冲突的概率就越低\",{\"1\":{\"73\":1,\"77\":1}}],[\"哈希冲突的最佳情况与最差情况\",{\"1\":{\"72\":1}}],[\"哈希冲突会导致查询结果错误\",{\"1\":{\"65\":1}}],[\"哈希冲突\",{\"0\":{\"65\":1},\"1\":{\"75\":1}}],[\"哈希冲突示例\",{\"1\":{\"64\":1}}],[\"哈希冲突与扩容\",{\"0\":{\"64\":1}}],[\"哈希函数下\",{\"1\":{\"78\":1}}],[\"哈希函数将\",{\"1\":{\"77\":1}}],[\"哈希函数\",{\"1\":{\"63\":1,\"66\":1,\"68\":1,\"73\":1}}],[\"哈希函数工作原理\",{\"1\":{\"63\":1}}],[\"哈希函数的最后一步往往是对数组长度\",{\"1\":{\"78\":1}}],[\"哈希函数的输出结果也相同\",{\"1\":{\"64\":1}}],[\"哈希函数的作用是将所有\",{\"1\":{\"64\":1}}],[\"哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间\",{\"1\":{\"63\":1}}],[\"哈希函数的计算过程分为以下两步\",{\"1\":{\"63\":1}}],[\"哈希算法通常采用大质数作为模数\",{\"1\":{\"77\":1}}],[\"哈希算法还应该具备抗碰撞性和雪崩效应\",{\"1\":{\"77\":1}}],[\"哈希算法处在不断升级与优化的过程中\",{\"1\":{\"75\":1}}],[\"哈希算法的设计是一个需要考虑许多因素的复杂问题\",{\"1\":{\"74\":1}}],[\"哈希算法的设计\",{\"0\":{\"74\":1}}],[\"哈希算法的目标\",{\"0\":{\"73\":1}}],[\"哈希算法需要具备更高等级的安全特性\",{\"1\":{\"73\":1}}],[\"哈希算法除了可以用于实现哈希表\",{\"1\":{\"73\":1}}],[\"哈希算法应使得键值对均匀分布在哈希表中\",{\"1\":{\"73\":1}}],[\"哈希算法应始终产生相同的输出\",{\"1\":{\"73\":1}}],[\"哈希算法应具备以下特点\",{\"1\":{\"73\":1}}],[\"哈希算法\",{\"0\":{\"72\":1},\"1\":{\"63\":1,\"72\":1}}],[\"哈希表有相当一部分内存未使用\",{\"1\":{\"78\":1}}],[\"哈希表有三种常用的遍历方式\",{\"1\":{\"62\":1}}],[\"哈希表底层实现是数组\",{\"1\":{\"78\":1}}],[\"哈希表能够在\",{\"1\":{\"77\":1}}],[\"哈希表都存在\",{\"1\":{\"70\":1}}],[\"哈希表扩容操作的开销很大\",{\"1\":{\"77\":1}}],[\"哈希表扩容需将所有键值对从原哈希表迁移至新哈希表\",{\"1\":{\"64\":1}}],[\"哈希表扩容\",{\"1\":{\"64\":1}}],[\"哈希表容量越大\",{\"1\":{\"77\":1}}],[\"哈希表容量\",{\"1\":{\"64\":1,\"66\":1,\"68\":1}}],[\"哈希表简单实现\",{\"0\":{\"63\":1}}],[\"哈希表的时间效率变高\",{\"1\":{\"78\":1}}],[\"哈希表的时间复杂度可能发生劣化\",{\"1\":{\"78\":1}}],[\"哈希表的时间复杂度会退化至\",{\"1\":{\"78\":1}}],[\"哈希表的时间复杂度在什么情况下是\",{\"1\":{\"78\":1}}],[\"哈希表的目标是将一个较大的状态空间映射到一个较小的空间\",{\"1\":{\"78\":1}}],[\"哈希表的\",{\"1\":{\"76\":1}}],[\"哈希表的实用性越高\",{\"1\":{\"73\":1}}],[\"哈希表的性能则会急剧劣化\",{\"1\":{\"72\":1}}],[\"哈希表的键值对分布\",{\"1\":{\"68\":2}}],[\"哈希表的结构改良方法主要包括\",{\"1\":{\"65\":1}}],[\"哈希表的常见操作包括\",{\"1\":{\"62\":1}}],[\"哈希表的抽象表示\",{\"1\":{\"61\":1}}],[\"哈希表常用操作\",{\"0\":{\"62\":1}}],[\"哈希表和图等数据结构\",{\"1\":{\"30\":1}}],[\"哈希表\",{\"0\":{\"60\":1,\"61\":1},\"1\":{\"2\":1,\"20\":1,\"30\":1,\"61\":2,\"66\":1,\"68\":1},\"2\":{\"80\":1}}],[\"k\",{\"1\":{\"178\":2,\"179\":4,\"180\":2}}],[\"kv\",{\"1\":{\"62\":3,\"63\":3}}],[\"keyset\",{\"1\":{\"63\":4}}],[\"key\",{\"1\":{\"61\":2,\"62\":5,\"63\":25,\"64\":3,\"66\":18,\"68\":19,\"72\":1,\"73\":4,\"74\":7,\"76\":3,\"77\":3,\"78\":3}}],[\"向队列中插入元素\",{\"1\":{\"172\":1}}],[\"向左旋转\",{\"1\":{\"106\":1}}],[\"向右旋转\",{\"1\":{\"105\":2}}],[\"向哈希表中输入键\",{\"1\":{\"62\":1}}],[\"向下递推阶段会不断执行入栈操作\",{\"1\":{\"55\":1}}],[\"小数\",{\"1\":{\"76\":1}}],[\"小数或字符串等数据类型\",{\"1\":{\"76\":1}}],[\"小鸭\",{\"1\":{\"62\":1}}],[\"小法\",{\"1\":{\"62\":1}}],[\"小算\",{\"1\":{\"62\":1}}],[\"小啰\",{\"1\":{\"62\":1}}],[\"小哈\",{\"1\":{\"62\":1}}],[\"示例代码如下\",{\"1\":{\"62\":2,\"94\":1,\"96\":1}}],[\"查询效率\",{\"1\":{\"66\":1}}],[\"查询效率降低\",{\"1\":{\"66\":1}}],[\"查询学号为\",{\"1\":{\"64\":1}}],[\"查询操作就是找到\",{\"1\":{\"63\":1}}],[\"查询操作\",{\"1\":{\"62\":2,\"63\":1,\"66\":1,\"68\":1}}],[\"查询元素\",{\"1\":{\"61\":1,\"66\":1}}],[\"查找操作的时间复杂度也随之劣化\",{\"1\":{\"100\":1}}],[\"查找插入位置并插入节点\",{\"1\":{\"111\":1}}],[\"查找插入位置\",{\"1\":{\"95\":1}}],[\"查找的时候通过哈希函数找到对应的桶和键值对\",{\"1\":{\"78\":1}}],[\"查找其中值为\",{\"1\":{\"27\":1}}],[\"查找节点并删除\",{\"1\":{\"112\":1}}],[\"查找节点\",{\"0\":{\"27\":1,\"94\":1,\"113\":1},\"1\":{\"94\":1}}],[\"查找表\",{\"1\":{\"20\":1}}],[\"查找元素的时候会出现哈希冲突呢\",{\"1\":{\"78\":1}}],[\"查找元素\",{\"0\":{\"17\":1},\"1\":{\"61\":1,\"68\":1,\"70\":1,\"98\":1}}],[\"仅仅读取尾部的值\",{\"1\":{\"172\":1}}],[\"仅使用左旋或右旋都无法使子树恢复平衡\",{\"1\":{\"107\":1}}],[\"仅提供基本数据类型的哈希值计算\",{\"1\":{\"76\":1}}],[\"仅在必要时\",{\"1\":{\"65\":1}}],[\"仅用一个数组来实现哈希表\",{\"1\":{\"63\":1}}],[\"仅需将元素添加至数组\",{\"1\":{\"61\":1}}],[\"仅转换有效长度范围内的列表元素\",{\"1\":{\"47\":1}}],[\"除叶节点外\",{\"1\":{\"82\":1}}],[\"除哈希表外\",{\"1\":{\"61\":1}}],[\"除了包含值\",{\"1\":{\"21\":1}}],[\"输出的哈希值是不同的\",{\"1\":{\"76\":1}}],[\"输出长度\",{\"1\":{\"75\":1}}],[\"输出空间为数组容量大小\",{\"1\":{\"65\":1}}],[\"输出空间是所有桶\",{\"1\":{\"63\":1}}],[\"输出该节点在链表中的索引\",{\"1\":{\"27\":1}}],[\"输入的微小变化应当导致输出的显著且不可预测的变化\",{\"1\":{\"73\":1}}],[\"输入\",{\"1\":{\"66\":1,\"77\":1}}],[\"输入空间通常远大于输出空间\",{\"1\":{\"78\":1}}],[\"输入空间为全体整数\",{\"1\":{\"65\":1}}],[\"输入空间是所有\",{\"1\":{\"63\":1}}],[\"输入一个\",{\"1\":{\"63\":2}}],[\"输入一个学号\",{\"1\":{\"61\":1}}],[\"学号和\",{\"1\":{\"63\":1}}],[\"学号\",{\"1\":{\"61\":1}}],[\"姓名为例\",{\"1\":{\"63\":1}}],[\"姓名\",{\"1\":{\"61\":1}}],[\"hold\",{\"1\":{\"167\":1}}],[\"hardware\",{\"1\":{\"178\":1}}],[\"handle可用于pthread相关操作\",{\"1\":{\"178\":1}}],[\"handle\",{\"1\":{\"178\":3}}],[\"handler\",{\"1\":{\"153\":2}}],[\"has\",{\"1\":{\"166\":1,\"192\":4}}],[\"hashdos\",{\"1\":{\"76\":1}}],[\"hashdec\",{\"1\":{\"76\":1}}],[\"hashstr\",{\"1\":{\"76\":1}}],[\"hash<string>\",{\"1\":{\"76\":1}}],[\"hash<double>\",{\"1\":{\"76\":1}}],[\"hash<bool>\",{\"1\":{\"76\":1}}],[\"hash<int>\",{\"1\":{\"76\":1}}],[\"hashbol\",{\"1\":{\"76\":1}}],[\"hashnum\",{\"1\":{\"76\":1}}],[\"hashmap\",{\"1\":{\"71\":1,\"77\":1}}],[\"hashmapopenaddressing\",{\"1\":{\"68\":2}}],[\"hashmapchaining\",{\"1\":{\"66\":2}}],[\"hashfunc\",{\"1\":{\"63\":4,\"66\":4,\"68\":2}}],[\"hash\",{\"1\":{\"61\":1,\"63\":4,\"64\":1,\"72\":3,\"74\":5,\"76\":2},\"2\":{\"80\":1}}],[\"h>\",{\"1\":{\"153\":3}}],[\"h=2\",{\"1\":{\"116\":1}}],[\"hi\",{\"1\":{\"116\":2}}],[\"h+1\",{\"1\":{\"91\":1}}],[\"h\",{\"1\":{\"88\":1,\"91\":2}}],[\"height\",{\"1\":{\"83\":2,\"102\":4,\"103\":2,\"116\":2}}],[\"hello\",{\"1\":{\"76\":2}}],[\"head\",{\"1\":{\"26\":5,\"27\":5,\"171\":5,\"172\":11,\"173\":1}}],[\"时跳出循环\",{\"1\":{\"95\":1}}],[\"时应该继续遍历\",{\"1\":{\"68\":1}}],[\"时\",{\"1\":{\"57\":2,\"64\":1,\"66\":1,\"71\":1,\"95\":1,\"96\":4,\"105\":1,\"106\":1,\"149\":1,\"161\":1,\"163\":2}}],[\"时间的风险\",{\"1\":{\"78\":1}}],[\"时间\",{\"1\":{\"61\":3,\"94\":1,\"95\":1,\"96\":3,\"97\":1}}],[\"时间效率\",{\"1\":{\"54\":1}}],[\"时间片轮转调度算法是一种常见的\",{\"1\":{\"30\":1}}],[\"时间片轮转调度算法\",{\"1\":{\"30\":1}}],[\"时间下访问数组中的任意元素\",{\"1\":{\"26\":1}}],[\"时间复杂度的常数项更大\",{\"1\":{\"78\":1}}],[\"时间复杂度是\",{\"1\":{\"78\":1}}],[\"时间复杂度退化至\",{\"1\":{\"72\":1,\"91\":1}}],[\"时间复杂度都为\",{\"1\":{\"53\":1}}],[\"时间复杂度均为\",{\"1\":{\"47\":1}}],[\"时间复杂度\",{\"1\":{\"44\":1,\"50\":1}}],[\"时间复杂度确实是\",{\"1\":{\"39\":1}}],[\"时间复杂度为\",{\"1\":{\"24\":1,\"26\":1,\"35\":1}}],[\"时间复杂度高\",{\"1\":{\"15\":1}}],[\"时间内查询到\",{\"1\":{\"77\":1}}],[\"时间内获取对应的值\",{\"1\":{\"61\":1}}],[\"时间内获取节点内存地址\",{\"1\":{\"39\":1}}],[\"时间内访问和更新元素\",{\"1\":{\"34\":1}}],[\"时间内访问任何元素\",{\"1\":{\"19\":1}}],[\"时间内随机访问数组中的任意一个元素\",{\"1\":{\"13\":1}}],[\"撤销\",{\"1\":{\"57\":2}}],[\"章节中我们提到\",{\"1\":{\"100\":1}}],[\"章节中讨论\",{\"1\":{\"14\":1}}],[\"章节有提到\",{\"1\":{\"57\":1}}],[\"综上\",{\"1\":{\"54\":1}}],[\"综上所述\",{\"1\":{\"54\":1}}],[\"该子节点\",{\"1\":{\"96\":1}}],[\"该节点被称为这两个子节点的父节点\",{\"1\":{\"82\":1}}],[\"该位置可以被新元素使用\",{\"1\":{\"78\":1}}],[\"该页面会从栈顶弹出\",{\"1\":{\"57\":1}}],[\"该页面会被添加到栈顶\",{\"1\":{\"57\":1}}],[\"该容量可能超出实际需求\",{\"1\":{\"54\":1}}],[\"该示意图只是定性表示\",{\"1\":{\"39\":1}}],[\"具有很好的应用价值\",{\"1\":{\"100\":1}}],[\"具有很好的缓存本地性\",{\"1\":{\"54\":1}}],[\"具有稳定且高效的性能\",{\"1\":{\"98\":1}}],[\"具体关于条件变量后面会讲到\",{\"1\":{\"180\":1}}],[\"具体实现步骤如下\",{\"1\":{\"159\":1}}],[\"具体策略类\",{\"1\":{\"131\":1}}],[\"具体来说\",{\"1\":{\"68\":1,\"151\":1}}],[\"具体而言\",{\"1\":{\"61\":1}}],[\"具体是如何实现的\",{\"1\":{\"57\":1}}],[\"具体的方法名需要根据所使用的编程语言来确定\",{\"1\":{\"50\":1}}],[\"返回的结果会保存在future中\",{\"1\":{\"185\":1}}],[\"返回旋转之后的子树的根节点\",{\"1\":{\"116\":1}}],[\"返回旋转后子树的根节点\",{\"1\":{\"105\":1,\"106\":1}}],[\"返回子树的根节点\",{\"1\":{\"111\":1,\"112\":1}}],[\"返回目标节点\",{\"1\":{\"94\":1}}],[\"返回桶索引\",{\"1\":{\"68\":1}}],[\"返回移动后的桶索引\",{\"1\":{\"68\":1}}],[\"返回对应的桶索引\",{\"1\":{\"68\":1}}],[\"返回对应的姓名\",{\"1\":{\"61\":1}}],[\"返回\",{\"1\":{\"53\":1,\"68\":2}}],[\"返回扩展后的新数组\",{\"1\":{\"18\":1}}],[\"转化为\",{\"1\":{\"52\":1}}],[\"头插法\",{\"1\":{\"52\":1}}],[\"头节点\",{\"1\":{\"21\":1,\"46\":2}}],[\"使其继续执行\",{\"1\":{\"163\":1}}],[\"使其尝试重新锁定互斥量\",{\"1\":{\"159\":1}}],[\"使其对外表现的逻辑符合栈的特性\",{\"1\":{\"51\":1}}],[\"使树重新恢复平衡\",{\"1\":{\"115\":1}}],[\"使所有失衡节点恢复平衡\",{\"1\":{\"111\":1,\"112\":1}}],[\"使该子树重新恢复平衡\",{\"1\":{\"109\":1,\"111\":1,\"112\":1}}],[\"使失衡节点重新恢复平衡\",{\"1\":{\"104\":1,\"109\":1}}],[\"使得线程休眠等功能\",{\"1\":{\"178\":1}}],[\"使得它们可以互相替换\",{\"1\":{\"130\":1}}],[\"使得它们的哈希值相同\",{\"1\":{\"73\":1}}],[\"使得哈希表可以在出现哈希冲突时正常工作\",{\"1\":{\"65\":1}}],[\"使用时如何选择\",{\"1\":{\"187\":1}}],[\"使用原子变量的计数器\",{\"1\":{\"181\":1}}],[\"使用原子变量实现无锁队列\",{\"0\":{\"171\":1}}],[\"使用方式都类似\",{\"1\":{\"180\":1}}],[\"使用取模操作来实现循环队列\",{\"1\":{\"172\":1}}],[\"使用模板参数\",{\"1\":{\"172\":1}}],[\"使用场景\",{\"1\":{\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1}}],[\"使用链式地址\",{\"1\":{\"77\":1}}],[\"使用链表实现栈时\",{\"1\":{\"52\":1}}],[\"使用大质数作为模数\",{\"1\":{\"74\":1}}],[\"使用伪随机数进行探测\",{\"1\":{\"71\":1}}],[\"使用列表\",{\"1\":{\"66\":1}}],[\"使用迭代器遍历\",{\"1\":{\"62\":1}}],[\"使用\",{\"1\":{\"61\":3,\"94\":1,\"153\":2,\"171\":1,\"172\":3}}],[\"使用两个栈\",{\"1\":{\"57\":1}}],[\"使用双向队列可以方便地实现一些额外操作\",{\"1\":{\"57\":1}}],[\"使用数组实现栈时\",{\"1\":{\"53\":1}}],[\"换句话说\",{\"1\":{\"51\":1,\"63\":1,\"78\":1,\"100\":1,\"104\":1}}],[\"判断栈是否为空\",{\"1\":{\"52\":1,\"53\":1}}],[\"判断是否为空\",{\"1\":{\"50\":1}}],[\"判断队列是否为空\",{\"1\":{\"44\":1,\"46\":1,\"47\":1}}],[\"某些语言可能没有专门提供栈类\",{\"1\":{\"50\":1}}],[\"命名为例\",{\"1\":{\"50\":1}}],[\"出发\",{\"1\":{\"94\":1}}],[\"出现冲突\",{\"1\":{\"70\":1}}],[\"出栈\",{\"1\":{\"49\":1,\"52\":1,\"53\":1}}],[\"出队操作\",{\"1\":{\"47\":1}}],[\"出队\",{\"1\":{\"43\":1,\"46\":1,\"47\":1}}],[\"底部称为\",{\"1\":{\"49\":1}}],[\"就不需要使用std\",{\"1\":{\"181\":1}}],[\"就会进入就绪状态\",{\"1\":{\"149\":1}}],[\"就绪\",{\"1\":{\"148\":1,\"149\":4}}],[\"就可以获得有序的节点序列\",{\"1\":{\"116\":1}}],[\"就得到了栈这种数据结构\",{\"1\":{\"49\":1}}],[\"就是有点厚\",{\"1\":{\"6\":1}}],[\"就是是书太厚了\",{\"1\":{\"6\":1}}],[\"字典\",{\"1\":{\"71\":1}}],[\"字符串对比是否一定要用\",{\"1\":{\"116\":1}}],[\"字符串\",{\"1\":{\"76\":1}}],[\"字符\",{\"1\":{\"49\":1}}],[\"字节或\",{\"1\":{\"39\":1}}],[\"字节\",{\"1\":{\"39\":3}}],[\"餐厅的出餐队列等\",{\"1\":{\"48\":1}}],[\"功能的场景\",{\"1\":{\"48\":1}}],[\"先左旋再右旋\",{\"1\":{\"115\":1}}],[\"先左旋后右旋\",{\"0\":{\"107\":1},\"1\":{\"104\":1,\"107\":1,\"109\":3}}],[\"先右旋再左旋\",{\"1\":{\"115\":1}}],[\"先右旋后左旋\",{\"0\":{\"108\":1},\"1\":{\"104\":1,\"108\":1,\"109\":3}}],[\"先走到尽头\",{\"1\":{\"115\":1}}],[\"先在二叉树中查找到目标节点\",{\"1\":{\"96\":1}}],[\"先抛出结论\",{\"1\":{\"74\":1}}],[\"先计算哈希值\",{\"1\":{\"72\":1}}],[\"先来后到\",{\"1\":{\"48\":1}}],[\"先根据扩容倍数创建一个更大的数组\",{\"1\":{\"37\":1}}],[\"任意节点的左\",{\"1\":{\"92\":1}}],[\"任意节点都可以视作头节点\",{\"1\":{\"29\":1}}],[\"任何需要实现\",{\"1\":{\"48\":1}}],[\"高层模块不应依赖于低层模块\",{\"1\":{\"123\":1}}],[\"高度和深度等\",{\"1\":{\"115\":1}}],[\"高度和深度都需要加\",{\"1\":{\"83\":1}}],[\"高度为\",{\"1\":{\"91\":2}}],[\"高度等达到极大值或极小值\",{\"1\":{\"91\":1}}],[\"高度\",{\"1\":{\"83\":1}}],[\"高效率和均匀分布的特点\",{\"1\":{\"77\":1}}],[\"高\",{\"1\":{\"75\":2}}],[\"高并发成为工程师们需要重点攻克的问题\",{\"1\":{\"48\":1}}],[\"高级数据结构\",{\"1\":{\"30\":1}}],[\"短时间内会产生海量订单\",{\"1\":{\"48\":1}}],[\"订单将加入队列中\",{\"1\":{\"48\":1}}],[\"购物者下单后\",{\"1\":{\"48\":1}}],[\"淘宝订单\",{\"1\":{\"48\":1}}],[\"有std\",{\"1\":{\"185\":1}}],[\"有时候我们如果想真正执行异步操作可以对async进行封装\",{\"1\":{\"185\":1}}],[\"有了这个函数\",{\"1\":{\"109\":1}}],[\"有左子节点\",{\"1\":{\"106\":1}}],[\"有\",{\"1\":{\"105\":1,\"106\":1}}],[\"有右子节点\",{\"1\":{\"105\":1}}],[\"有兴趣的读者请自行学习\",{\"1\":{\"76\":1}}],[\"有兴趣的读者可以尝试自行实现\",{\"1\":{\"47\":1}}],[\"有助于数据分布得更加均匀\",{\"1\":{\"69\":1}}],[\"有初始值\",{\"1\":{\"33\":2}}],[\"joinable\",{\"1\":{\"178\":3}}],[\"join\",{\"1\":{\"157\":5,\"159\":1,\"160\":4,\"161\":2,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":2,\"172\":3,\"178\":5,\"179\":2,\"180\":1,\"182\":1,\"184\":1}}],[\"jdk\",{\"1\":{\"71\":1}}],[\"j++\",{\"1\":{\"47\":1}}],[\"j\",{\"1\":{\"47\":2}}],[\"java\",{\"1\":{\"21\":1,\"31\":1,\"37\":1,\"57\":1,\"64\":1,\"71\":1,\"77\":1,\"116\":2}}],[\"~a\",{\"1\":{\"188\":1}}],[\"~arrayhashmap\",{\"1\":{\"63\":1}}],[\"~arrayqueue\",{\"1\":{\"47\":1}}],[\"~threadguard\",{\"1\":{\"178\":1}}],[\"~lockfreequeue\",{\"1\":{\"171\":1,\"172\":1}}],[\"~linkedliststack\",{\"1\":{\"52\":1}}],[\"~linkedlistqueue\",{\"1\":{\"46\":1}}],[\"~hashmapopenaddressing\",{\"1\":{\"68\":1}}],[\"~hashmapchaining\",{\"1\":{\"66\":1}}],[\"或类\",{\"1\":{\"151\":1}}],[\"或者系统cpu个数\",{\"1\":{\"178\":1}}],[\"或者\",{\"1\":{\"157\":1}}],[\"或者由于其他更高优先级的进程需要\",{\"1\":{\"149\":1}}],[\"或者说对合数取模的弊端是什么\",{\"1\":{\"74\":1}}],[\"或\",{\"1\":{\"47\":1,\"50\":1,\"54\":1,\"66\":1,\"151\":2,\"153\":4,\"161\":1,\"163\":2}}],[\"环形数组\",{\"1\":{\"47\":1,\"68\":1}}],[\"环形链表常用于需要周期性操作的场景\",{\"1\":{\"30\":1}}],[\"环形链表\",{\"1\":{\"29\":1,\"38\":1}}],[\"你可能会发现一个问题\",{\"1\":{\"47\":1}}],[\"减少内存拷贝\",{\"1\":{\"188\":1}}],[\"减少读计数器\",{\"1\":{\"160\":1}}],[\"减少耦合\",{\"1\":{\"124\":1}}],[\"减少代码的复杂性\",{\"1\":{\"123\":1}}],[\"减少模块之间的耦合性\",{\"1\":{\"123\":1}}],[\"减少引入新\",{\"1\":{\"123\":1}}],[\"减少类的复杂性\",{\"1\":{\"123\":1}}],[\"减少哈希冲突\",{\"1\":{\"77\":1}}],[\"减少\",{\"1\":{\"47\":1}}],[\"增加\",{\"1\":{\"47\":2}}],[\"增删的优势可以在其他应用上得到体现\",{\"1\":{\"39\":1}}],[\"索引处\",{\"1\":{\"47\":1}}],[\"索引本质上是内存地址的偏移量\",{\"1\":{\"13\":1}}],[\"各项时间复杂度会劣化至\",{\"1\":{\"115\":1}}],[\"各项操作都变为线性操作\",{\"1\":{\"91\":1}}],[\"各种编程语言采取了不同的哈希表实现策略\",{\"1\":{\"71\":1}}],[\"各种操作的实现方法如下图所示\",{\"1\":{\"47\":1}}],[\"各类待办事项\",{\"1\":{\"48\":1}}],[\"各个节点可以存储不同类型的数据\",{\"1\":{\"39\":1}}],[\"各个节点通过\",{\"1\":{\"21\":1}}],[\"各个参数的设定也非常考究\",{\"1\":{\"37\":1}}],[\"定位对应的桶呢\",{\"1\":{\"63\":1}}],[\"定义常量\",{\"1\":{\"143\":1}}],[\"定义算法的通用接口\",{\"1\":{\"131\":1}}],[\"定义为节点左子树的高度减去右子树的高度\",{\"1\":{\"103\":1}}],[\"定义为\",{\"1\":{\"83\":1}}],[\"定义\",{\"1\":{\"47\":1,\"123\":5}}],[\"定量表示需要根据具体情况进行分析\",{\"1\":{\"39\":1}}],[\"描述\",{\"1\":{\"44\":1,\"50\":1}}],[\"入栈操作需要初始化节点对象并修改指针\",{\"1\":{\"54\":1}}],[\"入栈和出栈操作都在预先分配好的连续内存中进行\",{\"1\":{\"54\":1}}],[\"入栈与出栈操作分别对应在数组尾部添加元素与删除元素\",{\"1\":{\"53\":1}}],[\"入栈\",{\"1\":{\"49\":1,\"52\":1,\"53\":1}}],[\"入队和出队操作都只需进行一次操作\",{\"1\":{\"47\":1}}],[\"入队操作\",{\"1\":{\"47\":1}}],[\"入队\",{\"1\":{\"43\":1,\"46\":1,\"47\":1}}],[\"入门推荐\",{\"0\":{\"6\":1}}],[\"尾部称为\",{\"1\":{\"43\":1}}],[\"尾节点视为栈底\",{\"1\":{\"52\":1}}],[\"尾节点都指向该节点\",{\"1\":{\"46\":1}}],[\"尾节点指向空\",{\"1\":{\"29\":1}}],[\"尾节点指向的是\",{\"1\":{\"21\":1}}],[\"尾节点\",{\"1\":{\"21\":1,\"39\":1,\"46\":2}}],[\"队尾\",{\"1\":{\"43\":1,\"46\":1}}],[\"队首指针向后移动一位\",{\"1\":{\"47\":1}}],[\"队首指针\",{\"1\":{\"47\":1}}],[\"队首仅可删除节点\",{\"1\":{\"46\":1}}],[\"队首元素出队\",{\"1\":{\"44\":1}}],[\"队首\",{\"1\":{\"43\":1,\"46\":1}}],[\"队列使用一个动态分配的数组\",{\"1\":{\"172\":1}}],[\"队列中的节点数量是\",{\"1\":{\"116\":1}}],[\"队列是一种遵循先入先出原则的数据结构\",{\"1\":{\"56\":1}}],[\"队列在这些场景中可以有效地维护处理顺序\",{\"1\":{\"48\":1}}],[\"队列典型应用\",{\"0\":{\"48\":1}}],[\"队列已满\",{\"1\":{\"47\":1,\"171\":1,\"172\":1}}],[\"队列容量\",{\"1\":{\"47\":1}}],[\"队列长度\",{\"1\":{\"47\":1}}],[\"队列为空\",{\"1\":{\"46\":1,\"47\":1,\"171\":1,\"172\":1}}],[\"队列实现\",{\"0\":{\"45\":1}}],[\"队列的逻辑\",{\"1\":{\"57\":1}}],[\"队列的结论与前述栈的结论相似\",{\"1\":{\"56\":1}}],[\"队列的常见操作如下表所示\",{\"1\":{\"44\":1}}],[\"队列的先入先出规则\",{\"1\":{\"43\":1}}],[\"队列常用操作\",{\"0\":{\"44\":1}}],[\"队列模拟了排队现象\",{\"1\":{\"43\":1}}],[\"队列和栈\",{\"0\":{\"42\":1}}],[\"队列\",{\"0\":{\"43\":1},\"1\":{\"20\":1,\"30\":1,\"43\":1},\"2\":{\"59\":1}}],[\"队列与栈\",{\"1\":{\"2\":1}}],[\"顾名思义\",{\"1\":{\"43\":1,\"70\":1}}],[\"会根据实际情况决定采用哪种策略\",{\"1\":{\"185\":1}}],[\"会执行一次特殊的等量扩容操作\",{\"1\":{\"71\":1}}],[\"会触发扩容机制\",{\"1\":{\"54\":1}}],[\"会导致\",{\"1\":{\"39\":1}}],[\"会发现它们每个元素的\",{\"1\":{\"39\":1}}],[\"操作减少内存拷贝和移动\",{\"0\":{\"189\":1}}],[\"操作或等待某个事件发生\",{\"1\":{\"149\":1}}],[\"操作\",{\"1\":{\"39\":1,\"104\":1,\"105\":1,\"106\":1,\"163\":6}}],[\"操作系统我只推荐这一本书\",{\"1\":{\"7\":1}}],[\"必要使用链表的情况主要是二叉树和图\",{\"1\":{\"39\":1}}],[\"ms\",{\"1\":{\"183\":3}}],[\"milliseconds\",{\"1\":{\"179\":1,\"183\":1}}],[\"moved\",{\"1\":{\"189\":6}}],[\"move\",{\"1\":{\"178\":1,\"184\":1,\"188\":1,\"189\":1}}],[\"moduluskeyhash​=13=\",{\"1\":{\"74\":1}}],[\"moduluskeyhash​=9=\",{\"1\":{\"74\":1}}],[\"modulus\",{\"1\":{\"74\":4}}],[\"modern\",{\"1\":{\"7\":1}}],[\"mutable\",{\"1\":{\"183\":1}}],[\"mutual\",{\"1\":{\"167\":1}}],[\"mutex通过多种方式保证了线程安全\",{\"1\":{\"185\":1}}],[\"mutex来保护该变量啦\",{\"1\":{\"181\":1}}],[\"mutex举例吧\",{\"1\":{\"179\":1}}],[\"mutex和std\",{\"1\":{\"179\":1}}],[\"mutex分为四种\",{\"1\":{\"179\":1}}],[\"mutex是一种线程同步的手段\",{\"1\":{\"179\":1}}],[\"mutex相关\",{\"0\":{\"179\":1},\"1\":{\"177\":1}}],[\"mutex>\",{\"1\":{\"159\":1,\"160\":3,\"161\":2,\"180\":2,\"181\":3,\"183\":3}}],[\"mutex\",{\"1\":{\"159\":1,\"160\":1,\"161\":1,\"179\":14,\"180\":4,\"181\":5,\"183\":5}}],[\"memory\",{\"1\":{\"164\":2,\"169\":3,\"171\":7,\"172\":15,\"173\":6}}],[\"mtx\",{\"1\":{\"159\":2,\"160\":3,\"161\":3}}],[\"make\",{\"1\":{\"189\":1}}],[\"main\",{\"1\":{\"153\":1,\"157\":2,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":1,\"172\":2,\"178\":2,\"179\":2,\"180\":1,\"182\":1,\"184\":2,\"185\":1,\"188\":1,\"189\":1,\"195\":1}}],[\"mangling\",{\"1\":{\"142\":2}}],[\"malloc\",{\"1\":{\"139\":2}}],[\"max\",{\"1\":{\"102\":1}}],[\"map\",{\"1\":{\"62\":11}}],[\"map<int\",{\"1\":{\"62\":1,\"189\":1}}],[\"md5\",{\"1\":{\"75\":3,\"77\":2}}],[\"m\",{\"1\":{\"39\":2,\"100\":2,\"189\":3}}],[\"个键值对\",{\"1\":{\"71\":1}}],[\"个桶\",{\"1\":{\"63\":1}}],[\"个学生\",{\"1\":{\"61\":1}}],[\"个节点对象也分散存储在内存各处\",{\"1\":{\"39\":1}}],[\"个节点需要循环\",{\"1\":{\"26\":1}}],[\"个元素的地址是相连的\",{\"1\":{\"39\":1}}],[\"×1\",{\"1\":{\"39\":1}}],[\"一次是geta\",{\"1\":{\"188\":1}}],[\"一系列进程\",{\"1\":{\"167\":1}}],[\"一个进程\",{\"1\":{\"167\":1}}],[\"一个是调用join\",{\"1\":{\"178\":1}}],[\"一个是调用\",{\"1\":{\"157\":1}}],[\"一个模块只实现其功能的最小集\",{\"1\":{\"124\":1}}],[\"一个类应只有一个引起其变化的原因\",{\"1\":{\"123\":1}}],[\"一个用于记录当前正在读取的线程数\",{\"1\":{\"160\":1}}],[\"一个用于后一个元素\",{\"1\":{\"39\":1}}],[\"一个用于前一个元素\",{\"1\":{\"39\":1}}],[\"一套操作\",{\"1\":{\"116\":1}}],[\"一圈一圈向外扩展\",{\"1\":{\"115\":1}}],[\"一分为二\",{\"1\":{\"82\":1,\"115\":1}}],[\"一部分研究人员努力提升哈希算法的性能\",{\"1\":{\"75\":1}}],[\"一般情况下\",{\"1\":{\"39\":1}}],[\"一方面\",{\"1\":{\"39\":2}}],[\"一网打尽\",{\"1\":{\"5\":1}}],[\"长度\",{\"1\":{\"39\":1}}],[\"长度不可变的性质会导致列表的实用性降低\",{\"1\":{\"31\":1}}],[\"长度不可变\",{\"1\":{\"19\":1,\"28\":1}}],[\"浅蓝色的存储节点指针是占用一块内存地址吗\",{\"1\":{\"39\":1}}],[\"双向队列就像是栈和队列的组合或两个栈拼在了一起\",{\"1\":{\"57\":1}}],[\"双向队列像是两个栈拼接在了一起\",{\"1\":{\"57\":1}}],[\"双向队列\",{\"1\":{\"57\":1}}],[\"双向队列是一种具有更高自由度的队列\",{\"1\":{\"56\":1}}],[\"双向队列适合使用链表实现\",{\"1\":{\"39\":1}}],[\"双向链表的特性使得这种操作变得简单\",{\"1\":{\"30\":1}}],[\"双向链表的节点定义同时包含指向后继节点\",{\"1\":{\"29\":1}}],[\"双向链表常用于需要快速查找前一个和后一个元素的场景\",{\"1\":{\"30\":1}}],[\"双向链表节点结构体\",{\"1\":{\"29\":1}}],[\"双向链表更具灵活性\",{\"1\":{\"29\":1}}],[\"双向链表记录了两个方向的引用\",{\"1\":{\"29\":1}}],[\"双向链表\",{\"1\":{\"29\":1,\"38\":1}}],[\"再递归地构建左右子树\",{\"1\":{\"116\":1}}],[\"再回溯继续\",{\"1\":{\"115\":1}}],[\"再对\",{\"1\":{\"107\":1,\"108\":1}}],[\"再对数组长度取模\",{\"1\":{\"72\":1}}],[\"再例如\",{\"1\":{\"100\":1}}],[\"再将其删除\",{\"1\":{\"96\":1}}],[\"再将当前数组的所有元素依次移动至新数组\",{\"1\":{\"37\":1}}],[\"再从数组\",{\"1\":{\"61\":1}}],[\"再删除元素\",{\"1\":{\"39\":1}}],[\"那我们就再也无法控制线程什么时候结束了\",{\"1\":{\"157\":1,\"178\":1}}],[\"那\",{\"1\":{\"116\":1}}],[\"那为什么时间复杂度不是\",{\"1\":{\"39\":1}}],[\"那么就设计为\",{\"1\":{\"116\":1}}],[\"那么通常比哈希表更快\",{\"1\":{\"78\":1}}],[\"那么选择质数或者合数作为模数都可以\",{\"1\":{\"74\":1}}],[\"那么哈希值就会出现聚堆\",{\"1\":{\"74\":1}}],[\"那么所有可以被\",{\"1\":{\"74\":1}}],[\"那么数据就被视为完整\",{\"1\":{\"73\":1}}],[\"那么密码就被视为正确\",{\"1\":{\"73\":1}}],[\"那么需要两个栈来配合实现\",{\"1\":{\"55\":1}}],[\"那么可以省去初始化步骤\",{\"1\":{\"54\":1}}],[\"那么可以用数组存储\",{\"1\":{\"20\":1}}],[\"那么\",{\"1\":{\"39\":1,\"63\":1}}],[\"那么它会影响后继节点的内存回收\",{\"1\":{\"39\":1}}],[\"那么多余的空间就被浪费了\",{\"1\":{\"19\":1}}],[\"逻辑更加清晰\",{\"1\":{\"39\":1}}],[\"断开更加安全\",{\"1\":{\"39\":1}}],[\"做题\",{\"1\":{\"39\":1}}],[\"不带超时功能\",{\"1\":{\"179\":2}}],[\"不需要使用互斥量\",{\"1\":{\"185\":1}}],[\"不需要像packaged\",{\"1\":{\"185\":1}}],[\"不需要同步内存顺序\",{\"1\":{\"173\":1}}],[\"不需要加锁解锁\",{\"1\":{\"162\":1}}],[\"不能递归\",{\"1\":{\"179\":1}}],[\"不能递归使用\",{\"1\":{\"179\":1}}],[\"不能再通过join来等待线程执行完\",{\"1\":{\"178\":1}}],[\"不能再通过join来等待线程执行完成\",{\"1\":{\"157\":1}}],[\"不能直接删除元素\",{\"1\":{\"70\":1}}],[\"不应强迫一个类依赖于它不需要的接口\",{\"1\":{\"123\":1}}],[\"不属于右旋操作的维护范围\",{\"1\":{\"116\":1}}],[\"不匹配\",{\"1\":{\"78\":1}}],[\"不难发现\",{\"1\":{\"75\":1}}],[\"不存在\",{\"1\":{\"68\":1}}],[\"不存在上述数组扩容时效率降低的问题\",{\"1\":{\"54\":1}}],[\"不引入额外的数据结构\",{\"1\":{\"67\":1}}],[\"不过\",{\"1\":{\"54\":1}}],[\"不过这本书我更推荐有一定基础\",{\"1\":{\"7\":1}}],[\"不同编程语言采取了不同的哈希表实现\",{\"1\":{\"77\":1}}],[\"不同编程语言的内置哈希值计算函数的定义和方法不同\",{\"1\":{\"76\":1}}],[\"不同编程语言的方法名称可能会有所不同\",{\"1\":{\"44\":1}}],[\"不同类型的节点值占用的空间是不同的\",{\"1\":{\"39\":1}}],[\"不会创建线程\",{\"1\":{\"185\":1}}],[\"不会引起数据竞争\",{\"1\":{\"169\":1}}],[\"不会\",{\"1\":{\"39\":1}}],[\"不断开没有关系\",{\"1\":{\"39\":1}}],[\"不修改\",{\"1\":{\"39\":1}}],[\"呢\",{\"1\":{\"39\":2,\"78\":1}}],[\"设计模式是解决常见软件设计问题的通用解决方案\",{\"1\":{\"122\":1}}],[\"设计模式\",{\"0\":{\"122\":1},\"2\":{\"126\":1,\"129\":1,\"134\":1}}],[\"设计原则是指导代码设计的基本准则\",{\"1\":{\"123\":1}}],[\"设计原则\",{\"0\":{\"121\":1,\"123\":1},\"1\":{\"3\":1},\"2\":{\"126\":1}}],[\"设平衡因子为\",{\"1\":{\"103\":1}}],[\"设数组长度\",{\"1\":{\"63\":1}}],[\"设为\",{\"1\":{\"39\":1}}],[\"后使父进程退出\",{\"1\":{\"153\":1}}],[\"后变量不会释放\",{\"1\":{\"138\":1}}],[\"后序遍历是三种二叉树遍历方法\",{\"1\":{\"116\":1}}],[\"后序遍历皆属于深度优先搜索\",{\"1\":{\"115\":1}}],[\"后三种顺序\",{\"1\":{\"116\":1}}],[\"后代\",{\"1\":{\"82\":1}}],[\"后两位相同时\",{\"1\":{\"64\":1}}],[\"后退操作实际上是在执行出栈\",{\"1\":{\"55\":1}}],[\"后\",{\"1\":{\"39\":2}}],[\"8\",{\"1\":{\"39\":2,\"71\":3,\"74\":1}}],[\"单一职责\",{\"1\":{\"124\":1}}],[\"单一职责原则\",{\"1\":{\"123\":1}}],[\"单向性\",{\"1\":{\"73\":1}}],[\"单向链表通常用于实现栈\",{\"1\":{\"30\":1}}],[\"单向链表的节点包含值和指向下一节点的引用两项数据\",{\"1\":{\"29\":1}}],[\"单向链表\",{\"1\":{\"29\":1}}],[\"单次入栈操作的时间复杂度会劣化至\",{\"1\":{\"56\":1}}],[\"单个元素分别占用\",{\"1\":{\"39\":1}}],[\"两个线程同时运行\",{\"1\":{\"172\":1}}],[\"两个不同的\",{\"1\":{\"77\":1}}],[\"两个学号指向了同一个姓名\",{\"1\":{\"64\":1}}],[\"两项数据\",{\"1\":{\"61\":1}}],[\"两种符号的工作原理是不同的\",{\"1\":{\"116\":1}}],[\"两种实现都支持栈定义中的各项操作\",{\"1\":{\"54\":1}}],[\"两种实现对比\",{\"0\":{\"54\":1}}],[\"两种实现的对比结论与栈一致\",{\"1\":{\"47\":1}}],[\"两种类型\",{\"1\":{\"39\":1}}],[\"两者的特点呈现出互补的特性\",{\"1\":{\"38\":1}}],[\"连接两个节点的线段\",{\"1\":{\"83\":1}}],[\"连接\",{\"1\":{\"39\":1}}],[\"连续空间存储和分散空间存储\",{\"1\":{\"38\":1}}],[\"连续空间存储是一把双刃剑\",{\"1\":{\"19\":1}}],[\"连续内存空间\",{\"1\":{\"28\":1}}],[\"灵活性\",{\"1\":{\"39\":1}}],[\"大家有需要可以留言\",{\"1\":{\"183\":1}}],[\"大量僵尸进程可能会让系统管理者难以管理和监控系统状态\",{\"1\":{\"152\":1}}],[\"大多为\",{\"1\":{\"39\":1}}],[\"大多数编程语言会将数组元素初始化为\",{\"1\":{\"12\":1}}],[\"大小限制\",{\"1\":{\"39\":1}}],[\"更方便实现实现保护\",{\"1\":{\"185\":1}}],[\"更新头部指针\",{\"1\":{\"172\":1}}],[\"更新节点高度\",{\"1\":{\"102\":1,\"105\":1,\"106\":1,\"111\":1,\"112\":1}}],[\"更新元素\",{\"1\":{\"34\":1}}],[\"更近的桶\",{\"1\":{\"68\":1}}],[\"更占用空间\",{\"1\":{\"39\":1}}],[\"更容易碎片化\",{\"1\":{\"39\":1}}],[\"栈是一种遵循先入后出原则的数据结构\",{\"1\":{\"56\":1}}],[\"栈是一块较小的内存\",{\"1\":{\"39\":1}}],[\"栈为空\",{\"1\":{\"52\":1,\"53\":1}}],[\"栈遵循先入后出的原则\",{\"1\":{\"51\":1}}],[\"栈的数组实现可能导致一定程度的空间浪费\",{\"1\":{\"56\":1}}],[\"栈的数组实现具有较高的平均效率\",{\"1\":{\"56\":1}}],[\"栈的链表实现具有更为稳定的效率表现\",{\"1\":{\"56\":1}}],[\"栈的典型应用\",{\"0\":{\"55\":1}}],[\"栈的长度\",{\"1\":{\"52\":1}}],[\"栈的实现\",{\"0\":{\"51\":1}}],[\"栈的常用操作如下表所示\",{\"1\":{\"50\":1}}],[\"栈的常用操作\",{\"0\":{\"50\":1}}],[\"栈的先入后出规则\",{\"1\":{\"49\":1}}],[\"栈底\",{\"1\":{\"49\":1}}],[\"栈顶元素出栈\",{\"1\":{\"50\":1}}],[\"栈顶\",{\"1\":{\"49\":1}}],[\"栈\",{\"0\":{\"49\":1},\"1\":{\"49\":1,\"57\":3},\"2\":{\"59\":1}}],[\"栈和队列往往会使用编程语言提供的\",{\"1\":{\"39\":1}}],[\"栈和堆具有各自的特点\",{\"1\":{\"39\":1}}],[\"栈上的数组的大小需要在编译时确定\",{\"1\":{\"39\":1}}],[\"栈内存相对较小\",{\"1\":{\"39\":1}}],[\"栈与队列\",{\"1\":{\"30\":1}}],[\"然后子进程立即退出\",{\"1\":{\"153\":1}}],[\"然后构建引用\",{\"1\":{\"85\":1}}],[\"然后将中点元素作为根节点\",{\"1\":{\"116\":1}}],[\"然后将这些哈希值组合起来\",{\"1\":{\"76\":1}}],[\"然后将节点\",{\"1\":{\"66\":1}}],[\"然后与存储的哈希值进行比较\",{\"1\":{\"73\":1}}],[\"然后遍历链表并对比\",{\"1\":{\"66\":1}}],[\"然后把原数组元素依次复制到新数组\",{\"1\":{\"18\":1}}],[\"然而对于某些要求不高的场景\",{\"1\":{\"74\":1}}],[\"然而该哈希算法过于简单\",{\"1\":{\"73\":1}}],[\"然而无论是开放寻址还是链式地址\",{\"1\":{\"72\":1}}],[\"然而\",{\"1\":{\"39\":3,\"47\":2,\"50\":1,\"51\":1,\"54\":2,\"68\":2,\"69\":1,\"77\":1,\"78\":1,\"98\":1,\"116\":1}}],[\"quecapacity\",{\"1\":{\"47\":7}}],[\"quesize++\",{\"1\":{\"46\":1,\"47\":1}}],[\"quesize\",{\"1\":{\"46\":5,\"47\":8}}],[\"queue<int>\",{\"1\":{\"44\":1}}],[\"queue\",{\"1\":{\"39\":1,\"43\":1,\"44\":10,\"46\":2,\"171\":5,\"172\":8}}],[\"q\",{\"0\":{\"39\":1,\"57\":1,\"78\":1,\"116\":1},\"1\":{\"39\":10,\"57\":4,\"78\":6,\"116\":8}}],[\"显著提升程序的执行效率\",{\"1\":{\"38\":1}}],[\"预取机制以及空间局部性和时间局部性等数据加载机制\",{\"1\":{\"38\":1}}],[\"缓存不友好\",{\"1\":{\"39\":1}}],[\"缓存通过缓存行\",{\"1\":{\"38\":1}}],[\"缓存局部性\",{\"1\":{\"19\":1}}],[\"同时规定空节点的平衡因子为\",{\"1\":{\"103\":1}}],[\"同时满足这两类二叉树的所有性质\",{\"1\":{\"101\":1}}],[\"同时可以灵活调整长度\",{\"1\":{\"38\":1}}],[\"同样可以通过数组或链表来实现\",{\"1\":{\"56\":1}}],[\"同理可得右子树\",{\"1\":{\"82\":1}}],[\"同理\",{\"1\":{\"15\":1,\"106\":1}}],[\"通知\",{\"1\":{\"161\":1}}],[\"通常用布尔值或整数表示\",{\"1\":{\"159\":1}}],[\"通常使用递归来实现\",{\"1\":{\"115\":1}}],[\"通常通过队列来实现\",{\"1\":{\"115\":1}}],[\"通常认为时间复杂度是\",{\"1\":{\"78\":1}}],[\"通常情况下哈希函数的输入空间远大于输出空间\",{\"1\":{\"65\":1}}],[\"通常情况下\",{\"1\":{\"50\":1,\"77\":1}}],[\"通常情况下这\",{\"1\":{\"39\":1}}],[\"通常比\",{\"1\":{\"39\":1}}],[\"通常基于动态数组实现\",{\"1\":{\"38\":1}}],[\"通过右值引用\",{\"1\":{\"188\":1}}],[\"通过async可以直接创建异步的任务\",{\"1\":{\"185\":1}}],[\"通过get\",{\"1\":{\"184\":1}}],[\"通过及时调用\",{\"1\":{\"153\":1}}],[\"通过添加抽象接口层\",{\"1\":{\"124\":1}}],[\"通过多个特定接口来代替单一的总接口\",{\"1\":{\"123\":1}}],[\"通过抽象和接口\",{\"1\":{\"123\":1}}],[\"通过\",{\"1\":{\"116\":1,\"172\":1}}],[\"通过重写对象的哈希方法\",{\"1\":{\"76\":1}}],[\"通过哈希函数计算桶索引\",{\"1\":{\"68\":1}}],[\"通过某种哈希算法\",{\"1\":{\"63\":1}}],[\"通过取余操作实现\",{\"1\":{\"47\":1}}],[\"通过索引遍历列表\",{\"1\":{\"36\":1}}],[\"通过索引遍历数组\",{\"1\":{\"16\":1}}],[\"通过引用指向\",{\"1\":{\"23\":1}}],[\"通过它可以从当前节点访问到下一个节点\",{\"1\":{\"21\":1}}],[\"实现生产者\",{\"1\":{\"163\":1}}],[\"实现原理\",{\"1\":{\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1}}],[\"实现策略接口的不同算法\",{\"1\":{\"131\":1}}],[\"实现模块基于抽象接口实现具体的底层细节\",{\"1\":{\"124\":1}}],[\"实现的基础\",{\"1\":{\"139\":1}}],[\"实现的\",{\"1\":{\"63\":1}}],[\"实现高效的查找\",{\"1\":{\"99\":1}}],[\"实现高效的元素查询\",{\"1\":{\"61\":1}}],[\"实现高效的节点插入与删除\",{\"1\":{\"38\":1}}],[\"实际上相当于同步操作\",{\"1\":{\"185\":1}}],[\"实际上需要通过修改节点指针来实现\",{\"1\":{\"105\":1}}],[\"实际上\",{\"1\":{\"31\":1,\"73\":1}}],[\"且值相同\",{\"1\":{\"140\":1}}],[\"且最底层节点尽量靠左填充\",{\"1\":{\"89\":1}}],[\"且容易产生聚集\",{\"1\":{\"77\":1}}],[\"且链表长度达到\",{\"1\":{\"71\":1}}],[\"且可以灵活调整长度\",{\"1\":{\"38\":1}}],[\"且初始化后长度不可变\",{\"1\":{\"38\":1}}],[\"且元素类型相同\",{\"1\":{\"19\":1}}],[\"分为计数信号量和二进制信号量\",{\"1\":{\"163\":1}}],[\"分\",{\"1\":{\"96\":1}}],[\"分治\",{\"1\":{\"91\":1}}],[\"分布越均匀\",{\"1\":{\"73\":1}}],[\"分别运行在线程对象\",{\"1\":{\"157\":1}}],[\"分别有什么用呢\",{\"1\":{\"116\":1}}],[\"分别指向其左子节点和右子节点\",{\"1\":{\"115\":1}}],[\"分别指向左子节点\",{\"1\":{\"82\":1}}],[\"分别需要采用右旋\",{\"1\":{\"109\":1}}],[\"分别用于获取和更新节点的高度\",{\"1\":{\"102\":1}}],[\"分别视为\",{\"1\":{\"46\":1}}],[\"分别代表数据在计算机内存中的两种存储方式\",{\"1\":{\"38\":1}}],[\"分配了必要的资源后\",{\"1\":{\"149\":1}}],[\"分配由编译器自动完成\",{\"1\":{\"39\":1}}],[\"分配和释放效率\",{\"1\":{\"39\":1}}],[\"分散内存空间\",{\"1\":{\"28\":1}}],[\"倍\",{\"1\":{\"37\":1,\"54\":1,\"64\":1,\"66\":1}}],[\"声明一个变量\",{\"1\":{\"37\":1}}],[\"初始容量\",{\"1\":{\"37\":1,\"54\":1}}],[\"初始化的字符串都存储在字符串常量池中\",{\"1\":{\"116\":1}}],[\"初始化节点\",{\"1\":{\"85\":1,\"95\":1}}],[\"初始化二叉树\",{\"0\":{\"85\":1},\"1\":{\"85\":1}}],[\"初始化扩容后的新哈希表\",{\"1\":{\"66\":1,\"68\":1}}],[\"初始化哈希表\",{\"1\":{\"62\":1}}],[\"初始化\",{\"1\":{\"62\":1}}],[\"初始化栈\",{\"1\":{\"50\":1}}],[\"初始化队列\",{\"1\":{\"44\":1}}],[\"初始化列表\",{\"0\":{\"33\":1},\"1\":{\"33\":1,\"39\":1}}],[\"初始化各个节点\",{\"1\":{\"23\":1}}],[\"初始化完成后\",{\"1\":{\"23\":1}}],[\"初始化链表\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"初始化一个扩展长度后的数组\",{\"1\":{\"18\":1}}],[\"初始化数组\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"47\":1,\"63\":1}}],[\"包含退出状态信息等\",{\"1\":{\"151\":1}}],[\"包含多个桶\",{\"1\":{\"66\":1}}],[\"包含\",{\"1\":{\"63\":1}}],[\"包含元素\",{\"1\":{\"23\":1}}],[\"包括以下三个重点设计\",{\"1\":{\"37\":1}}],[\"感兴趣的读者可以查阅源码进行学习\",{\"1\":{\"37\":1}}],[\"许多编程语言内置了列表\",{\"1\":{\"37\":1}}],[\"许多编程语言中的标准库提供的列表是基于动态数组实现的\",{\"1\":{\"31\":1}}],[\"直到有线程通知或者超时才会唤醒正在阻塞的线程\",{\"1\":{\"183\":1}}],[\"直到锁可用为止\",{\"1\":{\"164\":1}}],[\"直到互斥量被解锁\",{\"1\":{\"159\":1}}],[\"直到线程函数执行结束\",{\"1\":{\"157\":1,\"178\":1}}],[\"直到越过叶节点\",{\"1\":{\"95\":1}}],[\"直到找到目标元素时返回\",{\"1\":{\"70\":1}}],[\"直到找到空位后插入元素\",{\"1\":{\"70\":1}}],[\"直到找到对应元素\",{\"1\":{\"68\":1}}],[\"直至找到正确的键值对或无法找到跳出为止\",{\"1\":{\"78\":1}}],[\"直至找到空桶\",{\"1\":{\"68\":1}}],[\"直至找到目标节点\",{\"1\":{\"26\":1}}],[\"直至冲突消失为止\",{\"1\":{\"65\":1}}],[\"直接看使用代码吧\",{\"1\":{\"182\":1}}],[\"直接看代码\",{\"1\":{\"157\":1,\"178\":1}}],[\"直接删除\",{\"1\":{\"112\":2}}],[\"直接提前返回\",{\"1\":{\"96\":1}}],[\"直接返回\",{\"1\":{\"95\":2,\"109\":1,\"111\":1}}],[\"直接回到数组头部继续遍历\",{\"1\":{\"47\":1}}],[\"直接遍历列表元素\",{\"1\":{\"36\":1}}],[\"与头部指针\",{\"1\":{\"172\":1}}],[\"与顺序和逆序遍历数组类似\",{\"1\":{\"116\":1}}],[\"与插入节点类似\",{\"1\":{\"96\":1}}],[\"与查找节点相同\",{\"1\":{\"95\":1}}],[\"与查找操作相似\",{\"1\":{\"95\":1}}],[\"与链表类似\",{\"1\":{\"82\":1,\"85\":1,\"86\":1}}],[\"与数组扩容类似\",{\"1\":{\"77\":1}}],[\"与数组一样\",{\"1\":{\"36\":1}}],[\"与\",{\"0\":{\"140\":1},\"1\":{\"73\":1,\"82\":1,\"140\":1,\"172\":1}}],[\"与线性探测相比\",{\"1\":{\"70\":1}}],[\"与值\",{\"1\":{\"61\":1}}],[\"与许多语言不同\",{\"1\":{\"39\":1}}],[\"与单向链表相比\",{\"1\":{\"29\":1}}],[\"64\",{\"1\":{\"71\":1}}],[\"6\",{\"0\":{\"143\":1,\"164\":1},\"1\":{\"35\":2,\"74\":8,\"192\":1}}],[\"清空列表\",{\"1\":{\"35\":1}}],[\"需要持有相关的互斥量\",{\"1\":{\"161\":1}}],[\"需要计算不同水果的价格\",{\"1\":{\"132\":1}}],[\"需要从底至顶执行旋转操作\",{\"1\":{\"112\":1}}],[\"需要先对\",{\"1\":{\"108\":1}}],[\"需要先查询到元素\",{\"1\":{\"61\":1}}],[\"需要在左旋中添加一步\",{\"1\":{\"106\":1}}],[\"需要在右旋中添加一步\",{\"1\":{\"105\":1}}],[\"需要特别注意的是\",{\"1\":{\"102\":1}}],[\"需要通过标记删除\",{\"1\":{\"78\":1}}],[\"需要注意以下两点\",{\"1\":{\"95\":1}}],[\"需要注意两点\",{\"1\":{\"66\":1}}],[\"需要注意的是\",{\"1\":{\"44\":1,\"86\":1}}],[\"需要针对具体情况进行分析\",{\"1\":{\"54\":1}}],[\"需要手动释放空间\",{\"1\":{\"12\":1}}],[\"需注意\",{\"1\":{\"33\":1}}],[\"视为父节点\",{\"1\":{\"82\":1}}],[\"视为等同的概念\",{\"1\":{\"31\":1}}],[\"视频播放器中\",{\"1\":{\"30\":1}}],[\"data\",{\"1\":{\"160\":3}}],[\"down\",{\"1\":{\"166\":1}}],[\"do\",{\"1\":{\"157\":2}}],[\"double\",{\"1\":{\"39\":2,\"54\":1,\"66\":4,\"68\":3,\"76\":1,\"153\":2,\"191\":1,\"192\":1}}],[\"dip\",{\"1\":{\"123\":1}}],[\"dict\",{\"1\":{\"71\":1,\"77\":1}}],[\"dfs\",{\"1\":{\"116\":1}}],[\"destruct\",{\"1\":{\"188\":7}}],[\"desaction\",{\"1\":{\"178\":5}}],[\"deferred表示延迟执行任务\",{\"1\":{\"185\":1}}],[\"deferred\",{\"1\":{\"185\":1}}],[\"default\",{\"1\":{\"102\":1,\"178\":2}}],[\"dequeue\",{\"1\":{\"171\":2,\"172\":5}}],[\"detach\",{\"1\":{\"157\":3,\"178\":3,\"184\":1}}],[\"depth\",{\"1\":{\"83\":1}}],[\"degree\",{\"1\":{\"83\":1}}],[\"dec\",{\"1\":{\"76\":2}}],[\"deletion\",{\"1\":{\"68\":1}}],[\"delete是c++语言标准库提供的一组用于动态创建\",{\"1\":{\"139\":1}}],[\"delete与malloc\",{\"0\":{\"139\":1}}],[\"delete\",{\"1\":{\"18\":1,\"25\":1,\"46\":1,\"47\":1,\"52\":1,\"63\":2,\"66\":3,\"68\":4,\"96\":1,\"112\":2,\"139\":1,\"171\":1,\"172\":1}}],[\"d\",{\"1\":{\"64\":1,\"160\":2}}],[\"dynamic\",{\"1\":{\"31\":1}}],[\"动态数组\",{\"1\":{\"31\":2,\"66\":1,\"76\":1}}],[\"为实现无锁编程提供了基础设施\",{\"1\":{\"170\":1}}],[\"为支持函数重载引入了name\",{\"1\":{\"142\":1}}],[\"为数组的指针\",{\"1\":{\"140\":1}}],[\"为数组名指向首元素地址即与\",{\"1\":{\"140\":1}}],[\"为数组长度\",{\"1\":{\"15\":1}}],[\"为原点\",{\"1\":{\"105\":1,\"106\":1}}],[\"为例\",{\"1\":{\"76\":1}}],[\"为什么要将\",{\"1\":{\"116\":1}}],[\"为什么要强调对质数取模\",{\"1\":{\"74\":1}}],[\"为什么\",{\"1\":{\"116\":1}}],[\"为什么哈希表扩容能够缓解哈希冲突\",{\"1\":{\"78\":1}}],[\"为什么在线性探测中\",{\"1\":{\"78\":1}}],[\"为什么不使用哈希函数\",{\"1\":{\"78\":1}}],[\"为什么数组要求相同类型的元素\",{\"1\":{\"39\":1}}],[\"为此\",{\"1\":{\"64\":1,\"68\":1}}],[\"为了便于使用\",{\"1\":{\"109\":1}}],[\"为了保持二叉搜索树\",{\"1\":{\"95\":1}}],[\"为了保护用户密码的安全\",{\"1\":{\"73\":1}}],[\"为了防止从哈希值推导出原始密码等逆向工程\",{\"1\":{\"73\":1}}],[\"为了防止频繁扩容\",{\"1\":{\"39\":1}}],[\"为了实现插入节点\",{\"1\":{\"95\":1}}],[\"为了实现\",{\"1\":{\"73\":1}}],[\"为了实现队列\",{\"1\":{\"45\":1}}],[\"为了降低哈希冲突的发生概率\",{\"1\":{\"72\":1}}],[\"为了更加充分地使用哈希表的空间\",{\"1\":{\"68\":1}}],[\"为了提升效率\",{\"1\":{\"65\":1}}],[\"为了解决该问题\",{\"1\":{\"65\":1,\"68\":1}}],[\"为了解决此问题\",{\"1\":{\"47\":1}}],[\"为了深入了解栈的运行机制\",{\"1\":{\"51\":1}}],[\"为了加深对列表工作原理的理解\",{\"1\":{\"37\":1}}],[\"为\",{\"1\":{\"38\":1,\"153\":1}}],[\"为解决此问题\",{\"1\":{\"31\":1}}],[\"并输出相应的信息\",{\"1\":{\"172\":1}}],[\"并使用\",{\"1\":{\"172\":2}}],[\"并释放互斥量\",{\"1\":{\"161\":1}}],[\"并根据父节点与子节点之间的索引映射关系来实现指针\",{\"1\":{\"115\":1}}],[\"并用该节点替换当前节点\",{\"1\":{\"112\":1}}],[\"并声明一个成员变量\",{\"1\":{\"93\":1}}],[\"并提供\",{\"1\":{\"78\":1}}],[\"并引起一些安全问题\",{\"1\":{\"75\":1}}],[\"并与接收到的哈希值进行比较\",{\"1\":{\"73\":1}}],[\"并清空栈\",{\"1\":{\"57\":1}}],[\"并在运行时决定使用哪种策略\",{\"1\":{\"131\":1}}],[\"并在树中递归删除节点\",{\"1\":{\"96\":1}}],[\"并在桶中获取\",{\"1\":{\"63\":1}}],[\"并在程序逻辑上忽略与栈无关的操作\",{\"1\":{\"50\":1}}],[\"并在另一端删除元素\",{\"1\":{\"45\":1}}],[\"并将互斥量状态设置为锁定\",{\"1\":{\"159\":1}}],[\"并将每个算法封装在独立的策略类中\",{\"1\":{\"130\":1}}],[\"并将搜索到的目标元素与该\",{\"1\":{\"68\":1}}],[\"并将其压入栈\",{\"1\":{\"57\":2}}],[\"并将\",{\"1\":{\"47\":2,\"172\":1}}],[\"并将原列表的所有元素搬运过去\",{\"1\":{\"39\":1}}],[\"并维护一个变量\",{\"1\":{\"47\":1}}],[\"并返回\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"66\":1,\"68\":1,\"112\":1}}],[\"并且仍然保持二叉搜索树的性质\",{\"1\":{\"105\":1}}],[\"并且通过哈希函数找到标记为已删除的位置时\",{\"1\":{\"78\":1}}],[\"并且这个质数最好足够大\",{\"1\":{\"74\":1}}],[\"并且这些数字的内存地址无须连续\",{\"1\":{\"39\":1}}],[\"并且由于哈希表容量\",{\"1\":{\"64\":1}}],[\"并且更加灵活\",{\"1\":{\"57\":1}}],[\"并且\",{\"1\":{\"54\":1}}],[\"并且可以在程序运行过程中进行动态扩容\",{\"1\":{\"31\":1}}],[\"并且可以灵活动态扩容\",{\"1\":{\"31\":1}}],[\"并不是连续的\",{\"1\":{\"39\":1}}],[\"并随着元素插入和删除实时更新\",{\"1\":{\"37\":1}}],[\"并生成一个随机序列\",{\"1\":{\"20\":1}}],[\"添加键值对\",{\"1\":{\"77\":1}}],[\"添加键值对和删除键值对等\",{\"1\":{\"62\":1}}],[\"添加到链表中\",{\"1\":{\"66\":1}}],[\"添加操作\",{\"1\":{\"62\":1,\"63\":1,\"66\":1,\"68\":1}}],[\"添加至栈顶\",{\"1\":{\"50\":1}}],[\"添加至队尾\",{\"1\":{\"47\":1}}],[\"添加\",{\"1\":{\"31\":1}}],[\"添加元素\",{\"1\":{\"28\":1,\"61\":2,\"66\":1}}],[\"支持对线程join或者detach\",{\"1\":{\"157\":1,\"178\":1}}],[\"支持操作\",{\"1\":{\"54\":1}}],[\"支持元素访问\",{\"1\":{\"31\":1}}],[\"支持随机访问\",{\"1\":{\"19\":1}}],[\"以控制并发操作的顺序性\",{\"1\":{\"169\":1}}],[\"以回收子进程的资源\",{\"1\":{\"153\":1}}],[\"以获取并处理子进程的退出状态\",{\"1\":{\"153\":1}}],[\"以便使用\",{\"1\":{\"116\":1}}],[\"以便实现无缝播放\",{\"1\":{\"30\":1}}],[\"以保持其有序状态\",{\"1\":{\"99\":1}}],[\"以实现有实际意义的操作\",{\"1\":{\"86\":1}}],[\"以最大化地保证哈希值均匀分布\",{\"1\":{\"77\":1}}],[\"以\",{\"1\":{\"76\":1,\"105\":1,\"106\":1}}],[\"以上两个都不是async的默认策略\",{\"1\":{\"185\":1}}],[\"以上介绍的简单哈希算法都比较\",{\"1\":{\"75\":1}}],[\"以上实现的队列仍然具有局限性\",{\"1\":{\"47\":1}}],[\"以尽可能消除周期性模式\",{\"1\":{\"74\":1}}],[\"以确保在此之前的所有操作不会被重排序到\",{\"1\":{\"173\":1}}],[\"以确保在没有锁的情况下实现线程安全\",{\"1\":{\"168\":1}}],[\"以确保加载的结果及其后续的操作不会被重排序到\",{\"1\":{\"173\":1}}],[\"以确保取出操作完成后\",{\"1\":{\"172\":1}}],[\"以确保插入操作完成后\",{\"1\":{\"172\":1}}],[\"以确保哈希值在合适的范围内\",{\"1\":{\"74\":1}}],[\"以确保性能\",{\"1\":{\"71\":1}}],[\"以来\",{\"1\":{\"71\":1}}],[\"以此类推\",{\"1\":{\"70\":1}}],[\"以查找目标键值对\",{\"1\":{\"66\":1}}],[\"以表示键值对\",{\"1\":{\"63\":1}}],[\"以下实现包含哈希表扩容方法\",{\"1\":{\"66\":1}}],[\"以下代码实现了一个包含懒删除的开放寻址\",{\"1\":{\"68\":1}}],[\"以下代码实现了一个简单哈希表\",{\"1\":{\"63\":1}}],[\"以下代码给出了链式地址哈希表的简单实现\",{\"1\":{\"66\":1}}],[\"以下为示例代码\",{\"1\":{\"53\":1}}],[\"以下是几种常用的方法\",{\"1\":{\"153\":1}}],[\"以下是常见的状态转换路径\",{\"1\":{\"149\":1}}],[\"以下是基于链表实现栈的示例代码\",{\"1\":{\"52\":1}}],[\"以下是用链表实现队列的代码\",{\"1\":{\"46\":1}}],[\"以及判断是否需要扩容\",{\"1\":{\"37\":1}}],[\"以及支持快速添加和删除节点\",{\"1\":{\"30\":1}}],[\"以及之后的所有元素向后移动一位\",{\"1\":{\"14\":1}}],[\"算法中\",{\"1\":{\"30\":1}}],[\"算法\",{\"1\":{\"30\":1,\"76\":2}}],[\"lsp\",{\"1\":{\"123\":1}}],[\"launch\",{\"1\":{\"185\":8}}],[\"latch\",{\"1\":{\"166\":2}}],[\"landis\",{\"1\":{\"100\":1}}],[\"lazy\",{\"1\":{\"68\":1}}],[\"level\",{\"1\":{\"83\":1}}],[\"leaf\",{\"1\":{\"83\":1}}],[\"leftrotate\",{\"1\":{\"106\":1,\"109\":3}}],[\"left\",{\"1\":{\"82\":4,\"94\":1,\"102\":1,\"106\":2}}],[\"lock通过raii技术方便了加锁和解锁调用\",{\"1\":{\"185\":1}}],[\"lock使用\",{\"1\":{\"180\":1}}],[\"lock类有unlock函数\",{\"1\":{\"180\":1}}],[\"lock更加轻量级\",{\"1\":{\"180\":1}}],[\"lock两种方式\",{\"1\":{\"180\":1}}],[\"lock相关\",{\"0\":{\"180\":1},\"1\":{\"177\":1}}],[\"lockfreequeue<int>\",{\"1\":{\"171\":1,\"172\":1}}],[\"lockfreequeue\",{\"1\":{\"171\":2,\"172\":4}}],[\"lock<std\",{\"1\":{\"160\":2,\"161\":1,\"180\":1,\"183\":3}}],[\"lock\",{\"1\":{\"159\":2,\"160\":4,\"161\":4,\"164\":2,\"168\":1,\"179\":2,\"180\":6,\"181\":6,\"183\":6,\"185\":2}}],[\"log2​\",{\"1\":{\"91\":1}}],[\"logn\",{\"1\":{\"66\":1,\"94\":1,\"95\":1,\"96\":3,\"98\":4,\"100\":2,\"115\":1}}],[\"loadfactor\",{\"1\":{\"66\":2,\"68\":2}}],[\"loadthres\",{\"1\":{\"66\":3,\"68\":2}}],[\"load\",{\"1\":{\"64\":1,\"171\":4,\"172\":8,\"173\":3,\"181\":1}}],[\"long\",{\"1\":{\"39\":2,\"74\":2}}],[\"lru\",{\"1\":{\"30\":2}}],[\"linux\",{\"1\":{\"151\":1}}],[\"linkedliststack\",{\"1\":{\"52\":2}}],[\"linkedlistqueue\",{\"1\":{\"46\":2}}],[\"linkedlist\",{\"1\":{\"46\":2,\"52\":2}}],[\"linked\",{\"1\":{\"21\":1}}],[\"listnode\",{\"1\":{\"21\":4,\"23\":10,\"24\":3,\"25\":3,\"26\":2,\"27\":1,\"29\":4,\"46\":5,\"52\":5}}],[\"list\",{\"1\":{\"21\":1,\"31\":3,\"39\":3,\"52\":1}}],[\"浏览器的前进后退功能本质上是\",{\"1\":{\"57\":1}}],[\"浏览器的前进后退是否是双向链表实现\",{\"1\":{\"57\":1}}],[\"浏览器就会对上一个网页执行入栈\",{\"1\":{\"55\":1}}],[\"浏览器中的后退与前进\",{\"1\":{\"55\":1}}],[\"浏览器需要知道用户访问过的前一个和后一个网页\",{\"1\":{\"30\":1}}],[\"浏览器历史\",{\"1\":{\"30\":1}}],[\"blue\",{\"1\":{\"195\":4}}],[\"blocked\",{\"1\":{\"148\":1}}],[\"by\",{\"1\":{\"193\":1}}],[\"be\",{\"1\":{\"189\":1}}],[\"begin\",{\"1\":{\"35\":2,\"62\":1,\"66\":1}}],[\"buffer\",{\"1\":{\"171\":5,\"172\":7}}],[\"bug\",{\"1\":{\"123\":1}}],[\"build\",{\"1\":{\"116\":1}}],[\"bucketstmp\",{\"1\":{\"66\":2,\"68\":2}}],[\"buckets\",{\"1\":{\"63\":11,\"66\":11,\"68\":23}}],[\"bucket\",{\"1\":{\"63\":3,\"66\":12}}],[\"break\",{\"1\":{\"94\":1,\"96\":1,\"195\":3}}],[\"bst\",{\"1\":{\"94\":3,\"96\":3}}],[\"barrier\",{\"1\":{\"165\":1}}],[\"bar\",{\"1\":{\"157\":6}}],[\"balancefactor\",{\"1\":{\"103\":1,\"109\":6}}],[\"balance\",{\"1\":{\"103\":1}}],[\"balanced\",{\"1\":{\"90\":1,\"101\":1}}],[\"back\",{\"1\":{\"35\":5,\"53\":3,\"63\":3,\"66\":1,\"160\":1,\"165\":1,\"166\":1,\"189\":6}}],[\"binarysearchtree\",{\"1\":{\"93\":1}}],[\"binary\",{\"1\":{\"82\":1,\"88\":1,\"89\":1,\"90\":1,\"92\":1,\"101\":1}}],[\"bit\",{\"1\":{\"75\":4}}],[\"books\",{\"0\":{\"203\":1}}],[\"bool\",{\"1\":{\"44\":1,\"46\":1,\"47\":1,\"50\":1,\"52\":1,\"53\":1,\"76\":1,\"161\":1,\"171\":2,\"172\":2}}],[\"bol\",{\"1\":{\"76\":2}}],[\"b\",{\"1\":{\"30\":1,\"57\":4,\"116\":2}}],[\"邻接表是表示图的一种常用方式\",{\"1\":{\"30\":1}}],[\"所需要的资源\",{\"1\":{\"167\":1}}],[\"所有等待的线程被唤醒\",{\"1\":{\"166\":1}}],[\"所有等待的线程继续执行\",{\"1\":{\"165\":1}}],[\"所有操作的时间复杂度将从\",{\"1\":{\"100\":1}}],[\"所有层的节点都被完全填满\",{\"1\":{\"88\":1}}],[\"所有后两位相等的\",{\"1\":{\"73\":1}}],[\"所有冲突的元素都会被放到一个链表中\",{\"1\":{\"30\":1}}],[\"所以条件变量都配合std\",{\"1\":{\"180\":1}}],[\"所以\",{\"1\":{\"39\":1}}],[\"所以上述查找操作被称为\",{\"1\":{\"17\":1}}],[\"所以我们无须特意去修改它\",{\"1\":{\"15\":1}}],[\"链式地址通过将单个元素转化为链表\",{\"1\":{\"77\":1}}],[\"链式地址存在以下局限性\",{\"1\":{\"66\":1}}],[\"链式地址哈希表\",{\"1\":{\"66\":2}}],[\"链式地址\",{\"0\":{\"66\":1},\"1\":{\"65\":1,\"66\":1}}],[\"链式地址是解决哈希冲突的主流方案之一\",{\"1\":{\"30\":1}}],[\"链表则是另一个极端\",{\"1\":{\"91\":1}}],[\"链表则不然\",{\"1\":{\"26\":1}}],[\"链表过长会降低查询效率\",{\"1\":{\"77\":1}}],[\"链表会转换为红黑树以提升查找性能\",{\"1\":{\"71\":1}}],[\"链表包含节点指针\",{\"1\":{\"66\":1}}],[\"链表和数组都符合要求\",{\"1\":{\"45\":1}}],[\"链表由节点组成\",{\"1\":{\"39\":1}}],[\"链表通过更改引用\",{\"1\":{\"38\":1}}],[\"链表天然可以看作一个列表\",{\"1\":{\"31\":1}}],[\"链表中的每个元素都代表与该顶点相连的其他顶点\",{\"1\":{\"30\":1}}],[\"链表典型应用\",{\"0\":{\"30\":1}}],[\"链表删除节点\",{\"1\":{\"25\":1}}],[\"链表插入节点示例\",{\"1\":{\"24\":1}}],[\"链表常用操作\",{\"0\":{\"22\":1}}],[\"链表比数组占用更多的内存空间\",{\"1\":{\"21\":1}}],[\"链表节点所占用的内存空间比数组元素更大\",{\"1\":{\"56\":1}}],[\"链表节点结构体\",{\"1\":{\"21\":1}}],[\"链表节点\",{\"1\":{\"21\":1}}],[\"链表的扩容非常灵活\",{\"1\":{\"54\":1}}],[\"链表的\",{\"1\":{\"39\":1}}],[\"链表的首个节点被称为\",{\"1\":{\"21\":1}}],[\"链表的组成单位是节点\",{\"1\":{\"21\":1}}],[\"链表的设计使得各个节点可以分散存储在内存各处\",{\"1\":{\"21\":1}}],[\"链表定义与存储方式\",{\"1\":{\"21\":1,\"39\":1}}],[\"链表\",{\"0\":{\"21\":1,\"28\":1},\"1\":{\"21\":1,\"28\":1,\"50\":1,\"61\":4,\"78\":1,\"91\":2},\"2\":{\"41\":1}}],[\"上执行代码\",{\"1\":{\"148\":1}}],[\"上下文类\",{\"1\":{\"131\":1}}],[\"上一个节点\",{\"1\":{\"29\":1}}],[\"上述代码中\",{\"1\":{\"157\":1,\"178\":1}}],[\"上述\",{\"1\":{\"21\":1}}],[\"即避免临时对象的拷贝构造和析构\",{\"1\":{\"188\":1}}],[\"即在执行时不会被其他线程打断\",{\"1\":{\"169\":1}}],[\"即进程描述符\",{\"1\":{\"152\":1}}],[\"即进程控制块\",{\"1\":{\"151\":1}}],[\"即被修饰变量不可以被修改\",{\"1\":{\"143\":1}}],[\"即指向第二个元素a\",{\"1\":{\"140\":1}}],[\"即一个类只负责一项职责\",{\"1\":{\"123\":1}}],[\"即它们在内存中的位置是否相同\",{\"1\":{\"116\":1}}],[\"即所经过的\",{\"1\":{\"102\":1}}],[\"即同样满足条件\",{\"1\":{\"92\":1}}],[\"即节点引用\",{\"1\":{\"83\":1}}],[\"即使对象的内容发生了变化\",{\"1\":{\"76\":1}}],[\"即某些位置比其他位置更容易被占用\",{\"1\":{\"69\":1}}],[\"即\",{\"1\":{\"69\":1}}],[\"即当哈希冲突比较严重时\",{\"1\":{\"65\":1}}],[\"即将元素添加至队尾\",{\"1\":{\"44\":1}}],[\"即新来的人不断加入队列尾部\",{\"1\":{\"43\":1}}],[\"即是本文描述的\",{\"1\":{\"33\":1}}],[\"即前面介绍的普通链表\",{\"1\":{\"29\":1}}],[\"即可得到左旋的实现代码\",{\"1\":{\"106\":1}}],[\"即可访问链表头节点\",{\"1\":{\"66\":1}}],[\"即可\",{\"1\":{\"24\":1,\"25\":1,\"68\":1}}],[\"可阻塞一个或多个线程\",{\"1\":{\"185\":1}}],[\"可用于实现单例\",{\"1\":{\"185\":1}}],[\"可用于替代\",{\"1\":{\"75\":1}}],[\"可重入\",{\"1\":{\"179\":1}}],[\"可能会导致系统无法创建新进程\",{\"1\":{\"152\":1}}],[\"可能导致二叉树退化为下图所示的链表\",{\"1\":{\"98\":1}}],[\"可能在经过哈希函数后得到相同的数组索引\",{\"1\":{\"77\":1}}],[\"可实现基于内容生成哈希值\",{\"1\":{\"76\":1}}],[\"可通过数组或链表来实现\",{\"1\":{\"56\":1}}],[\"可以用\",{\"1\":{\"187\":2}}],[\"可以使用std\",{\"1\":{\"184\":2}}],[\"可以使用数组作为查找表\",{\"1\":{\"20\":1}}],[\"可以很方便的获取线程函数的返回值\",{\"1\":{\"184\":1}}],[\"可以手动释放锁\",{\"1\":{\"180\":1}}],[\"可以动态的释放锁资源\",{\"1\":{\"180\":1}}],[\"可以递归使用\",{\"1\":{\"179\":1}}],[\"可以调用线程对象的detach函数\",{\"1\":{\"178\":1}}],[\"可以调用线程对象的\",{\"1\":{\"157\":1}}],[\"可以有效避免僵尸进程的产生\",{\"1\":{\"153\":1}}],[\"可以取代宏的功能\",{\"1\":{\"141\":1}}],[\"可以轻松更改折扣策略\",{\"1\":{\"132\":1}}],[\"可以通过调用\",{\"1\":{\"153\":1}}],[\"可以通过策略模式将计算逻辑封装成独立的策略类\",{\"1\":{\"132\":1}}],[\"可以通过进一步将链表转换为红黑树来提高效率\",{\"1\":{\"77\":1}}],[\"可以理解为资源的子节点的资源释放吗\",{\"1\":{\"116\":1}}],[\"可以观察到\",{\"1\":{\"106\":1}}],[\"可以直接删除\",{\"1\":{\"96\":1}}],[\"可以根据二叉搜索树的性质来查找\",{\"1\":{\"94\":1}}],[\"可以充分发挥二叉树\",{\"1\":{\"91\":1}}],[\"可以是整数\",{\"1\":{\"76\":1}}],[\"可以减少因取模操作而产生的周期性模式\",{\"1\":{\"74\":1}}],[\"可以最大化地保证哈希值的均匀分布\",{\"1\":{\"74\":1}}],[\"可以产生均匀分布的输出\",{\"1\":{\"73\":1}}],[\"可以看到\",{\"1\":{\"47\":1}}],[\"可以在一端添加元素\",{\"1\":{\"45\":1}}],[\"可以在代码中动态分配\",{\"1\":{\"39\":1}}],[\"可以朝两个方向遍历链表\",{\"1\":{\"29\":1}}],[\"可灵活扩展\",{\"1\":{\"28\":1}}],[\"由于节点大小满足\",{\"1\":{\"116\":1}}],[\"由于要保持二叉搜索树\",{\"1\":{\"96\":1}}],[\"由于加法和异或满足交换律\",{\"1\":{\"75\":1}}],[\"由于\",{\"1\":{\"74\":1,\"102\":1}}],[\"由于平方的增长\",{\"1\":{\"69\":1}}],[\"由于链表节点需要额外存储指针\",{\"1\":{\"54\":1}}],[\"由于入栈的元素可能会源源不断地增加\",{\"1\":{\"53\":1}}],[\"由于数据不是连续存放的\",{\"1\":{\"39\":1}}],[\"由于数组\",{\"1\":{\"61\":1}}],[\"由于数组具有更高的缓存命中率\",{\"1\":{\"38\":1}}],[\"由于数组的长度不可变\",{\"1\":{\"15\":1}}],[\"由于数组的长度是固定的\",{\"1\":{\"14\":1}}],[\"由于每个元素需要两个额外的指针\",{\"1\":{\"39\":1}}],[\"由于它们采用两种相反的存储策略\",{\"1\":{\"28\":1}}],[\"下表展示了在实际应用中常见的哈希算法\",{\"1\":{\"75\":1}}],[\"下表总结了数组和链表的各项特点并对比了操作效率\",{\"1\":{\"28\":1}}],[\"下\",{\"1\":{\"73\":1}}],[\"下面是一个简单的无锁单生产者单消费者队列的实现示例\",{\"1\":{\"171\":1}}],[\"下面详细介绍这些旋转操作\",{\"1\":{\"104\":1}}],[\"下面举几个例子\",{\"1\":{\"71\":1}}],[\"下面以线性探测为例\",{\"1\":{\"67\":1}}],[\"下图展示的四种失衡情况与上述案例逐个对应\",{\"1\":{\"109\":1}}],[\"下图展示了二叉树的理想结构与退化结构\",{\"1\":{\"91\":1}}],[\"下图展示了开放寻址\",{\"1\":{\"68\":1}}],[\"下图展示了一个链式地址哈希表的例子\",{\"1\":{\"66\":1}}],[\"下图展示了数组的主要概念和存储方式\",{\"1\":{\"10\":1}}],[\"下图给出了一个示例\",{\"1\":{\"86\":1}}],[\"下图以\",{\"1\":{\"63\":1}}],[\"下一个节点\",{\"1\":{\"29\":1}}],[\"此方法简单粗暴且有效\",{\"1\":{\"65\":1}}],[\"此时线程对象的生命周期结束调用析构函数清理资源\",{\"1\":{\"157\":1,\"178\":1}}],[\"此时子进程的父进程是\",{\"1\":{\"153\":1}}],[\"此时需要先对\",{\"1\":{\"107\":1}}],[\"此时可以将链表转换为\",{\"1\":{\"66\":1}}],[\"此时节点\",{\"1\":{\"39\":1}}],[\"此时就不能用以下公式计算偏移量了\",{\"1\":{\"39\":1}}],[\"此时链表的灵活性优势就体现出来了\",{\"1\":{\"21\":1}}],[\"此过程也属于线性查找\",{\"1\":{\"27\":1}}],[\"遍历二叉树有前\",{\"1\":{\"116\":1}}],[\"遍历至\",{\"1\":{\"95\":1}}],[\"遍历桶\",{\"1\":{\"66\":3}}],[\"遍历哈希表\",{\"1\":{\"62\":1}}],[\"遍历键和遍历值\",{\"1\":{\"62\":1}}],[\"遍历键值对\",{\"1\":{\"62\":2}}],[\"遍历列表\",{\"0\":{\"36\":1}}],[\"遍历链表删除节点\",{\"1\":{\"46\":1,\"52\":1}}],[\"遍历链表\",{\"1\":{\"27\":1}}],[\"遍历数组\",{\"0\":{\"16\":1},\"1\":{\"16\":1}}],[\"轮循环内查找任意节点\",{\"1\":{\"98\":1}}],[\"轮\",{\"1\":{\"26\":1}}],[\"也称平衡二叉搜索树\",{\"1\":{\"115\":1}}],[\"也能使树重新变为\",{\"1\":{\"104\":1}}],[\"也是平衡二叉树\",{\"1\":{\"101\":1}}],[\"也常作为哈希表扩容的触发条件\",{\"1\":{\"64\":1}}],[\"也会出现很多空位\",{\"1\":{\"39\":1}}],[\"也就是说\",{\"1\":{\"26\":1}}],[\"也可以重入\",{\"1\":{\"185\":1}}],[\"也可以\",{\"1\":{\"39\":1}}],[\"也可以直接遍历各元素\",{\"1\":{\"36\":1}}],[\"也可以直接遍历获取数组中的每个元素\",{\"1\":{\"16\":1}}],[\"也可能会使用环形链表\",{\"1\":{\"30\":1}}],[\"也可用于实现各种复杂数据结构\",{\"1\":{\"20\":1}}],[\"逐个向后遍历\",{\"1\":{\"26\":1}}],[\"访问栈顶元素\",{\"1\":{\"50\":2,\"52\":1,\"53\":1}}],[\"访问队首元素\",{\"1\":{\"44\":2,\"46\":1,\"47\":1}}],[\"访问索引\",{\"1\":{\"34\":1}}],[\"访问链表中索引为\",{\"1\":{\"26\":1}}],[\"访问链表的第\",{\"1\":{\"26\":1}}],[\"访问节点\",{\"0\":{\"26\":1}}],[\"访问元素\",{\"0\":{\"13\":1,\"34\":1},\"1\":{\"28\":1,\"34\":1}}],[\"尽管在删除操作完成后节点\",{\"1\":{\"25\":1}}],[\"只是监视\",{\"1\":{\"187\":1}}],[\"只是在特定使用场景下时间效率变高了\",{\"1\":{\"78\":1}}],[\"只要求操作是原子的\",{\"1\":{\"173\":1}}],[\"只要保证程序的逻辑是正确的就行\",{\"1\":{\"39\":1}}],[\"只可以在当前文件访问\",{\"1\":{\"138\":1}}],[\"只有在高频添加\",{\"1\":{\"98\":1}}],[\"只有最底层的节点未被填满\",{\"1\":{\"89\":1}}],[\"只有不可变对象是可哈希的\",{\"1\":{\"77\":1}}],[\"只有不可变对象才可作为哈希表的\",{\"1\":{\"76\":1}}],[\"只需将头节点从链表中删除即可\",{\"1\":{\"52\":1}}],[\"只需将\",{\"1\":{\"47\":1}}],[\"只需改变一个节点的引用\",{\"1\":{\"25\":1}}],[\"只用前面一部分\",{\"1\":{\"15\":1}}],[\"相等\",{\"1\":{\"172\":2}}],[\"相同\",{\"1\":{\"140\":1}}],[\"相应地\",{\"1\":{\"106\":1}}],[\"相较线性探测更不易产生聚集\",{\"1\":{\"77\":1}}],[\"相较\",{\"1\":{\"75\":1}}],[\"相较于\",{\"1\":{\"114\":1}}],[\"相较于数组\",{\"1\":{\"35\":1}}],[\"相较于单向链表\",{\"1\":{\"29\":1}}],[\"相关信息\",{\"1\":{\"70\":1,\"76\":1,\"83\":1,\"86\":1,\"88\":1,\"103\":1,\"177\":1,\"187\":1}}],[\"相对地\",{\"1\":{\"39\":1}}],[\"相比之下\",{\"1\":{\"24\":1,\"56\":1}}],[\"相连接\",{\"1\":{\"21\":1}}],[\"之前\",{\"1\":{\"173\":1}}],[\"之间的关系\",{\"1\":{\"116\":1}}],[\"之间的大小关系\",{\"1\":{\"94\":1}}],[\"之间的派生关系\",{\"1\":{\"82\":1}}],[\"之间的映射\",{\"1\":{\"61\":1}}],[\"之间不存在公约数\",{\"1\":{\"74\":1}}],[\"之间插入一个新节点\",{\"1\":{\"24\":1}}],[\"之后\",{\"1\":{\"173\":1}}],[\"之后插入节点\",{\"1\":{\"24\":1}}],[\"之后的首个节点\",{\"1\":{\"25\":1}}],[\"之后的所有元素向前移动一位\",{\"1\":{\"15\":1}}],[\"之后的元素都向前移动一位\",{\"1\":{\"15\":1}}],[\"之后再把元素赋值给该索引\",{\"1\":{\"14\":1}}],[\"假如线程函数执行时间较长\",{\"1\":{\"157\":1,\"178\":1}}],[\"假如我们将列表\",{\"1\":{\"76\":1}}],[\"假如我们希望实现\",{\"1\":{\"61\":1}}],[\"假如我们想实现字符到\",{\"1\":{\"20\":1}}],[\"假如把列表元素换成链表节点\",{\"1\":{\"39\":1}}],[\"假设有数组\",{\"0\":{\"140\":1}}],[\"假设将\",{\"1\":{\"74\":1}}],[\"假设我们有一个水果计价系统\",{\"1\":{\"132\":1}}],[\"假设我们选择右子树的最小节点\",{\"1\":{\"96\":1}}],[\"假设我们选择合数\",{\"1\":{\"74\":1}}],[\"假设我们想在相邻的两个节点\",{\"1\":{\"24\":1}}],[\"假设被删除节点未被正常回收\",{\"1\":{\"39\":1}}],[\"而std\",{\"1\":{\"184\":3}}],[\"而不是std\",{\"1\":{\"180\":1}}],[\"而不会阻塞或挂起\",{\"1\":{\"164\":1}}],[\"而constexpr有\",{\"1\":{\"141\":1}}],[\"而无需修改订单类的代码\",{\"1\":{\"132\":1}}],[\"而无法减少哈希冲突的发生\",{\"1\":{\"72\":1}}],[\"而空节点的高度为\",{\"1\":{\"102\":1}}],[\"而二叉搜索树满足\",{\"1\":{\"97\":1}}],[\"而需要使用一个节点替换该节点\",{\"1\":{\"96\":1}}],[\"而删除节点通常意味着删除该节点及其所有子树\",{\"1\":{\"86\":1}}],[\"而\",{\"1\":{\"77\":1,\"78\":1,\"116\":1}}],[\"而当所有节点都偏向一侧时\",{\"1\":{\"91\":1}}],[\"而当\",{\"1\":{\"74\":1}}],[\"而当查询元素时\",{\"1\":{\"68\":1}}],[\"而当数组非常大时\",{\"1\":{\"21\":1}}],[\"而通过线性探测\",{\"1\":{\"68\":1}}],[\"而输入空间往往远大于输出空间\",{\"1\":{\"64\":1}}],[\"而向上回溯阶段则会不断执行出栈操作\",{\"1\":{\"55\":1}}],[\"而对于出栈操作\",{\"1\":{\"52\":1}}],[\"而位于队列头部的人逐个离开\",{\"1\":{\"43\":1}}],[\"而非链表\",{\"1\":{\"39\":1}}],[\"而非节点本身\",{\"1\":{\"39\":1}}],[\"而只在必要时才使用链表\",{\"1\":{\"39\":1}}],[\"而是未定义\",{\"1\":{\"185\":1}}],[\"而是存储密码的哈希值\",{\"1\":{\"73\":1}}],[\"而是跳过\",{\"1\":{\"69\":1}}],[\"而是利用一个常量\",{\"1\":{\"68\":1}}],[\"而是通过\",{\"1\":{\"67\":1}}],[\"而是对数字的引用\",{\"1\":{\"39\":1}}],[\"而是分别跟\",{\"1\":{\"39\":1}}],[\"而在链表中却没有强调相同类型呢\",{\"1\":{\"39\":1}}],[\"而堆上的数组的大小可以在运行时动态确定\",{\"1\":{\"39\":1}}],[\"而堆内存相对更大\",{\"1\":{\"39\":1}}],[\"而链表是退化后的最差状态\",{\"1\":{\"115\":1}}],[\"而链表是由多个独立的节点对象组成的\",{\"1\":{\"23\":1}}],[\"而链表则在内存使用上更加灵活\",{\"1\":{\"38\":1}}],[\"等待其它线程通知后唤醒\",{\"1\":{\"185\":1}}],[\"等待线程完成\",{\"1\":{\"172\":1}}],[\"等待和保持\",{\"1\":{\"167\":1}}],[\"等待所有线程到达锁存器\",{\"1\":{\"166\":1}}],[\"等待所有线程到达屏障点\",{\"1\":{\"165\":1}}],[\"等待所有已终止的子进程\",{\"1\":{\"153\":1}}],[\"等待机制\",{\"1\":{\"165\":1,\"166\":1}}],[\"等待操作\",{\"1\":{\"163\":1}}],[\"等待条件变量的通知\",{\"1\":{\"161\":1}}],[\"等待\",{\"1\":{\"161\":2,\"171\":2,\"172\":2}}],[\"等待信号\",{\"1\":{\"153\":1}}],[\"等待子进程结束并回收资源\",{\"1\":{\"153\":1}}],[\"等待再次被调度\",{\"1\":{\"149\":1}}],[\"等待资源释放\",{\"1\":{\"163\":1}}],[\"等待资源\",{\"1\":{\"149\":1}}],[\"等待下一次调度\",{\"1\":{\"149\":1}}],[\"等待调度器的调度\",{\"1\":{\"149\":1}}],[\"等待被调度器分配\",{\"1\":{\"148\":1}}],[\"等语言拥有自动垃圾回收机制\",{\"1\":{\"57\":1}}],[\"等\",{\"1\":{\"23\":1,\"31\":1,\"37\":1,\"39\":1,\"75\":1,\"77\":1,\"162\":1,\"164\":1,\"169\":1}}],[\"等支持指针的语言中\",{\"1\":{\"21\":1}}],[\"构建树的方法已在二叉搜索树代码中的\",{\"1\":{\"116\":1}}],[\"构建节点之间的引用\",{\"1\":{\"23\":1,\"85\":1}}],[\"构造方法\",{\"1\":{\"66\":1,\"68\":1}}],[\"构造函数初始化队列的容量\",{\"1\":{\"172\":1}}],[\"构造函数\",{\"1\":{\"21\":1,\"29\":1,\"139\":1}}],[\"构成的输入空间映射到数组所有索引构成的输出空间\",{\"1\":{\"64\":1}}],[\"第二次的destruct是因为临时对象在构造a对象之后就销毁了\",{\"1\":{\"188\":1}}],[\"第二步是构建节点之间的引用关系\",{\"1\":{\"23\":1}}],[\"第一个参数是创建策略\",{\"1\":{\"185\":1}}],[\"第一个子进程退出\",{\"1\":{\"153\":1}}],[\"第一个子进程\",{\"1\":{\"153\":1}}],[\"第一步是初始化各个节点对象\",{\"1\":{\"23\":1}}],[\"第\",{\"1\":{\"91\":1}}],[\"建立链表分为两步\",{\"1\":{\"23\":1}}],[\"x\",{\"1\":{\"21\":2,\"29\":2,\"70\":5,\"78\":2,\"82\":2,\"102\":2,\"157\":1,\"184\":2,\"192\":3}}],[\"指什么呢\",{\"1\":{\"116\":1}}],[\"指向下一个元素的位置\",{\"1\":{\"172\":1}}],[\"指向下一节点的指针\",{\"1\":{\"21\":1}}],[\"指向树的根节点\",{\"1\":{\"93\":1}}],[\"指向队尾索引\",{\"1\":{\"47\":1}}],[\"指向队尾元素之后的下一个位置\",{\"1\":{\"47\":1}}],[\"指向队首元素\",{\"1\":{\"47\":1}}],[\"指向队首元素的索引\",{\"1\":{\"47\":1}}],[\"指向哪里都不会对该链表产生影响\",{\"1\":{\"39\":1}}],[\"指向前驱节点的指针\",{\"1\":{\"29\":1}}],[\"指向后继节点的指针\",{\"1\":{\"29\":1}}],[\"指针的问题\",{\"1\":{\"187\":1}}],[\"指针初始化为\",{\"1\":{\"172\":1}}],[\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定\",{\"1\":{\"39\":1}}],[\"指针\",{\"1\":{\"21\":2,\"24\":1,\"25\":1,\"29\":1,\"38\":1,\"39\":1,\"82\":1,\"83\":1,\"85\":2}}],[\"节点插入和节点删除操作与链表操作方法类似\",{\"1\":{\"115\":1}}],[\"节点增删操作的平均效率更高\",{\"1\":{\"114\":1}}],[\"节点下方为平衡因子\",{\"1\":{\"105\":1}}],[\"节点平衡因子\",{\"0\":{\"103\":1},\"1\":{\"103\":1}}],[\"节点高度等于最高子树高度\",{\"1\":{\"102\":1}}],[\"节点高度\",{\"0\":{\"102\":1},\"1\":{\"102\":2}}],[\"节点总数为\",{\"1\":{\"91\":1}}],[\"节点总数\",{\"1\":{\"91\":1}}],[\"节点所在的层\",{\"1\":{\"83\":1}}],[\"节点\",{\"1\":{\"82\":5,\"105\":1}}],[\"节点之间通过引用\",{\"1\":{\"39\":1}}],[\"节点值\",{\"1\":{\"21\":1,\"29\":1,\"82\":1,\"102\":1}}],[\"节点的平衡因子\",{\"1\":{\"103\":1}}],[\"节点的高度\",{\"1\":{\"83\":1}}],[\"节点的深度\",{\"1\":{\"83\":1}}],[\"节点的子节点的数量\",{\"1\":{\"83\":1}}],[\"节点的度\",{\"1\":{\"83\":1}}],[\"节点的\",{\"1\":{\"21\":1}}],[\"v\",{\"1\":{\"163\":3,\"189\":3,\"192\":2,\"193\":2}}],[\"variable提供等待的同步机制\",{\"1\":{\"185\":1}}],[\"variable相关\",{\"0\":{\"183\":1},\"1\":{\"177\":1}}],[\"variable\",{\"1\":{\"161\":1,\"183\":1}}],[\"variable>\",{\"1\":{\"161\":1}}],[\"valueset\",{\"1\":{\"63\":4}}],[\"value\",{\"1\":{\"61\":2,\"62\":3,\"63\":4,\"68\":1,\"76\":1,\"77\":2,\"160\":2,\"162\":1,\"184\":2}}],[\"val\",{\"1\":{\"21\":2,\"29\":2,\"63\":5,\"66\":5,\"68\":5,\"82\":2,\"94\":4,\"102\":2,\"111\":6,\"112\":5}}],[\"velsky\",{\"1\":{\"100\":1}}],[\"vector<complicated>\",{\"1\":{\"189\":1}}],[\"vector<std\",{\"1\":{\"165\":1,\"166\":1}}],[\"vector<string>\",{\"1\":{\"63\":2}}],[\"vector<vector<pair\",{\"1\":{\"66\":2}}],[\"vector<pair\",{\"1\":{\"63\":4,\"68\":3}}],[\"vector<int>\",{\"1\":{\"33\":2,\"46\":2,\"47\":2,\"52\":2,\"53\":2,\"63\":2,\"160\":1,\"193\":1}}],[\"vector\",{\"1\":{\"31\":1,\"33\":1,\"39\":2,\"46\":1,\"47\":1,\"53\":1,\"116\":1}}],[\"vs\",{\"0\":{\"28\":1}}],[\"void\",{\"1\":{\"14\":1,\"15\":1,\"16\":1,\"24\":1,\"25\":1,\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"63\":3,\"66\":4,\"68\":4,\"95\":1,\"96\":1,\"102\":1,\"153\":1,\"157\":2,\"159\":1,\"160\":2,\"161\":2,\"162\":1,\"163\":1,\"164\":3,\"165\":1,\"166\":1,\"181\":4,\"182\":1,\"183\":2,\"184\":1,\"191\":1}}],[\"scoped\",{\"1\":{\"195\":1}}],[\"switch\",{\"1\":{\"195\":1}}],[\"swap\",{\"1\":{\"162\":1,\"164\":1,\"169\":1}}],[\"should\",{\"1\":{\"189\":1}}],[\"shared\",{\"1\":{\"160\":4,\"184\":1,\"187\":6}}],[\"sha\",{\"1\":{\"75\":13,\"77\":4}}],[\"sub\",{\"1\":{\"181\":2}}],[\"subtree\",{\"1\":{\"82\":2}}],[\"spinlock\",{\"0\":{\"164\":1},\"1\":{\"164\":5}}],[\"spawn\",{\"1\":{\"157\":2}}],[\"sleep\",{\"1\":{\"161\":1,\"163\":1,\"164\":1,\"178\":1}}],[\"sync\",{\"1\":{\"165\":2,\"166\":3}}],[\"synchronize\",{\"1\":{\"157\":1}}],[\"systemd\",{\"1\":{\"153\":1}}],[\"signal\",{\"1\":{\"153\":1,\"163\":1}}],[\"signum\",{\"1\":{\"153\":1}}],[\"sigchld\",{\"1\":{\"153\":8}}],[\"size++\",{\"1\":{\"66\":1,\"68\":1}}],[\"size\",{\"1\":{\"13\":3,\"14\":2,\"15\":2,\"16\":2,\"17\":2,\"18\":3,\"36\":1,\"37\":1,\"39\":2,\"44\":2,\"46\":4,\"47\":6,\"50\":2,\"52\":4,\"53\":3,\"66\":6,\"68\":5,\"76\":4,\"116\":1,\"171\":5,\"172\":4}}],[\"srp\",{\"1\":{\"123\":1}}],[\"salt\",{\"1\":{\"76\":1}}],[\"sem\",{\"1\":{\"163\":3}}],[\"semaphore<1>\",{\"1\":{\"163\":1}}],[\"set\",{\"1\":{\"161\":2,\"164\":2,\"184\":1}}],[\"search\",{\"1\":{\"92\":1,\"94\":4,\"101\":1}}],[\"separate\",{\"1\":{\"66\":1}}],[\"seconds\",{\"1\":{\"161\":1,\"163\":1,\"164\":1,\"178\":1}}],[\"second\",{\"1\":{\"62\":1,\"157\":4}}],[\"self\",{\"1\":{\"39\":2}}],[\"store\",{\"1\":{\"171\":2,\"172\":4,\"173\":2,\"181\":2}}],[\"stuff\",{\"1\":{\"157\":2}}],[\"static\",{\"0\":{\"138\":1},\"1\":{\"192\":1,\"195\":1}}],[\"stacktop\",{\"1\":{\"52\":10}}],[\"stack<int>\",{\"1\":{\"50\":1}}],[\"stack\",{\"1\":{\"39\":1,\"49\":1,\"50\":10,\"52\":2,\"53\":9}}],[\"step4\",{\"1\":{\"94\":1,\"96\":1,\"105\":1}}],[\"step3\",{\"1\":{\"94\":1,\"96\":1,\"105\":1}}],[\"step2\",{\"1\":{\"94\":1,\"96\":1,\"105\":1}}],[\"stksize++\",{\"1\":{\"52\":1}}],[\"stksize\",{\"1\":{\"52\":4}}],[\"std\",{\"0\":{\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":1},\"1\":{\"39\":5,\"76\":1,\"157\":6,\"159\":6,\"160\":11,\"161\":11,\"162\":6,\"163\":7,\"164\":9,\"165\":6,\"166\":6,\"170\":1,\"171\":14,\"172\":18,\"173\":3,\"177\":7,\"178\":15,\"179\":16,\"180\":8,\"181\":6,\"182\":4,\"183\":6,\"184\":18,\"185\":24,\"187\":3,\"188\":2,\"189\":6,\"193\":2,\"195\":4}}],[\"stl\",{\"1\":{\"39\":1}}],[\"strategy\",{\"1\":{\"130\":1}}],[\"str\",{\"1\":{\"76\":2}}],[\"string>\",{\"1\":{\"62\":1}}],[\"string\",{\"1\":{\"39\":1,\"62\":1,\"63\":4,\"66\":2,\"68\":2,\"74\":1,\"76\":1,\"116\":2,\"189\":3}}],[\"struct\",{\"1\":{\"21\":1,\"29\":1,\"63\":1,\"82\":1,\"102\":1,\"181\":2,\"188\":1,\"189\":1}}],[\"应采用的旋转方法\",{\"1\":{\"109\":1}}],[\"应用\",{\"1\":{\"75\":1}}],[\"应当极难找到两个不同的输入\",{\"1\":{\"73\":1}}],[\"应根据具体需求和场景做出恰当选择\",{\"1\":{\"38\":1}}],[\"应被替换为\",{\"1\":{\"21\":1}}],[\"应该没谁比c++之父更有发言权吧\",{\"1\":{\"7\":1}}],[\"green\",{\"1\":{\"195\":3}}],[\"grandchild\",{\"1\":{\"105\":2,\"106\":2}}],[\"grand\",{\"1\":{\"105\":3,\"106\":3,\"116\":1}}],[\"g++\",{\"1\":{\"188\":3}}],[\"gurad相比于std\",{\"1\":{\"180\":1}}],[\"guard和std\",{\"1\":{\"180\":1,\"185\":1}}],[\"guard\",{\"1\":{\"159\":1,\"178\":1,\"180\":1}}],[\"guard<std\",{\"1\":{\"159\":1,\"161\":1,\"180\":1,\"181\":3}}],[\"guidelines解析\",{\"1\":{\"7\":1}}],[\"g\",{\"1\":{\"100\":1,\"185\":1}}],[\"geta\",{\"1\":{\"188\":3}}],[\"getcount\",{\"1\":{\"183\":1}}],[\"get\",{\"1\":{\"63\":1,\"66\":1,\"68\":1,\"178\":2,\"181\":2,\"184\":4,\"185\":1}}],[\"go\",{\"1\":{\"21\":1,\"71\":2}}],[\"中退出\",{\"1\":{\"167\":1}}],[\"中呢\",{\"1\":{\"116\":1}}],[\"中序\",{\"1\":{\"115\":1,\"116\":1}}],[\"中序遍历有序\",{\"0\":{\"97\":1}}],[\"中序遍历序列\",{\"1\":{\"96\":1}}],[\"中序遍历的下一个节点\",{\"1\":{\"96\":1}}],[\"中提出了\",{\"1\":{\"100\":1}}],[\"中任意节点的左子树和右子树的高度之差的绝对值不超过\",{\"1\":{\"90\":1}}],[\"中间插入节点\",{\"1\":{\"86\":1}}],[\"中删除\",{\"1\":{\"61\":1}}],[\"中弹出最近的操作\",{\"1\":{\"57\":2}}],[\"中需要手动释放内存\",{\"1\":{\"57\":1}}],[\"中初始化\",{\"1\":{\"39\":1}}],[\"中\",{\"1\":{\"33\":1,\"39\":1,\"64\":1,\"76\":1,\"116\":5,\"151\":1,\"157\":1,\"172\":1}}],[\"中的原子操作\",{\"0\":{\"170\":1}}],[\"中的下一个节点\",{\"1\":{\"96\":1}}],[\"中的数字也被包装为对象\",{\"1\":{\"39\":1}}],[\"中的相同\",{\"1\":{\"39\":1}}],[\"中的\",{\"1\":{\"31\":4,\"162\":1}}],[\"中分别被记为\",{\"1\":{\"21\":1}}],[\"中随机抽取一个数字\",{\"1\":{\"13\":1}}],[\"ptr\",{\"1\":{\"187\":11}}],[\"point\",{\"1\":{\"165\":2,\"166\":4}}],[\"pop\",{\"1\":{\"44\":2,\"46\":2,\"47\":1,\"50\":3,\"52\":2,\"53\":3}}],[\"pid2\",{\"1\":{\"153\":2}}],[\"pid\",{\"1\":{\"153\":14}}],[\"perfect\",{\"1\":{\"88\":1}}],[\"peek\",{\"1\":{\"44\":1,\"46\":2,\"47\":2,\"50\":2}}],[\"params\",{\"1\":{\"185\":2}}],[\"parent\",{\"1\":{\"82\":1}}],[\"packaged\",{\"1\":{\"184\":7,\"185\":1}}],[\"pauses\",{\"1\":{\"157\":2}}],[\"pause\",{\"1\":{\"153\":1}}],[\"pattern\",{\"1\":{\"130\":1}}],[\"pairset\",{\"1\":{\"63\":5}}],[\"pair\",{\"1\":{\"63\":24,\"66\":22,\"68\":21,\"189\":1}}],[\"put\",{\"1\":{\"63\":1,\"66\":2,\"68\":2}}],[\"public\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"63\":2,\"66\":1,\"68\":1,\"116\":3,\"164\":1,\"171\":1,\"172\":1,\"178\":1,\"183\":1}}],[\"push\",{\"1\":{\"35\":5,\"44\":6,\"46\":2,\"47\":1,\"50\":7,\"52\":2,\"53\":3,\"63\":3,\"66\":1,\"160\":1,\"189\":3}}],[\"prom\",{\"1\":{\"184\":3}}],[\"promise更高级的东西\",{\"1\":{\"185\":1}}],[\"promise\",{\"1\":{\"184\":1}}],[\"promise包装的是一个值\",{\"1\":{\"184\":1}}],[\"promise<int>\",{\"1\":{\"184\":1}}],[\"promise与std\",{\"1\":{\"184\":1}}],[\"promise用来包装一个值\",{\"1\":{\"184\":1}}],[\"promise和std\",{\"1\":{\"184\":2}}],[\"produced\",{\"1\":{\"171\":1,\"172\":1}}],[\"producer\",{\"1\":{\"171\":2,\"172\":3}}],[\"programming\",{\"1\":{\"168\":1}}],[\"proceeding\",{\"1\":{\"165\":1,\"166\":1}}],[\"process\",{\"1\":{\"151\":1}}],[\"preemption\",{\"1\":{\"167\":1}}],[\"pre\",{\"1\":{\"95\":6,\"96\":5}}],[\"prev\",{\"1\":{\"29\":2}}],[\"prints\",{\"1\":{\"195\":1}}],[\"print\",{\"1\":{\"63\":1,\"66\":1,\"68\":1,\"159\":2,\"161\":2}}],[\"private\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"63\":1,\"66\":1,\"68\":1,\"116\":3,\"171\":1,\"178\":1,\"183\":1}}],[\"primer\",{\"1\":{\"6\":1}}],[\"p\",{\"1\":{\"24\":5,\"25\":7,\"39\":6,\"86\":5,\"163\":3}}],[\"python\",{\"1\":{\"21\":1,\"31\":1,\"37\":1,\"39\":2,\"57\":1,\"71\":1,\"76\":2,\"77\":1}}],[\"和右子节点\",{\"1\":{\"82\":1}}],[\"和反撤销\",{\"1\":{\"57\":1}}],[\"和实例对象等\",{\"1\":{\"39\":1}}],[\"和前驱节点\",{\"1\":{\"29\":1}}],[\"和\",{\"0\":{\"188\":1},\"1\":{\"21\":3,\"23\":1,\"24\":1,\"31\":2,\"33\":1,\"39\":3,\"46\":2,\"47\":1,\"57\":2,\"61\":1,\"63\":1,\"64\":2,\"65\":1,\"68\":1,\"74\":1,\"75\":2,\"77\":1,\"82\":1,\"83\":1,\"94\":1,\"96\":1,\"100\":1,\"116\":2,\"140\":1,\"157\":2,\"172\":1,\"173\":1,\"187\":1}}],[\"和指向下一节点的\",{\"1\":{\"21\":1}}],[\"和某个元素的索引\",{\"1\":{\"13\":1}}],[\"值得说明的是\",{\"1\":{\"74\":1}}],[\"值得思考的是\",{\"1\":{\"74\":1}}],[\"值得注意的是\",{\"1\":{\"14\":1,\"66\":1,\"68\":1}}],[\"值\",{\"1\":{\"21\":1,\"76\":1}}],[\"每种哈希算法的最后一步都是对大质数\",{\"1\":{\"74\":1}}],[\"每轮乘以一个常数\",{\"1\":{\"74\":1}}],[\"每轮判断元素值是否匹配\",{\"1\":{\"17\":1}}],[\"每当一个线程到达屏障点时\",{\"1\":{\"165\":1}}],[\"每当遇到哈希冲突时\",{\"1\":{\"65\":1}}],[\"每当用户执行一个操作\",{\"1\":{\"57\":1}}],[\"每当我们打开新的网页\",{\"1\":{\"55\":1}}],[\"每次完成任务时\",{\"1\":{\"166\":1}}],[\"每次累积之前都会对哈希值进行旋转操作\",{\"1\":{\"74\":1}}],[\"每次调用函数时\",{\"1\":{\"55\":1}}],[\"每次插入与删除操作都是\",{\"1\":{\"39\":1}}],[\"每个二叉树节点包含一个值以及两个指针\",{\"1\":{\"115\":1}}],[\"每个节点都有两个引用\",{\"1\":{\"82\":1}}],[\"每个节点都包含两项数据\",{\"1\":{\"21\":1}}],[\"每个节点包含值\",{\"1\":{\"82\":1}}],[\"每个元素对应唯一的桶索引\",{\"1\":{\"78\":1}}],[\"每个桶都是一个列表\",{\"1\":{\"66\":1}}],[\"每个桶仅能存储一个键值对\",{\"1\":{\"66\":1}}],[\"每个桶可存储一个键值对\",{\"1\":{\"63\":1}}],[\"每个学生都有\",{\"1\":{\"61\":1}}],[\"每个进程被赋予一个时间片\",{\"1\":{\"30\":1}}],[\"对已获得的资源保持不放\",{\"1\":{\"167\":1}}],[\"对外提供尽可能少的接口\",{\"1\":{\"124\":1}}],[\"对修改关闭\",{\"1\":{\"123\":1}}],[\"对合数取模更容易出现聚集现象\",{\"1\":{\"74\":1}}],[\"对输入的每个字符的\",{\"1\":{\"74\":1}}],[\"对于保持系统的稳定性和资源利用率至关重要\",{\"1\":{\"153\":1}}],[\"对于引用类型\",{\"1\":{\"116\":1}}],[\"对于基本数据类型\",{\"1\":{\"116\":1}}],[\"对于只有一个节点的二叉树\",{\"1\":{\"116\":1}}],[\"对于二叉树中的某个节点\",{\"1\":{\"115\":1}}],[\"对于上述失衡二叉树的镜像情况\",{\"1\":{\"108\":1}}],[\"对于上述示例中的哈希函数\",{\"1\":{\"64\":1}}],[\"对于下图中的失衡节点\",{\"1\":{\"107\":1}}],[\"对于根节点\",{\"1\":{\"92\":1}}],[\"对于密码学的相关应用\",{\"1\":{\"73\":1}}],[\"对于相同的输入\",{\"1\":{\"73\":1}}],[\"对于链式地址哈希表\",{\"1\":{\"72\":1}}],[\"对于入栈操作\",{\"1\":{\"52\":1}}],[\"对于环形数组\",{\"1\":{\"47\":1}}],[\"对缓存的利用率较低\",{\"1\":{\"39\":1}}],[\"对时间效率和空间效率是否有影响\",{\"1\":{\"39\":1}}],[\"对应的索引也可能发生变化\",{\"1\":{\"78\":1}}],[\"对应的数组索引\",{\"1\":{\"63\":1}}],[\"对应的键值对在数组中的存储位置\",{\"1\":{\"63\":1}}],[\"对应的桶索引\",{\"1\":{\"68\":4}}],[\"对应的桶\",{\"1\":{\"63\":1}}],[\"对应的元素存放在数组中的对应位置\",{\"1\":{\"20\":1}}],[\"对应队列\",{\"1\":{\"30\":1}}],[\"对应栈\",{\"1\":{\"30\":1}}],[\"对象的哈希值计算需要自行实现\",{\"1\":{\"76\":1}}],[\"对象的哈希值基于其内存地址生成\",{\"1\":{\"76\":1}}],[\"对象等\",{\"1\":{\"49\":1}}],[\"对象\",{\"1\":{\"21\":1,\"172\":1}}],[\"存储方式\",{\"1\":{\"28\":1}}],[\"存储数组的内存空间必须是连续的\",{\"1\":{\"21\":1}}],[\"存储在堆上\",{\"1\":{\"12\":1}}],[\"存储在栈上和堆上的数组都被存储在连续内存空间内\",{\"1\":{\"39\":1}}],[\"存储在栈上\",{\"1\":{\"12\":1}}],[\"空节点平衡因子为\",{\"1\":{\"103\":1}}],[\"空\",{\"1\":{\"21\":1}}],[\"空闲的内存空间可能散落在内存各处\",{\"1\":{\"21\":1}}],[\"空间效率\",{\"1\":{\"54\":1}}],[\"空间效率高\",{\"1\":{\"19\":1}}],[\"空间开销\",{\"1\":{\"39\":1}}],[\"空间浪费\",{\"1\":{\"19\":1}}],[\"图\",{\"1\":{\"30\":1,\"39\":1}}],[\"图的邻接矩阵表示实际上是一个二维数组\",{\"1\":{\"20\":1}}],[\"图等数据结构\",{\"1\":{\"20\":1}}],[\"堆的大小一般受限于可用内存\",{\"1\":{\"39\":1}}],[\"堆上的分配和释放操作通常比栈上的慢\",{\"1\":{\"39\":1}}],[\"堆\",{\"1\":{\"20\":1}}],[\"张量之间的线性代数运算\",{\"1\":{\"20\":1}}],[\"矩阵\",{\"1\":{\"20\":1}}],[\"神经网络中大量使用了向量\",{\"1\":{\"20\":1}}],[\"码累积到一个哈希值中\",{\"1\":{\"74\":1}}],[\"码累积到哈希值中\",{\"1\":{\"74\":1}}],[\"码进行相加\",{\"1\":{\"74\":1}}],[\"码值作为索引\",{\"1\":{\"20\":1}}],[\"码的映射\",{\"1\":{\"20\":1}}],[\"则在完整表达式结尾\",{\"1\":{\"185\":1}}],[\"则唤醒所有读线程\",{\"1\":{\"160\":1}}],[\"则唤醒一个写线程\",{\"1\":{\"160\":2}}],[\"则唤醒一个线程\",{\"1\":{\"159\":1}}],[\"则锁定成功\",{\"1\":{\"160\":1}}],[\"则线程进入等待队列\",{\"1\":{\"160\":2}}],[\"则线程成功锁定\",{\"1\":{\"159\":1}}],[\"则增加读计数器\",{\"1\":{\"160\":1}}],[\"则该线程进入等待队列并挂起\",{\"1\":{\"159\":1}}],[\"则该进程被挂起并返回到就绪队列中\",{\"1\":{\"149\":1}}],[\"则底层节点数量\",{\"1\":{\"116\":1}}],[\"则一棵\",{\"1\":{\"103\":1}}],[\"则重新指定根节点\",{\"1\":{\"96\":1}}],[\"则直接返回\",{\"1\":{\"96\":1}}],[\"则删除操作流程如下图所示\",{\"1\":{\"96\":1}}],[\"则初始化根节点\",{\"1\":{\"95\":1}}],[\"则不执行插入\",{\"1\":{\"95\":1}}],[\"则不需要释放内存\",{\"1\":{\"57\":1}}],[\"则节点总数为\",{\"1\":{\"88\":1}}],[\"则其左子节点和右子节点分别是\",{\"1\":{\"82\":1}}],[\"则尝试\",{\"1\":{\"70\":1}}],[\"则用删除标记覆盖它\",{\"1\":{\"68\":1}}],[\"则添加该键值对\",{\"1\":{\"68\":1}}],[\"则覆盖\",{\"1\":{\"68\":1}}],[\"则使用相同步长向后进行线性遍历\",{\"1\":{\"68\":1}}],[\"则从冲突位置向后线性遍历\",{\"1\":{\"68\":1}}],[\"则将其更改为新值\",{\"1\":{\"169\":1}}],[\"则将互斥量状态设置为未锁定\",{\"1\":{\"159\":1}}],[\"则将中序遍历的下个节点删除\",{\"1\":{\"112\":1}}],[\"则将键值对移动至该索引处\",{\"1\":{\"68\":1}}],[\"则将键值对添加至尾部\",{\"1\":{\"66\":1}}],[\"则将该节点添加到尾节点后\",{\"1\":{\"46\":1}}],[\"则更新对应\",{\"1\":{\"66\":1}}],[\"则返回\",{\"1\":{\"70\":1}}],[\"则返回添加点的索引\",{\"1\":{\"68\":1}}],[\"则返回空字符串\",{\"1\":{\"66\":1,\"68\":1}}],[\"则返回对应\",{\"1\":{\"66\":1,\"68\":1}}],[\"则返回到数组头部\",{\"1\":{\"47\":1}}],[\"则必然有多个整数映射至同一桶索引\",{\"1\":{\"65\":1}}],[\"则可以采用下图所示的哈希表来实现\",{\"1\":{\"61\":1}}],[\"则可以在\",{\"1\":{\"61\":1}}],[\"则可以将字符的\",{\"1\":{\"20\":1}}],[\"则令头\",{\"1\":{\"46\":1}}],[\"则多次引用了同一个列表\",{\"1\":{\"39\":1}}],[\"则会造成内存空间浪费\",{\"1\":{\"31\":1}}],[\"则很可能无法满足使用需求\",{\"1\":{\"31\":1}}],[\"则得到一个环形链表\",{\"1\":{\"29\":1}}],[\"则只需改变两个节点引用\",{\"1\":{\"24\":1}}],[\"则需重新建立一个更大的数组\",{\"1\":{\"18\":1}}],[\"则需要执行下图所示的\",{\"1\":{\"106\":1}}],[\"则需要先将上面的盘子依次移走\",{\"1\":{\"49\":1}}],[\"则需要先扩容列表再添加\",{\"1\":{\"39\":1}}],[\"则需要进行扩容\",{\"1\":{\"37\":1}}],[\"则需要把索引\",{\"1\":{\"15\":1}}],[\"则需要将该元素之后的所有元素都向后移动一位\",{\"1\":{\"14\":1}}],[\"argument\",{\"1\":{\"191\":1}}],[\"arguments\",{\"1\":{\"191\":2}}],[\"args>\",{\"1\":{\"185\":1}}],[\"args\",{\"1\":{\"185\":2,\"191\":4}}],[\"arrive\",{\"1\":{\"165\":1}}],[\"arr1\",{\"1\":{\"12\":1}}],[\"arr\",{\"1\":{\"12\":1,\"47\":3}}],[\"arrayhashmap\",{\"1\":{\"63\":2}}],[\"arraystack\",{\"1\":{\"53\":1}}],[\"arrayqueue\",{\"1\":{\"47\":2}}],[\"arraylist\",{\"1\":{\"31\":1}}],[\"array\",{\"1\":{\"10\":1,\"31\":1,\"52\":1,\"53\":2}}],[\"await\",{\"1\":{\"183\":1}}],[\"astring\",{\"1\":{\"189\":5}}],[\"async更方便的实现了异步调用\",{\"1\":{\"185\":1}}],[\"async策略来调用async\",{\"1\":{\"185\":1}}],[\"async表示任务执行在另一线程\",{\"1\":{\"185\":1}}],[\"async具体语法如下\",{\"1\":{\"185\":1}}],[\"async\",{\"1\":{\"185\":10}}],[\"async是比future\",{\"1\":{\"185\":1}}],[\"async相关\",{\"0\":{\"185\":1},\"1\":{\"177\":1}}],[\"ascii\",{\"1\":{\"20\":2,\"74\":3}}],[\"action\",{\"1\":{\"178\":3}}],[\"acquire\",{\"1\":{\"163\":2,\"164\":1,\"169\":1,\"171\":2,\"172\":4,\"173\":3}}],[\"access\",{\"1\":{\"26\":1,\"193\":1}}],[\"atomic提供了原子变量\",{\"1\":{\"185\":1}}],[\"atomic相关\",{\"0\":{\"181\":1},\"1\":{\"177\":1}}],[\"atomic<t>\",{\"1\":{\"181\":1}}],[\"atomic<size\",{\"1\":{\"171\":2}}],[\"atomic<int>\",{\"1\":{\"162\":1,\"181\":1}}],[\"atomic\",{\"1\":{\"162\":1,\"164\":2,\"170\":1}}],[\"all\",{\"1\":{\"161\":2,\"183\":1}}],[\"algorithm\",{\"1\":{\"100\":1}}],[\"a+1\",{\"1\":{\"140\":2}}],[\"anint\",{\"1\":{\"189\":5}}],[\"and\",{\"1\":{\"157\":2,\"162\":2,\"164\":3,\"165\":1,\"167\":1,\"169\":1,\"191\":1}}],[\"an\",{\"1\":{\"100\":1}}],[\"add\",{\"1\":{\"162\":1,\"181\":2}}],[\"addressing\",{\"1\":{\"67\":1}}],[\"adelson\",{\"1\":{\"100\":1}}],[\"avltree\",{\"1\":{\"105\":3}}],[\"avl\",{\"0\":{\"100\":1,\"101\":1,\"104\":1,\"110\":1,\"114\":1},\"1\":{\"66\":1,\"100\":5,\"101\":1,\"102\":2,\"103\":1,\"104\":1,\"109\":1,\"111\":2,\"113\":1,\"114\":1,\"115\":3}}],[\"auto\",{\"1\":{\"62\":2,\"63\":1,\"66\":4,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"178\":3,\"179\":4,\"180\":2,\"182\":1,\"185\":2,\"192\":3,\"194\":1}}],[\"a\",{\"0\":{\"39\":1,\"57\":1,\"78\":1,\"116\":1,\"140\":4},\"1\":{\"57\":4,\"64\":1,\"116\":2,\"140\":6,\"178\":2,\"188\":14,\"189\":3}}],[\"归并排序\",{\"1\":{\"20\":1}}],[\"快速排序\",{\"1\":{\"20\":1}}],[\"排序和搜索\",{\"1\":{\"20\":1}}],[\"开闭原则\",{\"1\":{\"123\":1}}],[\"开放寻址法都有不能直接删除元素的缺陷\",{\"1\":{\"78\":1}}],[\"开放寻址通过多次探测来处理哈希冲突\",{\"1\":{\"77\":1}}],[\"开放寻址哈希表\",{\"1\":{\"68\":1}}],[\"开放寻址\",{\"0\":{\"67\":1},\"1\":{\"65\":1,\"67\":1,\"68\":1,\"70\":1}}],[\"开销很大\",{\"1\":{\"19\":1}}],[\"开始计数会更自然\",{\"1\":{\"13\":1}}],[\"当需要获取线程函数返回值\",{\"1\":{\"184\":1}}],[\"当需要获取线程中的某个值\",{\"1\":{\"184\":1}}],[\"当需要快速查找一个元素或其对应关系时\",{\"1\":{\"20\":1}}],[\"当前cpu个数\",{\"1\":{\"178\":1}}],[\"当前线程id\",{\"1\":{\"178\":1}}],[\"当计数器减为零时\",{\"1\":{\"166\":1}}],[\"当计数器达到零时\",{\"1\":{\"165\":1}}],[\"当持有锁的线程释放自旋锁时\",{\"1\":{\"164\":1}}],[\"当写线程解锁时\",{\"1\":{\"160\":1}}],[\"当读线程解锁时\",{\"1\":{\"160\":1}}],[\"当一个线程尝试获取自旋锁时\",{\"1\":{\"164\":1}}],[\"当一个线程尝试锁定互斥量时\",{\"1\":{\"159\":1}}],[\"当一个线程执行\",{\"1\":{\"163\":2}}],[\"当一个线程修改条件状态并调用\",{\"1\":{\"161\":1}}],[\"当一个线程请求写锁定时\",{\"1\":{\"160\":1}}],[\"当一个线程请求读锁定时\",{\"1\":{\"160\":1}}],[\"当一个线程解锁互斥量时\",{\"1\":{\"159\":1}}],[\"当一个子进程结束时\",{\"1\":{\"151\":1}}],[\"当子进程结束时\",{\"1\":{\"153\":1}}],[\"当子节点数量\",{\"1\":{\"96\":1}}],[\"当父进程调用\",{\"1\":{\"151\":1}}],[\"当等待的事件发生\",{\"1\":{\"149\":1}}],[\"当进程完成其任务或被强制终止时\",{\"1\":{\"149\":1}}],[\"当进程执行\",{\"1\":{\"149\":1}}],[\"当进程创建完成\",{\"1\":{\"149\":1}}],[\"当二叉搜索树退化为链表时\",{\"1\":{\"115\":1}}],[\"当二叉树平衡时\",{\"1\":{\"94\":1}}],[\"当二叉树的每层节点都被填满时\",{\"1\":{\"91\":1}}],[\"当节点\",{\"1\":{\"105\":1,\"106\":1}}],[\"当待删除节点的度为\",{\"1\":{\"96\":3}}],[\"当给定一个二叉树的节点时\",{\"1\":{\"82\":1}}],[\"当将新元素插入哈希表\",{\"1\":{\"78\":1}}],[\"当哈希函数设计得比较好\",{\"1\":{\"78\":1}}],[\"当哈希冲突比较严重时\",{\"1\":{\"78\":1}}],[\"当哈希表容量\",{\"1\":{\"72\":1}}],[\"当列表的内容发生变化时\",{\"1\":{\"76\":1}}],[\"当溢出桶过多时\",{\"1\":{\"71\":1}}],[\"当\",{\"1\":{\"71\":1}}],[\"当发生冲突时\",{\"1\":{\"69\":1}}],[\"当遇到空桶时跳出\",{\"1\":{\"68\":1}}],[\"当越过数组尾部时\",{\"1\":{\"68\":1}}],[\"当链表很长时\",{\"1\":{\"66\":1}}],[\"当负载因子超过阈值时\",{\"1\":{\"66\":1,\"68\":1}}],[\"当负载因子超过\",{\"1\":{\"64\":1,\"66\":1}}],[\"当输入的\",{\"1\":{\"64\":1}}],[\"当用户输入密码时\",{\"1\":{\"73\":1}}],[\"当用户执行\",{\"1\":{\"57\":2}}],[\"当用户点击后退按钮时\",{\"1\":{\"57\":1}}],[\"当用户点击前进或后退按钮时\",{\"1\":{\"30\":1}}],[\"当用户访问一个新页面时\",{\"1\":{\"57\":1}}],[\"当入栈与出栈操作的元素是基本数据类型时\",{\"1\":{\"54\":1}}],[\"当作栈来使用\",{\"1\":{\"50\":1}}],[\"当它们到达数组尾部时就无法继续移动了\",{\"1\":{\"47\":1}}],[\"当使用数组实现列表时\",{\"1\":{\"31\":1}}],[\"当时间片用完时\",{\"1\":{\"30\":1}}],[\"当插入操作在链表的一端进行\",{\"1\":{\"30\":1}}],[\"当插入和删除操作都在链表的一端进行时\",{\"1\":{\"30\":1}}],[\"当数组中元素较多时\",{\"1\":{\"19\":1}}],[\"当访问数组元素时\",{\"1\":{\"19\":1}}],[\"插入和删除操作的时间复杂度均为\",{\"1\":{\"115\":1}}],[\"插入\",{\"1\":{\"99\":1}}],[\"插入位置在\",{\"1\":{\"95\":2}}],[\"插入操作流程如下图所示\",{\"1\":{\"95\":1}}],[\"插入节点使用\",{\"1\":{\"95\":1}}],[\"插入节点可能会改变二叉树的原有逻辑结构\",{\"1\":{\"86\":1}}],[\"插入节点\",{\"0\":{\"24\":1,\"95\":1,\"111\":1},\"1\":{\"95\":2}}],[\"插入与删除通常是由一套操作配合完成的\",{\"1\":{\"86\":1}}],[\"插入与删除节点所需的旋转操作更少\",{\"1\":{\"114\":1}}],[\"插入与删除节点\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"插入与删除元素\",{\"0\":{\"35\":1}}],[\"插入与删除操作需要移动大量的元素\",{\"1\":{\"19\":1}}],[\"插入与删除效率低\",{\"1\":{\"19\":1}}],[\"插入元素\",{\"0\":{\"14\":1},\"1\":{\"68\":1,\"70\":1,\"98\":1}}],[\"还可以设置互斥量的超时时间\",{\"1\":{\"185\":1}}],[\"还可以获取线程id等信息\",{\"1\":{\"185\":1}}],[\"还未进入准备就绪队列\",{\"1\":{\"148\":1}}],[\"还广泛应用于其他领域中\",{\"1\":{\"73\":1}}],[\"还是数组吗\",{\"1\":{\"39\":1}}],[\"还是和节点值各占一半呢\",{\"1\":{\"39\":1}}],[\"还需额外保存一个引用\",{\"1\":{\"21\":1}}],[\"还需要对操作系统有深刻的理解\",{\"1\":{\"7\":1}}],[\"还会缓存其周围的其他数据\",{\"1\":{\"19\":1}}],[\"error\",{\"1\":{\"195\":1}}],[\"erase\",{\"1\":{\"35\":1,\"62\":1,\"66\":1}}],[\"easier\",{\"1\":{\"189\":1}}],[\"elide\",{\"1\":{\"188\":2}}],[\"else\",{\"1\":{\"46\":1,\"68\":2,\"94\":2,\"95\":2,\"96\":4,\"109\":2,\"111\":2,\"112\":4,\"153\":4,\"178\":1,\"183\":1}}],[\"emplace\",{\"1\":{\"165\":1,\"166\":1,\"189\":6}}],[\"empty\",{\"1\":{\"44\":2,\"50\":2}}],[\"equals\",{\"1\":{\"116\":3}}],[\"exclusion\",{\"1\":{\"167\":1}}],[\"execute\",{\"1\":{\"157\":1}}],[\"example\",{\"1\":{\"157\":1}}],[\"exit\",{\"1\":{\"153\":5}}],[\"extern\",{\"0\":{\"142\":1},\"1\":{\"142\":1}}],[\"extendratio\",{\"1\":{\"66\":3,\"68\":2}}],[\"extend\",{\"1\":{\"18\":1,\"66\":2,\"68\":2}}],[\"explicit\",{\"1\":{\"102\":1,\"183\":1}}],[\"e\",{\"1\":{\"100\":1}}],[\"edge\",{\"1\":{\"83\":1}}],[\"enum\",{\"1\":{\"178\":1,\"195\":2}}],[\"enqueue\",{\"1\":{\"171\":2,\"172\":5}}],[\"end\",{\"1\":{\"62\":1}}],[\"endl\",{\"1\":{\"47\":1,\"62\":2,\"63\":1,\"68\":3,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":2,\"166\":2,\"171\":2,\"172\":2,\"178\":5,\"179\":2,\"180\":1,\"182\":1,\"184\":2,\"185\":1}}],[\"enlarge\",{\"1\":{\"18\":2}}],[\"effective\",{\"1\":{\"7\":1}}],[\"扩容哈希表\",{\"1\":{\"66\":1,\"68\":1}}],[\"扩容后冲突消失\",{\"1\":{\"64\":1}}],[\"扩容后的容量也可能超出实际需求\",{\"1\":{\"54\":1}}],[\"扩容前键值对\",{\"1\":{\"64\":1}}],[\"扩容一般会乘以一个系数\",{\"1\":{\"39\":1}}],[\"扩容倍数\",{\"1\":{\"66\":1,\"68\":1}}],[\"扩容倍数所占的内存吗\",{\"1\":{\"39\":1}}],[\"扩容倍数等\",{\"1\":{\"37\":1}}],[\"扩容机制通常是按照特定倍率\",{\"1\":{\"54\":1}}],[\"扩容机制\",{\"1\":{\"37\":1}}],[\"扩容数组需要将所有数据复制到新数组\",{\"1\":{\"19\":1}}],[\"扩容数组\",{\"0\":{\"18\":1}}],[\"扩展数组长度\",{\"1\":{\"18\":1}}],[\"程序可能误判这些元素不存在\",{\"1\":{\"68\":1}}],[\"程序内存管理\",{\"1\":{\"55\":1}}],[\"程序运行时\",{\"1\":{\"38\":1}}],[\"程序需要从头节点出发\",{\"1\":{\"26\":1}}],[\"程序难以保证数组之后的内存空间是可用的\",{\"1\":{\"18\":1}}],[\"程序员的知识库\",{\"1\":{\"0\":1}}],[\"two\",{\"1\":{\"191\":1}}],[\"type\",{\"1\":{\"192\":4}}],[\"types\",{\"1\":{\"191\":1}}],[\"types>\",{\"1\":{\"191\":1}}],[\"typename\",{\"1\":{\"185\":1}}],[\"time\",{\"1\":{\"183\":3}}],[\"timed\",{\"1\":{\"179\":8}}],[\"tt\",{\"1\":{\"178\":3}}],[\"t>\",{\"1\":{\"171\":3,\"172\":1}}],[\"t4\",{\"1\":{\"160\":2}}],[\"t3\",{\"1\":{\"160\":2}}],[\"t2\",{\"1\":{\"160\":2}}],[\"t1\",{\"1\":{\"160\":2}}],[\"test\",{\"1\":{\"164\":2,\"188\":3}}],[\"terminated\",{\"1\":{\"148\":1}}],[\"template<class\",{\"1\":{\"191\":1}}],[\"template\",{\"1\":{\"171\":1,\"172\":1,\"185\":1}}],[\"tempval\",{\"1\":{\"112\":2}}],[\"temp\",{\"1\":{\"112\":6}}],[\"try\",{\"1\":{\"179\":1}}],[\"treenode\",{\"1\":{\"82\":4,\"85\":10,\"86\":2,\"94\":2,\"95\":4,\"96\":3,\"102\":6,\"103\":1,\"105\":4,\"106\":4,\"109\":2,\"111\":3,\"112\":4}}],[\"tree\",{\"1\":{\"82\":1,\"88\":1,\"89\":1,\"90\":1,\"92\":1,\"101\":1,\"116\":1}}],[\"true\",{\"1\":{\"76\":1,\"161\":2,\"171\":2,\"172\":2}}],[\"traverse\",{\"1\":{\"16\":1}}],[\"t\",{\"1\":{\"76\":4,\"153\":5,\"161\":2,\"171\":9,\"172\":8,\"178\":15,\"183\":4,\"184\":2}}],[\"th\",{\"1\":{\"159\":2,\"161\":2,\"162\":2,\"163\":2,\"164\":2,\"165\":2,\"166\":2,\"179\":4,\"180\":2,\"182\":2}}],[\"that\",{\"1\":{\"157\":2}}],[\"thread使线程的创建变得非常简单\",{\"1\":{\"185\":1}}],[\"thread高级些\",{\"1\":{\"184\":1}}],[\"threadguard\",{\"1\":{\"178\":8}}],[\"thread相关\",{\"0\":{\"178\":1},\"1\":{\"177\":1}}],[\"thread>\",{\"1\":{\"165\":1,\"166\":1}}],[\"threads\",{\"1\":{\"157\":1,\"159\":3,\"161\":3,\"162\":3,\"163\":3,\"164\":3,\"165\":3,\"166\":3,\"179\":6,\"180\":3,\"182\":3}}],[\"thread\",{\"1\":{\"157\":6,\"159\":5,\"160\":4,\"161\":5,\"162\":2,\"163\":4,\"164\":4,\"165\":2,\"166\":2,\"171\":2,\"172\":2,\"178\":10,\"179\":4,\"180\":2,\"182\":2,\"184\":2}}],[\"thread来创建线程\",{\"1\":{\"157\":1,\"178\":1}}],[\"throw\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1}}],[\"the\",{\"1\":{\"100\":1,\"166\":1,\"189\":1}}],[\"this\",{\"1\":{\"63\":2,\"161\":1,\"163\":1,\"164\":1,\"178\":1,\"187\":1}}],[\"task和promise那么麻烦\",{\"1\":{\"185\":1}}],[\"task包装的是一个函数\",{\"1\":{\"184\":1}}],[\"task在future高一层\",{\"1\":{\"184\":1}}],[\"task<int\",{\"1\":{\"184\":1}}],[\"task与std\",{\"1\":{\"184\":1}}],[\"task则用来包装一个调用对象\",{\"1\":{\"184\":1}}],[\"task\",{\"1\":{\"184\":5,\"185\":1}}],[\"tail\",{\"1\":{\"171\":5,\"172\":11,\"173\":2}}],[\"table\",{\"1\":{\"61\":1}}],[\"target\",{\"1\":{\"17\":2,\"27\":4}}],[\"to\",{\"1\":{\"195\":1}}],[\"tombstone\",{\"1\":{\"68\":19}}],[\"top\",{\"1\":{\"50\":2,\"52\":2,\"53\":2}}],[\"tovector\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1}}],[\"tmpval\",{\"1\":{\"96\":2}}],[\"tmp\",{\"1\":{\"46\":2,\"52\":2,\"66\":2,\"96\":11}}],[\"fno\",{\"1\":{\"188\":2}}],[\"fut\",{\"1\":{\"184\":6}}],[\"future用于异步调用的包装和返回值\",{\"1\":{\"185\":1}}],[\"future用于访问异步操作的结果\",{\"1\":{\"184\":1}}],[\"future的析构函数将阻塞直至异步计算完成\",{\"1\":{\"185\":1}}],[\"future<int>\",{\"1\":{\"184\":3}}],[\"future配合使用\",{\"1\":{\"184\":2}}],[\"future是不可以复制的\",{\"1\":{\"184\":1}}],[\"future作为异步结果的传输通道\",{\"1\":{\"184\":1}}],[\"future比std\",{\"1\":{\"184\":1}}],[\"future\",{\"1\":{\"184\":4,\"185\":1}}],[\"future相关\",{\"0\":{\"184\":1},\"1\":{\"177\":1}}],[\"func1\",{\"1\":{\"178\":2,\"179\":4,\"180\":2}}],[\"func\",{\"1\":{\"178\":3,\"184\":4,\"185\":3}}],[\"function\",{\"1\":{\"63\":1}}],[\"flag使用\",{\"1\":{\"182\":1}}],[\"flag\",{\"1\":{\"164\":5,\"182\":1}}],[\"fetch\",{\"1\":{\"162\":1}}],[\"false\",{\"1\":{\"161\":1,\"171\":2,\"172\":2}}],[\"factor\",{\"1\":{\"64\":1,\"103\":1}}],[\"found\",{\"1\":{\"202\":1}}],[\"foo\",{\"1\":{\"142\":2,\"157\":6}}],[\"forward<args>\",{\"1\":{\"185\":1}}],[\"forward<f>\",{\"1\":{\"185\":1}}],[\"fork\",{\"1\":{\"153\":10}}],[\"for\",{\"1\":{\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"36\":2,\"46\":1,\"47\":1,\"52\":1,\"62\":2,\"63\":5,\"66\":9,\"68\":3,\"74\":1,\"100\":1,\"159\":2,\"160\":1,\"161\":3,\"162\":3,\"163\":3,\"164\":3,\"165\":2,\"166\":2,\"171\":2,\"172\":2,\"178\":4,\"179\":7,\"180\":3,\"182\":2,\"183\":1,\"189\":1,\"193\":1}}],[\"f\",{\"1\":{\"78\":2,\"103\":1,\"185\":7,\"191\":4,\"194\":2}}],[\"f3​\",{\"1\":{\"70\":1}}],[\"f2​\",{\"1\":{\"70\":2}}],[\"f1​\",{\"1\":{\"70\":2}}],[\"final\",{\"1\":{\"162\":1}}],[\"finishes\",{\"1\":{\"157\":2}}],[\"findbucket\",{\"1\":{\"68\":4}}],[\"find\",{\"1\":{\"17\":1,\"27\":1}}],[\"firsttombstone\",{\"1\":{\"68\":8}}],[\"first\",{\"1\":{\"62\":1,\"157\":4}}],[\"from\",{\"1\":{\"195\":1}}],[\"front\",{\"1\":{\"44\":2,\"46\":11,\"47\":13}}],[\"free\",{\"1\":{\"139\":1,\"168\":1}}],[\"freememorylinkedlist\",{\"1\":{\"46\":1,\"52\":1}}],[\"线程池\",{\"1\":{\"185\":1}}],[\"线程同步\",{\"2\":{\"175\":1,\"197\":1}}],[\"线程同步机制\",{\"0\":{\"158\":1}}],[\"线程会持续等待直到成功取出元素\",{\"1\":{\"172\":1}}],[\"线程会持续等待直到成功插入\",{\"1\":{\"172\":1}}],[\"线程\",{\"1\":{\"167\":6}}],[\"线程等待直到锁存器倒数到零\",{\"1\":{\"166\":1}}],[\"线程将反复检查锁的状态\",{\"1\":{\"164\":1}}],[\"线程将自己添加到等待队列\",{\"1\":{\"161\":1}}],[\"线程在尝试获取锁时会反复检查锁的状态\",{\"1\":{\"164\":1}}],[\"线程在等待条件变量时\",{\"1\":{\"161\":1}}],[\"线程进入等待队列\",{\"1\":{\"163\":1}}],[\"线程再次进入等待状态\",{\"1\":{\"161\":1}}],[\"线程继续执行\",{\"1\":{\"160\":1,\"161\":1,\"163\":1}}],[\"线程资源在任务结束后会由操作系统自动回收\",{\"1\":{\"157\":1}}],[\"线程函数的返回值将会被忽略\",{\"1\":{\"157\":1,\"178\":1}}],[\"线程编程\",{\"0\":{\"156\":1},\"1\":{\"1\":1}}],[\"线性探测法会根据预先设定的步长依次向下查找\",{\"1\":{\"78\":1}}],[\"线性探测使用固定步长\",{\"1\":{\"77\":1}}],[\"线性探测到\",{\"1\":{\"68\":1}}],[\"线性探测到该空桶就会返回\",{\"1\":{\"68\":1}}],[\"线性探测容易产生\",{\"1\":{\"68\":1}}],[\"线性探测采用固定步长的线性搜索来进行探测\",{\"1\":{\"68\":1}}],[\"线性探测\",{\"0\":{\"68\":1},\"1\":{\"68\":4,\"70\":1}}],[\"线性结构\",{\"2\":{\"41\":1}}],[\"线性查找\",{\"1\":{\"17\":1}}],[\"若从\",{\"1\":{\"185\":1}}],[\"若删除节点为根节点\",{\"1\":{\"96\":1}}],[\"若无待删除节点\",{\"1\":{\"96\":1}}],[\"若无该\",{\"1\":{\"66\":1}}],[\"若树为空\",{\"1\":{\"95\":1,\"96\":1}}],[\"若树的高度为\",{\"1\":{\"88\":1}}],[\"若待插入节点在树中已存在\",{\"1\":{\"95\":1}}],[\"若哈希函数\",{\"1\":{\"70\":1}}],[\"若键值对不存在\",{\"1\":{\"68\":2}}],[\"若\",{\"1\":{\"68\":1,\"94\":3}}],[\"若之前遇到了删除标记\",{\"1\":{\"68\":1}}],[\"若之后不需要用到\",{\"1\":{\"57\":1}}],[\"若遇到空位或已尝试所有哈希函数\",{\"1\":{\"70\":1}}],[\"若遇到\",{\"1\":{\"68\":1}}],[\"若遇到指定\",{\"1\":{\"66\":1}}],[\"若发现哈希冲突\",{\"1\":{\"68\":1}}],[\"若发现桶内已有元素\",{\"1\":{\"68\":1}}],[\"若未找到\",{\"1\":{\"66\":1}}],[\"若找到键值对\",{\"1\":{\"68\":3}}],[\"若找到\",{\"1\":{\"66\":1}}],[\"若越过尾部\",{\"1\":{\"47\":1}}],[\"若插入元素时列表容量已满\",{\"1\":{\"37\":1}}],[\"若长度过大\",{\"1\":{\"31\":1}}],[\"若长度过小\",{\"1\":{\"31\":1}}],[\"若匹配则输出对应索引\",{\"1\":{\"17\":1}}],[\"若想删除索引\",{\"1\":{\"15\":1}}],[\"但只能使用一次\",{\"1\":{\"166\":1}}],[\"但在写入时只允许一个线程操作\",{\"1\":{\"160\":1}}],[\"但在扩容过程中\",{\"1\":{\"56\":1}}],[\"但有些题目或教材可能会将其定义为\",{\"1\":{\"83\":1}}],[\"但空间效率变低了\",{\"1\":{\"78\":1}}],[\"但为什么效率可以比它们更高呢\",{\"1\":{\"78\":1}}],[\"但多个哈希函数增加了计算量\",{\"1\":{\"77\":1}}],[\"但多个哈希函数会带来额外的计算量\",{\"1\":{\"70\":1}}],[\"但它会占用一个进程表项\",{\"1\":{\"152\":1}}],[\"但它的进程描述符\",{\"1\":{\"151\":1}}],[\"但它的内存地址不变\",{\"1\":{\"76\":1}}],[\"但它是可哈希的\",{\"1\":{\"76\":1}}],[\"但目前使用覆盖度不如\",{\"1\":{\"75\":1}}],[\"但不同的是\",{\"1\":{\"68\":1}}],[\"但效率太低\",{\"1\":{\"65\":1}}],[\"但需要注意的是\",{\"1\":{\"56\":1}}],[\"但由于扩容是低频操作\",{\"1\":{\"54\":1}}],[\"但由于其长度不可变\",{\"1\":{\"31\":1}}],[\"但这已超出了栈的定义范畴\",{\"1\":{\"54\":1}}],[\"但这样做会造成部分内存空间浪费\",{\"1\":{\"15\":1}}],[\"但二维数组会有这个问题\",{\"1\":{\"39\":1}}],[\"但好像一些算法书上不怎么直接使用它\",{\"1\":{\"39\":1}}],[\"但是在实际应用中使用智能指针有一些需要注意的地方\",{\"1\":{\"187\":1}}],[\"但是我平时只存放整形\",{\"1\":{\"181\":1}}],[\"但是\",{\"1\":{\"54\":1}}],[\"但是初始化\",{\"1\":{\"39\":1}}],[\"但是增删之前都需要\",{\"1\":{\"39\":1}}],[\"但可能导致部分内存空间浪费\",{\"1\":{\"38\":1,\"39\":1}}],[\"但可能浪费空间\",{\"1\":{\"28\":1}}],[\"但节点访问效率低\",{\"1\":{\"38\":1}}],[\"但插入和删除元素效率低\",{\"1\":{\"38\":1}}],[\"但插入和删除元素的效率仍与数组相同\",{\"1\":{\"35\":1}}],[\"但相应地也需要占用更多的内存空间\",{\"1\":{\"29\":1}}],[\"但实际上遍历此链表已经无法访问到\",{\"1\":{\"25\":1}}],[\"但从地址计算公式的角度看\",{\"1\":{\"13\":1}}],[\"的助手\",{\"1\":{\"187\":1}}],[\"的值\",{\"1\":{\"172\":2}}],[\"的值覆盖待删除节点的值\",{\"1\":{\"96\":1}}],[\"的进程\",{\"1\":{\"153\":1}}],[\"的风险\",{\"1\":{\"123\":1}}],[\"的满二叉树\",{\"1\":{\"116\":1}}],[\"的父节点和\",{\"1\":{\"116\":1}}],[\"的优先级遍历树\",{\"1\":{\"116\":1}}],[\"的优势\",{\"1\":{\"91\":1}}],[\"的遍历方式\",{\"1\":{\"115\":1}}],[\"的遍历顺序\",{\"1\":{\"97\":1}}],[\"的逐层遍历方式\",{\"1\":{\"115\":1}}],[\"的平衡因子\",{\"1\":{\"109\":1}}],[\"的左旋操作\",{\"1\":{\"106\":1}}],[\"的左子节点\",{\"1\":{\"105\":1}}],[\"的左子树中\",{\"1\":{\"94\":2,\"95\":1,\"96\":1}}],[\"的右子节点\",{\"1\":{\"106\":1}}],[\"的右子树中\",{\"1\":{\"94\":2,\"95\":1,\"96\":1}}],[\"的右旋操作\",{\"1\":{\"105\":1}}],[\"的数量\",{\"1\":{\"102\":1}}],[\"的大小关系\",{\"1\":{\"97\":1}}],[\"的大小关系循环向下搜索\",{\"1\":{\"95\":1}}],[\"的下一个节点\",{\"1\":{\"96\":1}}],[\"的位置\",{\"1\":{\"95\":1}}],[\"的性质仍然满足\",{\"1\":{\"96\":1}}],[\"的性质\",{\"1\":{\"95\":1,\"96\":1,\"104\":1}}],[\"的性能会更好\",{\"1\":{\"39\":1}}],[\"的树的高度\",{\"1\":{\"91\":1}}],[\"的树的节点总数\",{\"1\":{\"91\":1}}],[\"的树的叶节点数量\",{\"1\":{\"91\":1}}],[\"的分治逻辑\",{\"1\":{\"82\":1,\"115\":1}}],[\"的分布存在某种周期性时\",{\"1\":{\"74\":1}}],[\"的查询效率\",{\"1\":{\"78\":1}}],[\"的查询功能\",{\"1\":{\"61\":1}}],[\"的成员变量是可变的\",{\"1\":{\"76\":1}}],[\"的哈希值为\",{\"1\":{\"76\":4}}],[\"的哈希表数据结构\",{\"1\":{\"73\":1}}],[\"的实现开销更低\",{\"1\":{\"75\":1}}],[\"的输出都相同\",{\"1\":{\"73\":1}}],[\"的设计上\",{\"1\":{\"72\":1}}],[\"的问题\",{\"1\":{\"70\":1}}],[\"的步数\",{\"1\":{\"69\":1}}],[\"的索引\",{\"1\":{\"68\":1}}],[\"的增加\",{\"1\":{\"68\":1}}],[\"的两个学生时\",{\"1\":{\"64\":1}}],[\"的情况\",{\"1\":{\"64\":1}}],[\"的尾部即可\",{\"1\":{\"61\":1}}],[\"的体现\",{\"1\":{\"57\":1}}],[\"的每个元素引用相同的地址吗\",{\"1\":{\"39\":1}}],[\"的时间查找元素\",{\"1\":{\"39\":1}}],[\"的角度看\",{\"1\":{\"39\":1}}],[\"的引用\",{\"1\":{\"29\":1}}],[\"的首个节点\",{\"1\":{\"27\":1}}],[\"的节点称为\",{\"1\":{\"104\":1}}],[\"的节点\",{\"1\":{\"26\":1,\"27\":1}}],[\"的操作\",{\"1\":{\"18\":1}}],[\"的\",{\"1\":{\"15\":1,\"77\":2,\"98\":1}}],[\"内部有一个调度器\",{\"1\":{\"185\":1}}],[\"内置\",{\"1\":{\"76\":1}}],[\"内数组长度达到\",{\"1\":{\"71\":1}}],[\"内存序列模型\",{\"1\":{\"169\":1}}],[\"内存模型\",{\"1\":{\"162\":1}}],[\"内存地址偏移一个数组的位置\",{\"1\":{\"140\":1}}],[\"内存效率\",{\"1\":{\"28\":1}}],[\"内存可能无法提供如此大的连续空间\",{\"1\":{\"21\":1}}],[\"内存空间是所有程序的公共资源\",{\"1\":{\"21\":1}}],[\"内存浪费\",{\"1\":{\"15\":1}}],[\"内容质量很高\",{\"1\":{\"7\":1}}],[\"内容丰富且有条理有深度\",{\"1\":{\"6\":1}}],[\"++count\",{\"1\":{\"181\":3}}],[\"++counter\",{\"1\":{\"162\":1}}],[\"++i\",{\"1\":{\"159\":1,\"161\":1,\"162\":2,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":2,\"172\":2,\"178\":3,\"179\":4,\"180\":2,\"182\":1}}],[\"+1\",{\"1\":{\"140\":1}}],[\"+=\",{\"1\":{\"16\":1,\"36\":2}}],[\"+\",{\"1\":{\"15\":1,\"18\":1,\"35\":2,\"39\":1,\"47\":4,\"57\":1,\"66\":1,\"68\":1,\"102\":2,\"139\":2,\"171\":2,\"172\":4,\"184\":1,\"185\":1,\"188\":1}}],[\"<map>\",{\"1\":{\"189\":1}}],[\"<mutex>\",{\"1\":{\"159\":1,\"161\":1,\"179\":2,\"180\":1}}],[\"<future>\",{\"1\":{\"184\":2,\"185\":1}}],[\"<functional>\",{\"1\":{\"184\":2,\"185\":1}}],[\"<chrono>\",{\"1\":{\"179\":1,\"180\":1}}],[\"<condition\",{\"1\":{\"161\":1}}],[\"<typename\",{\"1\":{\"171\":1,\"172\":1,\"185\":1}}],[\"<thread>\",{\"1\":{\"157\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":1,\"178\":1,\"179\":2,\"180\":1,\"184\":2,\"185\":1}}],[\"<latch>\",{\"1\":{\"166\":1}}],[\"<barrier>\",{\"1\":{\"165\":1}}],[\"<atomic>\",{\"1\":{\"162\":1,\"164\":1,\"171\":1}}],[\"<vector>\",{\"1\":{\"160\":1,\"165\":1,\"166\":1,\"171\":1,\"189\":1}}],[\"<string>\",{\"1\":{\"189\":1}}],[\"<semaphore>\",{\"1\":{\"163\":1}}],[\"<shared\",{\"1\":{\"160\":1}}],[\"<signal\",{\"1\":{\"153\":1}}],[\"<sys\",{\"1\":{\"153\":1}}],[\"<unistd\",{\"1\":{\"153\":1}}],[\"<iostream>\",{\"1\":{\"153\":1,\"157\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":1,\"178\":1,\"179\":2,\"180\":1,\"184\":2,\"185\":1,\"188\":1,\"189\":1,\"195\":1}}],[\"<=\",{\"1\":{\"109\":1}}],[\"<−1\",{\"1\":{\"109\":2}}],[\"<0\",{\"1\":{\"109\":1}}],[\"<<endl\",{\"1\":{\"188\":3,\"189\":6}}],[\"<<\",{\"1\":{\"47\":2,\"62\":8,\"63\":4,\"66\":6,\"68\":8,\"74\":1,\"157\":2,\"159\":3,\"160\":3,\"161\":3,\"162\":3,\"163\":4,\"164\":4,\"165\":8,\"166\":8,\"171\":6,\"172\":6,\"178\":16,\"179\":6,\"180\":3,\"182\":2,\"184\":6,\"185\":2,\"193\":2,\"195\":5}}],[\"<\",{\"1\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"36\":1,\"46\":1,\"47\":1,\"66\":1,\"92\":2,\"94\":2,\"95\":4,\"96\":5,\"97\":2,\"109\":1,\"111\":1,\"112\":1,\"116\":2,\"159\":1,\"161\":1,\"162\":2,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":2,\"172\":2,\"178\":3,\"179\":4,\"180\":2,\"182\":1}}],[\"删除键值对和遍历哈希表等\",{\"1\":{\"77\":1}}],[\"删除标记\",{\"1\":{\"68\":1}}],[\"删除操作中的一步\",{\"1\":{\"116\":1}}],[\"删除操作\",{\"1\":{\"62\":1,\"63\":1,\"66\":1,\"68\":1,\"99\":1}}],[\"删除操作在链表的另一端进行\",{\"1\":{\"30\":1}}],[\"删除栈顶元素的操作叫作\",{\"1\":{\"49\":1}}],[\"删除头节点\",{\"1\":{\"46\":1}}],[\"删除队首元素的操作称为\",{\"1\":{\"43\":1}}],[\"删除和遍历等操作\",{\"1\":{\"31\":1}}],[\"删除链表的节点\",{\"1\":{\"25\":1}}],[\"删除节点操作要分三种情况处理\",{\"1\":{\"116\":1}}],[\"删除节点操作同样使用\",{\"1\":{\"96\":1}}],[\"删除节点\",{\"0\":{\"25\":1,\"96\":1,\"112\":1},\"1\":{\"39\":1,\"86\":1,\"96\":2}}],[\"删除索引\",{\"1\":{\"15\":1,\"35\":1}}],[\"删除元素完成后\",{\"1\":{\"15\":1}}],[\"删除元素\",{\"0\":{\"15\":1},\"1\":{\"28\":1,\"35\":1,\"61\":2,\"66\":1,\"98\":1}}],[\"了\",{\"1\":{\"15\":1,\"39\":1,\"76\":1}}],[\"无锁编程主要依赖于原子操作和内存序列模型\",{\"1\":{\"168\":1}}],[\"无锁编程\",{\"0\":{\"168\":1},\"1\":{\"168\":1}}],[\"无法多个进程\",{\"1\":{\"167\":1}}],[\"无法通过哈希值反推出关于输入数据的任何信息\",{\"1\":{\"73\":1}}],[\"无需锁定\",{\"1\":{\"162\":1}}],[\"无序数组\",{\"1\":{\"98\":1}}],[\"无返回值\",{\"1\":{\"50\":1}}],[\"无须旋转\",{\"1\":{\"109\":1}}],[\"无须进行额外的排序操作\",{\"1\":{\"97\":1}}],[\"无须使用者考虑容量限制的问题\",{\"1\":{\"31\":1}}],[\"无须额外的结构开销\",{\"1\":{\"19\":1}}],[\"无意义\",{\"1\":{\"15\":2}}],[\"无初始值\",{\"1\":{\"12\":1,\"33\":2}}],[\"请注意\",{\"1\":{\"15\":1,\"25\":1,\"70\":1,\"73\":1,\"76\":1,\"83\":1,\"88\":1,\"89\":1}}],[\"处理\",{\"1\":{\"153\":1}}],[\"处插入数字\",{\"1\":{\"35\":1}}],[\"处插入元素\",{\"1\":{\"14\":1}}],[\"处的元素更新为\",{\"1\":{\"34\":1}}],[\"处的元素\",{\"1\":{\"14\":1,\"15\":2,\"34\":1,\"35\":1}}],[\"赋给\",{\"1\":{\"14\":1}}],[\"将函数和future绑定起来\",{\"1\":{\"184\":1}}],[\"将数据和future绑定起来\",{\"1\":{\"184\":1}}],[\"将数组转化为\",{\"1\":{\"47\":1}}],[\"将头部指针所指向的元素存储到\",{\"1\":{\"172\":1}}],[\"将头节点作为栈顶\",{\"1\":{\"52\":1}}],[\"将新的尾部指针存储到\",{\"1\":{\"172\":1}}],[\"将元素存储在当前尾部指针所指向的位置\",{\"1\":{\"172\":1}}],[\"将元素插入其中\",{\"1\":{\"68\":1}}],[\"将线程和线程对象分离\",{\"1\":{\"157\":1,\"178\":1}}],[\"将子进程的父进程设置为\",{\"1\":{\"153\":1}}],[\"将重载函数重新命名成唯一的标识符\",{\"1\":{\"142\":1}}],[\"将其隔离到相同的模块\",{\"1\":{\"124\":1}}],[\"将调用模块与实现模块进行隔离\",{\"1\":{\"124\":1}}],[\"将该节点记为\",{\"1\":{\"105\":1}}],[\"将该节点置于\",{\"1\":{\"95\":1}}],[\"将待删除节点替换为其子节点即可\",{\"1\":{\"96\":1}}],[\"将所有的\",{\"1\":{\"106\":1}}],[\"将所有冲突元素存储在同一个链表中\",{\"1\":{\"77\":1}}],[\"将所有发生冲突的键值对都存储在同一链表中\",{\"1\":{\"66\":1}}],[\"将每个字符的\",{\"1\":{\"74\":1}}],[\"将输入数据的每个元素通过异或操作累积到一个哈希值中\",{\"1\":{\"74\":1}}],[\"将输入元素赋值给\",{\"1\":{\"47\":1}}],[\"将各个字符的\",{\"1\":{\"74\":1}}],[\"将得到的总和作为哈希值\",{\"1\":{\"74\":1}}],[\"将键值对从原哈希表搬运至新哈希表\",{\"1\":{\"66\":1,\"68\":1}}],[\"将键值对作为链表节点\",{\"1\":{\"66\":1}}],[\"将单个元素转换为链表\",{\"1\":{\"66\":1}}],[\"将哈希值对桶数量\",{\"1\":{\"63\":1}}],[\"将这个操作压入栈\",{\"1\":{\"57\":1}}],[\"将把元素添加到栈顶的操作叫作\",{\"1\":{\"49\":1}}],[\"将把元素加入队尾的操作称为\",{\"1\":{\"43\":1}}],[\"将链表转化为\",{\"1\":{\"46\":1}}],[\"将索引\",{\"1\":{\"34\":1}}],[\"将切换到下一个进程\",{\"1\":{\"30\":1}}],[\"将最后一个节点称为尾节点\",{\"1\":{\"29\":1}}],[\"将原数组中的所有元素复制到新数组\",{\"1\":{\"18\":1}}],[\"将\",{\"1\":{\"14\":1,\"47\":1,\"52\":1,\"105\":2,\"106\":2}}],[\">void\",{\"1\":{\"194\":1}}],[\">value\",{\"1\":{\"62\":2}}],[\">val\",{\"1\":{\"27\":1,\"46\":2,\"52\":2,\"63\":4,\"66\":4,\"68\":4,\"94\":2,\"95\":3,\"96\":5,\"111\":2,\"112\":5}}],[\">0\",{\"1\":{\"109\":1}}],[\">1\",{\"1\":{\"104\":1,\"109\":2}}],[\">height\",{\"1\":{\"102\":1}}],[\">right\",{\"1\":{\"85\":2,\"94\":1,\"95\":2,\"96\":5,\"102\":1,\"103\":1,\"105\":2,\"106\":2,\"109\":3,\"111\":2,\"112\":7}}],[\">left\",{\"1\":{\"85\":2,\"86\":3,\"94\":1,\"95\":2,\"96\":8,\"102\":1,\"103\":1,\"105\":2,\"106\":2,\"109\":3,\"111\":2,\"112\":7}}],[\">>\",{\"1\":{\"66\":2,\"74\":1}}],[\">key\",{\"1\":{\"63\":3,\"66\":5,\"68\":3}}],[\">second\",{\"1\":{\"62\":1}}],[\">first\",{\"1\":{\"62\":1}}],[\">=\",{\"1\":{\"52\":1,\"109\":1}}],[\">next\",{\"1\":{\"23\":4,\"24\":3,\"25\":4,\"26\":1,\"27\":1,\"46\":3,\"52\":3}}],[\">\",{\"1\":{\"14\":1,\"23\":4,\"25\":2,\"62\":2,\"63\":5,\"66\":2,\"68\":5,\"86\":1,\"94\":2,\"109\":1,\"111\":1,\"112\":1,\"153\":2,\"183\":2,\"184\":1}}],[\"implicit\",{\"1\":{\"195\":1}}],[\"item\",{\"1\":{\"171\":7,\"172\":11}}],[\"iter++\",{\"1\":{\"62\":1}}],[\"iter\",{\"1\":{\"62\":4}}],[\"is\",{\"1\":{\"163\":1,\"164\":1,\"165\":2,\"166\":1,\"189\":11}}],[\"isp\",{\"1\":{\"123\":1}}],[\"isempty\",{\"1\":{\"46\":1,\"47\":2,\"52\":2,\"53\":2}}],[\"id\",{\"1\":{\"39\":2,\"159\":4,\"161\":4,\"163\":2,\"164\":2,\"165\":3,\"166\":3,\"178\":1}}],[\"i−1\",{\"1\":{\"26\":1}}],[\"if\",{\"1\":{\"17\":1,\"25\":1,\"26\":1,\"27\":1,\"46\":2,\"47\":2,\"52\":1,\"53\":1,\"63\":4,\"66\":4,\"68\":11,\"94\":2,\"95\":4,\"96\":7,\"103\":1,\"109\":4,\"111\":3,\"112\":5,\"153\":5,\"171\":2,\"172\":4,\"178\":4,\"183\":2}}],[\"i++\",{\"1\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"36\":1,\"46\":1,\"47\":1,\"66\":1}}],[\"i\",{\"1\":{\"14\":5,\"15\":6,\"16\":3,\"17\":4,\"18\":4,\"26\":3,\"36\":3,\"46\":3,\"47\":3,\"52\":4,\"66\":5,\"91\":1,\"148\":1,\"149\":2,\"159\":4,\"161\":4,\"162\":5,\"163\":4,\"164\":4,\"165\":3,\"166\":3,\"171\":6,\"172\":7,\"178\":9,\"179\":12,\"180\":6,\"182\":3,\"193\":2}}],[\"inline\",{\"1\":{\"185\":1}}],[\"in\",{\"1\":{\"184\":2,\"185\":2}}],[\"increment\",{\"1\":{\"162\":2}}],[\"include\",{\"1\":{\"153\":4,\"157\":2,\"159\":3,\"160\":4,\"161\":4,\"162\":3,\"163\":3,\"164\":3,\"165\":4,\"166\":4,\"171\":4,\"178\":2,\"179\":7,\"180\":4,\"184\":8,\"185\":4,\"188\":1,\"189\":4,\"195\":1}}],[\"init\",{\"1\":{\"153\":7,\"164\":1}}],[\"information\",{\"1\":{\"100\":1}}],[\"inserthelper\",{\"1\":{\"111\":3}}],[\"insert\",{\"1\":{\"14\":1,\"24\":1,\"35\":1,\"95\":1,\"189\":3}}],[\"int\",{\"0\":{\"140\":1},\"1\":{\"12\":6,\"13\":5,\"14\":5,\"15\":4,\"16\":4,\"17\":5,\"18\":7,\"21\":2,\"26\":2,\"27\":3,\"29\":2,\"34\":1,\"36\":3,\"39\":3,\"44\":2,\"46\":7,\"47\":14,\"50\":2,\"52\":7,\"53\":5,\"54\":1,\"63\":11,\"66\":12,\"68\":15,\"74\":4,\"76\":1,\"82\":2,\"94\":1,\"95\":1,\"96\":2,\"102\":3,\"103\":1,\"109\":1,\"111\":1,\"112\":2,\"140\":2,\"142\":1,\"153\":2,\"157\":2,\"159\":3,\"160\":2,\"161\":3,\"162\":3,\"163\":3,\"164\":3,\"165\":3,\"166\":3,\"171\":4,\"172\":4,\"178\":6,\"179\":8,\"180\":4,\"181\":3,\"182\":2,\"184\":6,\"185\":3,\"188\":1,\"189\":4,\"191\":2,\"192\":3,\"193\":1,\"194\":1,\"195\":4}}],[\"index++\",{\"1\":{\"27\":1}}],[\"index\",{\"1\":{\"10\":1,\"14\":6,\"15\":4,\"26\":3,\"27\":2,\"63\":12,\"66\":7,\"68\":25,\"72\":1}}],[\"把索引\",{\"1\":{\"14\":1,\"15\":1}}],[\"列表中存储的不是数字本身\",{\"1\":{\"39\":1}}],[\"列表都会设定一个初始长度\",{\"1\":{\"39\":1}}],[\"列表的出现极大地提高了数组的实用性\",{\"1\":{\"39\":1}}],[\"列表的出现大幅提高了数组的实用性\",{\"1\":{\"38\":1}}],[\"列表是一种支持增删查改的元素有序集合\",{\"1\":{\"38\":1}}],[\"列表实现\",{\"0\":{\"37\":1}}],[\"列表可以根据索引遍历\",{\"1\":{\"36\":1}}],[\"列表可以自由地添加与删除元素\",{\"1\":{\"35\":1}}],[\"列表可以基于链表或数组实现\",{\"1\":{\"31\":1}}],[\"列表本质上是数组\",{\"1\":{\"34\":1}}],[\"列表常用操作\",{\"0\":{\"32\":1}}],[\"列表\",{\"0\":{\"31\":1},\"1\":{\"14\":1,\"31\":2}}],[\"丢失的末尾元素都是\",{\"1\":{\"15\":1}}],[\"丢失元素\",{\"1\":{\"15\":1}}],[\"丢失\",{\"1\":{\"14\":1}}],[\"如互斥锁\",{\"1\":{\"168\":1}}],[\"如计数器\",{\"1\":{\"162\":1}}],[\"如内存\",{\"1\":{\"151\":1}}],[\"如等待信号\",{\"1\":{\"149\":1}}],[\"如void\",{\"1\":{\"142\":1}}],[\"如\",{\"1\":{\"123\":1,\"148\":1,\"149\":1,\"151\":1,\"162\":1,\"164\":1,\"169\":1,\"173\":3}}],[\"如观察者模式\",{\"1\":{\"122\":1}}],[\"如适装饰器模式\",{\"1\":{\"122\":1}}],[\"如单例模式\",{\"1\":{\"122\":1}}],[\"如何创建线程\",{\"0\":{\"157\":1}}],[\"如何避免产生僵尸进程\",{\"0\":{\"153\":1}}],[\"如何从一组输入数据构建一棵二叉搜索树\",{\"1\":{\"116\":1}}],[\"如何基于\",{\"1\":{\"63\":1}}],[\"如下\",{\"1\":{\"180\":1}}],[\"如下表所示\",{\"1\":{\"91\":1,\"109\":1}}],[\"如下图所示\",{\"1\":{\"14\":1,\"15\":1,\"24\":1,\"25\":1,\"29\":1,\"43\":1,\"46\":1,\"49\":1,\"52\":1,\"53\":1,\"61\":1,\"64\":2,\"68\":1,\"72\":1,\"82\":1,\"88\":1,\"89\":1,\"90\":1,\"92\":1,\"94\":1,\"96\":2,\"97\":1,\"100\":1,\"105\":2,\"106\":1,\"108\":1}}],[\"如整数\",{\"1\":{\"49\":1}}],[\"如上一节所述\",{\"1\":{\"26\":1}}],[\"如以下代码所示\",{\"1\":{\"21\":1}}],[\"如果希望多个智能指针管理同一个资源\",{\"1\":{\"187\":1}}],[\"如果希望只有一个智能指针管理资源或者管理数组\",{\"1\":{\"187\":1}}],[\"如果需要复制放到容器中可以使用std\",{\"1\":{\"184\":1}}],[\"如果\",{\"1\":{\"172\":2}}],[\"如果是\",{\"1\":{\"169\":1}}],[\"如果是先查找元素\",{\"1\":{\"39\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"164\":1}}],[\"如果计数器值为零或负\",{\"1\":{\"163\":1}}],[\"如果计数器值为正\",{\"1\":{\"163\":1}}],[\"如果条件不满足\",{\"1\":{\"161\":1}}],[\"如果条件满足\",{\"1\":{\"161\":1}}],[\"如果读计数器为0且有写线程在等待\",{\"1\":{\"160\":1}}],[\"如果有线程在等待队列中\",{\"1\":{\"163\":1}}],[\"如果有写线程在等待\",{\"1\":{\"160\":1}}],[\"如果有写锁存在\",{\"1\":{\"160\":1}}],[\"如果有读线程在等待\",{\"1\":{\"160\":1}}],[\"如果有读锁或写锁存在\",{\"1\":{\"160\":1}}],[\"如果有大量僵尸进程存在\",{\"1\":{\"152\":1}}],[\"如果没有读锁和写锁存在\",{\"1\":{\"160\":1}}],[\"如果没有写锁存在\",{\"1\":{\"160\":1}}],[\"如果没有线程在等待\",{\"1\":{\"159\":1}}],[\"如果没有调用join或者detach函数\",{\"1\":{\"178\":1}}],[\"如果没有调用\",{\"1\":{\"157\":1}}],[\"如果等待队列中有其他线程\",{\"1\":{\"159\":1}}],[\"如果互斥量已锁定\",{\"1\":{\"159\":1}}],[\"如果互斥量未锁定\",{\"1\":{\"159\":1}}],[\"如果线程已经和对象分离\",{\"1\":{\"157\":1,\"178\":1}}],[\"如果不明确指定创建策略\",{\"1\":{\"185\":1}}],[\"如果不希望线程被阻塞执行\",{\"1\":{\"157\":1,\"178\":1}}],[\"如果不断开\",{\"1\":{\"39\":1}}],[\"如果父进程在子进程结束前退出\",{\"1\":{\"153\":1}}],[\"如果运行中的进程的时间片耗尽\",{\"1\":{\"149\":1}}],[\"如果要对比值\",{\"1\":{\"116\":1}}],[\"如果要同时支持后退和前进\",{\"1\":{\"55\":1}}],[\"如果方法只在类内部使用\",{\"1\":{\"116\":1}}],[\"如果考虑上述失衡二叉树的\",{\"1\":{\"106\":1}}],[\"如果将\",{\"1\":{\"82\":1}}],[\"如果一个功能能够在相同的时间复杂度下使用数组或链表实现\",{\"1\":{\"78\":1}}],[\"如果能够保证\",{\"1\":{\"74\":1}}],[\"如果输入\",{\"1\":{\"74\":1}}],[\"如果两者匹配\",{\"1\":{\"73\":2}}],[\"如果哈希冲突过于频繁\",{\"1\":{\"72\":1}}],[\"如果遇到空桶\",{\"1\":{\"68\":1}}],[\"如果后续仍需要使用弹出节点\",{\"1\":{\"57\":1}}],[\"如果入栈元素本身就是节点对象\",{\"1\":{\"54\":1}}],[\"如果入栈时超出数组容量\",{\"1\":{\"54\":1}}],[\"如果想取出底部的盘子\",{\"1\":{\"49\":1}}],[\"如果想在数组中间插入一个元素\",{\"1\":{\"14\":1}}],[\"如果队列已满\",{\"1\":{\"171\":1,\"172\":2}}],[\"如果队列不为空\",{\"1\":{\"46\":1}}],[\"如果队列为空\",{\"1\":{\"46\":1,\"171\":1,\"172\":2}}],[\"如果添加元素时超出列表长度\",{\"1\":{\"39\":1}}],[\"如果我们在二叉搜索树中不断地插入和删除节点\",{\"1\":{\"98\":1}}],[\"如果我们令单向链表的尾节点指向头节点\",{\"1\":{\"29\":1}}],[\"如果我们想随机抽取一些样本\",{\"1\":{\"20\":1}}],[\"如果我们希望扩容数组\",{\"1\":{\"18\":1}}],[\"如果数组分配的大小超过实际所需\",{\"1\":{\"19\":1}}],[\"如果c++98的朋友想进阶到c++11\",{\"1\":{\"7\":1}}],[\"它是一个基于任务的程序设计\",{\"1\":{\"185\":1}}],[\"它是基于任务的异步操作\",{\"1\":{\"185\":1}}],[\"它可以阻塞一个线程或者个线程\",{\"1\":{\"183\":1}}],[\"它可以被\",{\"1\":{\"74\":1}}],[\"它需要配合std\",{\"1\":{\"182\":1}}],[\"它需要对一组进程进行循环\",{\"1\":{\"30\":1}}],[\"它支持以下操作\",{\"1\":{\"170\":1}}],[\"它检查一个变量是否有特定的值\",{\"1\":{\"169\":1}}],[\"它定义了一系列算法\",{\"1\":{\"130\":1}}],[\"它只是插入\",{\"1\":{\"116\":1}}],[\"它通过旋转操作确保在不断插入和删除节点后树仍然保持平衡\",{\"1\":{\"115\":1}}],[\"它通过建立键\",{\"1\":{\"61\":1}}],[\"它体现了\",{\"1\":{\"115\":1}}],[\"它能够在不影响二叉树的中序遍历序列的前提下\",{\"1\":{\"104\":1}}],[\"它不直接从哈希表中移除元素\",{\"1\":{\"68\":1}}],[\"它相比数组更加耗费内存空间\",{\"1\":{\"66\":1}}],[\"它的所有资源\",{\"1\":{\"151\":1}}],[\"它的哈希值也随之改变\",{\"1\":{\"76\":1}}],[\"它的用途是什么\",{\"1\":{\"57\":1}}],[\"它的前身c++之父的很多心得经验的博客\",{\"1\":{\"7\":1}}],[\"它允许在两端进行元素的添加和删除操作\",{\"1\":{\"56\":1}}],[\"它保留了数组的优势\",{\"1\":{\"38\":1}}],[\"它继承了数组的各项优点\",{\"1\":{\"31\":1}}],[\"它表现的是栈\",{\"1\":{\"57\":1}}],[\"它表现的特性为先进先出\",{\"1\":{\"30\":1}}],[\"它表现的特性为先进后出\",{\"1\":{\"30\":1}}],[\"它表示元素的有序集合\",{\"1\":{\"31\":1}}],[\"它在\",{\"1\":{\"21\":1}}],[\"它们内部都有一个future\",{\"1\":{\"184\":1}}],[\"它们分为三大类\",{\"1\":{\"122\":1}}],[\"它们分别解决的两种失衡情况也是对称的\",{\"1\":{\"106\":1}}],[\"它们指向同一个对象\",{\"1\":{\"116\":1}}],[\"它们体现了\",{\"1\":{\"115\":1}}],[\"它们可以将任意长度的输入数据映射到恒定长度的哈希值\",{\"1\":{\"75\":1}}],[\"它们都能输出均匀分布的哈希值\",{\"1\":{\"74\":1}}],[\"它们只能保证哈希表可以在发生冲突时正常工作\",{\"1\":{\"72\":1}}],[\"它们被依次存储在该桶以及之下的桶中\",{\"1\":{\"68\":1}}],[\"它们的效率对比如下表所示\",{\"1\":{\"61\":1}}],[\"它们的实现比较复杂\",{\"1\":{\"37\":1}}],[\"它们的内存地址无须连续\",{\"1\":{\"21\":1}}],[\"它们之间没有空间再存放任何数据\",{\"1\":{\"14\":1}}],[\"紧挨着的\",{\"1\":{\"14\":1}}],[\"r\",{\"1\":{\"195\":4}}],[\"rw\",{\"1\":{\"160\":3}}],[\"running\",{\"1\":{\"148\":1}}],[\"rust\",{\"1\":{\"21\":1}}],[\"raii\",{\"1\":{\"139\":1}}],[\"range\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1}}],[\"rand\",{\"1\":{\"13\":1}}],[\"randomnum\",{\"1\":{\"13\":2}}],[\"randomindex\",{\"1\":{\"13\":2}}],[\"randomaccess\",{\"1\":{\"13\":1}}],[\"rotate\",{\"1\":{\"105\":3,\"109\":1,\"111\":1,\"112\":1,\"116\":1}}],[\"rothash\",{\"1\":{\"74\":1}}],[\"root\",{\"1\":{\"83\":1,\"93\":1,\"94\":2,\"95\":3,\"96\":4,\"116\":1,\"188\":6,\"189\":1}}],[\"rightrotate\",{\"1\":{\"105\":1,\"109\":3}}],[\"right\",{\"1\":{\"82\":4,\"94\":1,\"102\":1,\"105\":3,\"106\":2,\"116\":1}}],[\"red\",{\"1\":{\"195\":3}}],[\"redo\",{\"1\":{\"57\":1}}],[\"reference\",{\"1\":{\"193\":1}}],[\"ref\",{\"1\":{\"184\":1}}],[\"recursive\",{\"1\":{\"179\":2}}],[\"relaxed\",{\"1\":{\"169\":1,\"171\":2,\"172\":5,\"173\":2}}],[\"release\",{\"1\":{\"163\":2,\"164\":1,\"169\":1,\"171\":3,\"172\":6,\"173\":3}}],[\"reallyasync\",{\"1\":{\"185\":1}}],[\"reached\",{\"1\":{\"166\":1}}],[\"reader\",{\"1\":{\"160\":3}}],[\"read\",{\"1\":{\"160\":1}}],[\"ready\",{\"1\":{\"148\":1,\"161\":6}}],[\"rear\",{\"1\":{\"46\":6,\"47\":9}}],[\"result\",{\"1\":{\"184\":1}}],[\"resize\",{\"1\":{\"66\":2}}],[\"res\",{\"1\":{\"18\":3,\"39\":3,\"46\":4,\"52\":4,\"185\":3}}],[\"removehelper\",{\"1\":{\"112\":4}}],[\"remove\",{\"1\":{\"15\":1,\"25\":1,\"63\":1,\"66\":1,\"68\":1,\"96\":5}}],[\"return\",{\"1\":{\"13\":1,\"17\":2,\"18\":1,\"25\":1,\"26\":2,\"27\":2,\"46\":5,\"47\":7,\"52\":5,\"53\":5,\"63\":6,\"66\":6,\"68\":8,\"74\":1,\"94\":1,\"95\":2,\"96\":2,\"103\":2,\"105\":1,\"106\":1,\"109\":5,\"111\":3,\"112\":3,\"116\":1,\"153\":1,\"157\":1,\"159\":1,\"160\":1,\"161\":2,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"171\":5,\"172\":5,\"178\":3,\"179\":2,\"180\":1,\"181\":2,\"182\":1,\"183\":1,\"184\":3,\"185\":3,\"188\":2,\"189\":1}}],[\"ok\",{\"1\":{\"191\":3,\"192\":3,\"195\":1}}],[\"optimizer\",{\"1\":{\"189\":1}}],[\"operator=\",{\"1\":{\"178\":1}}],[\"open\",{\"1\":{\"67\":1}}],[\"other\",{\"1\":{\"189\":3}}],[\"once保证函数在多线程环境下只调用一次\",{\"1\":{\"185\":1}}],[\"onceflag\",{\"1\":{\"182\":2}}],[\"once\",{\"1\":{\"182\":4}}],[\"once来保证某一函数在多线程环境中只调用一次\",{\"1\":{\"182\":1}}],[\"once相关\",{\"0\":{\"182\":1},\"1\":{\"177\":1}}],[\"one\",{\"1\":{\"161\":1,\"191\":1}}],[\"ocp\",{\"1\":{\"123\":1}}],[\"origincounter\",{\"1\":{\"181\":1}}],[\"order\",{\"1\":{\"164\":2,\"169\":3,\"171\":7,\"172\":15,\"173\":6}}],[\"organization\",{\"1\":{\"100\":1}}],[\"or\",{\"1\":{\"96\":1}}],[\"of\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"100\":1}}],[\"out\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"188\":3,\"189\":1}}],[\"object\",{\"1\":{\"39\":1}}],[\"o\",{\"1\":{\"13\":1,\"15\":1,\"18\":1,\"19\":1,\"24\":2,\"26\":2,\"28\":6,\"34\":1,\"35\":2,\"39\":9,\"44\":3,\"47\":2,\"50\":3,\"53\":1,\"54\":1,\"56\":1,\"61\":14,\"66\":2,\"72\":1,\"77\":1,\"78\":6,\"91\":1,\"94\":1,\"95\":1,\"96\":3,\"97\":1,\"98\":7,\"100\":3,\"115\":2,\"148\":1,\"149\":2}}],[\"在没有返回值优化的情况下\",{\"1\":{\"188\":1}}],[\"在实际开发中\",{\"1\":{\"153\":1}}],[\"在实际中\",{\"1\":{\"75\":1}}],[\"在系统中\",{\"1\":{\"152\":1}}],[\"在预编译时期会被完整替换\",{\"1\":{\"141\":1}}],[\"在申请\",{\"1\":{\"139\":1}}],[\"在class中用于声明类成员或函数\",{\"1\":{\"138\":1}}],[\"在使用策略模式时\",{\"1\":{\"132\":1}}],[\"在插入或删除节点后\",{\"1\":{\"115\":1}}],[\"在需要频繁进行增删查改操作的场景中\",{\"1\":{\"100\":1}}],[\"在论文\",{\"1\":{\"100\":1}}],[\"在下图所示的完美二叉树中插入两个节点后\",{\"1\":{\"100\":1}}],[\"在多次插入和删除操作后\",{\"1\":{\"100\":1}}],[\"在理想情况下\",{\"1\":{\"98\":1}}],[\"在代码实现中\",{\"1\":{\"95\":1}}],[\"在二叉搜索树的删除节点方法的基础上\",{\"1\":{\"112\":1}}],[\"在二叉搜索树中删除节点\",{\"1\":{\"96\":3}}],[\"在二叉搜索树中插入节点\",{\"1\":{\"95\":1}}],[\"在二叉树中插入与删除节点\",{\"1\":{\"86\":1}}],[\"在二叉树中插入与删除节点可以通过修改指针来实现\",{\"1\":{\"86\":1}}],[\"在二叉树中\",{\"1\":{\"82\":1,\"83\":1,\"86\":1}}],[\"在最佳结构和最差结构下\",{\"1\":{\"91\":1}}],[\"在中文社区中\",{\"1\":{\"88\":1}}],[\"在中间插入元素\",{\"1\":{\"35\":1}}],[\"在完美二叉树中\",{\"1\":{\"88\":1}}],[\"在这种情况下\",{\"1\":{\"83\":1,\"100\":1}}],[\"在这种设定下\",{\"1\":{\"66\":1}}],[\"在扩容后可能会被分配到多个桶中\",{\"1\":{\"78\":1}}],[\"在扩容后\",{\"1\":{\"78\":1}}],[\"在密码学中\",{\"1\":{\"77\":1}}],[\"在许多编程语言中\",{\"1\":{\"76\":1}}],[\"在随机输入\",{\"1\":{\"73\":1}}],[\"在相同的哈希函数顺序下进行查找\",{\"1\":{\"70\":1}}],[\"在该位置插入节点\",{\"1\":{\"95\":1}}],[\"在该机制下\",{\"1\":{\"68\":1}}],[\"在该方案中\",{\"1\":{\"30\":1}}],[\"在开放寻址中删除元素导致的查询问题\",{\"1\":{\"68\":1}}],[\"在原始哈希表中\",{\"1\":{\"66\":1}}],[\"在哈希表中访问对应的桶\",{\"1\":{\"63\":1}}],[\"在哈希表中\",{\"1\":{\"63\":2,\"77\":1}}],[\"在哈希表中删除键值对\",{\"1\":{\"62\":1}}],[\"在哈希表中添加键值对\",{\"1\":{\"62\":1}}],[\"在哈希表中进行增删查改的时间复杂度都是\",{\"1\":{\"61\":1}}],[\"在出栈后\",{\"1\":{\"57\":1}}],[\"在时间效率和空间效率的对比上\",{\"1\":{\"56\":1}}],[\"在时间效率方面\",{\"1\":{\"56\":1}}],[\"在空间效率方面\",{\"1\":{\"56\":1}}],[\"在递归函数中\",{\"1\":{\"55\":1}}],[\"在初始化列表时\",{\"1\":{\"54\":1}}],[\"在基于链表的实现中\",{\"1\":{\"54\":1}}],[\"在基于数组的实现中\",{\"1\":{\"54\":1}}],[\"在此处执行需要守护的任务\",{\"1\":{\"153\":1}}],[\"在此\",{\"1\":{\"50\":1}}],[\"在此不再赘述\",{\"1\":{\"47\":1,\"113\":1}}],[\"在双十一期间\",{\"1\":{\"48\":1}}],[\"在越过数组尾部时\",{\"1\":{\"47\":1}}],[\"在不断进行入队和出队的过程中\",{\"1\":{\"47\":1}}],[\"在尾节点后添加\",{\"1\":{\"46\":1}}],[\"在尾部添加元素\",{\"1\":{\"35\":1}}],[\"在列表末尾添加元素是否时时刻刻都为\",{\"1\":{\"39\":1}}],[\"在列表尾部添加元素的时间复杂度为\",{\"1\":{\"35\":1}}],[\"在选择数据结构时\",{\"1\":{\"38\":1}}],[\"在本示例中\",{\"1\":{\"37\":2}}],[\"在索引\",{\"1\":{\"35\":1}}],[\"在接下来的讨论中\",{\"1\":{\"31\":1}}],[\"在某些数据缓冲区的实现中\",{\"1\":{\"30\":1}}],[\"在操作系统中\",{\"1\":{\"30\":1}}],[\"在缓存淘汰\",{\"1\":{\"30\":1}}],[\"在网页浏览器中\",{\"1\":{\"30\":1}}],[\"在环形链表中\",{\"1\":{\"29\":1}}],[\"在链表中插入和删除操作的时间复杂度是\",{\"1\":{\"39\":1}}],[\"在链表中插入节点非常容易\",{\"1\":{\"24\":1}}],[\"在链表中查找值为\",{\"1\":{\"27\":1}}],[\"在链表中访问节点的效率较低\",{\"1\":{\"26\":1}}],[\"在链表中删除节点也非常方便\",{\"1\":{\"25\":1}}],[\"在链表的节点\",{\"1\":{\"24\":1}}],[\"在大数据量下的效率较低\",{\"1\":{\"24\":1}}],[\"在大多数编程语言中\",{\"1\":{\"16\":1}}],[\"在\",{\"1\":{\"21\":1,\"39\":1,\"57\":1,\"76\":1,\"78\":1,\"86\":1,\"100\":1,\"111\":1,\"116\":3,\"172\":1}}],[\"在一个复杂的系统运行环境下\",{\"1\":{\"21\":1}}],[\"在复杂的系统环境中\",{\"1\":{\"18\":1}}],[\"在数组很大的情况下非常耗时\",{\"1\":{\"18\":1}}],[\"在数组中删除首元素的时间复杂度为\",{\"1\":{\"47\":1}}],[\"在数组中插入元素的时间复杂度为\",{\"1\":{\"24\":1}}],[\"在数组中查找指定元素\",{\"1\":{\"17\":1}}],[\"在数组中查找指定元素需要遍历数组\",{\"1\":{\"17\":1}}],[\"在数组中访问元素非常高效\",{\"1\":{\"13\":1}}],[\"在数组的索引\",{\"1\":{\"14\":1}}],[\"在区间\",{\"1\":{\"13\":1}}],[\"在未指定初始值的情况下\",{\"1\":{\"12\":1}}],[\"是\",{\"1\":{\"187\":1}}],[\"是因为我们不需要同步其他内存操作\",{\"1\":{\"172\":1}}],[\"是在\",{\"1\":{\"151\":1}}],[\"是内存地址偏移一个元素的位置\",{\"1\":{\"140\":1}}],[\"是c++\",{\"1\":{\"139\":1}}],[\"是c语言标准库提供的一组用于动态申请释放内存的api\",{\"1\":{\"139\":1}}],[\"是访问节点高度\",{\"1\":{\"116\":1}}],[\"是没有意义的\",{\"1\":{\"116\":1}}],[\"是的\",{\"1\":{\"116\":3}}],[\"是指从该节点到它的最远叶节点的距离\",{\"1\":{\"102\":1}}],[\"是最安全的哈希算法之一\",{\"1\":{\"75\":1}}],[\"是随机均匀分布的\",{\"1\":{\"74\":1}}],[\"是两个独立的概念\",{\"1\":{\"73\":1}}],[\"是哈希表的一个重要概念\",{\"1\":{\"64\":1}}],[\"是乱序的\",{\"1\":{\"61\":1}}],[\"是否需要释放出栈节点的内存\",{\"1\":{\"57\":1}}],[\"是否需要把\",{\"1\":{\"39\":1}}],[\"是不是因为有什么局限性呢\",{\"1\":{\"39\":1}}],[\"是一种在多线程环境中实现并发访问的技术\",{\"1\":{\"168\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"130\":1}}],[\"是一种形象化的说法\",{\"1\":{\"105\":1}}],[\"是一种非线性数据结构\",{\"1\":{\"82\":1}}],[\"是一种遵循先入后出逻辑的线性数据结构\",{\"1\":{\"49\":1}}],[\"是一种遵循先入先出规则的线性数据结构\",{\"1\":{\"43\":1}}],[\"是一种线性数据结构\",{\"1\":{\"10\":1,\"21\":1}}],[\"是一个抽象的数据结构概念\",{\"1\":{\"31\":1}}],[\"是合理的\",{\"1\":{\"13\":1}}],[\"因请求资源阻塞时\",{\"1\":{\"167\":1}}],[\"因为不是本文的主题\",{\"1\":{\"183\":1}}],[\"因为条件变量在wait时需要有手动释放锁的能力\",{\"1\":{\"180\":1}}],[\"因为高度和深度通常定义为\",{\"1\":{\"116\":1}}],[\"因为质数不与其他数字存在公约数\",{\"1\":{\"74\":1}}],[\"因为线性探测可能需要跳过多个\",{\"1\":{\"68\":1}}],[\"因为其之下可能还存在键值对\",{\"1\":{\"68\":1}}],[\"因为需要线性遍历链表来查找对应元素\",{\"1\":{\"66\":1}}],[\"因为哈希表扩容需要进行大量的数据搬运与哈希值计算\",{\"1\":{\"65\":1}}],[\"因为数组中包含了两种\",{\"1\":{\"39\":1}}],[\"因为数组是线性数据结构\",{\"1\":{\"17\":1}}],[\"因为从\",{\"1\":{\"13\":1}}],[\"因此也可以用\",{\"1\":{\"116\":1}}],[\"因此设置成\",{\"1\":{\"116\":1}}],[\"因此是一种平衡二叉搜索树\",{\"1\":{\"101\":1}}],[\"因此这个节点可以是右子树的最小节点或左子树的最大节点\",{\"1\":{\"96\":1}}],[\"因此执行\",{\"1\":{\"94\":2}}],[\"因此哈希函数的最后一步往往是对数组长度取模\",{\"1\":{\"78\":1}}],[\"因此常用在各类安全应用与协议中\",{\"1\":{\"75\":1}}],[\"因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串\",{\"1\":{\"75\":1}}],[\"因此输出的哈希值的均匀性会明显提升\",{\"1\":{\"74\":1}}],[\"因此理论上哈希冲突是不可避免的\",{\"1\":{\"65\":1}}],[\"因此需要遍历其中的所有元素\",{\"1\":{\"61\":1}}],[\"因此可以通过扩容哈希表来缓解哈希冲突\",{\"1\":{\"77\":1}}],[\"因此可以实现栈与队列的所有应用\",{\"1\":{\"57\":1}}],[\"因此可以在\",{\"1\":{\"34\":1}}],[\"因此不需要手动释放内存\",{\"1\":{\"57\":1}}],[\"因此链表节点占用的空间相对较大\",{\"1\":{\"54\":1}}],[\"因此平均效率更高\",{\"1\":{\"54\":1}}],[\"因此效率相对较低\",{\"1\":{\"54\":1}}],[\"因此效率较高\",{\"1\":{\"54\":1}}],[\"因此一般不会用到\",{\"1\":{\"54\":1}}],[\"因此我们只要按照\",{\"1\":{\"116\":1}}],[\"因此我们只能在栈顶添加或删除元素\",{\"1\":{\"51\":1}}],[\"因此我们需要为节点类添加\",{\"1\":{\"102\":1}}],[\"因此我们可以很容易地从哈希值反推出可用的\",{\"1\":{\"73\":1}}],[\"因此我们可以使用动态数组\",{\"1\":{\"53\":1}}],[\"因此栈可以视为一种受限制的数组或链表\",{\"1\":{\"51\":1}}],[\"因此堆更加适合存储大型数组\",{\"1\":{\"39\":1}}],[\"因此\",{\"1\":{\"39\":3,\"54\":1,\"63\":1,\"64\":2,\"78\":1,\"86\":1,\"95\":1,\"96\":1,\"111\":1,\"116\":1}}],[\"因此它们被各类安全应用弃用\",{\"1\":{\"75\":1}}],[\"因此它通常比链表更高效\",{\"1\":{\"38\":1}}],[\"因此它的索引为\",{\"1\":{\"13\":1}}],[\"因此只能看作一个具有长度限制的列表\",{\"1\":{\"31\":1}}],[\"因此各种性质和操作效率也呈现对立的特点\",{\"1\":{\"28\":1}}],[\"因此在高并发场景下具有更好的性能\",{\"1\":{\"162\":1}}],[\"因此在该空桶之下的元素都无法再被访问到\",{\"1\":{\"68\":1}}],[\"因此在相同数据量下\",{\"1\":{\"21\":1}}],[\"因此在大多数编程语言中\",{\"1\":{\"18\":1}}],[\"因此在插入元素后\",{\"1\":{\"15\":1}}],[\"因此插入一个元素必定会导致数组尾部元素\",{\"1\":{\"14\":1}}],[\"这里会以cppreference为主\",{\"1\":{\"185\":1}}],[\"这里暂不介绍\",{\"1\":{\"183\":1}}],[\"这里使用条件变量实现一个countdownlatch\",{\"1\":{\"183\":1}}],[\"这里主要介绍两种raii方式的锁封装\",{\"1\":{\"180\":1}}],[\"这里可以对thread进行封装\",{\"1\":{\"178\":1}}],[\"这里按照如下顺序介绍\",{\"1\":{\"177\":1}}],[\"这里需要注意\",{\"1\":{\"157\":1,\"178\":1}}],[\"这里有两种解决办法\",{\"1\":{\"157\":1,\"178\":1}}],[\"这里的锁就是上面介绍的std\",{\"1\":{\"183\":1}}],[\"这里的\",{\"1\":{\"116\":1}}],[\"这里的空间浪费主要有两方面含义\",{\"1\":{\"39\":1}}],[\"这里的空间浪费是指额外增加的变量如容量\",{\"1\":{\"39\":1}}],[\"这3者的区别\",{\"0\":{\"140\":1}}],[\"这方面有什么考量吗\",{\"1\":{\"116\":1}}],[\"这棵二叉搜索树便会退化为链表\",{\"1\":{\"100\":1}}],[\"这就代表有哈希冲突\",{\"1\":{\"78\":1}}],[\"这与数组等价\",{\"1\":{\"78\":1}}],[\"这可能会加剧哈希冲突\",{\"1\":{\"75\":1}}],[\"这可以通过在节点中保存一个指向父节点的引用来实现\",{\"1\":{\"30\":1}}],[\"这三个哈希值\",{\"1\":{\"74\":1}}],[\"这进一步增加了扩容过程的计算开销\",{\"1\":{\"64\":1}}],[\"这显然是不对的\",{\"1\":{\"64\":1}}],[\"这时可能会发生错误\",{\"1\":{\"178\":1}}],[\"这时可能会发生crash\",{\"1\":{\"157\":1}}],[\"这时各种操作的时间复杂度也会退化为\",{\"1\":{\"98\":1}}],[\"这时我们可以将该语言的\",{\"1\":{\"50\":1}}],[\"这时候时间复杂度就会是\",{\"1\":{\"39\":1}}],[\"这时候使用双向链表就非常合适\",{\"1\":{\"30\":1}}],[\"这个操作是原子的\",{\"1\":{\"169\":1}}],[\"这个在\",{\"1\":{\"57\":1}}],[\"这个问题不难解决\",{\"1\":{\"47\":1}}],[\"这个公式计算出的\",{\"1\":{\"47\":1}}],[\"这会导致出队操作效率较低\",{\"1\":{\"47\":1}}],[\"这些指令能够确保在多个线程操作同一数据时不会产生竞争条件\",{\"1\":{\"162\":1}}],[\"这些连续位置发生哈希冲突的可能性越大\",{\"1\":{\"68\":1}}],[\"这些元素的地址不连续\",{\"1\":{\"39\":1}}],[\"这些数据都是以数组的形式构建的\",{\"1\":{\"20\":1}}],[\"这\",{\"1\":{\"39\":1}}],[\"这样\",{\"1\":{\"142\":1}}],[\"这样可以动态选择合适的计算策略\",{\"1\":{\"132\":1}}],[\"这样在遍历至\",{\"1\":{\"95\":1}}],[\"这样在插入数据时\",{\"1\":{\"15\":1}}],[\"这样做可以最大程度保证树的平衡性\",{\"1\":{\"116\":1}}],[\"这样做既能保持哈希表的探测序列不变\",{\"1\":{\"78\":1}}],[\"这样做的好处是当每次查询或添加元素时\",{\"1\":{\"68\":1}}],[\"这样就可以解决c代码调用c++\",{\"1\":{\"142\":1}}],[\"这样就可以在\",{\"1\":{\"98\":1}}],[\"这样就不会有冲突了\",{\"1\":{\"78\":1}}],[\"这样就无须自行处理数组扩容问题\",{\"1\":{\"53\":1}}],[\"这样才能确保哈希表是可靠的\",{\"1\":{\"73\":1}}],[\"这样才能通过计算偏移量来获取对应元素位置\",{\"1\":{\"39\":1}}],[\"这样我们就可以通过后退操作回到上一个网页\",{\"1\":{\"55\":1}}],[\"这样一来\",{\"1\":{\"39\":1}}],[\"这两种初始化方法\",{\"1\":{\"33\":1}}],[\"这是无锁编程的核心操作之一\",{\"1\":{\"169\":1}}],[\"这是为了允许父进程能够获取子进程的退出状态\",{\"1\":{\"151\":1}}],[\"这是通过哈希函数\",{\"1\":{\"63\":1}}],[\"这是因为哈希函数计算需要开销\",{\"1\":{\"78\":1}}],[\"这是因为\",{\"1\":{\"76\":1}}],[\"这是因为对象的哈希值通常是基于内存地址生成的\",{\"1\":{\"76\":1}}],[\"这是因为每次删除操作都会产生一个删除标记\",{\"1\":{\"68\":1}}],[\"这是因为删除元素会在数组内产生一个空桶\",{\"1\":{\"68\":1}}],[\"这是因为数组中存储的是节点的引用\",{\"1\":{\"39\":1}}],[\"这是因为我们通常无法事先确定需要存储多少数据\",{\"1\":{\"31\":1}}],[\"这是一个有趣的问题\",{\"1\":{\"74\":1}}],[\"这是一个\",{\"1\":{\"18\":1}}],[\"这种方式也可以\",{\"1\":{\"181\":1}}],[\"这种现象被称为哈希冲突\",{\"1\":{\"77\":1}}],[\"这种做法可以有效防止\",{\"1\":{\"76\":1}}],[\"这种做法包含丰富的先验信息\",{\"1\":{\"19\":1}}],[\"这种节点插入方法被称为\",{\"1\":{\"52\":1}}],[\"这种周期性规律可以通过\",{\"1\":{\"47\":1}}],[\"这种循环操作可以通过环形链表来实现\",{\"1\":{\"30\":1}}],[\"这意味着在二叉搜索树中进行中序遍历时\",{\"1\":{\"97\":1}}],[\"这意味着即使哈希表中有空桶\",{\"1\":{\"69\":1}}],[\"这意味着节点\",{\"1\":{\"39\":1}}],[\"这意味着\",{\"1\":{\"25\":1,\"72\":1}}],[\"这意味着计算数组元素的内存地址非常容易\",{\"1\":{\"13\":1}}],[\"这似乎有些反直觉\",{\"1\":{\"13\":1}}],[\"观察下表\",{\"1\":{\"98\":1}}],[\"观察以上公式\",{\"1\":{\"72\":1}}],[\"观察发现\",{\"1\":{\"61\":1,\"74\":1}}],[\"观察上图\",{\"1\":{\"13\":1,\"21\":1}}],[\"观察者模式\",{\"0\":{\"127\":1},\"1\":{\"3\":1},\"2\":{\"129\":1}}],[\"从队列中取出元素\",{\"1\":{\"172\":1}}],[\"从刚创建对象开始就会新建一个线程用于执行函数\",{\"1\":{\"157\":1,\"178\":1}}],[\"从该节点到根节点的路径上可能会出现一系列失衡节点\",{\"1\":{\"111\":1}}],[\"从该链表的角度看\",{\"1\":{\"39\":1}}],[\"从底至顶看\",{\"1\":{\"105\":1}}],[\"从根节点出发\",{\"1\":{\"95\":1}}],[\"从根节点到该节点所经过的边的数量\",{\"1\":{\"83\":1}}],[\"从根节点到最远叶节点所经过的边的数量\",{\"1\":{\"83\":1}}],[\"从二叉树的根节点\",{\"1\":{\"94\":1}}],[\"从距离该节点最远的叶节点到该节点所经过的边的数量\",{\"1\":{\"83\":1}}],[\"从顶至底递增\",{\"1\":{\"83\":1}}],[\"从中删除键值对\",{\"1\":{\"66\":2}}],[\"从本质上看\",{\"1\":{\"64\":1}}],[\"从栈\",{\"1\":{\"57\":2}}],[\"从标准库的角度看\",{\"1\":{\"39\":1}}],[\"从数据结构与算法\",{\"1\":{\"39\":1}}],[\"从头节点遍历到尾节点已经不会遇到\",{\"1\":{\"39\":1}}],[\"从而防止僵尸进程的产生\",{\"1\":{\"153\":1}}],[\"从而导致的进程状态\",{\"1\":{\"151\":1}}],[\"从而导致以下不同点\",{\"1\":{\"39\":1}}],[\"从而提高了代码的可扩展性和维护性\",{\"1\":{\"132\":1}}],[\"从而提高效率\",{\"1\":{\"54\":1}}],[\"从而使得各种操作的时间复杂度保持在\",{\"1\":{\"100\":1}}],[\"从而得出一个重要性质\",{\"1\":{\"97\":1}}],[\"从而完成节点插入操作\",{\"1\":{\"95\":1}}],[\"从而实现哈希冲突的缓解\",{\"1\":{\"78\":1}}],[\"从而访问对应桶并获取\",{\"1\":{\"77\":1}}],[\"从而访问到对应的节点\",{\"1\":{\"39\":1}}],[\"从而加重哈希冲突\",{\"1\":{\"74\":1}}],[\"从而避免哈希冲突\",{\"1\":{\"74\":1}}],[\"从而破解密码\",{\"1\":{\"73\":1}}],[\"从而优化查询效率\",{\"1\":{\"68\":1}}],[\"从而进一步促使该位置的聚堆生长\",{\"1\":{\"68\":1}}],[\"从而将查询操作的时间复杂度优化至\",{\"1\":{\"66\":1}}],[\"从而简化代码\",{\"1\":{\"66\":1}}],[\"从而获取\",{\"1\":{\"63\":1}}],[\"从而获取该\",{\"1\":{\"63\":1}}],[\"从而引入扩容机制\",{\"1\":{\"47\":1}}],[\"从而难以选择合适的列表长度\",{\"1\":{\"31\":1}}],[\"从而借助高速缓存来提升后续操作的执行速度\",{\"1\":{\"19\":1}}],[\"从而无法安全地扩展数组容量\",{\"1\":{\"18\":1}}],[\"从而直接访问该元素\",{\"1\":{\"13\":1}}],[\"从入门\",{\"1\":{\"5\":1}}],[\"首先初始化节点\",{\"1\":{\"85\":1}}],[\"首先\",{\"1\":{\"78\":1}}],[\"首先通过哈希函数访问链表头节点\",{\"1\":{\"66\":1}}],[\"首尾相接\",{\"1\":{\"29\":1}}],[\"首个元素的地址偏移量是\",{\"1\":{\"13\":1}}],[\"首元素内存地址\",{\"1\":{\"13\":1,\"39\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"给定一组数据\",{\"1\":{\"98\":1}}],[\"给定一个待插入元素\",{\"1\":{\"95\":1}}],[\"给定一个列表索引\",{\"1\":{\"39\":1}}],[\"给定目标节点值\",{\"1\":{\"94\":1}}],[\"给定\",{\"1\":{\"61\":1}}],[\"给定数组内存地址\",{\"1\":{\"13\":1}}],[\"给定初始值\",{\"1\":{\"12\":1}}],[\"native\",{\"1\":{\"178\":2}}],[\"namespace\",{\"1\":{\"178\":1,\"179\":2,\"180\":1,\"184\":2,\"185\":1,\"188\":1,\"189\":1}}],[\"name\",{\"1\":{\"62\":1,\"189\":4}}],[\"n=7\",{\"1\":{\"116\":1}}],[\"n−1\",{\"1\":{\"91\":1}}],[\"n+1\",{\"1\":{\"91\":1,\"116\":1}}],[\"n5\",{\"1\":{\"39\":1,\"85\":2}}],[\"n4\",{\"1\":{\"23\":2,\"39\":1,\"85\":2}}],[\"n3\",{\"1\":{\"23\":3,\"39\":1,\"85\":2}}],[\"n2\",{\"1\":{\"23\":3,\"39\":1,\"85\":4,\"86\":3}}],[\"n1\",{\"1\":{\"23\":3,\"24\":3,\"25\":4,\"39\":1,\"85\":3,\"86\":3}}],[\"n0\",{\"1\":{\"23\":3,\"24\":5,\"25\":6}}],[\"nexttail\",{\"1\":{\"171\":3,\"172\":7,\"173\":1}}],[\"next\",{\"1\":{\"21\":2,\"23\":1,\"29\":2,\"39\":2}}],[\"newcounter\",{\"1\":{\"181\":1}}],[\"new的区别\",{\"0\":{\"139\":1}}],[\"new\",{\"0\":{\"139\":1},\"1\":{\"12\":2,\"18\":1,\"23\":5,\"46\":1,\"47\":1,\"52\":1,\"63\":1,\"66\":1,\"68\":2,\"85\":5,\"86\":1,\"95\":2,\"111\":1,\"139\":3,\"148\":1,\"157\":2,\"171\":1,\"172\":1}}],[\"not\",{\"1\":{\"202\":1}}],[\"notify\",{\"1\":{\"161\":4,\"183\":1}}],[\"no\",{\"1\":{\"167\":1,\"191\":1,\"195\":1}}],[\"now\",{\"1\":{\"157\":1}}],[\"none\",{\"1\":{\"21\":1,\"29\":1,\"39\":1,\"68\":3,\"70\":1,\"83\":1,\"95\":3}}],[\"node\",{\"1\":{\"21\":1,\"46\":9,\"52\":7,\"82\":3,\"83\":2,\"95\":3,\"102\":4,\"103\":4,\"105\":8,\"106\":7,\"107\":1,\"108\":1,\"109\":14,\"111\":13,\"112\":26,\"116\":3}}],[\"nullptr\",{\"1\":{\"21\":2,\"25\":1,\"26\":2,\"27\":1,\"29\":2,\"46\":3,\"52\":1,\"63\":6,\"68\":10,\"82\":2,\"94\":1,\"95\":3,\"96\":9,\"103\":1,\"111\":1,\"112\":8}}],[\"null\",{\"1\":{\"21\":1,\"153\":3}}],[\"num\",{\"1\":{\"14\":4,\"34\":1,\"36\":2,\"46\":5,\"47\":5,\"52\":4,\"53\":4,\"76\":2,\"94\":8,\"95\":9,\"96\":3}}],[\"nums1\",{\"1\":{\"12\":1,\"33\":1}}],[\"nums\",{\"1\":{\"12\":1,\"13\":2,\"14\":4,\"15\":3,\"16\":2,\"17\":2,\"18\":3,\"23\":3,\"33\":2,\"34\":2,\"35\":10,\"36\":3,\"47\":6}}],[\"n\",{\"1\":{\"15\":2,\"18\":1,\"24\":1,\"26\":1,\"28\":3,\"35\":1,\"39\":7,\"47\":1,\"54\":1,\"56\":1,\"61\":7,\"64\":1,\"66\":2,\"72\":1,\"78\":5,\"91\":2,\"97\":1,\"98\":3,\"100\":1,\"115\":1,\"157\":2,\"195\":8}}],[\"404\",{\"1\":{\"202\":1}}],[\"4=2h=\",{\"1\":{\"116\":1}}],[\"4614256650576692846\",{\"1\":{\"76\":1}}],[\"4\",{\"0\":{\"141\":1,\"172\":1},\"1\":{\"12\":2,\"23\":2,\"33\":1,\"35\":1,\"39\":2,\"44\":1,\"50\":1,\"66\":1,\"68\":1,\"69\":1,\"74\":2,\"82\":2,\"85\":1,\"189\":3,\"193\":1}}],[\"2h\",{\"1\":{\"91\":1,\"116\":1}}],[\"2h+1−1\",{\"1\":{\"88\":1,\"91\":1}}],[\"2i−1\",{\"1\":{\"91\":1}}],[\"224\",{\"1\":{\"75\":1}}],[\"20\",{\"1\":{\"171\":2,\"172\":2,\"178\":1,\"195\":1}}],[\"200\",{\"1\":{\"179\":3,\"180\":1}}],[\"2008\",{\"1\":{\"75\":1}}],[\"2002\",{\"1\":{\"75\":1}}],[\"20336\",{\"1\":{\"64\":2}}],[\"256\",{\"1\":{\"75\":3}}],[\"27\",{\"1\":{\"74\":2}}],[\"24\",{\"1\":{\"74\":2}}],[\"21\",{\"1\":{\"74\":2,\"195\":2}}],[\"28\",{\"1\":{\"74\":1}}],[\"236\",{\"1\":{\"64\":1}}],[\"2\",{\"0\":{\"139\":1,\"170\":1},\"1\":{\"12\":2,\"23\":2,\"33\":1,\"35\":1,\"37\":1,\"39\":2,\"44\":1,\"50\":1,\"54\":1,\"64\":1,\"66\":3,\"68\":2,\"74\":1,\"75\":6,\"77\":2,\"82\":1,\"83\":1,\"85\":1,\"88\":1,\"96\":4,\"111\":1,\"112\":2,\"116\":1,\"160\":1,\"167\":1,\"191\":1,\"193\":1}}],[\"384\",{\"1\":{\"75\":1}}],[\"33\",{\"1\":{\"74\":2}}],[\"30\",{\"1\":{\"74\":2}}],[\"32​\",{\"1\":{\"66\":1}}],[\"36\",{\"1\":{\"64\":2}}],[\"3\",{\"0\":{\"140\":1,\"171\":1},\"1\":{\"12\":2,\"23\":2,\"33\":1,\"35\":5,\"39\":3,\"44\":1,\"50\":1,\"66\":1,\"68\":1,\"74\":10,\"75\":3,\"76\":5,\"77\":1,\"85\":1,\"105\":1,\"107\":1,\"193\":1}}],[\"144\",{\"1\":{\"184\":1}}],[\"14159\",{\"1\":{\"76\":2}}],[\"1962\",{\"1\":{\"100\":1}}],[\"1995\",{\"1\":{\"75\":1}}],[\"1992\",{\"1\":{\"75\":1}}],[\"160\",{\"1\":{\"75\":1}}],[\"16750\",{\"1\":{\"62\":1}}],[\"11\",{\"1\":{\"74\":1}}],[\"18\",{\"1\":{\"74\":2}}],[\"15466937326284535026\",{\"1\":{\"76\":1}}],[\"15\",{\"1\":{\"74\":2}}],[\"15937\",{\"1\":{\"62\":2}}],[\"128\",{\"1\":{\"75\":1}}],[\"12836\",{\"1\":{\"62\":1,\"64\":2}}],[\"12\",{\"1\":{\"74\":3}}],[\"13\",{\"1\":{\"74\":1}}],[\"136\",{\"1\":{\"64\":1}}],[\"13276\",{\"1\":{\"62\":1}}],[\"1000\",{\"1\":{\"162\":1}}],[\"1000000007\",{\"1\":{\"74\":2}}],[\"100\",{\"1\":{\"63\":5,\"64\":2,\"73\":1}}],[\"10583\",{\"1\":{\"62\":2}}],[\"10\",{\"0\":{\"140\":1},\"1\":{\"37\":1,\"140\":1,\"159\":2,\"161\":2,\"162\":2,\"163\":2,\"164\":2,\"165\":2,\"166\":2,\"171\":1,\"172\":2,\"178\":2}}],[\"1\",{\"0\":{\"138\":1,\"169\":1},\"1\":{\"12\":2,\"13\":2,\"14\":2,\"15\":2,\"17\":1,\"19\":1,\"23\":3,\"24\":1,\"26\":1,\"27\":1,\"28\":3,\"33\":1,\"34\":5,\"35\":2,\"39\":7,\"44\":4,\"47\":7,\"50\":4,\"52\":1,\"53\":1,\"61\":8,\"68\":8,\"69\":1,\"71\":1,\"74\":1,\"75\":3,\"76\":2,\"77\":2,\"78\":3,\"83\":3,\"85\":1,\"90\":1,\"91\":2,\"92\":1,\"96\":5,\"98\":1,\"102\":2,\"109\":2,\"111\":1,\"112\":2,\"140\":1,\"153\":2,\"160\":1,\"161\":1,\"163\":4,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"171\":2,\"172\":4,\"178\":1,\"184\":1,\"185\":1,\"191\":2,\"193\":1}}],[\"=x\",{\"1\":{\"78\":2}}],[\"==\",{\"1\":{\"17\":1,\"25\":1,\"26\":1,\"27\":1,\"46\":3,\"47\":2,\"52\":1,\"53\":1,\"63\":1,\"66\":3,\"68\":6,\"95\":2,\"96\":6,\"103\":1,\"111\":1,\"112\":4,\"116\":3,\"153\":4,\"171\":2,\"172\":4,\"178\":1,\"183\":1}}],[\"=\",{\"1\":{\"12\":3,\"13\":2,\"14\":3,\"15\":2,\"16\":2,\"17\":1,\"18\":3,\"23\":9,\"24\":3,\"25\":3,\"26\":2,\"27\":3,\"33\":1,\"34\":2,\"36\":3,\"39\":6,\"44\":3,\"46\":15,\"47\":12,\"50\":3,\"52\":12,\"53\":1,\"62\":8,\"63\":17,\"64\":2,\"66\":10,\"68\":32,\"72\":1,\"74\":5,\"76\":8,\"85\":9,\"86\":4,\"94\":7,\"95\":10,\"96\":21,\"102\":3,\"103\":1,\"105\":4,\"106\":4,\"109\":3,\"111\":3,\"112\":15,\"116\":2,\"139\":2,\"153\":5,\"159\":2,\"161\":4,\"162\":3,\"163\":2,\"164\":3,\"165\":1,\"166\":1,\"171\":8,\"172\":12,\"178\":8,\"179\":8,\"180\":4,\"182\":2,\"183\":2,\"184\":3,\"185\":1,\"188\":2,\"189\":2,\"192\":4,\"193\":1,\"194\":1,\"195\":5}}],[\"512\",{\"1\":{\"75\":2}}],[\"5\",{\"0\":{\"142\":1},\"1\":{\"12\":6,\"23\":2,\"33\":1,\"35\":1,\"39\":2,\"44\":1,\"50\":1,\"74\":1,\"82\":2,\"85\":1,\"179\":4,\"180\":2,\"182\":2,\"184\":1,\"185\":1,\"192\":1,\"193\":1}}],[\"0\",{\"0\":{\"140\":1},\"1\":{\"12\":1,\"13\":4,\"16\":2,\"17\":1,\"18\":1,\"23\":1,\"26\":1,\"27\":1,\"34\":2,\"36\":3,\"39\":3,\"46\":4,\"47\":3,\"52\":3,\"53\":1,\"64\":1,\"66\":5,\"68\":4,\"74\":9,\"83\":1,\"86\":1,\"88\":1,\"96\":5,\"102\":2,\"103\":3,\"109\":2,\"112\":1,\"116\":1,\"140\":3,\"153\":12,\"157\":4,\"159\":2,\"160\":1,\"161\":2,\"162\":4,\"163\":2,\"164\":2,\"165\":2,\"166\":2,\"171\":5,\"172\":6,\"178\":5,\"179\":6,\"180\":3,\"182\":2,\"183\":5,\"184\":2,\"185\":1,\"188\":1,\"189\":1,\"191\":1,\"192\":2,\"193\":1}}],[\"我们应该使用\",{\"1\":{\"116\":1}}],[\"我们应当将注意力集中在哈希算法\",{\"1\":{\"72\":1}}],[\"我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号\",{\"1\":{\"109\":1}}],[\"我们通常会将输入数据排序\",{\"1\":{\"116\":1}}],[\"我们通常会用一些标准哈希算法\",{\"1\":{\"75\":1}}],[\"我们通常将\",{\"1\":{\"83\":1}}],[\"我们通常将头节点当作链表的代称\",{\"1\":{\"23\":1}}],[\"我们通常选取质数作为模数\",{\"1\":{\"74\":1}}],[\"我们通常不能完全填满它们\",{\"1\":{\"39\":1}}],[\"我们通常使用\",{\"1\":{\"33\":1}}],[\"我们只需将右旋的实现代码中的所有的\",{\"1\":{\"106\":1}}],[\"我们只需将元素插入链表头部\",{\"1\":{\"52\":1}}],[\"我们关注以该失衡节点为根节点的子树\",{\"1\":{\"105\":1}}],[\"我们同样将获取节点平衡因子的功能封装成函数\",{\"1\":{\"103\":1}}],[\"我们考虑使用数组或二叉搜索树存储\",{\"1\":{\"98\":1}}],[\"我们在二叉搜索树中获取有序数据仅需\",{\"1\":{\"97\":1}}],[\"我们在此采用与栈相同的方法命名\",{\"1\":{\"44\":1}}],[\"我们无法直接删除它\",{\"1\":{\"96\":1}}],[\"我们根据目标节点的子节点数量\",{\"1\":{\"96\":1}}],[\"我们声明一个节点\",{\"1\":{\"94\":1}}],[\"我们采取在链表或红黑树中执行查找操作\",{\"1\":{\"78\":1}}],[\"我们使用编程语言内置的哈希表时\",{\"1\":{\"78\":1}}],[\"我们希望哈希算法具有确定性\",{\"1\":{\"77\":1}}],[\"我们也能设计一些简单的哈希算法\",{\"1\":{\"74\":1}}],[\"我们就能对各种失衡情况进行旋转\",{\"1\":{\"109\":1}}],[\"我们就无法在哈希表中查询到原先的\",{\"1\":{\"76\":1}}],[\"我们就进行哈希表扩容\",{\"1\":{\"65\":1}}],[\"我们就可以利用\",{\"1\":{\"63\":1}}],[\"我们就可以从链表的头节点出发\",{\"1\":{\"23\":1}}],[\"我们得到\",{\"1\":{\"64\":1}}],[\"我们先考虑最简单的情况\",{\"1\":{\"63\":1}}],[\"我们向哈希表中输入一个键\",{\"1\":{\"61\":1}}],[\"我们不能在开放寻址哈希表中直接删除元素\",{\"1\":{\"68\":1}}],[\"我们不能简单地确定哪种实现更加节省内存\",{\"1\":{\"54\":1}}],[\"我们不一定需要用这么多\",{\"1\":{\"39\":1}}],[\"我们来尝试自己实现一个栈类\",{\"1\":{\"51\":1}}],[\"我们以常见的\",{\"1\":{\"50\":1}}],[\"我们把堆叠元素的顶部称为\",{\"1\":{\"49\":1}}],[\"我们往往更青睐使用数组实现算法\",{\"1\":{\"39\":1}}],[\"我们会发现两个数组中的相同数字拥有同一个\",{\"1\":{\"39\":1}}],[\"我们仍然可以在\",{\"1\":{\"39\":1}}],[\"我们维护一个指针变量始终指向头节点\",{\"1\":{\"39\":1}}],[\"我们规定每次将数组扩容至之前的\",{\"1\":{\"37\":1}}],[\"我们选择\",{\"1\":{\"37\":1}}],[\"我们尝试实现一个简易版列表\",{\"1\":{\"37\":1}}],[\"我们需要从递归的视角来看这个问题\",{\"1\":{\"116\":1}}],[\"我们需要从这个节点开始\",{\"1\":{\"111\":1}}],[\"我们需要保证在删除操作完成后\",{\"1\":{\"96\":1}}],[\"我们需要借助节点\",{\"1\":{\"95\":1}}],[\"我们需要通过哈希函数来重新计算所有键值对的存储位置\",{\"1\":{\"64\":1}}],[\"我们需要让\",{\"1\":{\"47\":1}}],[\"我们需要一种数据结构\",{\"1\":{\"45\":1}}],[\"我们需要快速找到最近最少使用的数据\",{\"1\":{\"30\":1}}],[\"我们需要访问节点的父节点\",{\"1\":{\"30\":1}}],[\"我们知道\",{\"1\":{\"21\":1,\"76\":1}}],[\"我们既可以通过索引遍历数组\",{\"1\":{\"16\":1}}],[\"我们将旋转操作封装成一个函数\",{\"1\":{\"109\":1}}],[\"我们将平衡因子绝对值\",{\"1\":{\"104\":1}}],[\"我们将创建两个工具函数\",{\"1\":{\"102\":1}}],[\"我们将二叉搜索树封装为一个类\",{\"1\":{\"93\":1}}],[\"我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树\",{\"1\":{\"82\":1}}],[\"我们将哈希表看作一个\",{\"1\":{\"68\":1}}],[\"我们将哈希表扩容至原先的\",{\"1\":{\"66\":1}}],[\"我们将这种多个输入对应同一输出的情况称为哈希冲突\",{\"1\":{\"64\":1}}],[\"我们将这个问题的解决方案留在\",{\"1\":{\"14\":1}}],[\"我们将\",{\"1\":{\"63\":1}}],[\"我们将数组中的每个空位称为桶\",{\"1\":{\"63\":1}}],[\"我们将盘子替换为各种类型的元素\",{\"1\":{\"49\":1}}],[\"我们将队列头部称为\",{\"1\":{\"43\":1}}],[\"我们将把\",{\"1\":{\"31\":1}}],[\"我们将首个节点称为头节点\",{\"1\":{\"29\":1}}],[\"我们将元素在数组中的位置称为该元素的索引\",{\"1\":{\"10\":1}}],[\"我们发现数组首个元素的索引为\",{\"1\":{\"13\":1}}],[\"我们可以利用这个特点做一些性能优化\",{\"1\":{\"188\":1}}],[\"我们可以获取到其父节点\",{\"1\":{\"95\":1}}],[\"我们可以调用\",{\"1\":{\"76\":1}}],[\"我们可以采用懒删除\",{\"1\":{\"68\":1}}],[\"我们可以采用以下策略\",{\"1\":{\"65\":1}}],[\"我们可以采用以下巧妙方法来避免这个问题\",{\"1\":{\"47\":1}}],[\"我们可以通过扩容哈希表来减少哈希冲突\",{\"1\":{\"64\":1}}],[\"我们可以通过哈希函数得到该\",{\"1\":{\"63\":1}}],[\"我们可以得出以下结论\",{\"1\":{\"54\":1}}],[\"我们可以\",{\"1\":{\"51\":1}}],[\"我们可以直接使用编程语言内置的栈类\",{\"1\":{\"50\":1}}],[\"我们可以直接使用编程语言中现成的队列类\",{\"1\":{\"44\":1}}],[\"我们可以将栈类比为桌面上的一摞盘子\",{\"1\":{\"49\":1}}],[\"我们可以将数组的尾部作为栈顶\",{\"1\":{\"53\":1}}],[\"我们可以将数组替换为动态数组\",{\"1\":{\"47\":1}}],[\"我们可以将数组视为首尾相接的\",{\"1\":{\"47\":1}}],[\"我们可以将链表的头节点视为栈顶\",{\"1\":{\"52\":1}}],[\"我们可以将链表的\",{\"1\":{\"46\":1}}],[\"我们可以定位列表尾部\",{\"1\":{\"37\":1}}],[\"我们可以使用它们得到一个特定顺序的遍历结果\",{\"1\":{\"116\":1}}],[\"我们可以使用一个变量\",{\"1\":{\"47\":1}}],[\"我们可以使用\",{\"1\":{\"31\":1}}],[\"我们可以使用下图所示的公式计算得到该元素的内存地址\",{\"1\":{\"13\":1}}],[\"我们可以初始化一个比较长的数组\",{\"1\":{\"15\":1}}],[\"我们可以在\",{\"1\":{\"13\":1,\"26\":1}}],[\"我们可以根据需求选用数组的两种初始化方式\",{\"1\":{\"12\":1}}],[\"其他线程能正确地看到更新的头部指针\",{\"1\":{\"172\":1}}],[\"其他线程能正确地看到更新的尾部指针\",{\"1\":{\"172\":1}}],[\"其他线程可以成功获取锁并继续执行\",{\"1\":{\"164\":1}}],[\"其他所有节点都包含子节点和非空子树\",{\"1\":{\"82\":1}}],[\"其实现原理如下\",{\"1\":{\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1}}],[\"其父进程没有及时调用\",{\"1\":{\"151\":1}}],[\"其节点总数\",{\"1\":{\"116\":1}}],[\"其查找\",{\"1\":{\"115\":1}}],[\"其左\",{\"1\":{\"115\":1}}],[\"其左子节点记为\",{\"1\":{\"105\":1}}],[\"其余所有节点的度都为\",{\"1\":{\"88\":1}}],[\"其两个指针均指向\",{\"1\":{\"83\":1}}],[\"其次\",{\"1\":{\"78\":1}}],[\"其操作方法与普通哈希表有所不同\",{\"1\":{\"68\":1}}],[\"其定义为哈希表的元素数量除以桶数量\",{\"1\":{\"64\":1}}],[\"其长度不可变\",{\"1\":{\"47\":1}}],[\"其支持元素增删查改操作\",{\"1\":{\"31\":1}}],[\"其存在以下局限性\",{\"1\":{\"19\":1}}],[\"其中a\",{\"1\":{\"140\":1}}],[\"其中每种情况都需要进行多个步骤的节点操作\",{\"1\":{\"116\":1}}],[\"其中查找待删除节点需要\",{\"1\":{\"96\":1}}],[\"其中图的每个顶点都与一个链表相关联\",{\"1\":{\"30\":1}}],[\"其中的每个元素都是一个节点对象\",{\"1\":{\"21\":1}}],[\"其中\",{\"1\":{\"15\":1,\"63\":1}}],[\"其将相同类型的元素存储在连续的内存空间中\",{\"1\":{\"10\":1}}],[\"其目的在于帮助想学习\",{\"1\":{\"0\":1}}],[\"书籍\",{\"2\":{\"8\":1}}],[\"书籍推荐\",{\"0\":{\"5\":1}}],[\"国内有大佬把它翻译成了中文书籍\",{\"1\":{\"7\":1}}],[\"英文不错的朋友可以直接看原文\",{\"1\":{\"7\":1}}],[\"cpp\",{\"1\":{\"188\":3}}],[\"cpu\",{\"1\":{\"30\":2,\"38\":1,\"148\":2,\"149\":3,\"152\":1}}],[\"centos7\",{\"1\":{\"188\":6,\"189\":1}}],[\"circular\",{\"1\":{\"167\":1}}],[\"cv\",{\"1\":{\"161\":6,\"183\":4}}],[\"callonce\",{\"1\":{\"182\":2}}],[\"call\",{\"0\":{\"182\":1},\"1\":{\"177\":1,\"182\":3,\"185\":1}}],[\"calls\",{\"1\":{\"157\":2}}],[\"cast<int>\",{\"1\":{\"195\":1}}],[\"case\",{\"1\":{\"195\":3}}],[\"case3\",{\"1\":{\"96\":3}}],[\"cas\",{\"1\":{\"162\":1,\"169\":1,\"170\":1}}],[\"capacity\",{\"1\":{\"47\":4,\"63\":3,\"64\":1,\"66\":7,\"68\":7,\"72\":2,\"171\":7,\"172\":9}}],[\"currenthead\",{\"1\":{\"171\":4,\"172\":8}}],[\"currenttail\",{\"1\":{\"171\":3,\"172\":5}}],[\"cur\",{\"1\":{\"94\":22,\"95\":11,\"96\":25}}],[\"chrono\",{\"1\":{\"161\":1,\"163\":1,\"164\":1,\"178\":1,\"179\":1,\"183\":1}}],[\"child\",{\"1\":{\"82\":2,\"96\":5,\"105\":11,\"106\":10,\"107\":1,\"108\":1,\"112\":3,\"116\":3}}],[\"char\",{\"1\":{\"74\":1}}],[\"chaining\",{\"1\":{\"66\":1}}],[\"class\",{\"1\":{\"46\":1,\"47\":1,\"52\":1,\"53\":1,\"63\":1,\"66\":1,\"68\":1,\"164\":1,\"171\":1,\"172\":1,\"178\":2,\"183\":1,\"195\":1}}],[\"clear\",{\"1\":{\"35\":1,\"63\":1,\"66\":1,\"164\":1}}],[\"c\",{\"0\":{\"142\":1},\"1\":{\"21\":1,\"31\":1,\"57\":1,\"74\":2,\"142\":2,\"189\":2}}],[\"color\",{\"1\":{\"195\":6}}],[\"collision\",{\"1\":{\"64\":1}}],[\"copy\",{\"1\":{\"188\":4}}],[\"complicated>\",{\"1\":{\"189\":1}}],[\"complicated\",{\"1\":{\"189\":7}}],[\"completed\",{\"1\":{\"157\":1}}],[\"complete\",{\"1\":{\"89\":1}}],[\"compare\",{\"1\":{\"162\":1,\"164\":1,\"169\":1}}],[\"conversion\",{\"1\":{\"195\":1}}],[\"contains\",{\"1\":{\"191\":3}}],[\"concurrency\",{\"1\":{\"178\":1}}],[\"concurrently\",{\"1\":{\"157\":1}}],[\"consumed\",{\"1\":{\"171\":1,\"172\":1}}],[\"consumer\",{\"1\":{\"171\":2,\"172\":3}}],[\"constucted\",{\"1\":{\"189\":5}}],[\"constructors\",{\"1\":{\"188\":2}}],[\"construct\",{\"1\":{\"188\":8}}],[\"constexpr\",{\"1\":{\"141\":1}}],[\"const\",{\"0\":{\"143\":1},\"1\":{\"63\":1,\"68\":2,\"74\":1,\"143\":1,\"160\":1,\"171\":1,\"172\":1,\"183\":1,\"188\":1,\"189\":1,\"192\":3,\"193\":2}}],[\"condition\",{\"0\":{\"183\":1},\"1\":{\"161\":1,\"177\":1,\"183\":1,\"185\":1}}],[\"cout<<\",{\"1\":{\"188\":3,\"189\":6}}],[\"cout\",{\"1\":{\"47\":1,\"62\":2,\"63\":1,\"66\":3,\"68\":3,\"157\":3,\"159\":1,\"160\":2,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":2,\"166\":2,\"171\":2,\"172\":2,\"178\":8,\"179\":4,\"180\":2,\"182\":1,\"184\":2,\"185\":1,\"193\":1,\"195\":4}}],[\"countdown\",{\"1\":{\"183\":1}}],[\"countdownlatch\",{\"1\":{\"183\":2}}],[\"counting\",{\"1\":{\"163\":1}}],[\"counter\",{\"1\":{\"162\":3}}],[\"count\",{\"1\":{\"16\":2,\"36\":4,\"166\":1,\"181\":9,\"183\":8}}],[\"core\",{\"1\":{\"7\":1}}],[\"c++11关于异步操作提供了future相关的类\",{\"1\":{\"184\":1}}],[\"c++11关于并发引入了好多好东西\",{\"1\":{\"177\":1}}],[\"c++11提供了std\",{\"1\":{\"182\":1}}],[\"c++11提供了原子类型\",{\"1\":{\"181\":1}}],[\"c++11主要有std\",{\"1\":{\"180\":1}}],[\"c++11还提供了获取线程id\",{\"1\":{\"178\":1}}],[\"c++11\",{\"0\":{\"176\":1},\"1\":{\"170\":1},\"2\":{\"197\":1}}],[\"c++11引入了std\",{\"1\":{\"157\":1,\"178\":1}}],[\"c++不能只学习语言本身\",{\"1\":{\"7\":1}}],[\"c++之父大作\",{\"1\":{\"7\":1}}],[\"c++程序设计\",{\"1\":{\"7\":1}}],[\"c++实战经验\",{\"1\":{\"6\":1}}],[\"c++20各种新特性\",{\"1\":{\"6\":1}}],[\"c++20高级编程\",{\"1\":{\"6\":1}}],[\"c++进阶\",{\"1\":{\"6\":1}}],[\"c++基础\",{\"1\":{\"6\":1}}],[\"c++基础知识介绍的非常全面\",{\"1\":{\"6\":1}}],[\"c++面试题\",{\"1\":{\"1\":1}}],[\"c++\",{\"0\":{\"137\":1,\"170\":1},\"1\":{\"0\":3,\"6\":1,\"7\":2,\"21\":2,\"31\":1,\"33\":1,\"37\":1,\"39\":1,\"57\":1,\"76\":1,\"116\":1,\"142\":1,\"162\":1,\"169\":1,\"188\":6,\"189\":2},\"2\":{\"4\":1,\"41\":1,\"59\":1,\"80\":1,\"118\":1,\"126\":1,\"129\":1,\"134\":1,\"145\":1,\"155\":1,\"175\":1}}],[\"想提升c++达到进阶水平的朋友学习\",{\"1\":{\"7\":1}}],[\"进程通信\",{\"2\":{\"155\":1}}],[\"进程接管孤儿进程或采用\",{\"1\":{\"153\":1}}],[\"进程接管\",{\"1\":{\"153\":1}}],[\"进程会自动调用\",{\"1\":{\"153\":1}}],[\"进程\",{\"1\":{\"153\":3}}],[\"进程表项的数量是有限的\",{\"1\":{\"152\":1}}],[\"进程进入终止状态\",{\"1\":{\"149\":1}}],[\"进程进入阻塞状态\",{\"1\":{\"149\":1}}],[\"进程进入运行状态\",{\"1\":{\"149\":1}}],[\"进程在其生命周期内可以在不同状态之间进行转换\",{\"1\":{\"149\":1}}],[\"进程已完成执行或因某种原因被强制终止\",{\"1\":{\"148\":1}}],[\"进程已经被创建并准备好执行\",{\"1\":{\"148\":1}}],[\"进程无法继续执行\",{\"1\":{\"148\":1}}],[\"进程正在\",{\"1\":{\"148\":1}}],[\"进程正在被创建\",{\"1\":{\"148\":1}}],[\"进程的基本状态\",{\"0\":{\"148\":1}}],[\"进程状态之间的转换\",{\"0\":{\"149\":1}}],[\"进程状态\",{\"0\":{\"147\":1}}],[\"进程编程\",{\"0\":{\"146\":1},\"1\":{\"1\":1}}],[\"进而决定了键值对在哈希表中的分布情况\",{\"1\":{\"72\":1}}],[\"进行业务逻辑的实现\",{\"1\":{\"124\":1}}],[\"进行探测\",{\"1\":{\"70\":1}}],[\"进行扩容的\",{\"1\":{\"54\":1}}],[\"进阶篇\",{\"1\":{\"7\":1}}],[\"进阶推荐\",{\"0\":{\"7\":1}}],[\"本身并不操作或者管理资源\",{\"1\":{\"187\":1}}],[\"本书介绍的多是c++11的新特性\",{\"1\":{\"7\":1}}],[\"本书都有涉及\",{\"1\":{\"6\":1}}],[\"本站是一个面向\",{\"1\":{\"0\":1}}],[\"到实战\",{\"1\":{\"5\":1}}],[\"到进阶\",{\"1\":{\"5\":1}}],[\"架构设计\",{\"0\":{\"3\":1,\"135\":1},\"2\":{\"125\":1,\"128\":1,\"133\":1,\"136\":1}}],[\"数字签名等\",{\"1\":{\"75\":1}}],[\"数量记录\",{\"1\":{\"37\":1}}],[\"数据发送方可以计算数据的哈希值并将其一同发送\",{\"1\":{\"73\":1}}],[\"数据完整性检查\",{\"1\":{\"73\":1}}],[\"数据操作效率基本一致\",{\"1\":{\"39\":1}}],[\"数据主要存储在内存中\",{\"1\":{\"38\":1}}],[\"数据流可能会被分成多个缓冲块并放入一个环形链表\",{\"1\":{\"30\":1}}],[\"数据缓冲区\",{\"1\":{\"30\":1}}],[\"数据结构的哈希值\",{\"0\":{\"76\":1}}],[\"数据结构实现\",{\"1\":{\"20\":1}}],[\"数据结构\",{\"0\":{\"2\":1,\"119\":1},\"2\":{\"40\":1,\"58\":1,\"79\":1,\"117\":1,\"120\":1}}],[\"数组比二叉搜索树的效率更高\",{\"1\":{\"98\":1}}],[\"数组中连续被占用的位置越长\",{\"1\":{\"68\":1}}],[\"数组中包含元素的有效区间为\",{\"1\":{\"47\":1}}],[\"数组长度\",{\"1\":{\"63\":1,\"78\":2}}],[\"数组索引\",{\"1\":{\"63\":1}}],[\"数组实现额外支持随机访问\",{\"1\":{\"54\":1}}],[\"数组或链表的部分无关操作\",{\"1\":{\"51\":1}}],[\"数组和链表也可以实现查询功能\",{\"1\":{\"61\":1}}],[\"数组和链表都可以在任意位置添加和删除元素\",{\"1\":{\"51\":1}}],[\"数组和链表是两种基本的数据结构\",{\"1\":{\"38\":1}}],[\"数组内存地址\",{\"1\":{\"39\":1}}],[\"数组同时包含\",{\"1\":{\"39\":1}}],[\"数组存储在栈上和存储在堆上\",{\"1\":{\"39\":1}}],[\"数组存储在连续的内存空间内\",{\"1\":{\"19\":1}}],[\"数组可提供更高的内存空间效率\",{\"1\":{\"38\":1}}],[\"数组可以用于实现栈\",{\"1\":{\"20\":1}}],[\"数组支持随机访问\",{\"1\":{\"38\":1}}],[\"数组也支持元素增删查改\",{\"1\":{\"31\":1}}],[\"数组整体是一个变量\",{\"1\":{\"23\":1}}],[\"数组是神经网络编程中最常使用的数据结构\",{\"1\":{\"20\":1}}],[\"数组是排序和搜索算法最常用的数据结构\",{\"1\":{\"20\":1}}],[\"数组是一种基础且常见的数据结构\",{\"1\":{\"20\":1}}],[\"数组典型应用\",{\"0\":{\"20\":1}}],[\"数组在初始化后长度就固定了\",{\"1\":{\"19\":1}}],[\"数组允许在\",{\"1\":{\"19\":1}}],[\"数组为数据分配了连续的内存块\",{\"1\":{\"19\":1}}],[\"数组的优点与局限性\",{\"0\":{\"19\":1}}],[\"数组的长度是不可变的\",{\"1\":{\"18\":1}}],[\"数组的插入和删除的平均时间复杂度均为\",{\"1\":{\"15\":1}}],[\"数组的插入与删除操作有以下缺点\",{\"1\":{\"15\":1}}],[\"数组删除元素示例\",{\"1\":{\"15\":1}}],[\"数组插入元素示例\",{\"1\":{\"14\":1}}],[\"数组元素则必须是相同类型的\",{\"1\":{\"39\":1}}],[\"数组元素在内存中是\",{\"1\":{\"14\":1}}],[\"数组元素的内存地址计算\",{\"1\":{\"13\":1}}],[\"数组元素被存储在连续的内存空间中\",{\"1\":{\"13\":1}}],[\"数组常用操作\",{\"0\":{\"11\":1}}],[\"数组定义与存储方式\",{\"1\":{\"10\":1}}],[\"数组\",{\"0\":{\"10\":1,\"28\":1},\"1\":{\"10\":1,\"28\":1,\"50\":1,\"61\":1,\"66\":1,\"76\":1},\"2\":{\"41\":1}}],[\"数组与链表\",{\"0\":{\"9\":1},\"1\":{\"2\":1}}],[\"面试题\",{\"2\":{\"144\":1,\"154\":1,\"174\":1,\"196\":1,\"199\":1}}],[\"面试题和数据结构算法\",{\"1\":{\"0\":1}}],[\"面试集锦\",{\"0\":{\"1\":1,\"198\":1}}],[\"掌握一些基本的算法和数据结构\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
