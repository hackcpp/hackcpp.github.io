const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":384,\"nextId\":384,\"documentIds\":{\"0\":\"0\",\"1\":\"0#面试集锦\",\"2\":\"0#数据结构\",\"3\":\"0#架构设计\",\"4\":\"0#其他\",\"5\":\"0@1\",\"6\":\"1\",\"7\":\"1#数组\",\"8\":\"1#数组常用操作\",\"9\":\"1#初始化数组\",\"10\":\"1#访问元素\",\"11\":\"1#插入元素\",\"12\":\"1#删除元素\",\"13\":\"1#遍历数组\",\"14\":\"1#查找元素\",\"15\":\"1#扩容数组\",\"16\":\"1#数组的优点与局限性\",\"17\":\"1#数组典型应用\",\"18\":\"1#链表\",\"19\":\"1#链表常用操作\",\"20\":\"1#初始化链表\",\"21\":\"1#插入节点\",\"22\":\"1#删除节点\",\"23\":\"1#访问节点\",\"24\":\"1#查找节点\",\"25\":\"1#数组-vs-链表\",\"26\":\"1#常见链表类型\",\"27\":\"1#链表典型应用\",\"28\":\"1#列表\",\"29\":\"1#列表常用操作\",\"30\":\"1#初始化列表\",\"31\":\"1#访问元素-1\",\"32\":\"1#插入与删除元素\",\"33\":\"1#遍历列表\",\"34\":\"1#列表实现\",\"35\":\"1#重点回顾\",\"36\":\"1#q-a\",\"37\":\"1@0\",\"38\":\"1@1\",\"39\":\"2\",\"40\":\"2#队列\",\"41\":\"2#队列常用操作\",\"42\":\"2#队列实现\",\"43\":\"2#基于链表的实现\",\"44\":\"2#基于数组的实现\",\"45\":\"2#队列典型应用\",\"46\":\"2#栈\",\"47\":\"2#栈的常用操作\",\"48\":\"2#栈的实现\",\"49\":\"2#基于链表的实现-1\",\"50\":\"2#基于数组的实现-1\",\"51\":\"2#两种实现对比\",\"52\":\"2#栈的典型应用\",\"53\":\"2#重点回顾\",\"54\":\"2#q-a\",\"55\":\"2@0\",\"56\":\"2@1\",\"57\":\"3\",\"58\":\"3#哈希表\",\"59\":\"3#哈希表常用操作\",\"60\":\"3#哈希表简单实现\",\"61\":\"3#哈希冲突与扩容\",\"62\":\"3#哈希冲突\",\"63\":\"3#链式地址\",\"64\":\"3#开放寻址\",\"65\":\"3#线性探测\",\"66\":\"3#平方探测\",\"67\":\"3#多次哈希\",\"68\":\"3#编程语言的选择\",\"69\":\"3#哈希算法\",\"70\":\"3#哈希算法的目标\",\"71\":\"3#哈希算法的设计\",\"72\":\"3#常见哈希算法\",\"73\":\"3#数据结构的哈希值\",\"74\":\"3#重点回顾\",\"75\":\"3#q-a\",\"76\":\"3@0\",\"77\":\"3@1\",\"78\":\"4\",\"79\":\"4#二叉树\",\"80\":\"4#二叉树常见术语\",\"81\":\"4#二叉树基本操作\",\"82\":\"4#初始化二叉树\",\"83\":\"4#插入与删除节点\",\"84\":\"4#常见二叉树类型\",\"85\":\"4#完美二叉树\",\"86\":\"4#完全二叉树\",\"87\":\"4#平衡二叉树\",\"88\":\"4#二叉树的退化\",\"89\":\"4#二叉搜索树\",\"90\":\"4#二叉搜索树的操作\",\"91\":\"4#查找节点\",\"92\":\"4#插入节点\",\"93\":\"4#删除节点\",\"94\":\"4#中序遍历有序\",\"95\":\"4#二叉搜索树的效率\",\"96\":\"4#二叉搜索树常见应用\",\"97\":\"4#avl-树\",\"98\":\"4#avl-树常见术语\",\"99\":\"4#节点高度\",\"100\":\"4#节点平衡因子\",\"101\":\"4#avl-树旋转\",\"102\":\"4#右旋\",\"103\":\"4#左旋\",\"104\":\"4#先左旋后右旋\",\"105\":\"4#先右旋后左旋\",\"106\":\"4#旋转的选择\",\"107\":\"4#avl-树常用操作\",\"108\":\"4#插入节点-1\",\"109\":\"4#删除节点-1\",\"110\":\"4#查找节点-1\",\"111\":\"4#avl-树典型应用\",\"112\":\"4#重点回顾\",\"113\":\"4#q-a\",\"114\":\"4@0\",\"115\":\"4@1\",\"116\":\"5\",\"117\":\"5@0\",\"118\":\"6\",\"119\":\"6@0\",\"120\":\"7\",\"121\":\"7#入门推荐\",\"122\":\"7#进阶推荐\",\"123\":\"7@1\",\"124\":\"8\",\"125\":\"8#设计模式\",\"126\":\"8#设计原则\",\"127\":\"8#关于架构设计的一点思考\",\"128\":\"8@0\",\"129\":\"8@1\",\"130\":\"9\",\"131\":\"9#概述\",\"132\":\"9#结构\",\"133\":\"9#示例\",\"134\":\"9@0\",\"135\":\"9@1\",\"136\":\"10\",\"137\":\"10#概述\",\"138\":\"10#结构\",\"139\":\"10#示例\",\"140\":\"10@0\",\"141\":\"10@1\",\"142\":\"11\",\"143\":\"11#概述\",\"144\":\"11#结构\",\"145\":\"11#示例\",\"146\":\"11@0\",\"147\":\"11@1\",\"148\":\"12\",\"149\":\"12#概述\",\"150\":\"12#结构\",\"151\":\"12#示例\",\"152\":\"12@0\",\"153\":\"12@1\",\"154\":\"13\",\"155\":\"13#概述\",\"156\":\"13#工厂模式\",\"157\":\"13#结构\",\"158\":\"13#示例\",\"159\":\"13#抽象工厂模式\",\"160\":\"13#结构-1\",\"161\":\"13#示例-1\",\"162\":\"13@0\",\"163\":\"13@1\",\"164\":\"14\",\"165\":\"14#概述\",\"166\":\"14#结构\",\"167\":\"14#示例\",\"168\":\"14#应用场景\",\"169\":\"14@0\",\"170\":\"14@1\",\"171\":\"15\",\"172\":\"15#mvvm-的核心概念\",\"173\":\"15#_1-model-模型\",\"174\":\"15#_2-view-视图\",\"175\":\"15#_3-viewmodel-视图模型\",\"176\":\"15#mvvm-的工作原理\",\"177\":\"15#mvvm-与-mvc、mvp-的对比\",\"178\":\"15#mvvm-的优缺点\",\"179\":\"15#优点\",\"180\":\"15#缺点\",\"181\":\"15#mvvm-应用示例-使用-vue-js\",\"182\":\"15#总结\",\"183\":\"15@0\",\"184\":\"15@1\",\"185\":\"16\",\"186\":\"16#model-view-框架的核心概念\",\"187\":\"16#model-模型\",\"188\":\"16#view-视图\",\"189\":\"16#delegate-委托\",\"190\":\"16#model-view-的数据流\",\"191\":\"16#数据绑定与更新\",\"192\":\"16#qt-中的-model-view-与-mvc\",\"193\":\"16#自定义模型\",\"194\":\"16#代理模型\",\"195\":\"16@0\",\"196\":\"16@1\",\"197\":\"17\",\"198\":\"17@0\",\"199\":\"18\",\"200\":\"18#_1-static-关键字的作用\",\"201\":\"18#_2-new-delete与malloc-new的区别\",\"202\":\"18#_3-假设有数组-int-a-10-a、-a-0-与-a-这3者的区别\",\"203\":\"18#_4-宏与constexpr-区别\",\"204\":\"18#_5-extern-c\",\"205\":\"18#_6-const-关键字的作用\",\"206\":\"18#继承与多态\",\"207\":\"18#c-的多态如何实现\",\"208\":\"18#基类的虚函数表存放在内存的什么区-虚表指针vptr的初始化时间\",\"209\":\"18#构造函数和析构函数可以调用虚函数\",\"210\":\"18#构造函数为什么不能为虚函数-析构函数为什么要虚函数\",\"211\":\"18@0\",\"212\":\"18@1\",\"213\":\"19\",\"214\":\"19#进程状态\",\"215\":\"19#进程的基本状态\",\"216\":\"19#进程状态之间的转换\",\"217\":\"19#状态转换示意图\",\"218\":\"19#僵尸进程\",\"219\":\"19#僵尸进程的影响\",\"220\":\"19#如何避免产生僵尸进程\",\"221\":\"19#守护进程\",\"222\":\"19#代码示例\",\"223\":\"19#代码解释\",\"224\":\"19#注意事项\",\"225\":\"19#进程间通信\",\"226\":\"19#_1-管道-pipes\",\"227\":\"19#_2-消息队列-message-queues\",\"228\":\"19#_3-共享内存-shared-memory\",\"229\":\"19#_4-信号量-semaphores\",\"230\":\"19#_5-信号-signals\",\"231\":\"19#_6-套接字-sockets\",\"232\":\"19#总结\",\"233\":\"19@0\",\"234\":\"19@1\",\"235\":\"20\",\"236\":\"20#如何创建线程\",\"237\":\"20#线程同步机制\",\"238\":\"20#_1-互斥量-mutex\",\"239\":\"20#_2-读写锁-shared-mutex\",\"240\":\"20#_3-条件变量-condition-variable\",\"241\":\"20#_4-原子操作-atomic-operations\",\"242\":\"20#_5-信号量-semaphore\",\"243\":\"20#_6-自旋锁-spinlock\",\"244\":\"20#_7-屏障-barrier\",\"245\":\"20#_8-锁存器-latch\",\"246\":\"20#死锁\",\"247\":\"20#无锁编程\",\"248\":\"20#_1-基本概念\",\"249\":\"20#_2-c-中的原子操作\",\"250\":\"20#_3-使用原子变量实现无锁队列\",\"251\":\"20#_4-代码结构和作用\",\"252\":\"20#_5-内存顺序-memory-order\",\"253\":\"20@0\",\"254\":\"20@1\",\"255\":\"21\",\"256\":\"21#新增线程编程相关模块\",\"257\":\"21#std-thread相关\",\"258\":\"21#std-mutex相关\",\"259\":\"21#std-lock相关\",\"260\":\"21#std-atomic相关\",\"261\":\"21#std-call-once相关\",\"262\":\"21#std-condition-variable相关\",\"263\":\"21#std-future相关\",\"264\":\"21#async相关\",\"265\":\"21#性能优化\",\"266\":\"21#内存管理-智能指针\",\"267\":\"21#std-shared-ptr\",\"268\":\"21#std-unqi-ptr\",\"269\":\"21#std-weak-ptr\",\"270\":\"21#右值引用和移动语义\",\"271\":\"21#容器新增-操作减少内存拷贝和移动\",\"272\":\"21#语法糖\",\"273\":\"21#可变模块参数\",\"274\":\"21#auto-自动推导\",\"275\":\"21#for-range-容器遍历\",\"276\":\"21#lamada-匿名函数\",\"277\":\"21#enum\",\"278\":\"21@0\",\"279\":\"21@1\",\"280\":\"22\",\"281\":\"22@0\",\"282\":\"23\",\"283\":\"23@1\",\"284\":\"24\",\"285\":\"24#什么是-constexpr\",\"286\":\"24#编译时加密与运行时解密的工作原理\",\"287\":\"24#实现示例\",\"288\":\"24#代码详解\",\"289\":\"24@0\",\"290\":\"24@1\",\"291\":\"25\",\"292\":\"25#tcp状态图解释\",\"293\":\"25#状态转换图\",\"294\":\"25#状态转换的简要说明\",\"295\":\"25#状态的作用\",\"296\":\"25#总结\",\"297\":\"25@0\",\"298\":\"25@1\",\"299\":\"26\",\"300\":\"26#waitpid-的语法\",\"301\":\"26#waitpid-的返回值\",\"302\":\"26#status-变量解释\",\"303\":\"26#示例代码\",\"304\":\"26#代码解释\",\"305\":\"26#waitpid-的常见应用\",\"306\":\"26#总结\",\"307\":\"26@0\",\"308\":\"26@1\",\"309\":\"27\",\"310\":\"27#常用-git-命令及其说明\",\"311\":\"27#repository-操作\",\"312\":\"27#修改管理\",\"313\":\"27#_1-git-add\",\"314\":\"27#_2-git-commit\",\"315\":\"27#_3-git-status\",\"316\":\"27#_4-git-log\",\"317\":\"27#_5-git-diff\",\"318\":\"27#_6-git-checkout\",\"319\":\"27#_7-git-stash\",\"320\":\"27#_8-git-reset\",\"321\":\"27#分支管理\",\"322\":\"27#_1-git-checkout\",\"323\":\"27#_2-git-branch\",\"324\":\"27#_3-git-merge\",\"325\":\"27#_4-git-rebase\",\"326\":\"27#数据同步\",\"327\":\"27#_1-git-pull\",\"328\":\"27#_2-git-push\",\"329\":\"27#_3-git-fetch\",\"330\":\"27#管理-submodule\",\"331\":\"27#_1-添加-submodule\",\"332\":\"27#_2-初始化和更新-submodule\",\"333\":\"27#_3-查看-submodule-状态\",\"334\":\"27#_4-更新-submodule-到最新版本\",\"335\":\"27#_5-删除-submodule\",\"336\":\"27#_6-将-submodule-更新到特定的-commit\",\"337\":\"27#_7-嵌套-submodule\",\"338\":\"27#_8-处理-submodule-的常见问题\",\"339\":\"27@0\",\"340\":\"27@1\",\"341\":\"28\",\"342\":\"28#_1-安装-cmake\",\"343\":\"28#_2-cmake-基本概念\",\"344\":\"28#_3-cmakelists-txt-的基本结构\",\"345\":\"28#_4-编写简单的-cmake-项目\",\"346\":\"28#_4-1-项目结构\",\"347\":\"28#_4-2-main-cpp-示例\",\"348\":\"28#_4-3-cmakelists-txt-示例\",\"349\":\"28#_5-生成并构建项目\",\"350\":\"28#_5-1-创建构建目录\",\"351\":\"28#_5-2-运行-cmake-命令\",\"352\":\"28#_5-3-构建项目\",\"353\":\"28#_6-常用-cmake-命令\",\"354\":\"28#_7-查找包和依赖项\",\"355\":\"28#_8-自定义编译选项\",\"356\":\"28#_9-安装目标\",\"357\":\"28#_10-常见生成器\",\"358\":\"28@0\",\"359\":\"28@1\",\"360\":\"29\",\"361\":\"29#波形绘制中-用到了策略模式-模版方法\",\"362\":\"29#工厂方法模式-内存池-用于创建频繁的对象\",\"363\":\"29#利用观察者模式-实现preference-配置更改的更新\",\"364\":\"29#拨测任务执行中用到了桥接模式-将任务逻辑和浏览器实现进行分离\",\"365\":\"29@0\",\"366\":\"29@1\",\"367\":\"30\",\"368\":\"30#环境准备\",\"369\":\"30#编译-linux-内核源码\",\"370\":\"30#启动文件系统制作\",\"371\":\"30#安装-qemu\",\"372\":\"30#使用-qemu-启动内核\",\"373\":\"30#使用-gdb-调试内核\",\"374\":\"30#常用-gdb-命令\",\"375\":\"30#参考\",\"376\":\"30@0\",\"377\":\"30@1\",\"378\":\"31\",\"379\":\"31@0\",\"380\":\"32\",\"381\":\"32@0\",\"382\":\"33\",\"383\":\"34\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,10],\"1\":[1,6],\"2\":[1,4],\"3\":[1,7],\"4\":[1,4],\"5\":[null,null,7],\"6\":[1],\"7\":[1,8],\"8\":[1],\"9\":[1,23],\"10\":[1,38],\"11\":[1,35],\"12\":[1,49],\"13\":[1,19],\"14\":[1,23],\"15\":[1,36],\"16\":[1,30],\"17\":[1,37],\"18\":[1,69],\"19\":[1],\"20\":[1,37],\"21\":[1,27],\"22\":[1,30],\"23\":[1,36],\"24\":[1,26],\"25\":[3,22],\"26\":[1,42],\"27\":[1,59],\"28\":[1,49],\"29\":[1],\"30\":[1,21],\"31\":[1,17],\"32\":[1,29],\"33\":[1,18],\"34\":[1,37],\"35\":[1,38],\"36\":[2,215],\"37\":[null,null,1],\"38\":[null,null,4],\"39\":[1],\"40\":[1,17],\"41\":[1,34],\"42\":[1,6],\"43\":[1,78],\"44\":[1,127],\"45\":[1,15],\"46\":[1,21],\"47\":[1,45],\"48\":[1,13],\"49\":[1,73],\"50\":[1,49],\"51\":[1,56],\"52\":[1,16],\"53\":[1,21],\"54\":[2,55],\"55\":[null,null,1],\"56\":[null,null,3],\"57\":[1],\"58\":[1,54],\"59\":[1,54],\"60\":[1,117],\"61\":[1,75],\"62\":[1,27],\"63\":[1,152],\"64\":[1,12],\"65\":[1,186],\"66\":[1,26],\"67\":[1,32],\"68\":[1,29],\"69\":[1,35],\"70\":[1,60],\"71\":[1,110],\"72\":[1,61],\"73\":[1,95],\"74\":[1,70],\"75\":[2,85],\"76\":[null,null,1],\"77\":[null,null,3],\"78\":[1],\"79\":[1,58],\"80\":[1,50],\"81\":[1],\"82\":[1,23],\"83\":[1,26],\"84\":[1],\"85\":[1,21],\"86\":[1,9],\"87\":[1,7],\"88\":[1,40],\"89\":[1,15],\"90\":[1,6],\"91\":[1,59],\"92\":[1,72],\"93\":[1,102],\"94\":[1,25],\"95\":[1,28],\"96\":[1,8],\"97\":[3,50],\"98\":[2,10],\"99\":[1,44],\"100\":[1,33],\"101\":[2,24],\"102\":[1,53],\"103\":[1,46],\"104\":[1,11],\"105\":[1,10],\"106\":[1,56],\"107\":[2],\"108\":[1,42],\"109\":[1,45],\"110\":[1,4],\"111\":[2,12],\"112\":[1,60],\"113\":[2,138],\"114\":[null,null,1],\"115\":[null,null,1],\"116\":[1],\"117\":[null,null,1],\"118\":[1],\"119\":[null,null,1],\"120\":[2,6],\"121\":[1,17],\"122\":[1,25],\"123\":[null,null,2],\"124\":[1],\"125\":[1,17],\"126\":[1,40],\"127\":[1,17],\"128\":[null,null,1],\"129\":[null,null,3],\"130\":[1],\"131\":[1,12],\"132\":[1,24],\"133\":[1,53],\"134\":[null,null,1],\"135\":[null,null,4],\"136\":[1],\"137\":[1,9],\"138\":[1,8],\"139\":[1,48],\"140\":[null,null,1],\"141\":[null,null,3],\"142\":[1],\"143\":[1,13],\"144\":[1,19],\"145\":[1,61],\"146\":[null,null,1],\"147\":[null,null,3],\"148\":[1],\"149\":[1,9],\"150\":[1,21],\"151\":[1,69],\"152\":[null,null,1],\"153\":[null,null,3],\"154\":[1],\"155\":[1,6],\"156\":[1,5],\"157\":[1,13],\"158\":[1,49],\"159\":[1,4],\"160\":[1,13],\"161\":[1,75],\"162\":[null,null,1],\"163\":[null,null,4],\"164\":[1],\"165\":[1,12],\"166\":[1,18],\"167\":[1,76],\"168\":[1,32],\"169\":[null,null,1],\"170\":[null,null,3],\"171\":[2,29],\"172\":[2,15],\"173\":[4,19],\"174\":[4,21],\"175\":[4,23],\"176\":[2,25],\"177\":[5,51],\"178\":[2],\"179\":[2,22],\"180\":[2,14],\"181\":[5,62],\"182\":[1,18],\"183\":[null,null,1],\"184\":[null,null,2],\"185\":[3,15],\"186\":[3],\"187\":[3,57],\"188\":[3,44],\"189\":[3,55],\"190\":[3,29],\"191\":[1,22],\"192\":[6,21],\"193\":[1,58],\"194\":[1,46],\"195\":[null,null,1],\"196\":[null,null,4],\"197\":[1],\"198\":[null,null,1],\"199\":[2],\"200\":[4,10],\"201\":[5,17],\"202\":[9,21],\"203\":[4,7],\"204\":[4,23],\"205\":[4,8],\"206\":[1],\"207\":[1,98],\"208\":[2,33],\"209\":[2,17],\"210\":[3,96],\"211\":[null,null,1],\"212\":[null,null,1],\"213\":[1],\"214\":[1],\"215\":[1,29],\"216\":[1,37],\"217\":[1],\"218\":[1,32],\"219\":[1,12],\"220\":[2,102],\"221\":[1,14],\"222\":[1,84],\"223\":[1,43],\"224\":[1,20],\"225\":[1,14],\"226\":[2,65],\"227\":[2,64],\"228\":[2,64],\"229\":[2,74],\"230\":[2,35],\"231\":[2,70],\"232\":[1,14],\"233\":[null,null,1],\"234\":[null,null,3],\"235\":[1],\"236\":[2,71],\"237\":[1],\"238\":[1,62],\"239\":[1,78],\"240\":[1,90],\"241\":[1,64],\"242\":[1,74],\"243\":[4,78],\"244\":[1,61],\"245\":[1,64],\"246\":[1,32],\"247\":[1,11],\"248\":[2,26],\"249\":[3,13],\"250\":[2,80],\"251\":[2,131],\"252\":[1,26],\"253\":[null,null,1],\"254\":[null,null,3],\"255\":[2],\"256\":[1,14],\"257\":[2,94],\"258\":[2,53],\"259\":[2,55],\"260\":[2,32],\"261\":[3,31],\"262\":[3,50],\"263\":[2,74],\"264\":[1,111],\"265\":[1],\"266\":[1,24],\"267\":[1,24],\"268\":[1,19],\"269\":[1,30],\"270\":[1,47],\"271\":[2,54],\"272\":[1],\"273\":[1,20],\"274\":[1,17],\"275\":[1,20],\"276\":[1,6],\"277\":[1,33],\"278\":[null,null,1],\"279\":[null,null,3],\"280\":[1],\"281\":[null,null,1],\"282\":[2],\"283\":[null,null,2],\"284\":[2,10],\"285\":[1,11],\"286\":[1,10],\"287\":[1,57],\"288\":[1,40],\"289\":[null,null,1],\"290\":[null,null,3],\"291\":[2,11],\"292\":[1,61],\"293\":[1,2],\"294\":[1,39],\"295\":[1,22],\"296\":[1,9],\"297\":[null,null,1],\"298\":[null,null,1],\"299\":[1,8],\"300\":[1,48],\"301\":[1,15],\"302\":[1,23],\"303\":[1,60],\"304\":[1,24],\"305\":[1,16],\"306\":[1,8],\"307\":[null,null,1],\"308\":[null,null,1],\"309\":[2,6],\"310\":[3],\"311\":[2,33],\"312\":[1],\"313\":[2,13],\"314\":[2,24],\"315\":[2,10],\"316\":[2,12],\"317\":[2,9],\"318\":[2,11],\"319\":[2,10],\"320\":[2,15],\"321\":[1],\"322\":[2,11],\"323\":[2,14],\"324\":[2,9],\"325\":[2,8],\"326\":[1],\"327\":[2,12],\"328\":[2,8],\"329\":[2,9],\"330\":[2,11],\"331\":[2,24],\"332\":[2,19],\"333\":[2,11],\"334\":[2,21],\"335\":[2,23],\"336\":[2,24],\"337\":[2,5],\"338\":[2,26],\"339\":[null,null,1],\"340\":[null,null,1],\"341\":[2,18],\"342\":[2,19],\"343\":[2,26],\"344\":[2,33],\"345\":[2],\"346\":[3,9],\"347\":[3,18],\"348\":[3,19],\"349\":[2],\"350\":[3,9],\"351\":[5,11],\"352\":[3,12],\"353\":[2,31],\"354\":[2,22],\"355\":[2,10],\"356\":[2,10],\"357\":[2,34],\"358\":[null,null,1],\"359\":[null,null,1],\"360\":[1],\"361\":[2,60],\"362\":[4,23],\"363\":[3,29],\"364\":[2,55],\"365\":[null,null,1],\"366\":[null,null,1],\"367\":[1,12],\"368\":[1,16],\"369\":[3,44],\"370\":[1,79],\"371\":[2,12],\"372\":[3,62],\"373\":[3,43],\"374\":[3,37],\"375\":[2,3],\"376\":[null,null,1],\"377\":[null,null,4],\"378\":[1],\"379\":[null,null,1],\"380\":[1],\"381\":[null,null,1],\"382\":[1,133],\"383\":[1,3]},\"averageFieldLength\":[1.5133763112251477,36.357314966775284,1.376200435090703],\"storedFields\":{\"0\":{\"h\":\"首页\",\"t\":[\"本站是一个面向 c++ 程序员的知识库，主要包含一些基本的 c++ 面试题和数据结构算法。其目的在于帮助想学习 c++ 编程同学，掌握一些基本的算法和数据结构。主要有以下几部分：\"]},\"1\":{\"h\":\"面试集锦\",\"t\":[\"c++面试题\",\"线程编程\",\"进程编程\",\"c++ 11 新特性\"]},\"2\":{\"h\":\"数据结构\",\"t\":[\"数组与链表\",\"队列与栈\",\"哈希表\",\"二叉树\"]},\"3\":{\"h\":\"架构设计\",\"t\":[\"设计原则\",\"观察者模式\",\"策略模式\",\"装饰器模式\",\"桥接模式\",\"工厂模式\",\"责任链模式\"]},\"4\":{\"h\":\"其他\",\"t\":[\"Linux 命令\",\"constexpr 实现编译时加密\"]},\"5\":{\"c\":[\"c++\",\"面试\",\"数据结构\",\"多线程\",\"c++11\",\"多进程\",\"设计模式\"]},\"6\":{\"h\":\"数组与链表\"},\"7\":{\"h\":\"数组\",\"t\":[\"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。下图展示了数组的主要概念和存储方式。\",\"数组定义与存储方式\"]},\"8\":{\"h\":\"数组常用操作\"},\"9\":{\"h\":\"初始化数组\",\"t\":[\"我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 0 ：\",\"/* 初始化数组 */ // 存储在栈上 int arr[5]; int nums[5] = { 1, 3, 2, 5, 4 }; // 存储在堆上（需要手动释放空间） int* arr1 = new int[5]; int* nums1 = new int[5] { 1, 3, 2, 5, 4 };\"]},\"10\":{\"h\":\"访问元素\",\"t\":[\"数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问该元素。\",\"数组元素的内存地址计算\",\"观察上图，我们发现数组首个元素的索引为 0 ，这似乎有些反直觉，因为从 1 开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是 0 ，因此它的索引为 0 是合理的。\",\"在数组中访问元素非常高效，我们可以在 O(1) 时间内随机访问数组中的任意一个元素。\",\"/* 随机访问元素 */ int randomAccess(int *nums, int size) { // 在区间 [0, size) 中随机抽取一个数字 int randomIndex = rand() % size; // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum; }\"]},\"11\":{\"h\":\"插入元素\",\"t\":[\"数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。\",\"数组插入元素示例\",\"值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素“丢失”。我们将这个问题的解决方案留在“列表”章节中讨论。\",\"/* 在数组的索引 index 处插入元素 num */ void insert(int *nums, int size, int num, int index) { // 把索引 index 以及之后的所有元素向后移动一位 for (int i = size - 1; i > index; i--) { nums[i] = nums[i - 1]; } // 将 num 赋给 index 处的元素 nums[index] = num; }\"]},\"12\":{\"h\":\"删除元素\",\"t\":[\"同理，如下图所示，若想删除索引 i 处的元素，则需要把索引 i 之后的元素都向前移动一位。\",\"数组删除元素示例\",\"请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。\",\"/* 删除索引 index 处的元素 */ void remove(int *nums, int size, int index) { // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i < size - 1; i++) { nums[i] = nums[i + 1]; } }\",\"总的来看，数组的插入与删除操作有以下缺点。\",\"时间复杂度高：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n 为数组长度。\",\"丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。\",\"内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费。\"]},\"13\":{\"h\":\"遍历数组\",\"t\":[\"在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：\",\"/* 遍历数组 */ void traverse(int *nums, int size) { int count = 0; // 通过索引遍历数组 for (int i = 0; i < size; i++) { count += nums[i]; } }\"]},\"14\":{\"h\":\"查找元素\",\"t\":[\"在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。\",\"因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。\",\"/* 在数组中查找指定元素 */ int find(int *nums, int size, int target) { for (int i = 0; i < size; i++) { if (nums[i] == target) return i; } return -1; }\"]},\"15\":{\"h\":\"扩容数组\",\"t\":[\"在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的。\",\"如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 O(n) 的操作，在数组很大的情况下非常耗时。代码如下所示：\",\"/* 扩展数组长度 */ int *extend(int *nums, int size, int enlarge) { // 初始化一个扩展长度后的数组 int *res = new int[size + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i < size; i++) { res[i] = nums[i]; } // 释放内存 delete[] nums; // 返回扩展后的新数组 return res; }\"]},\"16\":{\"h\":\"数组的优点与局限性\",\"t\":[\"数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\",\"空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\",\"支持随机访问：数组允许在 O(1) 时间内访问任何元素。\",\"缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\",\"连续空间存储是一把双刃剑，其存在以下局限性。\",\"插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\",\"长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\",\"空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\"]},\"17\":{\"h\":\"数组典型应用\",\"t\":[\"数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\",\"随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\",\"排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\",\"查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\",\"机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\",\"数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\"]},\"18\":{\"h\":\"链表\",\"t\":[\"内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。\",\"链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。\",\"链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。\",\"链表定义与存储方式\",\"观察上图，链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\",\"链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\",\"尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\",\"在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\",\"如以下代码所示，链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间。\",\"/* 链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向下一节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数 };\"]},\"19\":{\"h\":\"链表常用操作\"},\"20\":{\"h\":\"初始化链表\",\"t\":[\"建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点。\",\" /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */ // 初始化各个节点 ListNode* n0 = new ListNode(1); ListNode* n1 = new ListNode(3); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(5); ListNode* n4 = new ListNode(4); // 构建节点之间的引用 n0->next = n1; n1->next = n2; n2->next = n3; n3->next = n4;\",\"数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0 。\"]},\"21\":{\"h\":\"插入节点\",\"t\":[\"在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为 O(1)。\",\"相比之下，在数组中插入元素的时间复杂度为 O(n) ，在大数据量下的效率较低。\",\"链表插入节点示例\",\"/* 在链表的节点 n0 之后插入节点 P */ void insert(ListNode *n0, ListNode *P) { ListNode *n1 = n0->next; P->next = n1; n0->next = P; }\"]},\"22\":{\"h\":\"删除节点\",\"t\":[\"如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。\",\"请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\",\"链表删除节点\",\"/* 删除链表的节点 n0 之后的首个节点 */ void remove(ListNode *n0) { if (n0->next == nullptr) return; // n0 -> P -> n1 ListNode *P = n0->next; ListNode *n1 = P->next; n0->next = n1; // 释放内存 delete P; }\"]},\"23\":{\"h\":\"访问节点\",\"t\":[\"在链表中访问节点的效率较低。如上一节所述，我们可以在 O(1) 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i 个节点需要循环 i−1 轮，时间复杂度为 O(n) 。\",\"/* 访问链表中索引为 index 的节点 */ ListNode *access(ListNode *head, int index) { for (int i = 0; i < index; i++) { if (head == nullptr) return nullptr; head = head->next; } return head; }\"]},\"24\":{\"h\":\"查找节点\",\"t\":[\"遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找。代码如下所示：\",\"/* 在链表中查找值为 target 的首个节点 */ int find(ListNode *head, int target) { int index = 0; while (head != nullptr) { if (head->val == target) return index; head = head->next; index++; } return -1; }\"]},\"25\":{\"h\":\"数组 vs. 链表\",\"t\":[\"下表总结了数组和链表的各项特点并对比了操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。\",\"数组\",\"链表\",\"存储方式\",\"连续内存空间\",\"分散内存空间\",\"容量扩展\",\"长度不可变\",\"可灵活扩展\",\"内存效率\",\"元素占用内存少、但可能浪费空间\",\"元素占用内存多\",\"访问元素\",\"O(1)\",\"O(n)\",\"添加元素\",\"O(n)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(1)\"]},\"26\":{\"h\":\"常见链表类型\",\"t\":[\"如下图所示，常见的链表类型包括三种。\",\"单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\",\"环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\",\"双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\",\"/* 双向链表节点结构体 */ struct ListNode { int val; // 节点值 ListNode *next; // 指向后继节点的指针 ListNode *prev; // 指向前驱节点的指针 ListNode(int x) : val(x), next(nullptr), prev(nullptr) {} // 构造函数 };\",\"常见链表种类\"]},\"27\":{\"h\":\"链表典型应用\",\"t\":[\"单向链表通常用于实现栈、队列、哈希表和图等数据结构。\",\"栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。\",\"哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\",\"图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\",\"双向链表常用于需要快速查找前一个和后一个元素的场景。\",\"高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\",\"浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\",\"LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\",\"环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\",\"时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\",\"数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\"]},\"28\":{\"h\":\"列表\",\"t\":[\"列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。\",\"链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。\",\"数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。\",\"当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。\",\"为解决此问题，我们可以使用**动态数组（dynamic array）**来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\",\"实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。\"]},\"29\":{\"h\":\"列表常用操作\"},\"30\":{\"h\":\"初始化列表\",\"t\":[\"我们通常使用“无初始值”和“有初始值”这两种初始化方法：\",\"/* 初始化列表 */ // 需注意，C++ 中 vector 即是本文描述的 nums // 无初始值 vector<int> nums1; // 有初始值 vector<int> nums = { 1, 3, 2, 5, 4 };\"]},\"31\":{\"h\":\"访问元素\",\"t\":[\"列表本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。\",\" /* 访问元素 */ int num = nums[1]; // 访问索引 1 处的元素 /* 更新元素 */ nums[1] = 0; // 将索引 1 处的元素更新为 0\"]},\"32\":{\"h\":\"插入与删除元素\",\"t\":[\"相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。\",\"/* 清空列表 */ nums.clear(); /* 在尾部添加元素 */ nums.push_back(1); nums.push_back(3); nums.push_back(2); nums.push_back(5); nums.push_back(4); /* 在中间插入元素 */ nums.insert(nums.begin() + 3, 6); // 在索引 3 处插入数字 6 /* 删除元素 */ nums.erase(nums.begin() + 3); // 删除索引 3 处的元素\"]},\"33\":{\"h\":\"遍历列表\",\"t\":[\"与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。\",\" /* 通过索引遍历列表 */ int count = 0; for (int i = 0; i < nums.size(); i++) { count += nums[i]; } /* 直接遍历列表元素 */ count = 0; for (int num : nums) { count += num; }\"]},\"34\":{\"h\":\"列表实现\",\"t\":[\"许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。\",\"为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\",\"初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。\",\"数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\",\"扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。\"]},\"35\":{\"h\":\"重点回顾\",\"t\":[\"数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。\",\"数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。\",\"链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。\",\"列表是一种支持增删查改的元素有序集合，通常基于动态数组实现。它保留了数组的优势，同时可以灵活调整长度。\",\"列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。\",\"程序运行时，数据主要存储在内存中。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。\",\"缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。\",\"由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。\"]},\"36\":{\"h\":\"Q & A\",\"t\":[\"Q：数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？\",\"存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。\",\"分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。\",\"大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。\",\"灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。\",\"Q：为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？\",\"链表由节点组成，节点之间通过引用（指针）连接，各个节点可以存储不同类型的数据，例如 int、double、string、object 等。\",\"相对地，数组元素则必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节 和 8 字节 ，此时就不能用以下公式计算偏移量了，因为数组中包含了两种“元素长度”。\",\"# 元素内存地址 = 数组内存地址（首元素内存地址） + 元素长度 * 元素索引\",\"Q：删除节点 P 后，是否需要把 P.next 设为 None 呢？\",\"不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。\",\"从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。\",\"Q：在链表中插入和删除操作的时间复杂度是 O(1) 。但是增删之前都需要 O(n) 的时间查找元素，那为什么时间复杂度不是 O(n) 呢？\",\"如果是先查找元素、再删除元素，时间复杂度确实是 O(n) 。然而，链表的 O(1) 增删的优势可以在其他应用上得到体现。例如，双向队列适合使用链表实现，我们维护一个指针变量始终指向头节点、尾节点，每次插入与删除操作都是 O(1) 。\",\"Q：图“链表定义与存储方式”中，浅蓝色的存储节点指针是占用一块内存地址吗？还是和节点值各占一半呢？\",\"该示意图只是定性表示，定量表示需要根据具体情况进行分析。\",\"不同类型的节点值占用的空间是不同的，比如 int、long、double 和实例对象等。\",\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定，大多为 8 字节或 4 字节。\",\"Q：在列表末尾添加元素是否时时刻刻都为 O(1) ？\",\"如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 O(n) 。\",\"Q：“列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？\",\"这里的空间浪费主要有两方面含义：一方面，列表都会设定一个初始长度，我们不一定需要用这么多；另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 ×1.5 。这样一来，也会出现很多空位，我们通常不能完全填满它们。\",\"Q：在 Python 中初始化 n = [1, 2, 3] 后，这 3 个元素的地址是相连的，但是初始化 m = [2, 1, 3] 会发现它们每个元素的 id 并不是连续的，而是分别跟 n 中的相同。这些元素的地址不连续，那么 m 还是数组吗？\",\"假如把列表元素换成链表节点 n = [n1, n2, n3, n4, n5] ，通常情况下这 5 个节点对象也分散存储在内存各处。然而，给定一个列表索引，我们仍然可以在 O(1) 时间内获取节点内存地址，从而访问到对应的节点。这是因为数组中存储的是节点的引用，而非节点本身。\",\"与许多语言不同，Python 中的数字也被包装为对象，列表中存储的不是数字本身，而是对数字的引用。因此，我们会发现两个数组中的相同数字拥有同一个 id ，并且这些数字的内存地址无须连续。\",\"Q：C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？\",\"一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。\",\"空间开销：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以 std::list 通常比 std::vector 更占用空间。\",\"缓存不友好：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下，std::vector 的性能会更好。\",\"另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。\",\"Q：初始化列表 res = [0] * self.size() 操作，会导致 res 的每个元素引用相同的地址吗？\",\"不会。但二维数组会有这个问题，例如初始化二维列表 res = [[0]] * self.size() ，则多次引用了同一个列表 [0] 。\"]},\"37\":{\"c\":[\"数据结构\"]},\"38\":{\"c\":[\"c++\",\"线性结构\",\"数组\",\"链表\"]},\"39\":{\"h\":\"队列和栈\"},\"40\":{\"h\":\"队列\",\"t\":[\"队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\",\"如下图所示，我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。\",\"队列的先入先出规则\"]},\"41\":{\"h\":\"队列常用操作\",\"t\":[\"队列的常见操作如下表所示。需要注意的是，不同编程语言的方法名称可能会有所不同。我们在此采用与栈相同的方法命名。\",\"方法名\",\"描述\",\"时间复杂度\",\"push()\",\"元素入队，即将元素添加至队尾\",\"O(1)\",\"pop()\",\"队首元素出队\",\"O(1)\",\"peek()\",\"访问队首元素\",\"O(1)\",\"我们可以直接使用编程语言中现成的队列类：\",\" /* 初始化队列 */ queue<int> queue; /* 元素入队 */ queue.push(1); queue.push(3); queue.push(2); queue.push(5); queue.push(4); /* 访问队首元素 */ int front = queue.front(); /* 元素出队 */ queue.pop(); /* 获取队列的长度 */ int size = queue.size(); /* 判断队列是否为空 */ bool empty = queue.empty();\"]},\"42\":{\"h\":\"队列实现\",\"t\":[\"为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素，链表和数组都符合要求。\"]},\"43\":{\"h\":\"基于链表的实现\",\"t\":[\"如下图所示，我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。\",\"基于链表实现队列的入队出队操作\",\"linkedlist_queue_push\",\"linkedlist_queue_pop\",\"以下是用链表实现队列的代码：\",\"/* 基于链表实现的队列 */ class LinkedListQueue { private: ListNode *front, *rear; // 头节点 front ，尾节点 rear int queSize; public: LinkedListQueue() { front = nullptr; rear = nullptr; queSize = 0; } ~LinkedListQueue() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(front); } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return queSize == 0; } /* 入队 */ void push(int num) { // 在尾节点后添加 num ListNode *node = new ListNode(num); // 如果队列为空，则令头、尾节点都指向该节点 if (front == nullptr) { front = node; rear = node; } // 如果队列不为空，则将该节点添加到尾节点后 else { rear->next = node; rear = node; } queSize++; } /* 出队 */ int pop() { int num = peek(); // 删除头节点 ListNode *tmp = front; front = front->next; // 释放内存 delete tmp; queSize--; return num; } /* 访问队首元素 */ int peek() { if (size() == 0) throw out_of_range(\\\"队列为空\\\"); return front->val; } /* 将链表转化为 Vector 并返回 */ vector<int> toVector() { ListNode *node = front; vector<int> res(size()); for (int i = 0; i < res.size(); i++) { res[i] = node->val; node = node->next; } return res; } };\"]},\"44\":{\"h\":\"基于数组的实现\",\"t\":[\"在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。\",\"我们可以使用一个变量 front 指向队首元素的索引，并维护一个变量 size 用于记录队列长度。定义 rear = front + size ，这个公式计算出的 rear 指向队尾元素之后的下一个位置。\",\"基于此设计，数组中包含元素的有效区间为 [front, rear - 1]，各种操作的实现方法如下图所示。\",\"入队操作：将输入元素赋值给 rear 索引处，并将 size 增加 1 。\",\"出队操作：只需将 front 增加 1 ，并将 size 减少 1 。\",\"可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1) 。\",\"你可能会发现一个问题：在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。\",\"对于环形数组，我们需要让 front 或 rear 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示：\",\"/* 基于环形数组实现的队列 */ class ArrayQueue { private: int *nums; // 用于存储队列元素的数组 int front; // 队首指针，指向队首元素 int queSize; // 队列长度 int queCapacity; // 队列容量 public: ArrayQueue(int capacity) { // 初始化数组 nums = new int[capacity]; queCapacity = capacity; front = queSize = 0; } ~ArrayQueue() { delete[] nums; } /* 获取队列的容量 */ int capacity() { return queCapacity; } /* 获取队列的长度 */ int size() { return queSize; } /* 判断队列是否为空 */ bool isEmpty() { return size() == 0; } /* 入队 */ void push(int num) { if (queSize == queCapacity) { cout << \\\"队列已满\\\" << endl; return; } // 计算队尾指针，指向队尾索引 + 1 // 通过取余操作实现 rear 越过数组尾部后回到头部 int rear = (front + queSize) % queCapacity; // 将 num 添加至队尾 nums[rear] = num; queSize++; } /* 出队 */ int pop() { int num = peek(); // 队首指针向后移动一位，若越过尾部，则返回到数组头部 front = (front + 1) % queCapacity; queSize--; return num; } /* 访问队首元素 */ int peek() { if (isEmpty()) throw out_of_range(\\\"队列为空\\\"); return nums[front]; } /* 将数组转化为 Vector 并返回 */ vector<int> toVector() { // 仅转换有效长度范围内的列表元素 vector<int> arr(queSize); for (int i = 0, j = front; i < queSize; i++, j++) { arr[i] = nums[j % queCapacity]; } return arr; } };\",\"以上实现的队列仍然具有局限性：其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的读者可以尝试自行实现。\",\"两种实现的对比结论与栈一致，在此不再赘述。\"]},\"45\":{\"h\":\"队列典型应用\",\"t\":[\"淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。\",\"各类待办事项。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。\"]},\"46\":{\"h\":\"栈\",\"t\":[\"栈（stack）是一种遵循先入后出逻辑的线性数据结构。\",\"我们可以将栈类比为桌面上的一摞盘子，如果想取出底部的盘子，则需要先将上面的盘子依次移走。我们将盘子替换为各种类型的元素（如整数、字符、对象等），就得到了栈这种数据结构。\",\"如下图所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。\",\"栈的先入后出规则\"]},\"47\":{\"h\":\"栈的常用操作\",\"t\":[\"栈的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。在此，我们以常见的 push()、pop()、peek() 命名为例。\",\"方法\",\"描述\",\"时间复杂度\",\"push()\",\"元素入栈（添加至栈顶）\",\"O(1)\",\"pop()\",\"栈顶元素出栈\",\"O(1)\",\"peek()\",\"访问栈顶元素\",\"O(1)\",\"通常情况下，我们可以直接使用编程语言内置的栈类。然而，某些语言可能没有专门提供栈类，这时我们可以将该语言的“数组”或“链表”当作栈来使用，并在程序逻辑上忽略与栈无关的操作。\",\" /* 初始化栈 */ stack<int> stack; /* 元素入栈 */ stack.push(1); stack.push(3); stack.push(2); stack.push(5); stack.push(4); /* 访问栈顶元素 */ int top = stack.top(); /* 元素出栈 */ stack.pop(); // 无返回值 /* 获取栈的长度 */ int size = stack.size(); /* 判断是否为空 */ bool empty = stack.empty();\"]},\"48\":{\"h\":\"栈的实现\",\"t\":[\"为了深入了解栈的运行机制，我们来尝试自己实现一个栈类。\",\"栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素。然而，数组和链表都可以在任意位置添加和删除元素，因此栈可以视为一种受限制的数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性。\"]},\"49\":{\"h\":\"基于链表的实现\",\"t\":[\"使用链表实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底。\",\"如下图所示，对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。\",\"基于链表实现栈的入栈出栈操作\",\"linkedlist_stack_push\",\"linkedlist_stack_pop\",\"以下是基于链表实现栈的示例代码：\",\"/* 基于链表实现的栈 */ class LinkedListStack { private: ListNode *stackTop; // 将头节点作为栈顶 int stkSize; // 栈的长度 public: LinkedListStack() { stackTop = nullptr; stkSize = 0; } ~LinkedListStack() { // 遍历链表删除节点，释放内存 freeMemoryLinkedList(stackTop); } /* 获取栈的长度 */ int size() { return stkSize; } /* 判断栈是否为空 */ bool isEmpty() { return size() == 0; } /* 入栈 */ void push(int num) { ListNode *node = new ListNode(num); node->next = stackTop; stackTop = node; stkSize++; } /* 出栈 */ int pop() { int num = top(); ListNode *tmp = stackTop; stackTop = stackTop->next; // 释放内存 delete tmp; stkSize--; return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stackTop->val; } /* 将 List 转化为 Array 并返回 */ vector<int> toVector() { ListNode *node = stackTop; vector<int> res(size()); for (int i = res.size() - 1; i >= 0; i--) { res[i] = node->val; node = node->next; } return res; } };\"]},\"50\":{\"h\":\"基于数组的实现\",\"t\":[\"使用数组实现栈时，我们可以将数组的尾部作为栈顶。如下图所示，入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为 O(1) 。\",\"基于数组实现栈的入栈出栈操作\",\"array_stack_push\",\"array_stack_pop\",\"由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。以下为示例代码：\",\"/* 基于数组实现的栈 */ class ArrayStack { private: vector<int> stack; public: /* 获取栈的长度 */ int size() { return stack.size(); } /* 判断栈是否为空 */ bool isEmpty() { return stack.size() == 0; } /* 入栈 */ void push(int num) { stack.push_back(num); } /* 出栈 */ int pop() { int num = top(); stack.pop_back(); return num; } /* 访问栈顶元素 */ int top() { if (isEmpty()) throw out_of_range(\\\"栈为空\\\"); return stack.back(); } /* 返回 Vector */ vector<int> toVector() { return stack; } };\"]},\"51\":{\"h\":\"两种实现对比\",\"t\":[\"支持操作\",\"两种实现都支持栈定义中的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到。\",\"时间效率\",\"在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为 O(n) 。\",\"在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。\",\"综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 int 或 double ，我们可以得出以下结论。\",\"基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。\",\"基于链表实现的栈可以提供更加稳定的效率表现。\",\"空间效率\",\"在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费。\",\"然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。\",\"综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。\"]},\"52\":{\"h\":\"栈的典型应用\",\"t\":[\"浏览器中的后退与前进、软件中的撤销与反撤销。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。\",\"程序内存管理。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。\"]},\"53\":{\"h\":\"重点回顾\",\"t\":[\"栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。\",\"在时间效率方面，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 O(n) 。相比之下，栈的链表实现具有更为稳定的效率表现。\",\"在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。\",\"队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。\",\"双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。\"]},\"54\":{\"h\":\"Q & A\",\"t\":[\"Q：浏览器的前进后退是否是双向链表实现？\",\"浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便地实现一些额外操作，这个在“双向队列”章节有提到。\",\"Q：在出栈后，是否需要释放出栈节点的内存？\",\"如果后续仍需要使用弹出节点，则不需要释放内存。若之后不需要用到，Java 和 Python 等语言拥有自动垃圾回收机制，因此不需要手动释放内存；在 C 和 C++ 中需要手动释放内存。\",\"Q：双向队列像是两个栈拼接在了一起，它的用途是什么？\",\"双向队列就像是栈和队列的组合或两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。\",\"Q：撤销（undo）和反撤销（redo）具体是如何实现的？\",\"使用两个栈，栈 A 用于撤销，栈 B 用于反撤销。\",\"每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。\",\"当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。\",\"当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。\"]},\"55\":{\"c\":[\"数据结构\"]},\"56\":{\"c\":[\"c++\",\"栈\",\"队列\"]},\"57\":{\"h\":\"哈希表\"},\"58\":{\"h\":\"哈希表\",\"t\":[\"哈希表（hash table），又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在 O(1) 时间内获取对应的值 value 。\",\"如下图所示，给定 n 个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。\",\"哈希表的抽象表示\",\"除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。\",\"添加元素：仅需将元素添加至数组（链表）的尾部即可，使用 O(1) 时间。\",\"查询元素：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 O(n) 时间。\",\"删除元素：需要先查询到元素，再从数组（链表）中删除，使用 O(n) 时间。\",\"数组\",\"链表\",\"哈希表\",\"查找元素\",\"O(n)\",\"O(n)\",\"O(1)\",\"添加元素\",\"O(1)\",\"O(1)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(n)\",\"O(1)\",\"观察发现，在哈希表中进行增删查改的时间复杂度都是 O(1) ，非常高效。\"]},\"59\":{\"h\":\"哈希表常用操作\",\"t\":[\"哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对等，示例代码如下：\",\" /* 初始化哈希表 */ unordered_map<int, string> map; /* 添加操作 */ // 在哈希表中添加键值对 (key, value) map[12836] = \\\"小哈\\\"; map[15937] = \\\"小啰\\\"; map[16750] = \\\"小算\\\"; map[13276] = \\\"小法\\\"; map[10583] = \\\"小鸭\\\"; /* 查询操作 */ // 向哈希表中输入键 key ，得到值 value string name = map[15937]; /* 删除操作 */ // 在哈希表中删除键值对 (key, value) map.erase(10583);\",\"哈希表有三种常用的遍历方式：遍历键值对、遍历键和遍历值。示例代码如下：\",\" /* 遍历哈希表 */ // 遍历键值对 key->value for (auto kv: map) { cout << kv.first << \\\" -> \\\" << kv.second << endl; } // 使用迭代器遍历 key->value for (auto iter = map.begin(); iter != map.end(); iter++) { cout << iter->first << \\\"->\\\" << iter->second << endl; }\"]},\"60\":{\"h\":\"哈希表简单实现\",\"t\":[\"我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。\",\"那么，如何基于 key 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置。\",\"输入一个 key ，哈希函数的计算过程分为以下两步。\",\"通过某种哈希算法 hash() 计算得到哈希值。\",\"将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。\",\"index = hash(key) % capacity\",\"随后，我们就可以利用 index 在哈希表中访问对应的桶，从而获取 value 。\",\"设数组长度 capacity = 100、哈希算法 hash(key) = key ，易得哈希函数为 key % 100 。下图以 key 学号和 value 姓名为例，展示了哈希函数的工作原理。\",\"哈希函数工作原理\",\"以下代码实现了一个简单哈希表。其中，我们将 key 和 value 封装成一个类 Pair ，以表示键值对。\",\"/* 键值对 */ struct Pair { public: int key; string val; Pair(int key, string val) { this->key = key; this->val = val; } }; /* 基于数组实现的哈希表 */ class ArrayHashMap { private: vector<Pair *> buckets; public: ArrayHashMap() { // 初始化数组，包含 100 个桶 buckets = vector<Pair *>(100); } ~ArrayHashMap() { // 释放内存 for (const auto &bucket : buckets) { delete bucket; } buckets.clear(); } /* 哈希函数 */ int hashFunc(int key) { int index = key % 100; return index; } /* 查询操作 */ string get(int key) { int index = hashFunc(key); Pair *pair = buckets[index]; if (pair == nullptr) return \\\"\\\"; return pair->val; } /* 添加操作 */ void put(int key, string val) { Pair *pair = new Pair(key, val); int index = hashFunc(key); buckets[index] = pair; } /* 删除操作 */ void remove(int key) { int index = hashFunc(key); // 释放内存并置为 nullptr delete buckets[index]; buckets[index] = nullptr; } /* 获取所有键值对 */ vector<Pair *> pairSet() { vector<Pair *> pairSet; for (Pair *pair : buckets) { if (pair != nullptr) { pairSet.push_back(pair); } } return pairSet; } /* 获取所有键 */ vector<int> keySet() { vector<int> keySet; for (Pair *pair : buckets) { if (pair != nullptr) { keySet.push_back(pair->key); } } return keySet; } /* 获取所有值 */ vector<string> valueSet() { vector<string> valueSet; for (Pair *pair : buckets) { if (pair != nullptr) { valueSet.push_back(pair->val); } } return valueSet; } /* 打印哈希表 */ void print() { for (Pair *kv : pairSet()) { cout << kv->key << \\\" -> \\\" << kv->val << endl; } } };\"]},\"61\":{\"h\":\"哈希冲突与扩容\",\"t\":[\"从本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。\",\"对于上述示例中的哈希函数，当输入的 key 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：\",\"12836 % 100 = 36 20336 % 100 = 36\",\"如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为哈希冲突（hash collision）。\",\"哈希冲突示例\",\"容易想到，哈希表容量 n 越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。\",\"如下图所示，扩容前键值对 (136, A) 和 (236, D) 发生冲突，扩容后冲突消失。\",\"哈希表扩容\",\"类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\",\"负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表扩容至原先的 2 倍。\"]},\"62\":{\"h\":\"哈希冲突\",\"t\":[\"通常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。\",\"哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。\",\"改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\",\"仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\",\"哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。\"]},\"63\":{\"h\":\"链式地址\",\"t\":[\"在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。下图展示了一个链式地址哈希表的例子。\",\"链式地址哈希表\",\"基于链式地址实现的哈希表的操作方法发生了以下变化。\",\"查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对。\",\"添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\",\"删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\",\"链式地址存在以下局限性。\",\"占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。\",\"查询效率降低：因为需要线性遍历链表来查找对应元素。\",\"以下代码给出了链式地址哈希表的简单实现，需要注意两点。\",\"使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。\",\"以下实现包含哈希表扩容方法。当负载因子超过 32​ 时，我们将哈希表扩容至原先的 2 倍。\",\"/* 链式地址哈希表 */ class HashMapChaining { private: int size; // 键值对数量 int capacity; // 哈希表容量 double loadThres; // 触发扩容的负载因子阈值 int extendRatio; // 扩容倍数 vector<vector<Pair *>> buckets; // 桶数组 public: /* 构造方法 */ HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) { buckets.resize(capacity); } /* 析构方法 */ ~HashMapChaining() { for (auto &bucket : buckets) { for (Pair *pair : bucket) { // 释放内存 delete pair; } } } /* 哈希函数 */ int hashFunc(int key) { return key % capacity; } /* 负载因子 */ double loadFactor() { return (double)size / (double)capacity; } /* 查询操作 */ string get(int key) { int index = hashFunc(key); // 遍历桶，若找到 key ，则返回对应 val for (Pair *pair : buckets[index]) { if (pair->key == key) { return pair->val; } } // 若未找到 key ，则返回空字符串 return \\\"\\\"; } /* 添加操作 */ void put(int key, string val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor() > loadThres) { extend(); } int index = hashFunc(key); // 遍历桶，若遇到指定 key ，则更新对应 val 并返回 for (Pair *pair : buckets[index]) { if (pair->key == key) { pair->val = val; return; } } // 若无该 key ，则将键值对添加至尾部 buckets[index].push_back(new Pair(key, val)); size++; } /* 删除操作 */ void remove(int key) { int index = hashFunc(key); auto &bucket = buckets[index]; // 遍历桶，从中删除键值对 for (int i = 0; i < bucket.size(); i++) { if (bucket[i]->key == key) { Pair *tmp = bucket[i]; bucket.erase(bucket.begin() + i); // 从中删除键值对 delete tmp; // 释放内存 size--; return; } } } /* 扩容哈希表 */ void extend() { // 暂存原哈希表 vector<vector<Pair *>> bucketsTmp = buckets; // 初始化扩容后的新哈希表 capacity *= extendRatio; buckets.clear(); buckets.resize(capacity); size = 0; // 将键值对从原哈希表搬运至新哈希表 for (auto &bucket : bucketsTmp) { for (Pair *pair : bucket) { put(pair->key, pair->val); // 释放内存 delete pair; } } } /* 打印哈希表 */ void print() { for (auto &bucket : buckets) { cout << \\\"[\\\"; for (Pair *pair : bucket) { cout << pair->key << \\\" -> \\\" << pair->val << \\\", \\\"; } cout << \\\"]\\\\n\\\"; } } };\",\"值得注意的是，当链表很长时，查询效率 O(n) 很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至 O(logn) 。\"]},\"64\":{\"h\":\"开放寻址\",\"t\":[\"开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\",\"下面以线性探测为例，介绍开放寻址哈希表的工作机制。\"]},\"65\":{\"h\":\"线性探测\",\"t\":[\"线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。\",\"插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。\",\"查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。\",\"下图展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 key 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。\",\"开放寻址（线性探测）哈希表的键值对分布\",\"然而，线性探测容易产生“聚集现象”。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。\",\"值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如下图所示。\",\"在开放寻址中删除元素导致的查询问题\",\"为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。\",\"然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素。\",\"为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。\",\"以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。\",\" /* 开放寻址哈希表 */ class HashMapOpenAddressing { private: int size; // 键值对数量 int capacity = 4; // 哈希表容量 const double loadThres = 2.0 / 3.0; // 触发扩容的负载因子阈值 const int extendRatio = 2; // 扩容倍数 vector<Pair *> buckets; // 桶数组 Pair *TOMBSTONE = new Pair(-1, \\\"-1\\\"); // 删除标记 public: /* 构造方法 */ HashMapOpenAddressing() : size(0), buckets(capacity, nullptr) { } /* 析构方法 */ ~HashMapOpenAddressing() { for (Pair *pair : buckets) { if (pair != nullptr && pair != TOMBSTONE) { delete pair; } } delete TOMBSTONE; } /* 哈希函数 */ int hashFunc(int key) { return key % capacity; } /* 负载因子 */ double loadFactor() { return (double)size / capacity; } /* 搜索 key 对应的桶索引 */ int findBucket(int key) { int index = hashFunc(key); int firstTombstone = -1; // 线性探测，当遇到空桶时跳出 while (buckets[index] != nullptr) { // 若遇到 key ，返回对应的桶索引 if (buckets[index]->key == key) { // 若之前遇到了删除标记，则将键值对移动至该索引处 if (firstTombstone != -1) { buckets[firstTombstone] = buckets[index]; buckets[index] = TOMBSTONE; return firstTombstone; // 返回移动后的桶索引 } return index; // 返回桶索引 } // 记录遇到的首个删除标记 if (firstTombstone == -1 && buckets[index] == TOMBSTONE) { firstTombstone = index; } // 计算桶索引，越过尾部则返回头部 index = (index + 1) % capacity; } // 若 key 不存在，则返回添加点的索引 return firstTombstone == -1 ? index : firstTombstone; } /* 查询操作 */ string get(int key) { // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则返回对应 val if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { return buckets[index]->val; } // 若键值对不存在，则返回空字符串 return \\\"\\\"; } /* 添加操作 */ void put(int key, string val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor() > loadThres) { extend(); } // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则覆盖 val 并返回 if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { buckets[index]->val = val; return; } // 若键值对不存在，则添加该键值对 buckets[index] = new Pair(key, val); size++; } /* 删除操作 */ void remove(int key) { // 搜索 key 对应的桶索引 int index = findBucket(key); // 若找到键值对，则用删除标记覆盖它 if (buckets[index] != nullptr && buckets[index] != TOMBSTONE) { delete buckets[index]; buckets[index] = TOMBSTONE; size--; } } /* 扩容哈希表 */ void extend() { // 暂存原哈希表 vector<Pair *> bucketsTmp = buckets; // 初始化扩容后的新哈希表 capacity *= extendRatio; buckets = vector<Pair *>(capacity, nullptr); size = 0; // 将键值对从原哈希表搬运至新哈希表 for (Pair *pair : bucketsTmp) { if (pair != nullptr && pair != TOMBSTONE) { put(pair->key, pair->val); delete pair; } } } /* 打印哈希表 */ void print() { for (Pair *pair : buckets) { if (pair == nullptr) { cout << \\\"nullptr\\\" << endl; } else if (pair == TOMBSTONE) { cout << \\\"TOMBSTONE\\\" << endl; } else { cout << pair->key << \\\" -> \\\" << pair->val << endl; } } } };\"]},\"66\":{\"h\":\"平方探测\",\"t\":[\"平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。\",\"平方探测主要具有以下优势。\",\"平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。\",\"平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。\",\"然而，平方探测并不是完美的。\",\"仍然存在聚集现象，即某些位置比其他位置更容易被占用。\",\"由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。\"]},\"67\":{\"h\":\"多次哈希\",\"t\":[\"顾名思义，多次哈希方法使用多个哈希函数 f1​(x)、f2​(x)、f3​(x)、… 进行探测。\",\"插入元素：若哈希函数 f1​(x) 出现冲突，则尝试 f2​(x) ，以此类推，直到找到空位后插入元素。\",\"查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None 。\",\"与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。\",\"相关信息\",\"请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。\"]},\"68\":{\"h\":\"编程语言的选择\",\"t\":[\"各种编程语言采取了不同的哈希表实现策略，下面举几个例子。\",\"Python 采用开放寻址。字典 dict 使用伪随机数进行探测。\",\"Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。\",\"Go 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。\"]},\"69\":{\"h\":\"哈希算法\",\"t\":[\"前两节介绍了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生。\",\"如果哈希冲突过于频繁，哈希表的性能则会急剧劣化。如下图所示，对于链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都存储到同一个桶中，时间复杂度退化至 O(n) 。\",\"哈希冲突的最佳情况与最差情况\",\"键值对的分布情况由哈希函数决定。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：\",\"index = hash(key) % capacity\",\"观察以上公式，当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值，进而决定了键值对在哈希表中的分布情况。\",\"这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法 hash() 的设计上。\"]},\"70\":{\"h\":\"哈希算法的目标\",\"t\":[\"为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。\",\"确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。\",\"效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。\",\"均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。\",\"实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。\",\"密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。\",\"数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。\",\"对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。\",\"单向性：无法通过哈希值反推出关于输入数据的任何信息。\",\"抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同。\",\"雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化。\",\"请注意，“均匀分布”与“抗碰撞性”是两个独立的概念，满足均匀分布不一定满足抗碰撞性。例如，在随机输入 key 下，哈希函数 key % 100 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的 key 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 key ，从而破解密码。\"]},\"71\":{\"h\":\"哈希算法的设计\",\"t\":[\"哈希算法的设计是一个需要考虑许多因素的复杂问题。然而对于某些要求不高的场景，我们也能设计一些简单的哈希算法。\",\"加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。\",\"乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。\",\"异或哈希：将输入数据的每个元素通过异或操作累积到一个哈希值中。\",\"旋转哈希：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。\",\"/* 旋转哈希 */ int rotHash(string key) { long long hash = 0; const int MODULUS = 1000000007; for (unsigned char c : key) { hash = ((hash << 4) ^ (hash >> 28) ^ (int)c) % MODULUS; } return (int)hash; }\",\"观察发现，每种哈希算法的最后一步都是对大质数 1000000007 取模，以确保哈希值在合适的范围内。值得思考的是，为什么要强调对质数取模，或者说对合数取模的弊端是什么？这是一个有趣的问题。\",\"先抛出结论：使用大质数作为模数，可以最大化地保证哈希值的均匀分布。因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突。\",\"举个例子，假设我们选择合数 9 作为模数，它可以被 3 整除，那么所有可以被 3 整除的 key 都会被映射到 0、3、6 这三个哈希值。\",\"moduluskeyhash​=9={0,3,6,9,12,15,18,21,24,27,30,33,…}={0,3,6,0,3,6,0,3,6,0,3,6,…}​\",\"如果输入 key 恰好满足这种等差数列的数据分布，那么哈希值就会出现聚堆，从而加重哈希冲突。现在，假设将 modulus 替换为质数 13 ，由于 key 和 modulus 之间不存在公约数，因此输出的哈希值的均匀性会明显提升。\",\"moduluskeyhash​=13={0,3,6,9,12,15,18,21,24,27,30,33,…}={0,3,6,9,12,2,5,8,11,1,4,7,…}​\",\"值得说明的是，如果能够保证 key 是随机均匀分布的，那么选择质数或者合数作为模数都可以，它们都能输出均匀分布的哈希值。而当 key 的分布存在某种周期性时，对合数取模更容易出现聚集现象。\",\"总而言之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性模式，提升哈希算法的稳健性。\"]},\"72\":{\"h\":\"常见哈希算法\",\"t\":[\"不难发现，以上介绍的简单哈希算法都比较“脆弱”，远远没有达到哈希算法的设计目标。例如，由于加法和异或满足交换律，因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串，这可能会加剧哈希冲突，并引起一些安全问题。\",\"在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2 和 SHA-3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。\",\"近一个世纪以来，哈希算法处在不断升级与优化的过程中。一部分研究人员努力提升哈希算法的性能，另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题。下表展示了在实际应用中常见的哈希算法。\",\"MD5 和 SHA-1 已多次被成功攻击，因此它们被各类安全应用弃用。\",\"SHA-2 系列中的 SHA-256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常用在各类安全应用与协议中。\",\"SHA-3 相较 SHA-2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA-2 系列。\",\"MD5\",\"SHA-1\",\"SHA-2\",\"SHA-3\",\"推出时间\",\"1992\",\"1995\",\"2002\",\"2008\",\"输出长度\",\"128 bit\",\"160 bit\",\"256/512 bit\",\"224/256/384/512 bit\",\"哈希冲突\",\"较多\",\"较多\",\"很少\",\"很少\",\"安全等级\",\"低，已被成功攻击\",\"低，已被成功攻击\",\"高\",\"高\",\"应用\",\"已被弃用，仍用于数据完整性检查\",\"已被弃用\",\"加密货币交易验证、数字签名等\",\"可用于替代 SHA-2\"]},\"73\":{\"h\":\"数据结构的哈希值\",\"t\":[\"我们知道，哈希表的 key 可以是整数、小数或字符串等数据类型。编程语言通常会为这些数据类型提供内置的哈希算法，用于计算哈希表中的桶索引。以 Python 为例，我们可以调用 hash() 函数来计算各种数据类型的哈希值。\",\"整数和布尔量的哈希值就是其本身。\",\"浮点数和字符串的哈希值计算较为复杂，有兴趣的读者请自行学习。\",\"元组的哈希值是对其中每一个元素进行哈希，然后将这些哈希值组合起来，得到单一的哈希值。\",\"对象的哈希值基于其内存地址生成。通过重写对象的哈希方法，可实现基于内容生成哈希值。\",\"相关信息\",\"请注意，不同编程语言的内置哈希值计算函数的定义和方法不同。\",\" int num = 3; size_t hashNum = hash<int>()(num); // 整数 3 的哈希值为 3 bool bol = true; size_t hashBol = hash<bool>()(bol); // 布尔量 1 的哈希值为 1 double dec = 3.14159; size_t hashDec = hash<double>()(dec); // 小数 3.14159 的哈希值为 4614256650576692846 string str = \\\"Hello 算法\\\"; size_t hashStr = hash<string>()(str); // 字符串“Hello 算法”的哈希值为 15466937326284535026 // 在 C++ 中，内置 std:hash() 仅提供基本数据类型的哈希值计算 // 数组、对象的哈希值计算需要自行实现\",\"在许多编程语言中，只有不可变对象才可作为哈希表的 key 。假如我们将列表（动态数组）作为 key ，当列表的内容发生变化时，它的哈希值也随之改变，我们就无法在哈希表中查询到原先的 value 了。\",\"虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。这是因为对象的哈希值通常是基于内存地址生成的，即使对象的内容发生了变化，但它的内存地址不变，哈希值仍然是不变的。\",\"细心的你可能发现在不同控制台中运行程序时，输出的哈希值是不同的。这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。\"]},\"74\":{\"h\":\"重点回顾\",\"t\":[\"输入 key ，哈希表能够在 O(1) 时间内查询到 value ，效率非常高。\",\"常见的哈希表操作包括查询、添加键值对、删除键值对和遍历哈希表等。\",\"哈希函数将 key 映射为数组索引，从而访问对应桶并获取 value 。\",\"两个不同的 key 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为哈希冲突。\",\"哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。\",\"负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。\",\"链式地址通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以通过进一步将链表转换为红黑树来提高效率。\",\"开放寻址通过多次探测来处理哈希冲突。线性探测使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。\",\"不同编程语言采取了不同的哈希表实现。例如，Java 的 HashMap 使用链式地址，而 Python 的 Dict 采用开放寻址。\",\"在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。\",\"哈希算法通常采用大质数作为模数，以最大化地保证哈希值均匀分布，减少哈希冲突。\",\"常见的哈希算法包括 MD5、SHA-1、SHA-2 和 SHA-3 等。MD5 常用于校验文件完整性，SHA-2 常用于安全应用与协议。\",\"编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。\"]},\"75\":{\"h\":\"Q & A\",\"t\":[\"Q：哈希表的时间复杂度在什么情况下是 O(n) ？\",\"当哈希冲突比较严重时，哈希表的时间复杂度会退化至 O(n) 。当哈希函数设计得比较好、容量设置比较合理、冲突比较平均时，时间复杂度是 O(1) 。我们使用编程语言内置的哈希表时，通常认为时间复杂度是 O(1) 。\",\"Q：为什么不使用哈希函数 f(x)=x 呢？这样就不会有冲突了。\",\"在 f(x)=x 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而，输入空间通常远大于输出空间（数组长度），因此哈希函数的最后一步往往是对数组长度取模。换句话说，哈希表的目标是将一个较大的状态空间映射到一个较小的空间，并提供 O(1) 的查询效率。\",\"Q：哈希表底层实现是数组、链表、二叉树，但为什么效率可以比它们更高呢？\",\"首先，哈希表的时间效率变高，但空间效率变低了。哈希表有相当一部分内存未使用。\",\"其次，只是在特定使用场景下时间效率变高了。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，那么通常比哈希表更快。这是因为哈希函数计算需要开销，时间复杂度的常数项更大。\",\"最后，哈希表的时间复杂度可能发生劣化。例如在链式地址中，我们采取在链表或红黑树中执行查找操作，仍然有退化至 O(n) 时间的风险。\",\"Q：多次哈希有不能直接删除元素的缺陷吗？标记为已删除的空间还能再次使用吗？\",\"多次哈希是开放寻址的一种，开放寻址法都有不能直接删除元素的缺陷，需要通过标记删除。标记为已删除的空间可以再次使用。当将新元素插入哈希表，并且通过哈希函数找到标记为已删除的位置时，该位置可以被新元素使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。\",\"Q：为什么在线性探测中，查找元素的时候会出现哈希冲突呢？\",\"查找的时候通过哈希函数找到对应的桶和键值对，发现 key 不匹配，这就代表有哈希冲突。因此，线性探测法会根据预先设定的步长依次向下查找，直至找到正确的键值对或无法找到跳出为止。\",\"Q：为什么哈希表扩容能够缓解哈希冲突？\",\"哈希函数的最后一步往往是对数组长度 n 取模（取余），让输出值落在数组索引范围内；在扩容后，数组长度 n 发生变化，而 key 对应的索引也可能发生变化。原先落在同一个桶的多个 key ，在扩容后可能会被分配到多个桶中，从而实现哈希冲突的缓解。\"]},\"76\":{\"c\":[\"数据结构\"]},\"77\":{\"c\":[\"c++\",\"hash\",\"哈希表\"]},\"78\":{\"h\":\"二叉树\"},\"79\":{\"h\":\"二叉树\",\"t\":[\"二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。\",\" /* 二叉树节点结构体 */ struct TreeNode { int val; // 节点值 TreeNode *left; // 左子节点指针 TreeNode *right; // 右子节点指针 TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };\",\"每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）。\",\"在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。如下图所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。\",\"父节点、子节点、子树\"]},\"80\":{\"h\":\"二叉树常见术语\",\"t\":[\"二叉树的常用术语如下图所示。\",\"根节点（root node）：位于二叉树顶层的节点，没有父节点。\",\"叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。\",\"边（edge）：连接两个节点的线段，即节点引用（指针）。\",\"节点所在的层（level）：从顶至底递增，根节点所在层为 1 。\",\"节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\",\"二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。\",\"节点的深度（depth）：从根节点到该节点所经过的边的数量。\",\"节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。\",\"二叉树的常用术语\",\"相关信息\",\"请注意，我们通常将“高度”和“深度”定义为“经过的边的数量”，但有些题目或教材可能会将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要加 1 。\"]},\"81\":{\"h\":\"二叉树基本操作\"},\"82\":{\"h\":\"初始化二叉树\",\"t\":[\"与链表类似，首先初始化节点，然后构建引用（指针）。\",\" /* 初始化二叉树 */ // 初始化节点 TreeNode* n1 = new TreeNode(1); TreeNode* n2 = new TreeNode(2); TreeNode* n3 = new TreeNode(3); TreeNode* n4 = new TreeNode(4); TreeNode* n5 = new TreeNode(5); // 构建节点之间的引用（指针） n1->left = n2; n1->right = n3; n2->left = n4; n2->right = n5;\"]},\"83\":{\"h\":\"插入与删除节点\",\"t\":[\"与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例。\",\"在二叉树中插入与删除节点\",\" /* 插入与删除节点 */ TreeNode* P = new TreeNode(0); // 在 n1 -> n2 中间插入节点 P n1->left = P; P->left = n2; // 删除节点 P n1->left = n2;\",\"提示\",\"需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除通常是由一套操作配合完成的，以实现有实际意义的操作。\"]},\"84\":{\"h\":\"常见二叉树类型\"},\"85\":{\"h\":\"完美二叉树\",\"t\":[\"如下图所示，完美二叉树（perfect binary tree）所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树的高度为 h ，则节点总数为 2h+1−1 ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。\",\"提示\",\"请注意，在中文社区中，完美二叉树常被称为满二叉树。 \",\"完美二叉树\"]},\"86\":{\"h\":\"完全二叉树\",\"t\":[\"如下图所示，完全二叉树（complete binary tree）只有最底层的节点未被填满，且最底层节点尽量靠左填充。请注意，完美二叉树也是一棵完全二叉树。\",\"完全二叉树\"]},\"87\":{\"h\":\"平衡二叉树\",\"t\":[\"如下图所示，平衡二叉树（balanced binary tree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\",\"平衡二叉树\"]},\"88\":{\"h\":\"二叉树的退化\",\"t\":[\"下图展示了二叉树的理想结构与退化结构。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\",\"完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\",\"链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n) 。\",\"二叉树的最佳结构与最差结构\",\"如下表所示，在最佳结构和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大值或极小值。\",\"完美二叉树\",\"链表\",\"第 i 层的节点数量\",\"2i−1\",\"1\",\"高度为 h 的树的叶节点数量\",\"2h\",\"1\",\"高度为 h 的树的节点总数\",\"2h+1−1\",\"h+1\",\"节点总数为 n 的树的高度\",\"log2​(n+1)−1\",\"n−1\"]},\"89\":{\"h\":\"二叉搜索树\",\"t\":[\"如下图所示，二叉搜索树（binary search tree）满足以下条件。\",\"对于根节点，左子树中所有节点的值 < 根节点的值 < 右子树中所有节点的值。\",\"任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。\",\"二叉搜索树\"]},\"90\":{\"h\":\"二叉搜索树的操作\",\"t\":[\"我们将二叉搜索树封装为一个类 BinarySearchTree ，并声明一个成员变量 root ，指向树的根节点。\"]},\"91\":{\"h\":\"查找节点\",\"t\":[\"给定目标节点值 num ，可以根据二叉搜索树的性质来查找。如下图所示，我们声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系。\",\"若 cur.val < num ，说明目标节点在 cur 的右子树中，因此执行 cur = cur.right 。\",\"若 cur.val > num ，说明目标节点在 cur 的左子树中，因此执行 cur = cur.left 。\",\"若 cur.val = num ，说明找到目标节点，跳出循环并返回该节点。\",\"二叉搜索树查找节点示例\",\"bst_search_step2\",\"bst_search_step3\",\"bst_search_step4\",\"二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 O(logn) 时间。示例代码如下：\",\"/* 查找节点 */ TreeNode *search(int num) { TreeNode *cur = root; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 目标节点在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 目标节点在 cur 的左子树中 else if (cur->val > num) cur = cur->left; // 找到目标节点，跳出循环 else break; } // 返回目标节点 return cur; }\"]},\"92\":{\"h\":\"插入节点\",\"t\":[\"给定一个待插入元素 num ，为了保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，插入操作流程如下图所示。\",\"查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。\",\"在该位置插入节点：初始化节点 num ，将该节点置于 None 的位置。\",\"在二叉搜索树中插入节点\",\"在代码实现中，需要注意以下两点。\",\"二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。\",\"为了实现插入节点，我们需要借助节点 pre 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。\",\"/* 插入节点 */ void insert(int num) { // 若树为空，则初始化根节点 if (root == nullptr) { root = new TreeNode(num); return; } TreeNode *cur = root, *pre = nullptr; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 找到重复节点，直接返回 if (cur->val == num) return; pre = cur; // 插入位置在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 插入位置在 cur 的左子树中 else cur = cur->left; } // 插入节点 TreeNode *node = new TreeNode(num); if (pre->val < num) pre->right = node; else pre->left = node; }\",\"与查找节点相同，插入节点使用 O(logn) 时间。\"]},\"93\":{\"h\":\"删除节点\",\"t\":[\"先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 < 根节点 < 右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。\",\"如下图所示，当待删除节点的度为 0 时，表示该节点是叶节点，可以直接删除。\",\"在二叉搜索树中删除节点（度为 0 ）\",\"如下图所示，当待删除节点的度为 1 时，将待删除节点替换为其子节点即可。\",\"在二叉搜索树中删除节点（度为 1 ）\",\"当待删除节点的度为 2 时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，因此这个节点可以是右子树的最小节点或左子树的最大节点。\",\"假设我们选择右子树的最小节点（中序遍历的下一个节点），则删除操作流程如下图所示。\",\"找到待删除节点在“中序遍历序列”中的下一个节点，记为 tmp 。\",\"用 tmp 的值覆盖待删除节点的值，并在树中递归删除节点 tmp 。\",\"在二叉搜索树中删除节点（度为 2 ）\",\"bst_remove_case3_step2\",\"bst_remove_case3_step3\",\"bst_remove_case3_step4\",\"删除节点操作同样使用 O(logn) 时间，其中查找待删除节点需要 O(logn) 时间，获取中序遍历后继节点需要 O(logn) 时间。示例代码如下：\",\" /* 删除节点 */ void remove(int num) { // 若树为空，直接提前返回 if (root == nullptr) return; TreeNode *cur = root, *pre = nullptr; // 循环查找，越过叶节点后跳出 while (cur != nullptr) { // 找到待删除节点，跳出循环 if (cur->val == num) break; pre = cur; // 待删除节点在 cur 的右子树中 if (cur->val < num) cur = cur->right; // 待删除节点在 cur 的左子树中 else cur = cur->left; } // 若无待删除节点，则直接返回 if (cur == nullptr) return; // 子节点数量 = 0 or 1 if (cur->left == nullptr || cur->right == nullptr) { // 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点 TreeNode *child = cur->left != nullptr ? cur->left : cur->right; // 删除节点 cur if (cur != root) { if (pre->left == cur) pre->left = child; else pre->right = child; } else { // 若删除节点为根节点，则重新指定根节点 root = child; } // 释放内存 delete cur; } // 子节点数量 = 2 else { // 获取中序遍历中 cur 的下一个节点 TreeNode *tmp = cur->right; while (tmp->left != nullptr) { tmp = tmp->left; } int tmpVal = tmp->val; // 递归删除节点 tmp remove(tmp->val); // 用 tmp 覆盖 cur cur->val = tmpVal; } }\"]},\"94\":{\"h\":\"中序遍历有序\",\"t\":[\"如下图所示，二叉树的中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 < 根节点 < 右子节点”的大小关系。\",\"这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：二叉搜索树的中序遍历序列是升序的。\",\"利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 O(n) 时间，无须进行额外的排序操作，非常高效。\",\"二叉搜索树的中序遍历序列\"]},\"95\":{\"h\":\"二叉搜索树的效率\",\"t\":[\"给定一组数据，我们考虑使用数组或二叉搜索树存储。观察下表，二叉搜索树的各项操作的时间复杂度都是对数阶，具有稳定且高效的性能。只有在高频添加、低频查找删除数据的场景下，数组比二叉搜索树的效率更高。\",\"无序数组\",\"二叉搜索树\",\"查找元素\",\"O(n)\",\"O(logn)\",\"插入元素\",\"O(1)\",\"O(logn)\",\"删除元素\",\"O(n)\",\"O(logn)\",\"在理想情况下，二叉搜索树是“平衡”的，这样就可以在 logn 轮循环内查找任意节点。\",\"然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为下图所示的链表，这时各种操作的时间复杂度也会退化为 O(n) 。\",\"二叉搜索树退化\"]},\"96\":{\"h\":\"二叉搜索树常见应用\",\"t\":[\"用作系统中的多级索引，实现高效的查找、插入、删除操作。\",\"作为某些搜索算法的底层数据结构。\",\"用于存储数据流，以保持其有序状态。\"]},\"97\":{\"h\":\"AVL 树 *\",\"t\":[\"在“二叉搜索树”章节中我们提到，在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从 O(logn) 劣化为 O(n) 。\",\"如下图所示，经过两次删除节点操作，这棵二叉搜索树便会退化为链表。\",\"AVL 树在删除节点后发生退化\",\"再例如，在下图所示的完美二叉树中插入两个节点后，树将严重向左倾斜，查找操作的时间复杂度也随之劣化。\",\"AVL 树在插入节点后发生退化\",\"1962 年 G. M. Adelson-Velsky 和 E. M. Landis 在论文“An algorithm for the organization of information”中提出了 AVL 树。论文中详细描述了一系列操作，确保在持续添加和删除节点后，AVL 树不会退化，从而使得各种操作的时间复杂度保持在 O(logn) 级别。换句话说，在需要频繁进行增删查改操作的场景中，AVL 树能始终保持高效的数据操作性能，具有很好的应用价值。\"]},\"98\":{\"h\":\"AVL 树常见术语\",\"t\":[\"AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树（balanced binary search tree）。\"]},\"99\":{\"h\":\"节点高度\",\"t\":[\"由于 AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 height 变量：\",\" /* AVL 树节点类 */ struct TreeNode { int val{}; // 节点值 int height = 0; // 节点高度 TreeNode *left{}; // 左子节点 TreeNode *right{}; // 右子节点 TreeNode() = default; explicit TreeNode(int x) : val(x){} };\",\"“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为 0 ，而空节点的高度为 −1 。我们将创建两个工具函数，分别用于获取和更新节点的高度：\",\" /* 更新节点高度 */ void updateHeight(TreeNode *node) { // 节点高度等于最高子树高度 + 1 node->height = max(height(node->left), height(node->right)) + 1; }\"]},\"100\":{\"h\":\"节点平衡因子\",\"t\":[\"节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 。我们同样将获取节点平衡因子的功能封装成函数，方便后续使用：\",\" /* 获取平衡因子 */ int balanceFactor(TreeNode *node) { // 空节点平衡因子为 0 if (node == nullptr) return 0; // 节点平衡因子 = 左子树高度 - 右子树高度 return height(node->left) - height(node->right); }\",\"相关信息\",\"设平衡因子为 f ，则一棵 AVL 树的任意节点的平衡因子皆满足 −1≤f≤1 。\"]},\"101\":{\"h\":\"AVL 树旋转\",\"t\":[\"AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。\",\"我们将平衡因子绝对值 >1 的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。下面详细介绍这些旋转操作。\"]},\"102\":{\"h\":\"右旋\",\"t\":[\"如下图所示，节点下方为平衡因子。从底至顶看，二叉树中首个失衡节点是“节点 3”。我们关注以该失衡节点为根节点的子树，将该节点记为 node ，其左子节点记为 child ，执行“右旋”操作。完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质。\",\"右旋操作步骤\",\"avltree_right_rotate_step2\",\"avltree_right_rotate_step3\",\"avltree_right_rotate_step4\",\"如下图所示，当节点 child 有右子节点（记为 grand_child ）时，需要在右旋中添加一步：将 grand_child 作为 node 的左子节点。\",\"有 grand_child 的右旋操作\",\"“向右旋转”是一种形象化的说法，实际上需要通过修改节点指针来实现，代码如下所示：\",\" /* 右旋操作 */ TreeNode *rightRotate(TreeNode *node) { TreeNode *child = node->left; TreeNode *grandChild = child->right; // 以 child 为原点，将 node 向右旋转 child->right = node; node->left = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; }\"]},\"103\":{\"h\":\"左旋\",\"t\":[\"相应地，如果考虑上述失衡二叉树的“镜像”，则需要执行下图所示的“左旋”操作。\",\"左旋操作\",\"同理，如下图所示，当节点 child 有左子节点（记为 grand_child ）时，需要在左旋中添加一步：将 grand_child 作为 node 的右子节点。\",\"有 grand_child 的左旋操作\",\"可以观察到，右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的。基于对称性，我们只需将右旋的实现代码中的所有的 left 替换为 right ，将所有的 right 替换为 left ，即可得到左旋的实现代码：\",\" /* 左旋操作 */ TreeNode *leftRotate(TreeNode *node) { TreeNode *child = node->right; TreeNode *grandChild = child->left; // 以 child 为原点，将 node 向左旋转 child->left = node; node->right = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; }\"]},\"104\":{\"h\":\"先左旋后右旋\",\"t\":[\"对于下图中的失衡节点 3 ，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对 child 执行“左旋”，再对 node 执行“右旋”。\",\"先左旋后右旋\"]},\"105\":{\"h\":\"先右旋后左旋\",\"t\":[\"如下图所示，对于上述失衡二叉树的镜像情况，需要先对 child 执行“右旋”，再对 node 执行“左旋”。\",\"先右旋后左旋\"]},\"106\":{\"h\":\"旋转的选择\",\"t\":[\"下图展示的四种失衡情况与上述案例逐个对应，分别需要采用右旋、先左旋后右旋、先右旋后左旋、左旋的操作。\",\"AVL 树的四种旋转情况\",\"如下表所示，我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于上图中的哪种情况。\",\"失衡节点的平衡因子\",\"子节点的平衡因子\",\"应采用的旋转方法\",\">1 （左偏树）\",\"≥0\",\"右旋\",\">1 （左偏树）\",\"<0\",\"先左旋后右旋\",\"<−1 （右偏树）\",\"≤0\",\"左旋\",\"<−1 （右偏树）\",\">0\",\"先右旋后左旋\",\"为了便于使用，我们将旋转操作封装成一个函数。有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡。代码如下所示：\",\"/* 执行旋转操作，使该子树重新恢复平衡 */ TreeNode *rotate(TreeNode *node) { // 获取节点 node 的平衡因子 int _balanceFactor = balanceFactor(node); // 左偏树 if (_balanceFactor > 1) { if (balanceFactor(node->left) >= 0) { // 右旋 return rightRotate(node); } else { // 先左旋后右旋 node->left = leftRotate(node->left); return rightRotate(node); } } // 右偏树 if (_balanceFactor < -1) { if (balanceFactor(node->right) <= 0) { // 左旋 return leftRotate(node); } else { // 先右旋后左旋 node->right = rightRotate(node->right); return leftRotate(node); } } // 平衡树，无须旋转，直接返回 return node; }\"]},\"107\":{\"h\":\"AVL 树常用操作\"},\"108\":{\"h\":\"插入节点\",\"t\":[\"AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\" /* 递归插入节点（辅助方法） */ TreeNode *insertHelper(TreeNode *node, int val) { if (node == nullptr) return new TreeNode(val); /* 1. 查找插入位置并插入节点 */ if (val < node->val) node->left = insertHelper(node->left, val); else if (val > node->val) node->right = insertHelper(node->right, val); else return node; // 重复节点不插入，直接返回 updateHeight(node); // 更新节点高度 /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; }\"]},\"109\":{\"h\":\"删除节点\",\"t\":[\"类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\" /* 递归删除节点（辅助方法） */ TreeNode *removeHelper(TreeNode *node, int val) { if (node == nullptr) return nullptr; /* 1. 查找节点并删除 */ if (val < node->val) node->left = removeHelper(node->left, val); else if (val > node->val) node->right = removeHelper(node->right, val); else { if (node->left == nullptr || node->right == nullptr) { TreeNode *child = node->left != nullptr ? node->left : node->right; // 子节点数量 = 0 ，直接删除 node 并返回 if (child == nullptr) { delete node; return nullptr; } // 子节点数量 = 1 ，直接删除 node else { delete node; node = child; } } else { // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点 TreeNode *temp = node->right; while (temp->left != nullptr) { temp = temp->left; } int tempVal = temp->val; node->right = removeHelper(node->right, temp->val); node->val = tempVal; } } updateHeight(node); // 更新节点高度 /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; }\"]},\"110\":{\"h\":\"查找节点\",\"t\":[\"AVL 树的节点查找操作与二叉搜索树一致，在此不再赘述。\"]},\"111\":{\"h\":\"AVL 树典型应用\",\"t\":[\"组织和存储大型数据，适用于高频查找、低频增删的场景。\",\"用于构建数据库中的索引系统。\",\"红黑树也是一种常见的平衡二叉搜索树。相较于 AVL 树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高。\"]},\"112\":{\"h\":\"重点回顾\",\"t\":[\"二叉树是一种非线性数据结构，体现“一分为二”的分治逻辑。每个二叉树节点包含一个值以及两个指针，分别指向其左子节点和右子节点。\",\"对于二叉树中的某个节点，其左（右）子节点及其以下形成的树被称为该节点的左（右）子树。\",\"二叉树的相关术语包括根节点、叶节点、层、度、边、高度和深度等。\",\"二叉树的初始化、节点插入和节点删除操作与链表操作方法类似。\",\"常见的二叉树类型有完美二叉树、完全二叉树、完满二叉树和平衡二叉树。完美二叉树是最理想的状态，而链表是退化后的最差状态。\",\"二叉树可以用数组表示，方法是将节点值和空位按层序遍历顺序排列，并根据父节点与子节点之间的索引映射关系来实现指针。\",\"二叉树的层序遍历是一种广度优先搜索方法，它体现了“一圈一圈向外扩展”的逐层遍历方式，通常通过队列来实现。\",\"前序、中序、后序遍历皆属于深度优先搜索，它们体现了“先走到尽头，再回溯继续”的遍历方式，通常使用递归来实现。\",\"二叉搜索树是一种高效的元素查找数据结构，其查找、插入和删除操作的时间复杂度均为 O(logn) 。当二叉搜索树退化为链表时，各项时间复杂度会劣化至 O(n) 。\",\"AVL 树，也称平衡二叉搜索树，它通过旋转操作确保在不断插入和删除节点后树仍然保持平衡。\",\"AVL 树的旋转操作包括右旋、左旋、先右旋再左旋、先左旋再右旋。在插入或删除节点后，AVL 树会从底向顶执行旋转操作，使树重新恢复平衡。\"]},\"113\":{\"h\":\"Q & A\",\"t\":[\"Q：对于只有一个节点的二叉树，树的高度和根节点的深度都是 0 吗？\",\"是的，因为高度和深度通常定义为“经过的边的数量”。\",\"Q：二叉树中的插入与删除一般由一套操作配合完成，这里的“一套操作”指什么呢？可以理解为资源的子节点的资源释放吗？\",\"拿二叉搜索树来举例，删除节点操作要分三种情况处理，其中每种情况都需要进行多个步骤的节点操作。\",\"Q：为什么 DFS 遍历二叉树有前、中、后三种顺序，分别有什么用呢？\",\"与顺序和逆序遍历数组类似，前序、中序、后序遍历是三种二叉树遍历方法，我们可以使用它们得到一个特定顺序的遍历结果。例如在二叉搜索树中，由于节点大小满足 左子节点值 < 根节点值 < 右子节点值 ，因此我们只要按照“左 → 根 → 右”的优先级遍历树，就可以获得有序的节点序列。\",\"Q：右旋操作是处理失衡节点 node、child、grand_child 之间的关系，那 node 的父节点和 node 原来的连接不需要维护吗？右旋操作后岂不是断掉了？\",\"我们需要从递归的视角来看这个问题。右旋操作 right_rotate(root) 传入的是子树的根节点，最终 return child 返回旋转之后的子树的根节点。子树的根节点和其父节点的连接是在该函数返回后完成的，不属于右旋操作的维护范围。\",\"Q：在 C++ 中，函数被划分到 private 和 public 中，这方面有什么考量吗？为什么要将 height() 函数和 updateHeight() 函数分别放在 public 和 private 中呢？\",\"主要看方法的使用范围，如果方法只在类内部使用，那么就设计为 private 。例如，用户单独调用 updateHeight() 是没有意义的，它只是插入、删除操作中的一步。而 height() 是访问节点高度，类似于 vector.size() ，因此设置成 public 以便使用。\",\"Q：如何从一组输入数据构建一棵二叉搜索树？根节点的选择是不是很重要？\",\"是的，构建树的方法已在二叉搜索树代码中的 build_tree() 方法中给出。至于根节点的选择，我们通常会将输入数据排序，然后将中点元素作为根节点，再递归地构建左右子树。这样做可以最大程度保证树的平衡性。\",\"Q：在 Java 中，字符串对比是否一定要用 equals() 方法？\",\"在 Java 中，对于基本数据类型，== 用于对比两个变量的值是否相等。对于引用类型，两种符号的工作原理是不同的。\",\"== ：用来比较两个变量是否指向同一个对象，即它们在内存中的位置是否相同。\",\"equals()：用来对比两个对象的值是否相等。\",\"因此，如果要对比值，我们应该使用 equals() 。然而，通过 String a = \\\"hi\\\"; String b = \\\"hi\\\"; 初始化的字符串都存储在字符串常量池中，它们指向同一个对象，因此也可以用 a == b 来比较两个字符串的内容。\",\"Q：广度优先遍历到最底层之前，队列中的节点数量是 2h 吗？\",\"是的，例如高度 h=2 的满二叉树，其节点总数 n=7 ，则底层节点数量 4=2h=(n+1)/2 。\"]},\"114\":{\"c\":[\"数据结构\"]},\"115\":{\"c\":[\"c++\"]},\"116\":{\"h\":\"数据结构\"},\"117\":{\"c\":[\"数据结构\"]},\"118\":{\"h\":\"书籍推荐\"},\"119\":{\"c\":[\"书籍\"]},\"120\":{\"h\":\"c++ 书籍推荐\",\"t\":[\"推荐几本C++书籍，从入门，到进阶，到实战，一网打尽。\"]},\"121\":{\"h\":\"入门推荐\",\"t\":[\"C++ Primer\",\"前些年这本书可以说是C++入门必备，C++基础知识介绍的非常全面，缺点也很明显。。。就是是书太厚了-_-||\",\"C++20高级编程\",\"C++基础、C++进阶、C++20各种新特性、C++实战经验，本书都有涉及，内容丰富且有条理有深度，唯一的缺点，就是有点厚。\"]},\"122\":{\"h\":\"进阶推荐\",\"t\":[\"C++程序设计 进阶篇\",\"C++之父大作，关于C++，应该没谁比C++之父更有发言权吧，不过这本书我更推荐有一定基础，想提升C++达到进阶水平的朋友学习。\",\"Effective Modern C++\",\"本书介绍的多是C++11的新特性，如果C++98的朋友想进阶到C++11，推荐学习这本书。\",\"C++ Core Guidelines解析\",\"它的前身C++之父的很多心得经验的博客，英文不错的朋友可以直接看原文，国内有大佬把它翻译成了中文书籍，内容质量很高，推荐阅读。\",\"深入理解计算机系统\",\"C++不能只学习语言本身，还需要对操作系统有深刻的理解，操作系统我只推荐这一本书。\"]},\"123\":{\"c\":[\"c++\",\"book\"]},\"124\":{\"h\":\"设计原则\"},\"125\":{\"h\":\"设计模式\",\"t\":[\"设计模式是解决常见软件设计问题的通用解决方案。它们分为三大类：\",\"创建型模式：关注对象创建，如单例模式、工厂模式。\",\"结构型模式：关注对象组合，如装饰器模式、桥接模式，组合模式。\",\"行为型模式：关注对象间通信，如观察者模式、策略模式, 责任链模式。\"]},\"126\":{\"h\":\"设计原则\",\"t\":[\"设计原则是指导代码设计的基本准则，如：\",\"单一职责原则 (SRP)\",\"定义: 一个类应只有一个引起其变化的原因，即一个类只负责一项职责。\",\"目的: 提高代码的可维护性和可读性，减少类的复杂性。\",\"开闭原则 (OCP)\",\"定义: 软件实体应对扩展开放，对修改关闭。\",\"目的: 通过抽象和接口，允许添加新功能而无需修改现有代码，减少引入新 bug 的风险。\",\"里氏替换原则 (LSP)\",\"定义: 子类对象必须能够替换其父类对象且行为一致。\",\"目的: 保证继承层次的正确性，避免运行时错误。\",\"依赖倒置原则 (DIP)\",\"定义: 高层模块不应依赖于低层模块，二者都应该依赖于抽象；抽象不应依赖于细节，细节应该依赖于抽象。\",\"目的: 减少模块之间的耦合性，提高系统的灵活性和可扩展性。\",\"接口隔离原则 (ISP)\",\"定义: 不应强迫一个类依赖于它不需要的接口，接口应尽量细化。\",\"目的: 通过多个特定接口来代替单一的总接口，减少代码的复杂性，提高系统的灵活性。\"]},\"127\":{\"h\":\"关于架构设计的一点思考\",\"t\":[\"减少耦合\",\"通过添加抽象接口层，将调用模块与实现模块进行隔离，降低耦合性。调用模块只依赖抽象接口，进行业务逻辑的实现，实现模块基于抽象接口实现具体的底层细节。\",\"单一职责\",\"一个模块只实现其功能的最小集，对外提供尽可能少的接口，接口应尽量细化。\",\"隔离变化/稳定\",\"找出系统中可预计的变化，将其隔离到相同的模块。系统需求变动导致的修改尽可能的不会扩散的稳定的模块。\"]},\"128\":{\"c\":[\"架构设计\"]},\"129\":{\"c\":[\"c++\",\"设计模式\",\"设计原则\"]},\"130\":{\"h\":\"观察者模式\"},\"131\":{\"h\":\"概述\",\"t\":[\"观察者模式（Observer Pattern）是一种行为型设计模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，所有依赖于它的观察者对象都会收到通知并自动更新。观察者模式通常用于事件驱动的系统，如GUI事件处理、订阅者发布者模型等。\"]},\"132\":{\"h\":\"结构\",\"t\":[\"观察者模式主要涉及以下几个角色：\",\"主题（Subject）：持有观察者对象的引用，提供注册、移除和通知观察者的方法。当主题状态改变时，会通知所有已注册的观察者。\",\"观察者（Observer）：定义一个接口，用于接收主题的通知。所有具体的观察者类实现该接口，以便接收更新。\",\"具体主题（Concrete Subject）：实现主题接口，维护一个具体的状态。当状态改变时，会通知所有观察者。\",\"具体观察者（Concrete Observer）：实现观察者接口，负责在接收到主题的通知后进行相应的更新操作。\"]},\"133\":{\"h\":\"示例\",\"t\":[\" /* 观察者模式： 用于对象之间的“消息通知” */ #include <iostream> class IProgress { public: virtual void DoProgress(float value) = 0; }; class FileSpliter { public: void splitFile() { for (int i = 0; i < 100; i++) { //.... if (mIProgress) mIProgress->DoProgress((i+1)*100/100); } } void setProgress(IProgress* progress) {mIProgress = progress;} private: IProgress* mIProgress = nullptr; }; class MainForm: public IProgress{ public: void DoProgress(float value) override { std::cout << value << std::endl; } }; int main() { FileSpliter spliter; MainForm form; spliter.setProgress(&form); spliter.splitFile(); }\",\"总结\",\"观察者模式提供了一种将对象之间的依赖关系解耦的方式，使得对象可以独立变化而不影响彼此。\",\"支持广播通信，当主题状态改变时，所有观察者都可以自动接收到通知。\",\"观察者模式非常适用于需要动态更新和通知机制的场景，例如事件系统、消息传递系统等。通过使用观察者模式，可以有效地管理对象之间的依赖关系，并简化代码结构。\"]},\"134\":{\"c\":[\"架构设计\"]},\"135\":{\"c\":[\"c++\",\"设计模式\",\"观察者模式\",\"事件模式\"]},\"136\":{\"h\":\"策略模式\"},\"137\":{\"h\":\"概述\",\"t\":[\"策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装在独立的策略类中，使得它们可以互相替换。策略模式使得算法的变化不会影响到使用算法的客户类。\"]},\"138\":{\"h\":\"结构\",\"t\":[\"策略接口：定义算法的通用接口。\",\"具体策略类：实现策略接口的不同算法。\",\"上下文类：持有一个策略对象，并在运行时决定使用哪种策略。\"]},\"139\":{\"h\":\"示例\",\"t\":[\"// 策略接口 class DiscountStrategy { public: virtual double calculate(double price) const = 0; }; // 具体策略 class NoDiscount : public DiscountStrategy { public: double calculate(double price) const override { return price; } }; class SeasonalDiscount : public DiscountStrategy { public: double calculate(double price) const override { return price * 0.9; } }; //other discounts... // 上下文类 class Order { DiscountStrategy* mDiscountStrategy; public: Order(DiscountStrategy* strategy) : mDiscountStrategy(strategy) {} double getFinalPrice(double price) const { return mDiscountStrategy->calculate(price); } void setDiscountStrategy(DiscountStrategy* strategy) { mDiscountStrategy = strategy; } }; int main() { DiscountStrategy* strategy = new NoDiscount(); Order order(strategy); std::cout << order.getFinalPrice(100) << std::endl; delele strategy; strategy = new SeasonalDiscount(); order.setDiscountStrategy(strategy); std::cout << order.getFinalPrice(100) << std::endl; delele strategy; return 0; }\",\"总结\",\"策略模式可以使得算法独立于使用它的客户端而变化。\",\"可以避免使用条件语句来选择不同的算法。\",\"提高了代码的可扩展性，当有新的策略出现时，只需增加一个具体策略类，而不需要修改现有代码。\",\"策略模式适用于需要动态选择或更换算法的场景，可以保持代码的灵活性和可扩展性，避免将多个算法逻辑硬编码到一个类中。\"]},\"140\":{\"c\":[\"架构设计\"]},\"141\":{\"c\":[\"c++\",\"设计模式\",\"策略模式\"]},\"142\":{\"h\":\"装饰器模式\"},\"143\":{\"h\":\"概述\",\"t\":[\"装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中，来为原始对象提供新的行为。这种模式使得我们可以在不改变原始类代码的情况下，动态地添加新的功能。\",\"装饰器模式主要解决的问题是：当系统中出现新的功能需求时，不希望通过修改已有代码或继承来实现，而是希望通过动态组合的方式进行扩展。\"]},\"144\":{\"h\":\"结构\",\"t\":[\"装饰器模式通常涉及以下几个角色：\",\"组件接口（Component）：定义对象的接口，可以是抽象类或接口。\",\"具体组件（Concrete Component）：实现组件接口的具体类。\",\"装饰器类（Decorator）：实现组件接口，并持有一个组件对象的引用。这个类是装饰器模式的核心，通过在方法中调用组件对象的方法，实现功能的叠加。\",\"具体装饰器（Concrete Decorator）：继承装饰器类，具体实现要添加的功能。\"]},\"145\":{\"h\":\"示例\",\"t\":[\"#include <iostream> #include <string> /* 装饰器模式： 解决的问题： 在基础类上存在多维度功能的扩展，其中某个维度的扩展是可以叠加的，通过继承的方式会导致子类的‘组合爆炸’ */ class Stream { public: virtual std::string read() = 0; }; class FileStream: public Stream { public: std::string read() ovverride { std::cout << \\\"FileStream::read\\\" << std::endl; return \\\"\\\"; } }; class NetworkStream: public Stream { public: std::string read() override { std::cout << \\\"NetworkStream::read\\\" << std::endl; return \\\"\\\"; } }; class MemoryStream: public Stream { public: std::string read() { std::cout << \\\"MemoryStream::read\\\" << std::endl; return \\\"\\\"; } }; class BufferedStream: public Stream { public: BufferedStream(Stream* s): mSteam(s) {} virtual std::string read() ovverride { //..buffer return DoBuffer(mSteam->read()); } private: std::string DoBuffer(const std::string&) { std::cout << \\\"DoBuffer\\\" << std::endl; return \\\"\\\"; } private: Stream* mSteam = nullptr; }; class CryptoStream: public Stream { public: CryptoStream(Stream* s): mSteam(s) {} virtual std::string read() { //..Crypto return DoCrypto(mSteam->read()); } private: std::string DoCrypto(const std::string&) { std::cout << \\\"DoCrypto\\\" << std::endl; return \\\"\\\"; } private: Stream* mSteam = nullptr; }; int main() { FileStream* fs = new FileStream(); //缓冲文件流 BufferedStream* bfs = new BufferedStream(fs); bfs->read(); //加密文件流 CryptoStream* cfs = new CryptoStream(fs); cfs->read(); //加密+缓冲 文件流 CryptoStream* cbfs = new CryptoStream(bfs); cbfs->read(); }\",\"总结\",\"动态扩展对象的功能，灵活性高。\",\"避免了使用继承，减少类的数量。\",\"装饰器模式在需要动态添加功能的场景中非常有用，可以保持代码的开放封闭原则（对扩展开放，对修改封闭），使得系统更容易维护和扩展。\"]},\"146\":{\"c\":[\"架构设计\"]},\"147\":{\"c\":[\"c++\",\"设计模式\",\"装饰器模式\"]},\"148\":{\"h\":\"桥接模式\"},\"149\":{\"h\":\"概述\",\"t\":[\"桥接模式（Bridge Pattern）是一种结构型设计模式，它的主要目的是将抽象部分与实现部分分离，使它们可以独立地变化。桥接模式通过将类的功能层次与实现层次分离，使得系统更具扩展性和灵活性。\"]},\"150\":{\"h\":\"结构\",\"t\":[\"桥接模式涉及以下几个角色：\",\"抽象类（Abstraction）：定义了抽象的接口，通常包含一个实现部分的引用（实现类接口类型）。\",\"扩展抽象类（Refined Abstraction）：继承自抽象类，通常是具体的业务逻辑类，调用实现部分的功能。\",\"实现类接口（Implementor）：定义实现类的接口，但不提供具体实现。实现类接口与抽象类没有继承关系。\",\"具体实现类（Concrete Implementor）：实现实现类接口，提供具体的实现逻辑。\"]},\"151\":{\"h\":\"示例\",\"t\":[\"#include <iostream> #include <memory> class Color { public: virtual void applyColor() const = 0; virtual ~Color() = default; }; class RedColor : public Color { public: void applyColor() const override { std::cout << \\\"Applying red color.\\\" << std::endl; } }; class BlueColor : public Color { public: void applyColor() const override { std::cout << \\\"Applying blue color.\\\" << std::endl; } }; class Shape { protected: std::shared_ptr<Color> color; public: Shape(std::shared_ptr<Color> c) : color(std::move(c)) {} virtual void draw() const = 0; virtual ~Shape() = default; }; class Circle : public Shape { public: Circle(std::shared_ptr<Color> c) : Shape(std::move(c)) {} void draw() const override { std::cout << \\\"Drawing a circle. \\\"; color->applyColor(); } }; class Square : public Shape { public: Square(std::shared_ptr<Color> c) : Shape(std::move(c)) {} void draw() const override { std::cout << \\\"Drawing a square. \\\"; color->applyColor(); } }; int main() { // 颜色n * 形状m 种组合 std::shared_ptr<Color> red = std::make_shared<RedColor>(); std::shared_ptr<Color> blue = std::make_shared<BlueColor>(); std::shared_ptr<Shape> redCircle = std::make_shared<Circle>(red); std::shared_ptr<Shape> blueSquare = std::make_shared<Square>(blue); redCircle->draw(); blueSquare->draw(); return 0; }\",\"总结\",\"解耦抽象与实现：通过桥接模式，可以独立地扩展抽象类和实现类，而不会相互影响。\",\"提高系统扩展性：可以很容易地增加新的形状或颜色，实现类和抽象类之间可以自由组合。\",\"桥接模式非常适合在一个类有多个维度的变化，并且需要将这些维度解耦的场景中使用。通过这种模式，可以保持系统的灵活性，同时避免类爆炸问题。\"]},\"152\":{\"c\":[\"架构设计\"]},\"153\":{\"c\":[\"c++\",\"设计模式\",\"桥接模式\"]},\"154\":{\"h\":\"工厂模式\"},\"155\":{\"h\":\"概述\",\"t\":[\"工厂模式和抽象工厂模式都是创建型设计模式，旨在为客户端提供对象的创建方式，而不需要指定创建的具体类。它们的主要区别在于工厂模式适用于创建单一产品，而抽象工厂模式适用于创建相关产品的家族。\"]},\"156\":{\"h\":\"工厂模式\",\"t\":[\"工厂模式提供了一种创建对象的方式，具体的创建逻辑被封装在工厂类中，客户端通过调用工厂的方法来获取对象，而无需了解具体的创建过程。\"]},\"157\":{\"h\":\"结构\",\"t\":[\"产品接口（Product）：定义了工厂所要创建的对象的接口或抽象类。\",\"具体产品（Concrete Product）：实现产品接口的具体类。\",\"工厂接口（Creator）：定义创建产品的方法。\",\"具体工厂（Concrete Creator）：实现工厂接口，负责具体产品的实例化。\"]},\"158\":{\"h\":\"示例\",\"t\":[\"假设我们有一个交通工具的工厂，可以生产汽车和自行车。\",\"#include <iostream> #include <memory> class Vehicle { public: virtual void drive() const = 0; virtual ~Vehicle() = default; }; class Car : public Vehicle { public: void drive() const override { std::cout << \\\"Driving a car.\\\" << std::endl; } }; class Bike : public Vehicle { public: void drive() const override { std::cout << \\\"Riding a bike.\\\" << std::endl; } }; class VehicleFactory { public: virtual std::shared_ptr<Vehicle> createVehicle() const = 0; virtual ~VehicleFactory() = default; }; class CarFactory : public VehicleFactory { public: std::shared_ptr<Vehicle> createVehicle() const override { return std::make_shared<Car>(); } }; class BikeFactory : public VehicleFactory { public: std::shared_ptr<Vehicle> createVehicle() const override { return std::make_shared<Bike>(); } }; int main() { std::shared_ptr<VehicleFactory> carFactory = std::make_shared<CarFactory>(); std::shared_ptr<VehicleFactory> bikeFactory = std::make_shared<BikeFactory>(); std::shared_ptr<Vehicle> car = carFactory->createVehicle(); std::shared_ptr<Vehicle> bike = bikeFactory->createVehicle(); car->drive(); bike->drive(); return 0; }\"]},\"159\":{\"h\":\"抽象工厂模式\",\"t\":[\"抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。抽象工厂模式通常用于创建不同产品族的对象。\"]},\"160\":{\"h\":\"结构\",\"t\":[\"抽象产品（Abstract Product）：定义产品家族中的各个产品的接口。\",\"具体产品（Concrete Product）：实现具体的产品类。\",\"抽象工厂（Abstract Factory）：定义创建产品族中各产品的接口。\",\"具体工厂（Concrete Factory）：实现创建具体产品族的方法。\"]},\"161\":{\"h\":\"示例\",\"t\":[\"假设我们有一个操作系统的工厂，可以生产不同操作系统环境下的按钮和文本框。\",\"class Button { public: virtual void click() const = 0; virtual ~Button() = default; }; class TextBox { public: virtual void type() const = 0; virtual ~TextBox() = default; }; class WindowsButton : public Button { public: void click() const override { std::cout << \\\"Windows Button clicked.\\\" << std::endl; } }; class WindowsTextBox : public TextBox { public: void type() const override { std::cout << \\\"Typing in Windows TextBox.\\\" << std::endl; } }; class MacOSButton : public Button { public: void click() const override { std::cout << \\\"MacOS Button clicked.\\\" << std::endl; } }; class MacOSTextBox : public TextBox { public: void type() const override { std::cout << \\\"Typing in MacOS TextBox.\\\" << std::endl; } }; class GUIFactory { public: virtual std::shared_ptr<Button> createButton() const = 0; virtual std::shared_ptr<TextBox> createTextBox() const = 0; virtual ~GUIFactory() = default; }; class WindowsFactory : public GUIFactory { public: std::shared_ptr<Button> createButton() const override { return std::make_shared<WindowsButton>(); } std::shared_ptr<TextBox> createTextBox() const override { return std::make_shared<WindowsTextBox>(); } }; class MacOSFactory : public GUIFactory { public: std::shared_ptr<Button> createButton() const override { return std::make_shared<MacOSButton>(); } std::shared_ptr<TextBox> createTextBox() const override { return std::make_shared<MacOSTextBox>(); } }; int main() { std::shared_ptr<GUIFactory> factory; // 使用Windows工厂创建产品 factory = std::make_shared<WindowsFactory>(); std::shared_ptr<Button> winButton = factory->createButton(); std::shared_ptr<TextBox> winTextBox = factory->createTextBox(); winButton->click(); winTextBox->type(); // 使用MacOS工厂创建产品 factory = std::make_shared<MacOSFactory>(); std::shared_ptr<Button> macButton = factory->createButton(); std::shared_ptr<TextBox> macTextBox = factory->createTextBox(); macButton->click(); macTextBox->type(); return 0; }\",\"总结\",\"工厂模式：用于创建单一类型的对象，将对象的实例化过程封装在工厂类中，减少客户端与具体类的耦合。\",\"抽象工厂模式：用于创建一系列相关或相互依赖的对象，通过定义一组工厂接口，客户端可以使用这些接口创建具体的产品对象，适用于需要创建多个产品族的场景。\",\"这两种模式都可以提高代码的灵活性和可维护性，特别是在需要扩展产品种类或改变产品族的实现时，非常有用。\"]},\"162\":{\"c\":[\"架构设计\"]},\"163\":{\"c\":[\"c++\",\"设计模式\",\"工厂模式\",\"抽象工厂模式\"]},\"164\":{\"h\":\"责任链模式\"},\"165\":{\"h\":\"概述\",\"t\":[\"责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。该模式将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为止。\"]},\"166\":{\"h\":\"结构\",\"t\":[\"责任链模式的核心思想是将请求沿着一条链传递，每个链上的对象都有机会处理请求。如果当前对象无法处理该请求，则将其传递给下一个对象，直到找到能够处理请求的对象。\",\"这个模式主要包括以下几个部分：\",\"处理者（Handler）：接口或抽象类，定义了处理请求的抽象方法，同时维护一个指向下一个处理者的引用。\",\"具体处理者（Concrete Handler）：实现了处理者接口，负责处理具体的请求。\",\"请求：需要沿着责任链传递的请求。\"]},\"167\":{\"h\":\"示例\",\"t\":[\"下面是一个用 C++ 实现的请假流程处理的责任链模式示例。这个示例模拟了请假请求根据天数由不同级别的领导审批的场景。\",\"#include <iostream> #include <memory> // 抽象处理者类 class LeaveHandler { protected: std::shared_ptr<LeaveHandler> nextHandler; public: // 设置下一个处理者 void setNextHandler(std::shared_ptr<LeaveHandler> handler) { nextHandler = handler; } // 处理请假请求的虚函数 virtual bool handleRequest(int days) = 0; }; // Team Leader 处理类 class TeamLeaderHandler : public LeaveHandler { public: bool handleRequest(int days) override { if (days <= 3) { std::cout << \\\"Team Leader approved \\\" << days << \\\" days leave.\\\" << std::endl; return true; } else if (nextHandler != nullptr) { return nextHandler->handleRequest(days); } else { return false; } } }; // Manager 处理类 class ManagerHandler : public LeaveHandler { public: void handleRequest(int days) override { if (days > 3 && days <= 7) { std::cout << \\\"Manager approved \\\" << days << \\\" days leave.\\\" << std::endl; return true; } else if (nextHandler != nullptr) { nextHandler->handleRequest(days); } else { return false; } } }; // Director 处理类 class DirectorHandler : public LeaveHandler { public: void handleRequest(int days) override { if (days > 7) { std::cout << \\\"Director approved \\\" << days << \\\" days leave.\\\" << std::endl; return true; } else if (nextHandler != nullptr) { nextHandler->handleRequest(days); } else { return false; } } }; int main() { // 创建处理者对象 std::shared_ptr<LeaveHandler> teamLeader = std::make_shared<TeamLeaderHandler>(); std::shared_ptr<LeaveHandler> manager = std::make_shared<ManagerHandler>(); std::shared_ptr<LeaveHandler> director = std::make_shared<DirectorHandler>(); // 设置责任链 teamLeader->setNextHandler(manager); manager->setNextHandler(director); // 发送不同天数的请假请求 int leaveDays1 = 2; // 由 Team Leader 处理 int leaveDays2 = 5; // 由 Manager 处理 int leaveDays3 = 10; // 由 Director 处理 teamLeader->handleRequest(leaveDays1); teamLeader->handleRequest(leaveDays2); teamLeader->handleRequest(leaveDays3); return 0; }\",\"运行上述代码后，输出结果如下：\",\"Team Leader approved 2 days leave. Manager approved 5 days leave. Director approved 10 days leave.\"]},\"168\":{\"h\":\"应用场景\",\"t\":[\"请求处理链：例如在 Web 服务器中，处理请求的各个过滤器（Filter）构成了一条责任链，每个过滤器负责处理特定类型的请求。\",\"事件处理系统：在图形用户界面（GUI）中，事件处理链可以使用责任链模式，将事件沿着组件树传递，直到某个组件处理该事件。\",\"日志处理：在日志框架中，多个日志处理器（如控制台日志、文件日志、远程日志等）可以组成责任链，依次处理日志信息。\",\"总结\",\"责任链模式通过将请求沿着一条链传递，实现了请求的解耦处理。它使得请求的发送者和接收者之间不再紧耦合，增强了系统的灵活性和可扩展性。在某些需要链式处理请求的场景中，责任链模式非常有用，但也需要注意链条过长带来的性能问题。\"]},\"169\":{\"c\":[\"架构设计\"]},\"170\":{\"c\":[\"c++\",\"设计模式\",\"责任链模式\"]},\"171\":{\"h\":\"MVVM 模式\",\"t\":[\"MVVM（Model-View-ViewModel）是一种常用于前端开发中的架构模式，它将用户界面逻辑和业务逻辑进行分离，从而使代码更具可维护性和可测试性。MVVM 模式是由微软架构师 John Gossman 于 2005 年提出的，最初用于 WPF（Windows Presentation Foundation） 和 Silverlight 中，现已广泛应用于各种前端框架和工具，如 Vue.js、Angular、React+Redux 等。\"]},\"172\":{\"h\":\"MVVM 的核心概念\",\"t\":[\"MVVM 模式由三部分组成：\",\"Model（模型）\",\"View（视图）\",\"ViewModel（视图模型）\",\"这三部分通过数据绑定（Data Binding）机制相互通信，实现界面和数据的自动同步。下面是各个部分的详细解释：\"]},\"173\":{\"h\":\"1. Model（模型）\",\"t\":[\"Model 代表应用程序的数据和业务逻辑，通常是纯粹的 JavaScript 对象、类或者数据结构。它负责处理与业务逻辑相关的所有操作，如数据的获取、保存和更新等。\",\"职责： \",\"管理应用程序的核心数据。\",\"处理业务逻辑，如增删改查等。\",\"与服务层（如 API）交互，获取或更新数据。\"]},\"174\":{\"h\":\"2. View（视图）\",\"t\":[\"View 是用户界面（UI）的展现层，负责将 ViewModel 中的数据展示给用户。它通常由 HTML、CSS 等构建而成，负责呈现数据和处理用户的输入（如按钮点击、表单提交等）。\",\"职责： \",\"负责界面的展示。\",\"捕捉用户输入，并将其传递给 ViewModel。\",\"数据绑定机制确保视图能够实时反映 ViewModel 的变化。\"]},\"175\":{\"h\":\"3. ViewModel（视图模型）\",\"t\":[\"ViewModel 作为 View 和 Model 之间的桥梁，负责处理界面显示逻辑。它从 Model 中获取数据并提供给 View，还处理用户的输入，并将其传递给 Model。ViewModel 不直接操作 View，而是通过数据绑定和命令机制进行交互。\",\"职责： \",\"提供 View 所需的数据。\",\"响应 View 的用户操作，并将操作传递给 Model。\",\"实现双向数据绑定，使得 View 和 Model 之间保持同步。\"]},\"176\":{\"h\":\"MVVM 的工作原理\",\"t\":[\"MVVM 的工作原理是通过数据绑定实现视图和模型的同步。视图层（View）直接绑定到 ViewModel 中的属性，这样当 ViewModel 中的数据发生变化时，视图会自动更新。同时，视图的用户输入会通过绑定机制传递给 ViewModel，ViewModel 再更新 Model。\",\"单向绑定：ViewModel 到 View 的数据流动。当 ViewModel 中的数据发生变化时，View 自动更新。\",\"双向绑定：View 到 ViewModel 的数据流动也同步。例如，用户在表单中输入数据时，ViewModel 会自动更新。\"]},\"177\":{\"h\":\"MVVM 与 MVC、MVP 的对比\",\"t\":[\"MVC（Model-View-Controller）：MVC 中，控制器（Controller）负责响应用户交互并更新模型（Model）。视图（View）观察模型，并根据模型的变化进行更新。MVC 的控制器承担了较多的业务逻辑处理工作。\",\"MVP（Model-View-Presenter）：MVP 中，Presenter 是负责视图与模型之间通信的中介，View 不直接依赖 Model。Presenter 包含了 UI 逻辑和交互逻辑，处理用户事件，并与 Model 交互。\",\"MVVM：MVVM 的核心是 ViewModel，它将 Model 和 View 进行解耦。View 和 ViewModel 通过数据绑定机制进行通信，View 只关注界面展示，ViewModel 负责处理逻辑。\",\"对比总结：\",\"解耦程度：MVVM 提高了 View 和 Model 的解耦程度，尤其在数据绑定方面更为自动化和灵活。\",\"代码维护：由于 ViewModel 仅处理与 UI 逻辑相关的部分，Model 专注于业务逻辑，这使得 MVVM 在代码的分离和维护性方面优于 MVC 和 MVP。\",\"适用场景：MVVM 更适合需要复杂数据绑定和动态 UI 更新的应用，特别是在现代前端框架（如 Vue、Angular）中应用广泛。\"]},\"178\":{\"h\":\"MVVM 的优缺点\"},\"179\":{\"h\":\"优点：\",\"t\":[\"解耦性好：View 和 Model 之间没有直接的依赖关系，二者通过 ViewModel 进行沟通，代码更具模块化。\",\"可测试性强：由于 ViewModel 独立于 View，业务逻辑和数据处理部分可以通过单元测试进行验证，而不依赖于实际的 UI。\",\"数据绑定机制：数据绑定使得 View 和 ViewModel 之间的同步更加方便，减少了手动操作 DOM 的代码。\"]},\"180\":{\"h\":\"缺点：\",\"t\":[\"学习成本高：对于初学者来说，理解 MVVM 的数据绑定和通信机制可能有一定的难度。\",\"性能问题：在复杂的场景下，大量的数据绑定可能会引起性能问题，尤其是在数据变更频繁的情况下。\",\"调试难度增加：由于数据绑定是自动化的，可能导致调试过程变得更加复杂，不易跟踪数据的流动。\"]},\"181\":{\"h\":\"MVVM 应用示例：使用 Vue.js\",\"t\":[\"Vue.js 是一种典型的 MVVM 框架，下面展示了一个简单的 Vue.js 示例，展示 MVVM 的工作原理。\",\"<div id=\\\"app\\\"> <input v-model=\\\"name\\\" placeholder=\\\"Enter your name\\\"> <p>Hello, {{ name }}!</p> </div> <script src=\\\"https://cdn.jsdelivr.net/npm/vue@2\\\"></script> <script> new Vue({ el: '#app', data: { name: '' } }); </script>\",\"在这个示例中：\",\"Model：data 对象中存储的 name 字段。\",\"View：HTML 模板中展示数据的部分，如 input 和 p 标签。\",\"ViewModel：Vue 实例管理的数据和行为，负责与 View 的数据绑定和交互。\",\"当用户在输入框中输入数据时，v-model 会自动更新 data 中的 name，并且由于数据绑定，{{ name }} 会同步更新到页面上。\"]},\"182\":{\"h\":\"总结\",\"t\":[\"MVVM 模式通过数据绑定机制，将 View 和 Model 进行解耦，使得前端开发中的数据管理和 UI 渲染变得更加高效。它非常适合需要频繁更新 UI 的应用，尤其在现代前端开发框架中广泛应用。虽然 MVVM 提供了很好的解耦性和可维护性，但也带来了性能和调试方面的挑战，因此在应用时需要根据具体情况权衡。\"]},\"183\":{\"c\":[\"架构设计\"]},\"184\":{\"c\":[\"设计模式\",\"MVVM\"]},\"185\":{\"h\":\"Model-View 框架\",\"t\":[\"Qt 的 Model-View 框架是一种用于处理和显示数据的灵活机制，特别适合需要在用户界面中展示大量或复杂数据的应用程序。通过将数据和显示逻辑解耦，Model-View 框架提供了更高的灵活性和可维护性。Qt 的 Model-View 框架包含三个主要组件：Model（模型）、View（视图）和 Delegate（委托）。\"]},\"186\":{\"h\":\"Model-View 框架的核心概念\"},\"187\":{\"h\":\"Model（模型）\",\"t\":[\"Model 是数据的抽象表示，负责存储和管理数据，并向 View 提供访问这些数据的接口。Model 不直接与 UI 打交道，而是通过信号和槽机制通知 View 数据的变化。Qt 提供了几个现成的模型类，如 QStandardItemModel 和 QStringListModel，开发者也可以通过继承 QAbstractItemModel、QAbstractTableModel 或 QAbstractListModel 来自定义模型。\",\"Model 的主要职责：\",\"管理数据：模型负责存储和管理数据，包括对数据的增删改查操作。\",\"提供接口：模型通过标准化的接口提供数据给 View。\",\"通知数据变更：模型会在数据发生变化时发出信号，通知 View 更新显示。\",\"Qt 中常用的 Model 类：\",\"QAbstractItemModel：所有自定义模型的基类，适合树状结构数据。\",\"QAbstractListModel：用于一维列表数据的基类。\",\"QAbstractTableModel：用于二维表格数据的基类。\",\"QStandardItemModel：提供标准的项目模型，实现了表格和树状结构的支持。\",\"示例：使用 QStandardItemModel 来存储和操作数据。\",\"QStandardItemModel *model = new QStandardItemModel(); model->setHorizontalHeaderLabels({\\\"Name\\\", \\\"Age\\\"}); QStandardItem *item1 = new QStandardItem(\\\"John\\\"); QStandardItem *item2 = new QStandardItem(\\\"25\\\"); model->appendRow({item1, item2});\"]},\"188\":{\"h\":\"View（视图）\",\"t\":[\"View 负责展示数据，是用户与数据进行交互的界面部分。View 通过访问 Model 提供的数据，并将这些数据渲染到屏幕上。常用的视图类包括 QListView、QTableView 和 QTreeView，它们分别用于显示列表、表格和树形数据。\",\"View 的主要职责：\",\"显示数据：View 从 Model 中获取数据并进行显示。\",\"用户交互：View 处理用户的输入，如点击、编辑等。\",\"数据同步：View 会自动更新显示，确保与 Model 数据保持一致。\",\"Qt 中常用的 View 类：\",\"QListView：用于显示列表数据。\",\"QTableView：用于显示表格数据。\",\"QTreeView：用于显示树形结构数据。\",\"示例：使用 QTableView 显示 QStandardItemModel 的数据。\",\"QTableView *view = new QTableView(); view->setModel(model); view->show();\"]},\"189\":{\"h\":\"Delegate（委托）\",\"t\":[\"Delegate 是 View 和 Model 之间的中介，用于定制数据的显示和编辑。通过委托，开发者可以控制单元格的外观和编辑方式。Qt 默认的委托类是 QStyledItemDelegate，你可以继承这个类来自定义数据的显示和编辑行为。\",\"Delegate 的主要职责：\",\"渲染数据：委托负责将 Model 中的数据渲染为可视化的控件或元素。\",\"编辑数据：委托还负责处理数据的编辑，提供自定义的编辑控件和逻辑。\",\"示例：自定义委托，通过 QStyledItemDelegate 渲染数据。\",\"class CustomDelegate : public QStyledItemDelegate { Q_OBJECT public: CustomDelegate(QObject *parent = nullptr) : QStyledItemDelegate(parent) {} void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const override { painter->save(); // 自定义绘制逻辑 painter->drawText(option.rect, Qt::AlignCenter, index.data().toString()); painter->restore(); } }; // 在视图中使用自定义委托 view->setItemDelegate(new CustomDelegate());\"]},\"190\":{\"h\":\"Model-View 的数据流\",\"t\":[\"Model-View 模式的关键在于数据与 UI 的分离，数据流的方向如下：\",\"View 获取数据：View 通过 setModel() 设置模型，并通过模型的标准接口（如 data()、rowCount()、columnCount()）获取数据并显示在界面上。\",\"用户交互：用户在 View 中进行操作（如点击、编辑），这些操作会通过委托发送到 Model，Model 根据操作更新数据。\",\"Model 通知 View：当 Model 数据发生变化时，Model 通过信号通知 View，View 自动刷新显示。\"]},\"191\":{\"h\":\"数据绑定与更新\",\"t\":[\"在 Qt 的 Model-View 模式中，数据更新主要依赖于信号与槽机制。Model 通过 dataChanged() 等信号通知 View 数据已更改，View 会根据这些信号自动更新显示内容。常用的更新信号包括：\",\"dataChanged()：当模型中的某个数据项发生变化时发出。\",\"layoutChanged()：当模型的布局发生变化时发出，例如排序、筛选等操作。\",\"rowsInserted()、rowsRemoved()：当插入或删除行时发出。\"]},\"192\":{\"h\":\"Qt 中的 Model-View 与 MVC\",\"t\":[\"Qt 的 Model-View 框架类似于传统的 MVC（Model-View-Controller）模式，但它没有显式的 Controller。Qt 的设计将 Controller 的职责分散到 View 和 Delegate 中：\",\"View：负责展示数据，并处理用户交互。\",\"Delegate：负责处理数据的呈现和编辑。\",\"通过这种设计，Qt 的 Model-View 框架能够更加灵活地支持各种数据展示场景，开发者可以更自由地定制数据的显示和交互行为。\"]},\"193\":{\"h\":\"自定义模型\",\"t\":[\"虽然 Qt 提供了多种现成的模型类，但在实际应用中，经常需要创建自定义模型，以适应复杂的数据结构和特定的业务需求。自定义模型需要继承 QAbstractItemModel、QAbstractTableModel 或 QAbstractListModel，并实现相关的接口方法。\",\"常见需要实现的方法：\",\"rowCount()：返回模型的行数。\",\"columnCount()：返回模型的列数。\",\"data()：返回指定索引处的数据。\",\"setData()：用于修改指定索引处的数据。\",\"headerData()：返回模型的表头数据。\",\"示例：自定义一个简单的表格模型。\",\"class CustomTableModel : public QAbstractTableModel { Q_OBJECT public: CustomTableModel(QObject *parent = nullptr) : QAbstractTableModel(parent) {} int rowCount(const QModelIndex &parent = QModelIndex()) const override { return 5; // 5 行 } int columnCount(const QModelIndex &parent = QModelIndex()) const override { return 3; // 3 列 } QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override { if (role == Qt::DisplayRole) { return QString(\\\"Row%1, Column%2\\\").arg(index.row()).arg(index.column()); } return QVariant(); } };\"]},\"194\":{\"h\":\"代理模型\",\"t\":[\"Qt 提供了一些代理模型（Proxy Model）来对原始模型的数据进行转换或过滤。常用的代理模型有：\",\"QSortFilterProxyModel：用于对数据进行排序和过滤。\",\"QIdentityProxyModel：直接映射原始模型，适合做数据的装饰或修改。\",\"使用代理模型可以在不修改原始模型的情况下，对数据进行排序、过滤或其他转换操作。\",\"示例：使用 QSortFilterProxyModel 进行排序。\",\"QSortFilterProxyModel *proxyModel = new QSortFilterProxyModel(); proxyModel->setSourceModel(model); proxyModel->sort(0, Qt::AscendingOrder); // 对第 0 列进行升序排序 view->setModel(proxyModel);\",\"总结\",\"Qt 的 Model-View 框架通过将数据和显示逻辑解耦，提供了更高的灵活性和可维护性。无论是使用现成的模型类，还是通过自定义模型，开发者都能够以更清晰的方式管理复杂的数据展示和用户交互。通过委托机制，Qt 允许开发者定制数据的显示和编辑，使得 UI 的表现力更强。而代理模型则进一步扩展了数据处理的能力，使得数据的排序、过滤等操作更加方便。\"]},\"195\":{\"c\":[\"架构设计\"]},\"196\":{\"c\":[\"设计模式\",\"Model-View\",\"Qt\"]},\"197\":{\"h\":\"架构设计\"},\"198\":{\"c\":[\"架构设计\"]},\"199\":{\"h\":\"c++ 基础\"},\"200\":{\"h\":\"1. static 关键字的作用？\",\"t\":[\"修饰全局变量或函数，限制作用范围，只可以在当前文件访问；\",\"修饰局部变量，延长变量的生命周期为整个程序的生命周期，函数return 后变量不会释放；\",\"在class中用于声明类成员或函数，类成员或函数可以直接通过类名访问无需创建对象；\"]},\"201\":{\"h\":\"2. new/delete与malloc/new的区别？\",\"t\":[\"malloc/new 是c语言标准库提供的一组用于动态申请释放内存的API；\",\"new/delete是c++语言标准库提供的一组用于动态创建/释放对象的操作符，在申请/释放内存的基础上还会额外调用构造/析构函数，是c++ RAII 实现的基础；\",\"new = malloc + 构造函数，delete = 析构函数 + free；\"]},\"202\":{\"h\":\"3. 假设有数组 int a[10], a、&a[0]与 &a 这3者的区别？\",\"t\":[\"a、&a[0]与 &a 都是一个指针代表一个内存，且值相同；\",\"其中a 为数组名指向首元素地址即与&a[0] 相同，&a 为数组的指针，三者做运算时有差异： a+1 和 &a[0]+1 是内存地址偏移一个元素的位置(地址值+sizeof(int))，即指向第二个元素a[1], &a+1, 内存地址偏移一个数组的位置(地址值+sizeof(int)*10)\"]},\"203\":{\"h\":\"4. 宏与constexpr 区别?\",\"t\":[\"宏用于定义常量和简单的代码片段，在预编译时期会被完整替换；\",\"constexpr 可以取代宏的功能，用来定义常量和函数；\",\"宏没有类型安全检查，而constexpr有\"]},\"204\":{\"h\":\"5. extern \\\"C\\\"\",\"t\":[\"c++ 为支持函数重载引入了name mangling 技术，将重载函数重新命名成唯一的标识符，如void foo(int) 函数名被修饰成_ZfooEi, 这样 c 代码link foo 函数时会失败；\",\"extern \\\"C\\\" 让c++ 代码编译时不使用name mangling，保持与c 语言一样的方式， 这样就可以解决c代码调用c++ 代码的存在的link 问题\"]},\"205\":{\"h\":\"6. const 关键字的作用？\",\"t\":[\"定义常量，即被修饰变量不可以被修改；\",\"const& 用于函数穿参数\",\"修饰成员函数表示函数体不会修改类成员（被mutable 修饰除外）\"]},\"206\":{\"h\":\"继承与多态\"},\"207\":{\"h\":\"C++的多态如何实现\",\"t\":[\"C++的多态性，一言以蔽之就是：\",\"在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。\",\"举个例子：\",\"#include <iostream> using namespace std; class Base{ public: virtual void fun(){ cout << \\\" Base::func()\\\" <<endl; } }; class Son1 : public Base{ public: virtual void fun() override{ cout << \\\" Son1::func()\\\" <<endl; } }; class Son2 : public Base{ }; int main() { Base* base = new Son1; base->fun(); base = new Son2; base->fun(); delete base; base = NULL; return 0; } // 运行结果 // Son1::func() // Base::func()\",\"例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？这里需要引出虚表和虚基表指针的概念。\",\"虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表\",\"虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针\",\"上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：\",\"(1)编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址\",\"(2)编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数\",\"(3)所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表\",\"(4)当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面\",\"这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。\"]},\"208\":{\"h\":\"基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间\",\"t\":[\"首先整理一下虚函数表的特征：\",\"虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成\",\"虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段\",\"虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中\",\"根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：\",\"虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别\",\"由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。\"]},\"209\":{\"h\":\"构造函数和析构函数可以调用虚函数?\",\"t\":[\"在C++中，提倡不在构造函数和析构函数中调用虚函数；\",\"构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；\",\"因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；\",\"析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。\"]},\"210\":{\"h\":\"构造函数为什么不能为虚函数？析构函数为什么要虚函数？\",\"t\":[\"1、 从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。\",\"问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。\",\"2、 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。\",\"构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。\",\"所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\",\"3、构造函数不须要是虚函数，也不同意是虚函数，由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。\",\"4、从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。\",\"5、当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。\",\"因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。\",\"并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。\",\"VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。\",\"因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。\",\"直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。\",\"具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。\",\"所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。\"]},\"211\":{\"c\":[\"面试题\"]},\"212\":{\"c\":[\"c++\"]},\"213\":{\"h\":\"进程编程\"},\"214\":{\"h\":\"进程状态\"},\"215\":{\"h\":\"进程的基本状态\",\"t\":[\"新建（New）：\",\"进程正在被创建，还未进入准备就绪队列。\",\"就绪（Ready）：\",\"进程已经被创建并准备好执行，等待被调度器分配 CPU 资源。\",\"运行（Running）：\",\"进程正在 CPU 上执行代码。\",\"阻塞（Blocked）：\",\"进程无法继续执行，正在等待某个事件（如 I/O 完成、资源可用）发生。\",\"终止（Terminated）：\",\"进程已完成执行或因某种原因被强制终止，系统将其从内存中移除。\"]},\"216\":{\"h\":\"进程状态之间的转换\",\"t\":[\"进程在其生命周期内可以在不同状态之间进行转换，以下是常见的状态转换路径：\",\"新建 → 就绪：\",\"当进程创建完成，分配了必要的资源后，就会进入就绪状态，等待调度器的调度。\",\"就绪 → 运行：\",\"调度器选择一个就绪的进程并将其分配给 CPU，进程进入运行状态。\",\"运行 → 就绪：\",\"如果运行中的进程的时间片耗尽，或者由于其他更高优先级的进程需要 CPU，则该进程被挂起并返回到就绪队列中，等待下一次调度。\",\"运行 → 阻塞：\",\"当进程执行 I/O 操作或等待某个事件发生（如等待信号、等待资源）时，进程进入阻塞状态，CPU 被释放给其他就绪进程。\",\"阻塞 → 就绪：\",\"当等待的事件发生（如 I/O 完成或资源可用），阻塞的进程会被移回就绪队列，等待再次被调度。\",\"运行 → 终止：\",\"当进程完成其任务或被强制终止时，进程进入终止状态，系统将其从内存中清除。\"]},\"217\":{\"h\":\"状态转换示意图\"},\"218\":{\"h\":\"僵尸进程\",\"t\":[\"僵尸进程（Zombie Process）是在 UNIX 或类 UNIX 系统（如 Linux）中，子进程终止后，其父进程没有及时调用 wait() 或 waitpid() 函数回收子进程的退出状态信息，从而导致的进程状态。\",\"具体来说，当一个子进程结束时，它的所有资源（如内存、文件描述符等）都会被操作系统回收，但它的进程描述符（即进程控制块，包含退出状态信息等）仍然保留在系统中。这是为了允许父进程能够获取子进程的退出状态。当父进程调用 wait() 或 waitpid() 获取子进程的退出状态后，僵尸进程的进程描述符才会被完全清除。\"]},\"219\":{\"h\":\"僵尸进程的影响\",\"t\":[\"资源占用：虽然僵尸进程不会占用内存或 CPU，但它会占用一个进程表项（即进程描述符）。在系统中，进程表项的数量是有限的，如果有大量僵尸进程存在，可能会导致系统无法创建新进程。\",\"系统管理的麻烦：大量僵尸进程可能会让系统管理者难以管理和监控系统状态。\"]},\"220\":{\"h\":\"如何避免产生僵尸进程？\",\"t\":[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态。以下是几种常用的方法：\",\"及时调用 wait() 或 waitpid()：\",\"父进程在适当的时机调用 wait() 或 waitpid() 函数，以获取并处理子进程的退出状态，从而防止僵尸进程的产生。\",\"pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 wait(NULL); // 等待子进程结束并回收资源 }\",\"使用 SIGCHLD 信号处理子进程的结束：\",\"当子进程结束时，父进程会收到 SIGCHLD 信号。父进程可以在信号处理程序中调用 wait() 或 waitpid() 以回收子进程的资源。\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> #include <signal.h> void sigchld_handler(int signum) { // 等待所有已终止的子进程 while (waitpid(-1, NULL, WNOHANG) > 0); } int main() { // 注册 SIGCHLD 信号处理程序 signal(SIGCHLD, sigchld_handler); pid_t pid = fork(); if (pid == 0) { // 子进程代码 exit(0); } else { // 父进程代码 // 父进程继续执行其任务 pause(); // 等待信号（例如 SIGCHLD） } return 0; }\",\"将子进程的父进程设置为 init 进程（或 systemd）：\",\"如果父进程在子进程结束前退出，子进程会被 init 进程（PID 为 1 的进程）接管。init 进程会自动调用 wait() 回收子进程的资源，避免僵尸进程的产生。可以通过调用 fork() 后使父进程退出，子进程被 init 接管。\",\"pid_t pid = fork(); if (pid > 0) { // 父进程退出 exit(0); } // 子进程继续执行 // 此时子进程的父进程是 init 进程\",\"采用 double fork() 技术：\",\"父进程通过 fork() 创建一个子进程，子进程再 fork() 创建一个孙子进程，然后子进程立即退出，父进程只需等待子进程的退出状态，孙子进程则由 init 进程接管。\",\"pid_t pid = fork(); if (pid == 0) { // 第一个子进程 pid_t pid2 = fork(); if (pid2 == 0) { // 孙子进程 // 在此处执行需要守护的任务 exit(0); } else { // 第一个子进程退出 exit(0); } } else { // 父进程等待第一个子进程退出 wait(NULL); }\",\"::: 僵尸进程是因父进程未及时处理子进程的退出状态而产生的。通过及时调用 wait() 系列函数、处理 SIGCHLD 信号、使用 init 进程接管孤儿进程或采用 double fork() 技术，可以有效避免僵尸进程的产生。在实际开发中，选择适当的方法管理子进程的生命周期，对于保持系统的稳定性和资源利用率至关重要。 :::\"]},\"221\":{\"h\":\"守护进程\",\"t\":[\"在 Linux 系统中，守护进程（Daemon）是一种在后台运行的进程，通常不与任何终端关联。创建守护进程的步骤包括分离进程、关闭标准文件描述符、设置新的会话等。下面是一个用 C++ 创建守护进程的示例代码。\"]},\"222\":{\"h\":\"代码示例\",\"t\":[\"#include <iostream> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <signal.h> #include <stdlib.h> void createDaemon() { pid_t pid; // 1. Fork子进程并退出父进程，使子进程在后台运行 pid = fork(); if (pid < 0) { std::cerr << \\\"Fork failed.\\\" << std::endl; exit(EXIT_FAILURE); } if (pid > 0) { // 父进程退出 exit(EXIT_SUCCESS); } // 2. 创建新的会话，脱离终端 if (setsid() < 0) { std::cerr << \\\"Failed to create new session.\\\" << std::endl; exit(EXIT_FAILURE); } // 3. Fork第二个子进程，确保守护进程不能重新打开控制终端 pid = fork(); if (pid < 0) { std::cerr << \\\"Fork failed.\\\" << std::endl; exit(EXIT_FAILURE); } if (pid > 0) { // 第一个子进程退出 exit(EXIT_SUCCESS); } // 4. 设置文件权限掩码 umask(0); // 5. 更改工作目录 if (chdir(\\\"/\\\") < 0) { std::cerr << \\\"Failed to change directory to /.\\\" << std::endl; exit(EXIT_FAILURE); } // 6. 关闭标准文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); // 7. 将标准文件描述符重定向到 /dev/null open(\\\"/dev/null\\\", O_RDWR); // STDIN_FILENO = 0 dup(0); // STDOUT_FILENO = 1 dup(0); // STDERR_FILENO = 2 // 守护进程的主循环 while (true) { // 执行守护进程的任务 sleep(10); // 示例：每隔10秒执行一次任务 } } int main() { // 创建守护进程 createDaemon(); // 守护进程的其他工作逻辑可以写在这里 return 0; }\"]},\"223\":{\"h\":\"代码解释\",\"t\":[\"Fork 子进程并退出父进程：\",\"调用 fork() 创建一个子进程。父进程退出，子进程继续运行，从而实现进程在后台运行。\",\"创建新的会话：\",\"调用 setsid() 创建一个新的会话。子进程成为新的会话组长，从而脱离控制终端。\",\"Fork 第二个子进程：\",\"再次 fork()，目的是防止守护进程重新获取控制终端。第一个子进程退出，第二个子进程继续运行。\",\"设置文件权限掩码：\",\"使用 umask(0) 清除文件权限掩码，以确保守护进程创建的新文件有正确的权限。\",\"更改工作目录：\",\"将当前工作目录更改为根目录（/），以避免守护进程占用可卸载的文件系统。\",\"关闭标准文件描述符：\",\"关闭标准输入、标准输出和标准错误输出文件描述符，守护进程不再依赖于终端。\",\"重定向标准文件描述符：\",\"将标准文件描述符重定向到 /dev/null，即使守护进程尝试读取或写入标准输入输出，也不会有任何操作。\",\"主循环：\",\"在守护进程的主循环中执行具体任务。可以使用 sleep() 模拟周期性任务执行。\"]},\"224\":{\"h\":\"注意事项\",\"t\":[\"信号处理：守护进程通常需要处理系统信号，如 SIGTERM 用于优雅地终止进程。\",\"日志记录：守护进程不能直接输出到终端，通常会使用日志文件或 syslog 记录日志。\",\"运行权限：某些守护进程需要特定的权限，如 root 权限，这时需要特别注意权限管理。\",\"以上代码创建了一个简单的守护进程，实际应用中可以根据需求扩展守护进程的功能，如处理信号、写日志等。\"]},\"225\":{\"h\":\"进程间通信\",\"t\":[\"进程间通信（Inter-rocess Communication，IPC）是操作系统提供的功能，允许不同的进程之间交换数据和信号。在多任务操作系统中，进程是独立的实体，各自拥有独立的内存空间。因此，IPC 成为进程之间协调和数据共享的关键手段。常见的进程间通信方式包括：\"]},\"226\":{\"h\":\"1.\",\"t\":[\"管道是最基本的 IPC 机制，用于在父子进程之间传递数据。管道是一种半双工的通信方式，数据只能单向流动。\",\"无名管道 (Anonymous Pipes)：只能用于有亲缘关系的进程（如父子进程）之间。\",\"有名管道 (Named Pipes, FIFO)：可以用于无亲缘关系的进程之间。\",\"示例代码（无名管道）：\",\"#include <iostream> #include <unistd.h> int main() { int fd[2]; pipe(fd); // 创建无名管道 pid_t pid = fork(); if (pid == 0) { // 子进程 close(fd[0]); // 关闭读端 const char* msg = \\\"Hello from child process\\\"; write(fd[1], msg, strlen(msg) + 1); // 写入管道 close(fd[1]); // 关闭写端 } else { // 父进程 close(fd[1]); // 关闭写端 char buffer[128]; read(fd[0], buffer, sizeof(buffer)); // 从管道读取 std::cout << \\\"Parent received: \\\" << buffer << std::endl; close(fd[0]); // 关闭读端 } return 0; }\"]},\"227\":{\"h\":\"2.\",\"t\":[\"消息队列允许进程以消息为单位进行通信，消息队列可以实现多个进程之间的消息传递和同步。\",\"示例代码：\",\"#include <iostream> #include <sys/ipc.h> #include <sys/msg.h> #include <cstring> struct Message { long msg_type; char msg_text[100]; }; int main() { key_t key = ftok(\\\"progfile\\\", 65); // 生成唯一键 int msgid = msgget(key, 0666 | IPC_CREAT); // 创建消息队列 if (fork() == 0) { // 子进程 Message msg; msg.msg_type = 1; strcpy(msg.msg_text, \\\"Hello from child process\\\"); msgsnd(msgid, &msg, sizeof(msg.msg_text), 0); // 发送消息 std::cout << \\\"Message sent from child process\\\" << std::endl; } else { // 父进程 Message msg; msgrcv(msgid, &msg, sizeof(msg.msg_text), 1, 0); // 接收消息 std::cout << \\\"Parent received: \\\" << msg.msg_text << std::endl; msgctl(msgid, IPC_RMID, NULL); // 删除消息队列 } return 0; }\"]},\"228\":{\"h\":\"3.\",\"t\":[\"共享内存是一种高效的进程间通信方式，允许多个进程直接访问同一块内存区域。共享内存速度快，但需要进程间同步机制（如信号量）来避免数据竞争。\",\"示例代码：\",\"#include <iostream> #include <sys/ipc.h> #include <sys/shm.h> #include <cstring> int main() { key_t key = ftok(\\\"shmfile\\\", 65); // 生成唯一键 int shmid = shmget(key, 1024, 0666 | IPC_CREAT); // 创建共享内存 if (fork() == 0) { // 子进程 char* str = (char*) shmat(shmid, (void*)0, 0); // 连接共享内存 strcpy(str, \\\"Hello from child process\\\"); shmdt(str); // 分离共享内存 } else { // 父进程 wait(NULL); // 等待子进程完成 char* str = (char*) shmat(shmid, (void*)0, 0); // 连接共享内存 std::cout << \\\"Parent received: \\\" << str << std::endl; shmdt(str); // 分离共享内存 shmctl(shmid, IPC_RMID, NULL); // 销毁共享内存 } return 0; }\"]},\"229\":{\"h\":\"4.\",\"t\":[\"信号量是一种用于进程间同步的机制，常与共享内存结合使用，以防止多个进程同时访问共享资源。\",\"示例代码：\",\"#include <iostream> #include <sys/ipc.h> #include <sys/sem.h> union semun { int val; struct semid_ds *buf; unsigned short *array; struct seminfo *__buf; }; void semaphoreWait(int semid) { struct sembuf sb = {0, -1, 0}; // 减少信号量 semop(semid, &sb, 1); } void semaphoreSignal(int semid) { struct sembuf sb = {0, 1, 0}; // 增加信号量 semop(semid, &sb, 1); } int main() { key_t key = ftok(\\\"semfile\\\", 65); int semid = semget(key, 1, 0666 | IPC_CREAT); semun sem_union; sem_union.val = 1; semctl(semid, 0, SETVAL, sem_union); // 初始化信号量 if (fork() == 0) { // 子进程 semaphoreWait(semid); std::cout << \\\"Child process is in critical section\\\" << std::endl; sleep(2); std::cout << \\\"Child process leaving critical section\\\" << std::endl; semaphoreSignal(semid); } else { // 父进程 semaphoreWait(semid); std::cout << \\\"Parent process is in critical section\\\" << std::endl; sleep(2); std::cout << \\\"Parent process leaving critical section\\\" << std::endl; semaphoreSignal(semid); wait(NULL); // 等待子进程完成 semctl(semid, 0, IPC_RMID); // 删除信号量 } return 0; }\"]},\"230\":{\"h\":\"5.\",\"t\":[\"信号是一种异步通知机制，用于通知进程某个事件发生。信号可以用于进程间的简单通信或异常处理。\",\"示例代码：\",\"#include <iostream> #include <csignal> #include <unistd.h> void signalHandler(int signum) { std::cout << \\\"Interrupt signal (\\\" << signum << \\\") received.\\\\n\\\"; exit(signum); } int main() { signal(SIGINT, signalHandler); // 注册信号处理程序 std::cout << \\\"Waiting for signal SIGINT (Ctrl+C)...\\\\n\\\"; while (true) { sleep(1); // 模拟进程在运行 } return 0; }\"]},\"231\":{\"h\":\"6.\",\"t\":[\"套接字是一种网络通信的进程间通信方式，适用于分布式系统中的进程间通信。它支持 TCP 和 UDP 两种模式，可以用于不同主机之间的进程通信。\",\"示例代码（TCP 套接字）：\",\"// server.cpp #include <iostream> #include <sys/socket.h> #include <netinet/in.h> #include <unistd.h> int main() { int server_fd = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in address = {AF_INET, htons(8080), INADDR_ANY}; bind(server_fd, (struct sockaddr*)&address, sizeof(address)); listen(server_fd, 3); int new_socket = accept(server_fd, NULL, NULL); const char* msg = \\\"Hello from server\\\"; send(new_socket, msg, strlen(msg), 0); close(new_socket); close(server_fd); return 0; } // client.cpp #include <iostream> #include <sys/socket.h> #include <arpa/inet.h> #include <unistd.h> int main() { int sock = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in serv_addr = {AF_INET, htons(8080), inet_addr(\\\"127.0.0.1\\\")}; connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)); char buffer[1024] = {0}; read(sock, buffer, sizeof(buffer)); std::cout << \\\"Message from server: \\\" << buffer << std::endl; close(sock); return 0; }\"]},\"232\":{\"h\":\"总结\",\"t\":[\"进程间通信是操作系统中用于协调和共享数据的重要机制。根据应用场景的不同，可以选择不同的 IPC 方式，如管道、消息队列、共享内存、信号量、信\",\"号和套接字。每种通信方式都有其优缺点和适用场景，需要根据需求进行选择。\"]},\"233\":{\"c\":[\"面试题\"]},\"234\":{\"c\":[\"c++\",\"多进程\",\"进程通信\"]},\"235\":{\"h\":\"线程编程\"},\"236\":{\"h\":\"如何创建线程？\",\"t\":[\"C++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：\",\"// thread example #include <iostream> // std::cout #include <thread> // std::thread void foo() { // do stuff... } void bar(int x) { // do stuff... } int main() { std::thread first (foo); // spawn new thread that calls foo() std::thread second (bar,0); // spawn new thread that calls bar(0) std::cout << \\\"main, foo and bar now execute concurrently...\\\\n\\\"; // synchronize threads: first.join(); // pauses until first finishes second.join(); // pauses until second finishes std::cout << \\\"foo and bar completed.\\\\n\\\"; return 0; }\",\"上述代码中，函数 foo() 和 bar(0) 分别运行在线程对象 first 和 second 中，从刚创建对象开始就会新建一个线程用于执行函数，调用 join() 函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的 detach() 函数，表示将线程和线程对象分离，新的线程与主线程没有任何关联，线程资源在任务结束后会由操作系统自动回收。\",\"如果没有调用 join() 或者 detach() 函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生crash，这里有两种解决办法，一个是调用 join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用 detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完成。\"]},\"237\":{\"h\":\"线程同步机制\"},\"238\":{\"h\":\"\",\"t\":[\"实现原理：\",\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问。具体实现步骤如下：\",\"基本结构：\",\"互斥量有一个内部状态，通常用布尔值或整数表示（锁定或未锁定）。\",\"维护一个等待队列，用于保存等待锁的线程。\",\"锁定 (Lock)：\",\"当一个线程尝试锁定互斥量时，如果互斥量未锁定，则线程成功锁定，并将互斥量状态设置为锁定。\",\"如果互斥量已锁定，则该线程进入等待队列并挂起，直到互斥量被解锁。\",\"解锁 (Unlock)：\",\"当一个线程解锁互斥量时，如果等待队列中有其他线程，则唤醒一个线程，使其尝试重新锁定互斥量。\",\"如果没有线程在等待，则将互斥量状态设置为未锁定。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> std::mutex mtx; void print_thread_id(int id) { std::lock_guard<std::mutex> guard(mtx); // 自动加锁和解锁 std::cout << \\\"Thread #\\\" << id << std::endl; } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_thread_id, i); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"239\":{\"h\":\"\",\"t\":[\"实现原理：\",\"读写锁允许多个线程同时读取，但在写入时只允许一个线程操作。其实现原理如下：\",\"基本结构：\",\"读写锁包含两个计数器：一个用于记录当前正在读取的线程数，另一个用于记录是否有写线程在等待。\",\"维护一个等待队列，用于保存等待的线程。\",\"读锁定 (Read Lock)：\",\"当一个线程请求读锁定时，如果没有写锁存在，则增加读计数器，线程继续执行。\",\"如果有写锁存在，则线程进入等待队列。\",\"写锁定 (Write Lock)：\",\"当一个线程请求写锁定时，如果没有读锁和写锁存在，则锁定成功。\",\"如果有读锁或写锁存在，则线程进入等待队列。\",\"解锁 (Unlock)：\",\"当读线程解锁时，减少读计数器，如果读计数器为0且有写线程在等待，则唤醒一个写线程。\",\"当写线程解锁时，如果有读线程在等待，则唤醒所有读线程；如果有写线程在等待，则唤醒一个写线程。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <shared_mutex> #include <vector> std::shared_mutex rw_mtx; std::vector<int> data; void reader() { std::shared_lock<std::shared_mutex> lock(rw_mtx); for (const auto& d : data) { std::cout << d << \\\" \\\"; } std::cout << std::endl; } void writer(int value) { std::unique_lock<std::shared_mutex> lock(rw_mtx); data.push_back(value); } int main() { std::thread t1(writer, 1); std::thread t2(reader); std::thread t3(writer, 2); std::thread t4(reader); t1.join(); t2.join(); t3.join(); t4.join(); return 0; }\"]},\"240\":{\"h\":\"\",\"t\":[\"实现原理：\",\"条件变量用于线程之间的等待和通知机制。其实现原理如下：\",\"基本结构：\",\"条件变量与一个互斥量和一个条件状态相关联。\",\"维护一个等待队列，用于保存等待条件的线程。\",\"等待 (Wait)：\",\"线程在等待条件变量时，需要持有相关的互斥量。\",\"线程将自己添加到等待队列，并释放互斥量，等待条件变量的通知。\",\"通知 (Notify)：\",\"当一个线程修改条件状态并调用 notify_one 或 notify_all 时，唤醒一个或所有等待队列中的线程。\",\"被唤醒的线程重新获得互斥量，检查条件状态，如果条件满足，线程继续执行；如果条件不满足，线程再次进入等待状态。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <mutex> #include <condition_variable> std::mutex cv_mtx; std::condition_variable cv; bool ready = false; void print_id(int id) { std::unique_lock<std::mutex> lock(cv_mtx); cv.wait(lock, [] { return ready; }); // 等待 ready 变为 true std::cout << \\\"Thread #\\\" << id << std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard<std::mutex> lock(cv_mtx); ready = true; } cv.notify_all(); // 唤醒所有等待的线程 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(print_id, i); } std::thread t(set_ready); for (auto& th : threads) { th.join(); } t.join(); return 0; }\",\"使用场景：\",\"条件变量常用于线程之间的协调，例如在生产者-消费者模型中，生产者线程通知消费者线程有新数据可用，消费者线程等待该通知。\"]},\"241\":{\"h\":\"\",\"t\":[\"实现原理：\",\"原子操作通过硬件支持的指令集实现，保证在并发环境下操作的不可分割性。其实现原理如下：\",\"硬件支持：\",\"原子操作依赖于硬件提供的原子指令，如 compare-and-swap (CAS)、fetch-and-add 等，这些指令能够确保在多个线程操作同一数据时不会产生竞争条件。\",\"内存模型：\",\"C++ 中的 std::atomic 提供了对不同内存模型的支持，确保在不同平台上实现一致的原子操作行为。\",\"无需锁定：\",\"原子操作直接操作共享变量，不需要加锁解锁，因此在高并发场景下具有更好的性能。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> std::atomic<int> counter(0); void increment() { for (int i = 0; i < 1000; ++i) { ++counter; // 原子操作 } } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(increment); } for (auto& th : threads) { th.join(); } std::cout << \\\"Final counter value: \\\" << counter << std::endl; return 0; }\",\"使用场景：\",\"原子操作适用于需要高效并发访问的场景，如计数器、标志位等，避免使用锁机制带来的开销。\"]},\"242\":{\"h\":\"\",\"t\":[\"实现原理：\",\"信号量是一种控制对共享资源访问的计数器，分为计数信号量和二进制信号量。其实现原理如下：\",\"计数器：\",\"信号量内部维护一个计数器，表示当前可用资源的数量。计数器初始值通常为资源的总量。\",\"P 操作 (等待操作)：\",\"当一个线程执行 P 操作（wait 或 acquire）时，计数器减 1。如果计数器值为正，线程继续执行；如果计数器值为零或负，线程进入等待队列，等待资源释放。\",\"V 操作 (释放操作)：\",\"当一个线程执行 V 操作（signal 或 release）时，计数器加 1。如果有线程在等待队列中，唤醒一个线程，使其继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <semaphore> std::counting_semaphore<1> sem(1); void worker(int id) { sem.acquire(); // P 操作 std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); sem.release(); // V 操作 } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"信号量适用于控制对资源的并发访问数量，例如限制同时访问文件的线程数、实现生产者-消费者模型等。\"]},\"243\":{\"h\":\"6. 自旋锁 (Spinlock)\",\"t\":[\"实现原理：\",\"自旋锁是一种忙等待锁，线程在尝试获取锁时会反复检查锁的状态，而不会阻塞或挂起。其实现原理如下：\",\"忙等待：\",\"当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，线程将反复检查锁的状态，直到锁可用为止。\",\"自旋锁通常通过硬件的原子操作实现，如 test-and-set、compare-and-swap 等。\",\"解锁：\",\"当持有锁的线程释放自旋锁时，其他线程可以成功获取锁并继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <atomic> class Spinlock { std::atomic_flag flag = ATOMIC_FLAG_INIT; public: void lock() { while (flag.test_and_set(std::memory_order_acquire)); // 自旋等待 } void unlock() { flag.clear(std::memory_order_release); } }; Spinlock spinlock; void worker(int id) { spinlock.lock(); std::cout << \\\"Thread #\\\" << id << \\\" is working\\\" << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); spinlock.unlock(); } int main() { std::thread threads[10]; for (int i = 0; i < 10; ++i) { threads[i] = std::thread(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"自旋锁适用于锁定时间非常短的场景，例如在中断上下文或需要避免线程调度开销的情况下使用。\"]},\"244\":{\"h\":\"\",\"t\":[\"实现原理：\",\"屏障用于同步一组线程，确保所有线程都到达某个同步点后才能继续执行。其实现原理如下：\",\"计数器：\",\"屏障内部维护一个计数器，表示已到达屏障的线程数量。每当一个线程到达屏障点时，计数器减 1。\",\"等待机制：\",\"当计数器达到零时，表示所有线程都已到达屏障点，屏障解除，所有等待的线程继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <barrier> #include <vector> std::barrier sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" is waiting\\\" << std::endl; sync_point.arrive_and_wait(); // 等待所有线程到达屏障点 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"屏障适用于并行计算中需要同步多个线程的场景，例如在每个计算步骤完成后同步所有线程。\"]},\"245\":{\"h\":\"\",\"t\":[\"实现原理：\",\"锁存器类似于屏障，但只能使用一次，线程等待直到锁存器倒数到零。其实现原理如下：\",\"倒数计数器：\",\"锁存器内部维护一个倒数计数器，表示需要完成的任务数量。每次完成任务时，计数器减 1。\",\"等待机制：\",\"当计数器减为零时，所有等待的线程被唤醒，继续执行。\",\"代码示例：\",\"#include <iostream> #include <thread> #include <latch> #include <vector> std::latch sync_point(10); void worker(int id) { std::cout << \\\"Thread #\\\" << id << \\\" has reached the latch point\\\" << std::endl; sync_point.count_down(); // 锁存器计数减少 sync_point.wait(); // 等待所有线程到达锁存器 std::cout << \\\"Thread #\\\" << id << \\\" is proceeding\\\" << std::endl; } int main() { std::vector<std::thread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(worker, i); } for (auto& th : threads) { th.join(); } return 0; }\",\"使用场景：\",\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景，例如初始化任务完成后启动主任务。\"]},\"246\":{\"h\":\"死锁\",\"t\":[\"死锁的四个条件(循环等待不可抢占的互斥资源):\",\"禁止抢占(no preemption)：系统资源不能被强制从一个进程(线程)中退出，已经获得的资源在未使用完之前不能被抢占。\",\"等待和保持(hold and wait)：一个进程(线程)因请求资源阻塞时，对已获得的资源保持不放。\",\"互斥(mutual exclusion)：资源只能同时分配给一个进程(线程)，无法多个进程(线程)共享。\",\"循环等待(circular waiting)：一系列进程(线程)互相持有其他进程(线程)所需要的资源。\",\"死锁问题的排查\",\"参考 1\",\"参考 2\"]},\"247\":{\"h\":\"无锁编程\",\"t\":[\"无锁编程（Lock-Free Programming）是一种在多线程环境中实现并发访问的技术，目的是避免传统锁机制（如互斥锁）带来的性能开销和死锁风险。无锁编程主要依赖于原子操作和内存序列模型，以确保在没有锁的情况下实现线程安全。\"]},\"248\":{\"h\":\"1. 基本概念\",\"t\":[\"原子操作：原子操作是不可分割的，多个线程对同一变量进行原子操作时，不会引起数据竞争。\",\"CAS (Compare-and-Swap)：这是无锁编程的核心操作之一，它检查一个变量是否有特定的值，如果是，则将其更改为新值。这个操作是原子的，即在执行时不会被其他线程打断。\",\"内存序列模型：C++ 提供了一组内存序列模型（如 memory_order_relaxed、memory_order_acquire、memory_order_release 等），以控制并发操作的顺序性。\"]},\"249\":{\"h\":\"2. C++ 中的原子操作\",\"t\":[\"C++11 引入了 std::atomic 模板类，为实现无锁编程提供了基础设施。它支持以下操作：\",\"原子加载和存储\",\"原子递增和递减\",\"原子交换\",\"原子比较并交换（CAS）\"]},\"250\":{\"h\":\"3. 使用原子变量实现无锁队列\",\"t\":[\"下面是一个简单的无锁单生产者单消费者队列的实现示例：\",\"#include <atomic> #include <iostream> #include <thread> #include <vector> template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; } bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; } bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; // 使用 memory_order_release 确保更新操作一定在取值之后 head.store((currentHead + 1) % capacity, std::memory_order_release); return true; } private: T* buffer; size_t capacity; std::atomic<size_t> head; std::atomic<size_t> tail; }; int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\"]},\"251\":{\"h\":\"4. 代码结构和作用\",\"t\":[\"类定义与构造函数\",\"template <typename T> class LockFreeQueue { public: LockFreeQueue(size_t capacity) : capacity(capacity), head(0), tail(0) { buffer = new T[capacity]; } ~LockFreeQueue() { delete[] buffer; }\",\"LockFreeQueue 类是一个泛型队列，使用模板参数 T 来定义队列元素的类型。\",\"构造函数初始化队列的容量 capacity，并将 head 和 tail 指针初始化为 0。\",\"队列使用一个动态分配的数组 buffer 来存储元素。\",\"enqueue 方法\",\"bool enqueue(const T& item) { size_t currentTail = tail.load(std::memory_order_relaxed); size_t nextTail = (currentTail + 1) % capacity; if (nextTail == head.load(std::memory_order_acquire)) { return false; // 队列已满 } buffer[currentTail] = item; tail.store(nextTail, std::memory_order_release); return true; }\",\"enqueue 方法用于将一个元素插入队列。\",\"tail.load(std::memory_order_relaxed)：原子地加载当前的尾部指针 tail 的值。使用 memory_order_relaxed 是因为我们不需要同步其他内存操作，仅仅读取尾部的值。\",\"nextTail = (currentTail + 1) % capacity：计算插入元素后的尾部指针值，使用取模操作来实现循环队列。\",\"if (nextTail == head.load(std::memory_order_acquire))：检查队列是否已满。如果 nextTail 与头部指针 head 相等，说明队列已满。\",\"buffer[currentTail] = item：将元素存储在当前尾部指针所指向的位置。\",\"tail.store(nextTail, std::memory_order_release)：将新的尾部指针存储到 tail，并使用 memory_order_release 以确保插入操作完成后，其他线程能正确地看到更新的尾部指针。\",\"dequeue 方法\",\"bool dequeue(T& item) { size_t currentHead = head.load(std::memory_order_relaxed); if (currentHead == tail.load(std::memory_order_acquire)) { return false; // 队列为空 } item = buffer[currentHead]; head.store((currentHead + 1) % capacity, std::memory_order_release); return true; }\",\"dequeue 方法用于从队列中取出一个元素。\",\"currentHead = head.load(std::memory_order_relaxed)：原子地加载当前的头部指针 head 的值。\",\"if (currentHead == tail.load(std::memory_order_acquire))：检查队列是否为空。如果 head 与 tail 相等，说明队列为空。\",\"item = buffer[currentHead]：将头部指针所指向的元素存储到 item 中。\",\"head.store((currentHead + 1) % capacity, std::memory_order_release)：更新头部指针，指向下一个元素的位置，并使用 memory_order_release 以确保取出操作完成后，其他线程能正确地看到更新的头部指针。\",\"主函数中的生产者和消费者\",\"int main() { LockFreeQueue<int> queue(10); // 启动生产者线程 std::thread producer([&queue]() { for (int i = 0; i < 20; ++i) { while (!queue.enqueue(i)) { // 如果队列已满，等待 } std::cout << \\\"Produced: \\\" << i << std::endl; } }); // 启动消费者线程 std::thread consumer([&queue]() { for (int i = 0; i < 20; ++i) { int item; while (!queue.dequeue(item)) { // 如果队列为空，等待 } std::cout << \\\"Consumed: \\\" << item << std::endl; } }); producer.join(); consumer.join(); return 0; }\",\"在 main 函数中，创建了一个 LockFreeQueue 对象 queue，容量为 10。\",\"生产者线程 producer 向队列中插入元素，使用 while (!queue.enqueue(i)) 检查插入操作是否成功。如果队列已满，线程会持续等待直到成功插入。\",\"消费者线程 consumer 从队列中取出元素，使用 while (!queue.dequeue(item)) 检查取出操作是否成功。如果队列为空，线程会持续等待直到成功取出元素。\",\"两个线程同时运行，生产者插入数据，消费者取出数据，并输出相应的信息。\",\"最后，通过 join() 等待线程完成，确保主线程在两个子线程结束后才退出。\"]},\"252\":{\"h\":\"\",\"t\":[\"memory_order_relaxed：用于没有数据依赖的地方，只要求操作是原子的，不需要同步内存顺序。适用于 load 和 store，如 tail.load(std::memory_order_relaxed)。\",\"memory_order_acquire：用于加载操作，以确保加载的结果及其后续的操作不会被重排序到 acquire 之前。适用于检查队列是否满或空，如 head.load(std::memory_order_acquire)。\",\"memory_order_release：用于存储操作，以确保在此之前的所有操作不会被重排序到 release 之后。适用于更新指针操作，如 tail.store(nextTail, std::memory_order_release)。\"]},\"253\":{\"c\":[\"面试题\"]},\"254\":{\"c\":[\"c++\",\"多线程\",\"线程同步\"]},\"255\":{\"h\":\"c++11 新特性\"},\"256\":{\"h\":\"新增线程编程相关模块\",\"t\":[\"相关信息\",\"c++11关于并发引入了好多好东西，这里按照如下顺序介绍：\",\"std::thread相关\",\"std::mutex相关\",\"std::lock相关\",\"std::atomic相关\",\"std::call_once相关\",\"std::condition_variable相关\",\"std::future相关\",\"async相关\"]},\"257\":{\"h\":\"std::thread相关\",\"t\":[\"c++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：\",\"#include <iostream> #include <thread> using namespace std; int main() { auto func = []() { for (int i = 0; i < 10; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread t(func); if (t.joinable()) { t.detach(); } auto func1 = [](int k) { for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread tt(func1, 20); if (tt.joinable()) { // 检查线程可否被join tt.join(); } return 0; }\",\"上述代码中，函数func和func1运行在线程对象t和tt中，从刚创建对象开始就会新建一个线程用于执行函数，调用join函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的detach函数，表示将线程和线程对象分离。\",\"如果没有调用join或者detach函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完。\",\"这里可以对thread进行封装，避免没有调用join或者detach可导致程序出错的情况出现：\",\"class ThreadGuard { public: enum class DesAction { join, detach }; ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){}; ~ThreadGuard() { if (t_.joinable()) { if (action_ == DesAction::join) { t_.join(); } else { t_.detach(); } } } ThreadGuard(ThreadGuard&&) = default; ThreadGuard& operator=(ThreadGuard&&) = default; std::thread& get() { return t_; } private: std::thread t_; DesAction action_; }; int main() { ThreadGuard t(std::thread([]() { for (int i = 0; i < 10; ++i) { std::cout << \\\"thread guard \\\" << i << \\\" \\\"; } std::cout << std::endl;}), ThreadGuard::DesAction::join); return 0; }\",\"c++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能\",\"std::thread t(func); cout << \\\"当前线程ID \\\" << t.get_id() << endl; cout << \\\"当前cpu个数 \\\" << std::thread::hardware_concurrency() << endl; auto handle = t.native_handle();// handle可用于pthread相关操作 std::this_thread::sleep_for(std::chrono::seconds(1));\"]},\"258\":{\"h\":\"std::mutex相关\",\"t\":[\"std::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。\",\"mutex分为四种：\",\"std::mutex：独占的互斥量，不能递归使用，不带超时功能\",\"std::recursive_mutex：递归互斥量，可重入，不带超时功能\",\"std::timed_mutex：带超时的互斥量，不能递归\",\"std::recursive_timed_mutex：带超时的互斥量，可以递归使用\",\"拿一个std::mutex和std::timed_mutex举例吧，别的都是类似的使用方式：\",\"std::mutex: #include <iostream> #include <mutex> #include <thread> using namespace std; std::mutex mutex_; int main() { auto func1 = [](int k) { mutex_.lock(); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; mutex_.unlock(); }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; } std::timed_mutex: #include <iostream> #include <mutex> #include <thread> #include <chrono> using namespace std; std::timed_mutex timed_mutex_; int main() { auto func1 = [](int k) { timed_mutex_.try_lock_for(std::chrono::milliseconds(200)); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; timed_mutex_.unlock(); }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"259\":{\"h\":\"std::lock相关\",\"t\":[\"这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。\",\"c++11主要有std::lock_guard和std::unique_lock两种方式，使用方式都类似，如下：\",\"#include <iostream> #include <mutex> #include <thread> #include <chrono> using namespace std; std::mutex mutex_; int main() { auto func1 = [](int k) { // std::lock_guard<std::mutex> lock(mutex_); std::unique_lock<std::mutex> lock(mutex_); for (int i = 0; i < k; ++i) { cout << i << \\\" \\\"; } cout << endl; }; std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(func1, 200); } for (auto& th : threads) { th.join(); } return 0; }\",\"std::lock_gurad相比于std::unique_lock更加轻量级，少了一些成员函数，std::unique_lock类有unlock函数，可以手动释放锁，所以条件变量都配合std::unique_lock使用，而不是std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力，具体关于条件变量后面会讲到。\"]},\"260\":{\"h\":\"std::atomic相关\",\"t\":[\"c++11提供了原子类型 std::atomic<T>，理论上这个T可以是任意类型，但是我平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就不需要使用std::mutex来保护该变量啦。看一个计数器的代码：\",\"struct OriginCounter { // 普通的计数器 int count; std::mutex mutex_; void add() { std::lock_guard<std::mutex> lock(mutex_); ++count; } void sub() { std::lock_guard<std::mutex> lock(mutex_); --count; } int get() { std::lock_guard<std::mutex> lock(mutex_); return count; } }; struct NewCounter { // 使用原子变量的计数器 std::atomic<int> count; void add() { ++count; // count.store(++count);这种方式也可以 } void sub() { --count; // count.store(--count); } int get() { return count.load(); } };\"]},\"261\":{\"h\":\"std::call_once相关\",\"t\":[\"c++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码吧：\",\"std::once_flag onceflag; void CallOnce() { std::call_once(onceflag, []() { cout << \\\"call once\\\" << endl; }); } int main() { std::thread threads[5]; for (int i = 0; i < 5; ++i) { threads[i] = std::thread(CallOnce); } for (auto& th : threads) { th.join(); } return 0; }\"]},\"262\":{\"h\":\"std::condition_variable相关\",\"t\":[\"条件变量是c++11引入的一种同步机制，它可以阻塞一个线程或者个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的std::unique_lock。\",\"这里使用条件变量实现一个CountDownLatch：\",\"class CountDownLatch { public: explicit CountDownLatch(uint32_t count) : count_(count); void CountDown() { std::unique_lock<std::mutex> lock(mutex_); --count_; if (count_ == 0) { cv_.notify_all(); } } void Await(uint32_t time_ms = 0) { std::unique_lock<std::mutex> lock(mutex_); while (count_ > 0) { if (time_ms > 0) { cv_.wait_for(lock, std::chrono::milliseconds(time_ms)); } else { cv_.wait(lock); } } } uint32_t GetCount() const { std::unique_lock<std::mutex> lock(mutex_); return count_; } private: std::condition_variable cv_; mutable std::mutex mutex_; uint32_t count_ = 0; };\",\"关于条件变量其实还涉及到通知丢失和虚假唤醒问题，因为不是本文的主题，这里暂不介绍，大家有需要可以留言。\"]},\"263\":{\"h\":\"std::future相关\",\"t\":[\"c++11关于异步操作提供了future相关的类，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高级些，std::future作为异步结果的传输通道，通过get()可以很方便的获取线程函数的返回值，std::promise用来包装一个值，将数据和future绑定起来，而std::packaged_task则用来包装一个调用对象，将函数和future绑定起来，方便异步调用。而std::future是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。\",\"std::promise与std::future配合使用\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; void func(std::future<int>& fut) { int x = fut.get(); cout << \\\"value: \\\" << x << endl; } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(func, std::ref(fut)); prom.set_value(144); t.join(); return 0; }\",\"std::packaged_task与std::future配合使用\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; int func(int in) { return in + 1; } int main() { std::packaged_task<int(int)> task(func); std::future<int> fut = task.get_future(); std::thread(std::move(task), 5).detach(); cout << \\\"result \\\" << fut.get() << endl; return 0; }\",\"三者之间的关系:\",\"std::future用于访问异步操作的结果，而std::promise和std::packaged_task在future高一层，它们内部都有一个future;\",\"promise包装的是一个值，packaged_task包装的是一个函数，当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。\"]},\"264\":{\"h\":\"async相关\",\"t\":[\"async是比future，packaged_task，promise更高级的东西，它是基于任务的异步操作，通过async可以直接创建异步的任务，返回的结果会保存在future中，不需要像packaged_task和promise那么麻烦，关于线程操作应该优先使用async，看一段使用代码：\",\"#include <functional> #include <future> #include <iostream> #include <thread> using namespace std; int func(int in) { return in + 1; } int main() { auto res = std::async(func, 5); // res.wait(); cout << res.get() << endl; // 阻塞直到函数返回 return 0; }\",\"async具体语法如下：\",\"async(std::launch::async | std::launch::deferred, func, args...);\",\"第一个参数是创建策略：\",\"std::launch::async表示任务执行在另一线程\",\"std::launch::deferred表示延迟执行任务，调用get或者wait时才会执行，不会创建线程，惰性执行在当前线程。\",\"如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。\",\"若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：\",\"std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f() std::async(std::launch::async, []{ g(); }); // f() 完成前不开始\",\"注意：关于async启动策略这里网上和各种书籍介绍的五花八门，这里会以cppreference为主。\",\"• 有时候我们如果想真正执行异步操作可以对async进行封装，强制使用std::launch::async策略来调用async。\",\"template <typename F, typename... Args> inline auto ReallyAsync(F&& f, Args&&... params) { return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...); }\",\"总结\",\"std::thread使线程的创建变得非常简单，还可以获取线程id等信息。\",\"std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。\",\"std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。\",\"std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量\",\"std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。\",\"std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。\",\"std::future用于异步调用的包装和返回值。\",\"async更方便的实现了异步调用，异步调用优先使用async取代创建线程。\"]},\"265\":{\"h\":\"性能优化\"},\"266\":{\"h\":\"\",\"t\":[\"相关信息\",\"智能指针是为没有垃圾回收机制的语言解决可能的内存泄露问题的利器，但是在实际应用中使用智能指针有一些需要注意的地方，好在这些问题都可以解决。\",\"shared_ptr 和 unqi_ptr 使用时如何选择：如果希望只有一个智能指针管理资源或者管理数组，可以用 uniq_ptr；如果希望多个智能指针管理同一个资源，可以用 shared_ptr。\",\"weak_ptr 是 shared_ptr 的助手，只是监视 shared_ptr 管理的资源是否被释放，本身并不操作或者管理资源。用于解决 shared_ptr 循环引用和返回 this 指针的问题\",\"智能指针线程安全\"]},\"267\":{\"h\":\"\",\"t\":[\"实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。\",\"智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针\",\"每次创建类的新对象时，初始化指针并将引用计数置为1\",\"当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数\",\"对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数\",\"调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）\"]},\"268\":{\"h\":\"\",\"t\":[\"unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。\"]},\"269\":{\"h\":\"\",\"t\":[\"weak_ptr：弱引用。引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。\"]},\"270\":{\"h\":\"和\",\"t\":[\"移动构造函数 + std::move: 减少内存拷贝\",\"#include <iostream> using namespace std; struct A { A(){cout<<\\\"construct\\\"<<endl;} A(const A& a){cout<<\\\"copy construct\\\" <<endl;} ~A(){cout<<\\\"destruct\\\"<<endl;} }; A GetA(){ return A();} int main() { /* 在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是GetA（）函数内部创建的对象返回后构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的destruct是因为临时对象在构造a对象之后就销毁了 */ A a = GetA(); /* 通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构 */ //A&& a = GetA(); return 0; }\",\"[root@centos7 c++]# g++ test.cpp [root@centos7 c++]# ./a.out construct destruct [root@centos7 c++]# g++ test.cpp -fno-elide-constructors [root@centos7 c++]# ./a.out construct copy construct destruct copy construct destruct destruct [root@centos7 c++]# g++ test.cpp -fno-elide-constructors [root@centos7 c++]# ./a.out construct copy construct destruct destruct\"]},\"271\":{\"h\":\"容器新增 操作减少内存拷贝和移动\",\"t\":[\"#include <vector> #include <map> #include <string> #include <iostream> using namespace std; struct Complicated { int year; std::string name; Complicated(int a, string c):year(a),name(c) { cout<<\\\"is constucted\\\"<<endl; } Complicated(const Complicated&other):year(other.year),name(std::move(other.name)) { cout<<\\\"is moved\\\"<<endl; } }; int main() { std::map<int, Complicated> m; int anInt = 4; std::string aString = \\\"C++\\\"; cout<<\\\"—insert--\\\"<<endl; m.insert(std::make_pair(4, Complicated(anInt, aString))); cout<<\\\"—emplace--\\\"<<endl; // should be easier for the optimizer m.emplace(4, Complicated(anInt, aString)); cout<<\\\"--emplace_back--\\\"<<endl; vector<Complicated> v; v.emplace_back(anInt, aString); cout<<\\\"--push_back--\\\"<<endl; v.push_back(Complicated(anInt, aString)); return 0; }\",\"[root@centos7 c++]# ./a.out —insert-- is constucted is moved is moved —emplace-- is constucted is moved --emplace_back-- is constucted --push_back-- is constucted is moved is moved\"]},\"272\":{\"h\":\"语法糖\"},\"273\":{\"h\":\"\",\"t\":[\" template<class... Types> void f(Types... args); f(); // OK: args contains no arguments f(1); // OK: args contains one argument: int f(2, 1.0); // OK: args contains two arguments: int and double\"]},\"274\":{\"h\":\"\",\"t\":[\" auto x = 5; // OK: x has type int const auto *v = &x, u = 6; // OK: v has type const int*, u has type const int static auto y = 0.0; // OK: y has type double\"]},\"275\":{\"h\":\"\",\"t\":[\" std::vector<int> v = {0, 1, 2, 3, 4, 5}; for (const int& i : v) // access by const reference std::cout << i << ' ';\"]},\"276\":{\"h\":\"\",\"t\":[\"auto f = [&](int)->void{}; f();\"]},\"277\":{\"h\":\"\",\"t\":[\"#include <iostream> int main() { enum class Color { red, green = 20, blue }; Color r = Color::blue; switch(r) { case Color::red : std::cout << \\\"red\\\\n\\\"; break; case Color::green: std::cout << \\\"green\\\\n\\\"; break; case Color::blue : std::cout << \\\"blue\\\\n\\\"; break; } // int n = r; // error: no implicit conversion from scoped enum to int int n = static_cast<int>(r); // OK, n = 21 std::cout << n << '\\\\n'; // prints 21 }\"]},\"278\":{\"c\":[\"面试题\"]},\"279\":{\"c\":[\"c++11\",\"多线程\",\"线程同步\"]},\"280\":{\"h\":\"面试集锦\"},\"281\":{\"c\":[\"面试题\"]},\"282\":{\"h\":\"Linux 常用命令\"},\"283\":{\"c\":[\"Linux\",\"命令\"]},\"284\":{\"h\":\"constexpr 实现编译时加密\",\"t\":[\"介绍一种利用 constexpr 实现编译时加密，运行时解密的方法。本文将介绍这一技术，并展示一个具体的实现示例。\",\"提示\",\"逆向工程常通过执行文件的中静态字符串信息找到关键点函数进行逆向，编译时加密可以一定程度上避免这个问题。\"]},\"285\":{\"h\":\"？\",\"t\":[\"constexpr 是 C++11 引入的一个关键字，允许我们在编译时计算表达式的值。这意味着某些计算可以在编译时完成，从而提高运行时性能。在我们的例子中，我们使用 constexpr 实现编译时加密。\"]},\"286\":{\"h\":\"编译时加密与运行时解密的工作原理\",\"t\":[\"我们通过定义一个 constexpr 函数来实现字符的加密和解密。然后，使用模板类在编译时对字符串进行加密，并在运行时对其进行解密。这样，敏感信息在编译时就被加密，从而不会以明文形式出现在可执行文件中。\"]},\"287\":{\"h\":\"实现示例\",\"t\":[\"以下是一个完整的实现示例：\",\"#include <iostream> // 用于字符加密和解密的constexpr函数 constexpr char xor_character(char c, unsigned key) { return c ^ key; } // 模板类用于编译时加密和运行时解密 template<unsigned SIZE> class EncryptString { public: // 构造函数在编译时对字符串进行加密 constexpr EncryptString(const char* raw_str) { for(unsigned i = 0; i < SIZE - 1; ++i) { m_data[i] = xor_character(raw_str[i], i); } m_data[SIZE - 1] = 0; // 添加字符串结束符 } // 解密函数在运行时对字符串进行解密 char* decrypt() const { unsigned i = 0; for(; i < SIZE-1; ++i) { m_data[i] = xor_character(m_data[i], i); } m_data[SIZE-1] = 0; // 添加字符串结束符 return m_data; } private: mutable char m_data[SIZE]={'\\\\0'}; }; // 宏定义用于简化加密字符串的使用 #define PROTECTED_STR(str) []{ \\\\ constexpr EncryptString<sizeof(str)> e(str);\\\\ std::cout << e.decrypt() << std::endl;\\\\ }() int main() { PROTECTED_STR(\\\"heng\\\");//编译后的执行文件中不存在‘heng’ 关键字符串信息 // std::cout << \\\"heng\\\" << std::endl;// 编译后的执行文件包含有 ‘heng’ 关键字符串信息，提供逆袭的信息点 return 0; }\"]},\"288\":{\"h\":\"代码详解\",\"t\":[\"xor_character 函数:\",\"使用 XOR 操作对字符进行加密和解密。密钥是字符的位置索引。\",\"EncryptString 类:\",\"模板类，用于在编译时加密字符串。\",\"构造函数通过 xor_character 函数对输入字符串进行加密，并存储在 m_data 数组中。\",\"decrypt 函数在运行时对字符串进行解密。\",\"PROTECTED_STR 宏:\",\"利用 lambda 表达式和 constexpr 特性，简化加密字符串的使用。\",\"在运行时对加密的字符串进行解密并返回。\",\"main 函数:\",\"演示如何使用 PROTECTED_STR 宏来加密和解密字符串，并将解密后的字符串输出。\",\"利用 constexpr 实现编译时加密和运行时解密是一种有效保护敏感信息的方法。本文展示了该技术的一个具体实现示例，并详细解释了其工作原理。通过这种方式，可以提高应用程序的安全性，避免给逆向提供敏感信息点。\"]},\"289\":{\"c\":[\"其他\"]},\"290\":{\"c\":[\"c++\",\"constexpr\",\"逆向\"]},\"291\":{\"h\":\"tcp 连接状态\",\"t\":[\"TCP连接的状态图（TCP Connection State Diagram）展示了TCP协议在建立连接、传输数据、关闭连接过程中可能的状态及其转换。了解这些状态对于网络调试、性能优化和网络编程都非常有帮助。\"]},\"292\":{\"h\":\"TCP状态图解释\",\"t\":[\"在TCP连接的生命周期中，有多个状态，以下是主要的TCP连接状态及其转换：\",\"CLOSED: 初始状态，表示套接字没有被使用或已经关闭。\",\"LISTEN: 服务器套接字正在监听连接请求。这个状态通常由服务器处于被动打开（Passive Open）状态时进入。\",\"SYN-SENT: 客户端在发送SYN（同步）包后进入这个状态，等待服务器的SYN-ACK。表示主动打开（Active Open）的一端已经发送了连接请求。\",\"SYN-RECEIVED: 服务器在接收到客户端的SYN包后，发送SYN-ACK，并进入这个状态，等待客户端的ACK确认。\",\"ESTABLISHED: 表示连接已经建立，数据可以在客户端和服务器之间双向传输。这个是正常的数据传输状态。\",\"FIN-WAIT-1: 连接的主动关闭方（通常是客户端）发送FIN（结束）包后进入这个状态，等待对方的ACK。\",\"FIN-WAIT-2: 主动关闭方接收到ACK后，进入这个状态，等待对方发送FIN包。\",\"CLOSE-WAIT: 被动关闭方接收到FIN包后，进入这个状态，等待应用程序关闭连接。\",\"CLOSING: 在极少见的情况下，双方同时发送FIN包时会进入这个状态，等待对方的ACK。\",\"LAST-ACK: 被动关闭方在发送ACK并等待对方确认后进入这个状态。\",\"TIME-WAIT: 主动关闭方在发送最后的ACK后，进入这个状态，确保对方收到了ACK，防止旧数据包干扰，保持这个状态2倍的最大报文段寿命时间（通常是2分钟）。\",\"CLOSED: 所有资源释放后，连接彻底关闭，返回到初始状态。\"]},\"293\":{\"h\":\"状态转换图\",\"t\":[\"以下是TCP连接状态的转换图：\"]},\"294\":{\"h\":\"状态转换的简要说明\",\"t\":[\"CLOSED 到 LISTEN： 服务器调用listen()函数进入LISTEN状态，准备接受连接。\",\"SYN-SENT： 客户端调用connect()后发送SYN包，进入SYN-SENT状态。\",\"SYN-RECEIVED： 服务器接收到SYN包后，回复SYN-ACK，并进入SYN-RECEIVED状态。\",\"ESTABLISHED： 双方都接收到对方的确认包后，进入ESTABLISHED状态，开始数据传输。\",\"FIN-WAIT-1： 主动关闭方发送FIN包后进入FIN-WAIT-1状态。\",\"CLOSE-WAIT： 被动关闭方接收到FIN包后进入CLOSE-WAIT状态，等待应用程序关闭连接。\",\"LAST-ACK： 被动关闭方在发送ACK包后进入LAST-ACK状态，等待最后的确认。\",\"TIME-WAIT： 主动关闭方在发送最后的ACK包后进入TIME-WAIT状态，确保对方接收并释放资源。\"]},\"295\":{\"h\":\"状态的作用\",\"t\":[\"LISTEN： 服务器等待连接请求的状态。\",\"SYN-SENT/SYN-RECEIVED： 建立连接时的握手状态，确保双方都准备好通信。\",\"ESTABLISHED： 连接已建立，数据可以传输。\",\"FIN-WAIT-1/FIN-WAIT-2/CLOSE-WAIT/LAST-ACK/TIME-WAIT： 连接关闭时的状态，确保所有数据正确传输，并正确关闭连接。\"]},\"296\":{\"h\":\"总结\",\"t\":[\"TCP连接状态图详细展示了从连接建立到数据传输，再到连接关闭的整个过程。理解这些状态对于调试网络问题、优化应用程序性能、设计健壮的网络服务非常重要。通过分析TCP连接的状态，可以识别出哪些连接处于非正常状态，并采取相应的措施来修复或优化。\"]},\"297\":{\"c\":[\"其他\"]},\"298\":{\"c\":[\"tcp\"]},\"299\":{\"h\":\"waitpid\",\"t\":[\"waitpid 是 Unix/Linux 系统中用于等待子进程状态变化的系统调用。它允许父进程挂起执行，直到指定的子进程终止或者发生了其他指定的状态变化。\"]},\"300\":{\"h\":\"的语法\",\"t\":[\"pid_t waitpid(pid_t pid, int *status, int options);\",\"pid: 要等待的子进程的进程 ID，特殊值如下：\",\"pid > 0: 等待进程 ID 为 pid 的特定子进程。\",\"pid == 0: 等待任何属于与调用进程相同进程组的子进程。\",\"pid < -1: 等待进程组 ID 等于 |pid| 的任何子进程。\",\"pid == -1: 等待任何子进程，即等效于 wait()。\",\"status: 指向一个 int 变量的指针，用于保存子进程的终止状态。\",\"options: 可以是 0 或者下列标志的组合：\",\"WNOHANG: 如果没有子进程退出或状态变化，则立即返回，而不阻塞。\",\"WUNTRACED: 当一个子进程停止（例如被 SIGSTOP 信号停止）时返回其状态，而不是等到子进程终止。\",\"WCONTINUED: 如果子进程在接收到 SIGCONT 信号后继续运行，并且其状态尚未报告，则返回其状态。\"]},\"301\":{\"h\":\"的返回值\",\"t\":[\"成功时，返回等待的子进程的 PID。\",\"如果设置了 WNOHANG 且没有立即可用的子进程终止状态，则返回 0。\",\"失败时，返回 -1，并设置 errno 以指示错误。\"]},\"302\":{\"h\":\"变量解释\",\"t\":[\"status 变量是一个整数，包含子进程的状态信息。可以使用一系列宏来解析这个状态值：\",\"WIFEXITED(status)：如果子进程正常终止，则返回非零值。\",\"WEXITSTATUS(status)：如果子进程正常终止，返回子进程的退出状态码。\",\"WIFSIGNALED(status)：如果子进程因信号终止，则返回非零值。\",\"WTERMSIG(status)：如果子进程因信号终止，返回导致终止的信号编号。\",\"WIFSTOPPED(status)：如果子进程处于停止状态，则返回非零值。\",\"WSTOPSIG(status)：如果子进程处于停止状态，返回导致停止的信号编号。\",\"WIFCONTINUED(status)：如果子进程已继续执行，则返回非零值（使用 WCONTINUED 标志时）。\"]},\"303\":{\"h\":\"示例代码\",\"t\":[\"以下是一个使用 waitpid 等待子进程终止的示例代码：\",\"#include <iostream> #include <sys/wait.h> #include <unistd.h> int main() { pid_t pid = fork(); if (pid == 0) { // 子进程代码 std::cout << \\\"Child process running, PID: \\\" << getpid() << std::endl; sleep(2); // 模拟一些工作 std::cout << \\\"Child process terminating\\\" << std::endl; return 42; // 子进程的退出状态码 } else if (pid > 0) { // 父进程代码 int status; pid_t result = waitpid(pid, &status, 0); // 等待子进程终止 if (result == -1) { std::cerr << \\\"waitpid failed\\\" << std::endl; } else { std::cout << \\\"Child process \\\" << result << \\\" terminated\\\" << std::endl; if (WIFEXITED(status)) { std::cout << \\\"Child exited with status: \\\" << WEXITSTATUS(status) << std::endl; } else if (WIFSIGNALED(status)) { std::cout << \\\"Child killed by signal: \\\" << WTERMSIG(status) << std::endl; } else if (WIFSTOPPED(status)) { std::cout << \\\"Child stopped by signal: \\\" << WSTOPSIG(status) << std::endl; } else if (WIFCONTINUED(status)) { std::cout << \\\"Child continued\\\" << std::endl; } } } else { std::cerr << \\\"fork failed\\\" << std::endl; } return 0; }\"]},\"304\":{\"h\":\"代码解释\",\"t\":[\"fork(): 创建一个子进程。pid 为 0 表示子进程，在子进程中执行特定代码。pid 为正表示父进程，父进程等待子进程结束。\",\"waitpid(pid, &status, 0): 父进程调用 waitpid 等待子进程终止，并获取其退出状态。\",\"WIFEXITED(status): 检查子进程是否正常退出。如果是，WEXITSTATUS(status) 将返回子进程的退出状态码。\",\"WIFSIGNALED(status): 检查子进程是否被信号终止。如果是，WTERMSIG(status) 将返回导致子进程终止的信号编号。\"]},\"305\":{\"h\":\"的常见应用\",\"t\":[\"管理多个子进程：waitpid 可以与 WNOHANG 选项一起使用，用于轮询多个子进程的状态，适合管理并发运行的子进程。\",\"处理特定子进程：通过传递特定的 PID，waitpid 可以用于等待和管理某个特定子进程的状态变化。\",\"防止僵尸进程：父进程使用 waitpid 回收子进程的退出状态，可以防止僵尸进程的产生。\"]},\"306\":{\"h\":\"总结\",\"t\":[\"waitpid 是一个强大的系统调用，允许父进程灵活地等待和处理子进程的状态变化。通过正确使用 waitpid，可以有效地管理并发进程，处理子进程的终止状态，防止僵尸进程。\"]},\"307\":{\"c\":[\"其他\"]},\"308\":{\"c\":[\"linux\"]},\"309\":{\"h\":\"git 常用命令\",\"t\":[\"Git 是最常用的版本控制工具之一，广泛用于开发和项目管理中。以下是一些常用的 Git 命令及其详细说明：\"]},\"310\":{\"h\":\"常用 Git 命令及其说明\"},\"311\":{\"h\":\"repository 操作\",\"t\":[\"git init\",\"作用：本地初始化一个新的 Git 仓库。\",\"用法：在一个空目录中运行 git init，Git 会创建一个 .git 目录，用于存储仓库的元数据。\",\" git init\",\"git clone\",\"作用：从远程仓库克隆一个仓库到本地。\",\"用法：git clone 后跟仓库 URL，可以将远程仓库复制到本地。\",\" git clone https://github.com/user/repository.git\",\"git remote\",\"作用：管理远程仓库地址。\",\"用法：\",\"查看当前的远程仓库：git remote -v\",\"添加新的远程仓库：git remote add origin https://github.com/user/repo.git\",\"删除远程仓库：git remote remove origin\",\"git remote -v # 查看远程仓库 git remote add origin https://github.com/user/repo.git # 添加远程仓库\"]},\"312\":{\"h\":\"修改管理\"},\"313\":{\"h\":\"1.\",\"t\":[\"作用：将文件添加到暂存区（stage），为下次提交做准备。\",\"用法：git add 后跟文件路径，或使用 . 添加当前目录下的所有更改。\",\"git add file.txt git add .\"]},\"314\":{\"h\":\"2.\",\"t\":[\"作用：提交暂存区的更改，生成新的提交。\",\"用法：git commit 通常跟 -m 选项来添加提交信息，描述本次提交的内容。\",\"git commit -m \\\"Add new feature\\\"\",\"修改commit信息： 使用 --amend 修改最后一次提交的信息或内容。\",\"git commit --amend -m \\\"Corrected commit message\\\"\",\"多次提交合并：使用 rebase 合并最近几次的commit。\",\"git rebase -i HEAD～n\"]},\"315\":{\"h\":\"3.\",\"t\":[\"作用：显示工作目录和暂存区的状态，查看哪些文件有更改、哪些文件被暂存、哪些文件未被跟踪。\",\"用法：运行 git status 可以看到当前分支的状态信息。\",\"git status\"]},\"316\":{\"h\":\"4.\",\"t\":[\"作用：显示仓库的提交历史记录。\",\"用法：git log 列出当前分支的所有提交。你可以使用 --oneline 选项简化输出，或者 --graph 查看分支图形。\",\"git log git log --oneline git log --graph --oneline\"]},\"317\":{\"h\":\"5.\",\"t\":[\"作用：查看工作目录、暂存区和最新提交之间的差异。\",\"用法：git diff 显示未暂存的更改，git diff --staged 显示已暂存但未提交的更改。\",\"git diff git diff --staged\"]},\"318\":{\"h\":\"6.\",\"t\":[\"作用：恢复工作目录中文件的状态。\",\"用法：git checkout -- 后跟文件。\",\" git checkout feature-branch git checkout -- file.txt # 恢复文件\"]},\"319\":{\"h\":\"7.\",\"t\":[\"作用：保存当前工作目录的更改，以便稍后恢复，而不影响当前的代码提交历史。\",\"用法：git stash 可以在不提交代码的情况下保存未完成的工作。\",\"git stash git stash pop # 恢复工作\"]},\"320\":{\"h\":\"8.\",\"t\":[\"作用：重置当前分支的提交历史或工作目录状态，回退到之前的某个提交点。\",\"用法：\",\"git reset --soft：保留工作区文件，只回退提交。\",\"git reset --hard：丢弃工作区文件和提交历史。\",\"git reset --soft HEAD~1 # 回退一提交，但保留工作目录更改 git reset --hard HEAD~1 # 丢弃更改\"]},\"321\":{\"h\":\"分支管理\"},\"322\":{\"h\":\"1.\",\"t\":[\"作用：切换分支。\",\"用法：git checkout 后跟分支名称，切换到指定分支\",\"git checkout feature-branch git checkout -b feature-branch #创建并切换分支\"]},\"323\":{\"h\":\"2.\",\"t\":[\"作用：管理分支。列出、创建或删除分支。\",\"用法：\",\"列出分支：git branch\",\"创建新分支：git branch branch_name\",\"删除分支：git branch -d branch_name\",\"git branch # 列出所有分支 git branch feature-branch # 创建新分支 git branch -d feature-branch # 删除分支\"]},\"324\":{\"h\":\"3.\",\"t\":[\"作用：合并分支，将指定分支的更改合并到当前分支。\",\"用法：git merge 后跟要合并的分支名称。\",\"git merge feature-branch\"]},\"325\":{\"h\":\"4.\",\"t\":[\"作用：将当前分支的更改应用到另一分支的顶端，从而保持线性历史。\",\"用法：git rebase 可以让你的提交历史保持整洁。\",\"git rebase main\"]},\"326\":{\"h\":\"数据同步\"},\"327\":{\"h\":\"1.\",\"t\":[\"作用：从远程仓库拉取更改并合并到本地分支。相当于 git fetch 加 git merge。\",\"用法：git pull 默认从当前跟踪的远程分支拉取更新。\",\" git pull origin main\"]},\"328\":{\"h\":\"2.\",\"t\":[\"作用：将本地分支的提交推送到远程仓库。\",\"用法：git push 将更改推送到远程分支。\",\"git push origin main\"]},\"329\":{\"h\":\"3.\",\"t\":[\"作用：从远程仓库获取最新的提交和分支信息，但不合并到本地分支。\",\"用法：git fetch 会下载远程仓库的所有更改，但不会自动合并。\",\" git fetch origin\"]},\"330\":{\"h\":\"管理 Submodule\",\"t\":[\"Git Submodule 是一个非常有用的功能，允许你在一个 Git 仓库中包含另一个独立的 Git 仓库。这对于需要将多个项目组合在一起的场景非常实用，例如一个大型项目包含多个子模块。以下是常见的 Git Submodule 操作和使用场景的详细介绍。\"]},\"331\":{\"h\":\"1.\",\"t\":[\"作用：在你的项目中添加一个子模块，它指向另一个 Git 仓库。\",\"命令：\",\"git submodule add <repository_url> <path>\",\"示例：\",\"git submodule add https://github.com/example/repo.git libs/repo\",\"这会将 repo 仓库克隆到当前项目的 libs/repo 目录，并将其作为子模块添加。\"]},\"332\":{\"h\":\"2.\",\"t\":[\"初始化：当你克隆包含子模块的仓库时，子模块不会自动被克隆。你需要先初始化它们：\",\"git submodule init\",\"更新子模块：初始化之后，使用以下命令克隆并更新子模块到最新提交：\",\"git submodule update\",\"克隆仓库时自动初始化和更新子模块：可以使用 --recurse-submodules 选项在克隆时自动初始化并更新所有子模块：\",\"git clone --recurse-submodules <repository_url>\"]},\"333\":{\"h\":\"3.\",\"t\":[\"作用：显示当前仓库中所有子模块的状态，例如子模块当前指向的 commit。\",\"命令：\",\"git submodule status\",\"输出中会显示子模块的哈希、路径以及子模块是否是最新的。\"]},\"334\":{\"h\":\"4.\",\"t\":[\"作用：如果子模块的上游仓库有新的提交，你可以将子模块更新到最新版本。\",\"命令：\",\"进入子模块目录，然后拉取最新的更改：\",\"cd libs/repo git pull origin main\",\"回到主项目后，提交子模块的更新：\",\"git add libs/repo git commit -m \\\"Update submodule\\\"\"]},\"335\":{\"h\":\"5.\",\"t\":[\"作用：从项目中移除子模块。\",\"步骤：\",\"删除子模块的条目：从 .gitmodules 文件中移除子模块条目。\",\"删除子模块配置：从 .git/config 文件中移除子模块的配置条目。\",\"删除子模块目录：手动删除子模块目录并从版本控制中移除：\",\"git rm -f libs/repo\",\"提交更改：\",\"git commit -m \\\"Remove submodule\\\"\"]},\"336\":{\"h\":\"6.\",\"t\":[\"作用：在某些场景下，你可能希望子模块保持在特定的 commit，而不是跟随最新的更改。\",\"命令：\",\"进入子模块目录，检查出所需的 commit：\",\"cd libs/repo git checkout <commit_hash>\",\"回到主项目，添加并提交子模块的状态：\",\"git add libs/repo git commit -m \\\"Update submodule to specific commit\\\"\"]},\"337\":{\"h\":\"7.\",\"t\":[\"子模块本身也可以包含子模块，称为嵌套子模块。这些子模块的操作与普通子模块类似，但需要特别注意初始化和更新嵌套结构时可能出现的复杂性。\"]},\"338\":{\"h\":\"8.\",\"t\":[\"子模块指针未更新：当你更新子模块后，可能会忘记将更新提交到主仓库。确保更新完子模块后，执行 git add 和 git commit 将指针的变化保存到主仓库。\",\"子模块无法初始化或更新：确保子模块的 URL 正确，并且你有相应的权限克隆子模块。\",\"总结\",\"Git Submodule 是在大型项目或多仓库项目中非常有用的功能，可以让你更好地组织代码。通过上述命令，你可以轻松地添加、更新、管理和删除子模块。掌握这些操作将帮助你有效地管理项目依赖关系和模块化代码结构。\"]},\"339\":{\"c\":[\"其他\"]},\"340\":{\"c\":[\"git\"]},\"341\":{\"h\":\"cmake 基本使用\",\"t\":[\"CMake 是一个跨平台的构建系统生成工具，广泛用于 C/C++ 项目的构建管理。它可以生成适用于不同编译器和操作系统的构建系统文件，如 Makefile、Ninja 文件或 Visual Studio 工程文件。以下是 CMake 的基本教程，帮助你快速上手。\"]},\"342\":{\"h\":\"1.\",\"t\":[\"CMake 支持多平台，以下是不同系统的安装方式：\",\"Ubuntu/Debian：\",\"sudo apt-get install cmake\",\"macOS（使用 Homebrew）：\",\"brew install cmake\",\"Windows： 通过 CMake 官方网站 下载安装程序。\"]},\"343\":{\"h\":\"2.\",\"t\":[\"CMakeLists.txt：CMake 的核心文件，包含构建系统的配置和构建指令。每个 CMake 项目都至少需要一个 CMakeLists.txt 文件。\",\"生成器：CMake 可以为不同平台生成相应的构建系统，如 Makefiles、Ninja 文件或 Visual Studio 项目文件。\",\"构建目录：通常，CMake 项目采用 \\\"out-of-source\\\" 构建，即构建文件和源文件分离。\"]},\"344\":{\"h\":\"3.\",\"t\":[\"一个简单的 CMakeLists.txt 文件通常包含以下内容：\",\"# 声明最低 CMake 版本要求 cmake_minimum_required(VERSION 3.10) # 定义项目名称和语言 project(HelloWorld VERSION 1.0 LANGUAGES C CXX) # 添加可执行文件 add_executable(hello main.cpp)\",\"cmake_minimum_required()：指定最低 CMake 版本。\",\"project()：定义项目的名称和版本信息。\",\"add_executable()：定义一个可执行文件，并指定源文件。\"]},\"345\":{\"h\":\"4.\"},\"346\":{\"h\":\"4.1 项目结构\",\"t\":[\"创建一个简单的项目结构：\",\"my_project/ ├── CMakeLists.txt └── main.cpp\"]},\"347\":{\"h\":\"4.2 示例\",\"t\":[\"在 main.cpp 中编写简单的 C++ 代码：\",\"#include <iostream> int main() { std::cout << \\\"Hello, World!\\\" << std::endl; return 0; }\"]},\"348\":{\"h\":\"4.3 示例\",\"t\":[\"创建一个最简单的 CMakeLists.txt 文件，如下所示：\",\"cmake_minimum_required(VERSION 3.10) project(HelloWorld) add_executable(hello main.cpp)\"]},\"349\":{\"h\":\"5.\"},\"350\":{\"h\":\"5.1 创建构建目录\",\"t\":[\"推荐使用 \\\"out-of-source\\\" 构建，将所有构建文件放到单独的目录中：\",\"mkdir build cd build\"]},\"351\":{\"h\":\"5.2 运行 CMake 命令\",\"t\":[\"在构建目录中运行 CMake：\",\"cmake ..\",\"这会生成一个适合当前平台的构建系统文件（如 Makefile 或 Visual Studio 项目）。\"]},\"352\":{\"h\":\"5.3 构建项目\",\"t\":[\"生成构建文件后，可以使用生成的构建系统工具进行编译：\",\"Makefile 构建：\",\"make\",\"Ninja 构建（如果使用 Ninja 生成器）：\",\"ninja\",\"生成的可执行文件将位于构建目录中，你可以运行它：\",\"./hello\"]},\"353\":{\"h\":\"6.\",\"t\":[\"设置变量：\",\"set(MY_VARIABLE \\\"value\\\")\",\"使用 ${MY_VARIABLE} 访问变量。\",\"添加库： 你可以使用 add_library() 添加静态或动态库：\",\"add_library(my_library STATIC src/mylib.cpp)\",\"包含目录： 使用 include_directories() 将目录添加到编译器的包含路径中：\",\"include_directories(include/)\",\"链接库： 使用 target_link_libraries() 为目标（如可执行文件或库）添加依赖库：\",\"target_link_libraries(hello my_library)\"]},\"354\":{\"h\":\"7.\",\"t\":[\"CMake 提供了 find_package() 函数，用于查找系统中已安装的库。例如，查找并使用 Boost 库：\",\"find_package(Boost REQUIRED) include_directories(${Boost_INCLUDE_DIRS}) target_link_libraries(hello ${Boost_LIBRARIES})\"]},\"355\":{\"h\":\"8.\",\"t\":[\"通过 target_compile_options() 为编译器指定自定义编译选项：\",\"target_compile_options(hello PRIVATE -Wall -Wextra)\"]},\"356\":{\"h\":\"9.\",\"t\":[\"CMake 还支持安装可执行文件和库。你可以使用 install() 函数：\",\"install(TARGETS hello DESTINATION bin)\"]},\"357\":{\"h\":\"10.\",\"t\":[\"Unix Makefiles：适用于大多数 Linux/Unix 系统，默认生成 Makefile。\",\"Ninja：适用于快速构建，可以通过 -G Ninja 选项指定生成器。\",\"Visual Studio：适用于 Windows，生成 Visual Studio 项目文件。\",\"总结\",\"CMake 是一个非常灵活和强大的构建工具，适合处理复杂的跨平台项目。通过以上基本操作和命令，你可以快速上手并使用 CMake 管理你的 C/C++ 项目。在此基础上，CMake 还支持很多高级功能，如测试、打包等，推荐深入学习并灵活运用。\"]},\"358\":{\"c\":[\"其他\"]},\"359\":{\"c\":[\"cmake\"]},\"360\":{\"h\":\"梳理下在工作中使用到的设计模式\"},\"361\":{\"h\":\"，模版方法\",\"t\":[\" class Wave { public: //模版方法，draw 的流程基本固定，但是某些步骤的细节部分由子类实现 void draw(const DrawOption& op) { beginDraw(op); doDraw(op);// 具体绘制延后到子类实现 endDraw(); } protected: // 抽象方法, 具体的绘制由子类实现 virtual void doDraw(const DrawOption&) = 0; private: void beginDraw(const drawOption& op) { // do something } void endDraw() { } }; class BitWav : public Wave { protected: void doDraw(const DrawOption& op) override { // draw bit wave } }; class BusWav : public Wave { protected: void doDraw(const DrawOption& op) override { // draw bus wave } }; //策略模式, 将波形绘制配置的初始化逻辑抽象出来，由子类实现具体的设置逻辑 class WaveStyle { public: virtual void initDrawOption(DrawOption& op) const = 0; }; class DarkWaveStyle : public WaveStyle { public: void initDrawOption(DrawOption& op) const override { //do something 用dark style 初始化op } }; class LightWaveStyle : public WaveStyle { public: virtual void initDrawOption(DrawOption& op) const override { //do something light style 初始化op } }; class Cavas { public: void drawWaves() { auto& waves = getWaves(); //策略模式 for (auto& wave : waves) { DrawOption op;// 绘制参数 color, width, ... //根据装载的mStyle 初始化绘制参数op mstlye->initDrawOption(op); wave->draw(op); } } void setWaveStyle(WaveStyle* style) { mStyle = style; } private: WaveStyle* mStyle = nullptr; };\"]},\"362\":{\"h\":\"工厂方法模式 + 内存池 用于创建频繁的对象\",\"t\":[\"class Signal { public: static Signal* create(const SignalOption& op) { // do something 从内存中申请一个对象，并初始化 void* mem = pool->malloc(sizeof(Signal)); new (mem) Signal(op); return (Signal*)mem; } }; class Scope { public: static Scope* create(const ScopeOption& op) { // do something 从内存中申请一个对象，并初始化 void* mem = pool->malloc(sizeof(Scope)); new (mem) Scope(op); return (Scope*)mem; } };\"]},\"363\":{\"h\":\"，实现preference 配置更改的更新\",\"t\":[\"class Preference { public: class PreferenceObserver { public: virtual void update() = 0; }; void setValue(float value) { if (mValue != value) { mValue = value; notifyObservers(); } } void addObserver(PreferenceObserver* observer) { mObservers.push_back(observer); } void notifyObservers() { for (auto& observer : mObservers) { observer->update(); } } private: std::vector<PreferenceObserver*> mObservers; int mValue; };\"]},\"364\":{\"h\":\"，将任务逻辑和浏览器实现进行分离\",\"t\":[\"class Browser { public: virtual void play(const Option& script) = 0; }; class ChromeBrowser : public Browser { public: void play(const Option& script) override { // do something } }; class IEBrower : public Browser { public: void play(const Option& script) override { // do something } }; class Task { public: void setBrowser(Browser* browser) { // do something mBrowser = browser; } virtual void run() = 0; protected: Browser* mBrowser = nullptr; }; class WebTask : public Task { public: void run() override { // do something auto script = getScript(); mBrower->play(script); // do something 数据处理 } }; class VideoTask : public Task { public: void run() override { // do something auto url = getVideoURL(); mBrower->play(url); // do something 数据处理 } }; class TaskManager { public: void runTasks() { //根据配置 task 装载不同 browser 做具体的浏览操作 //桥接模式： 分离任务逻辑和执行实现 for (auto& task : mTaskList) { if (useIE) { task->setBrower(new IEBrowser); } else { task->setBrower(new Chrome); } task->run(); } } private: std::vector<Task*> mTaskList; };\"]},\"365\":{\"c\":[\"其他\"]},\"366\":{\"c\":[\"设计模式\"]},\"367\":{\"h\":\"利用QEMU+GDB调试Linux内核\",\"t\":[\"使用 QEMU 和 GDB 调试 Linux 内核是一种非常强大的方法，可以帮助开发人员调试和分析内核的行为。下面将详细介绍如何设置和使用 QEMU 和 GDB 来调试 Linux 内核。\"]},\"368\":{\"h\":\"环境准备\",\"t\":[\"系统环境\",\"22.04.3-Ubuntu\",\"gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\",\"GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1\"]},\"369\":{\"h\":\"编译 Linux 内核源码\",\"t\":[\"# 获取 Linux 内核源码 wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.10.6.tar.xz # 解压 tar -xvf linux-6.10.6.tar.xz cd linux-6.10.6 # 配置内核（使用默认配置） make defconfig #运行结束生成 .config 文件在当前目录 # 生成调试符号并编译内核 make -j$(nproc) vmlinux # 拷贝编译好的镜像备用 cp vmlinux ../ cp arch/x86/boot/bzImage ../\",\"提示\",\"vmlinux: 一个包含调试符号的未压缩内核映像，GDB 调试时会用到它,在当前目录linux-6.10.6\",\"bzImage: 编译后的镜像 bzImage, 路径： linux-6.10.6/arch/x86/boot/bzImage\"]},\"370\":{\"h\":\"启动文件系统制作\",\"t\":[\"wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2 tar -xvf busybox-1.36.1.tar.bz2 cd busybox-1.36.1 make menuconfig #-> Settings # --- Build Options # [*] Build static binary (no shared libs) #进行静态编译 (CONFIG_STATIC) # 安装完成后生成的相关文件会在 _install 目录下 make && make install #busybox-1.36.1/_install cd _install mkdir proc mkdir sys # init 为内核启动的初始化程序, 内容在下面 vim init # 必须设置成可执行文件 chmod +x init # 打包启动的文件系统 find . | cpio -o --format=newc > ../../rootfs.img\",\"init 文件内容\",\"#!/bin/sh echo \\\"{==DBG==} INIT SCRIPT\\\" mkdir /tmp mount -t proc none /proc mount -t sysfs none /sys mount -t debugfs none /sys/kernel/debug mount -t tmpfs none /tmp mdev -s echo -e \\\"{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds\\\" # normal user setsid /bin/cttyhack setuidgid 1000 /bin/sh\"]},\"371\":{\"h\":\"安装 QEMU\",\"t\":[\"apt install qemu qemu-utils qemu-kvm virt-manager libvirt-daemon-system libvirt-clients bridge-utils\"]},\"372\":{\"h\":\"使用 QEMU 启动内核\",\"t\":[\"提示\",\"确保已经安装QEMU\",\"确保以下文件准备好： \",\"rootfs.img\",\"bzImage\",\"vmlinux\",\"使用 QEMU 启动内核，并开启 QEMU 的 GDB 远程调试功能。\",\"#ls 当前目录文件 #busybox-1.36.1 #busybox-1.36.1.tar.bz2 #rootfs.img #bzImage #vmlinux #linux-6.10.6 #linux-6.10.6.tar.xz qemu-system-x86_64 -kernel ./bzImage -initrd ./rootfs.img -append \\\"nokaslr console=ttyS0\\\" -s -S -nographic\",\"参数说明\",\"-kernel ./bzImage：指定启用的内核镜像；\",\"-initrd ./rootfs.img：指定启动的文件系统；\",\"-append \\\"nokaslr console=ttyS0\\\" ：附加参数，其中 nokaslr 参数必须添加进来，防止内核起始地址随机化，这样会导致 gdb 断点不能命中；\",\"-s ：监听在 gdb 1234 端口；\",\"-S ：表示启动后就挂起，等待 gdb 连接；\",\"-nographic：不启动图形界面，调试信息输出到终端与参数 console=ttyS0 组合使用\",\"此时，QEMU 已经启动并等待 GDB 的连接，CPU 被暂停。\"]},\"373\":{\"h\":\"使用 GDB 调试内核\",\"t\":[\"在另一个终端中启动 GDB，加载 vmlinux 文件（未压缩的内核映像），以便使用调试符号。\",\"gdb vmlinux\",\"在 GDB 中，使用 target remote 命令连接到 QEMU 提供的 GDB 服务器：\",\"(gdb) target remote :1234\",\"此时，GDB 已经连接到 QEMU，并可以控制虚拟机的执行。可以在内核的特定位置设置断点，并开始调试。例如，可以设置断点在 start_kernel 函数：\",\"(gdb) b start_kernel\",\"然后使用 continue 命令继续运行内核：\",\"(gdb) c\",\"当内核运行到 start_kernel 时，GDB 会暂停并命中断点，接下来你可以逐步执行代码 (step 或 next 命令)，查看变量的值等。\"]},\"374\":{\"h\":\"常用 GDB 命令\",\"t\":[\"b <function>：在函数入口处设置断点。\",\"b *<address>：在特定内存地址设置断点。\",\"info breakpoints：查看当前设置的断点。\",\"c：继续执行程序，直到下一个断点。\",\"step：单步执行代码，进入函数内部。\",\"next：单步执行代码，跳过函数调用。\",\"print <variable>：打印变量的值。\",\"x/<n> <address>：查看指定地址的内存内容。\",\"注意事项\",\"内核编译时需要启用调试符号 (.config 文件CONFIG_DEBUG_INFO=y)。\",\"QEMU 的 -s 和 -S 参数用于设置 GDB 远程调试的端口和暂停启动。\"]},\"375\":{\"h\":\"参考：\",\"t\":[\"官方文档\",\"其他资料1\",\"其他资料2\"]},\"376\":{\"c\":[\"其他\"]},\"377\":{\"c\":[\"Linux\",\"GDB\",\"kernel\",\"QEMU\"]},\"378\":{\"h\":\"其他\"},\"379\":{\"c\":[\"其他\"]},\"380\":{\"h\":\"副业搞钱\"},\"381\":{\"c\":[\"副业\"]},\"382\":{\"h\":\"\",\"t\":[\"Install Ollama\",\" curl -fsSL https://ollama.com/install.sh | sh # 启动服务 sudo systemctl restart ollama sudo vim /etc/systemd/system/ollama.service [Unit] Description=Ollama Service After=network-online.target [Service] ExecStart=/usr/local/bin/ollama serve User=ollama Group=ollama Restart=always RestartSec=3 Environment=\\\"PATH=/home/lucas/.local/bin:/home/lucas/anaconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\\\" Environment=\\\"OLLAMA_HOST=0.0.0.0:11434\\\" Environment=\\\"OLLAMA_ORIGINS=*\\\" [Install] WantedBy=default.target\",\"Start Using Models: Once installed, you can start downloading and running models, such as Llama, directly using commands like:\",\"ollama run llama3.1:8b\",\"The first time you run a model, it will be downloaded. Subsequent runs will use the local copy.\",\"Running Ollama with Docker and Open WebUI\",\"If you prefer a GUI over the command line, you can set up Open WebUI to interact with your models in a browser. First, ensure Docker is installed, then run:\",\"docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main\",\"Then, open your browser and go to http://localhost:3000.\"]},\"383\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"副业\",{\"2\":{\"381\":1}}],[\"副业搞钱\",{\"0\":{\"380\":1}}],[\"官方文档\",{\"1\":{\"375\":1}}],[\"官方网站\",{\"1\":{\"342\":1}}],[\"跳过函数调用\",{\"1\":{\"374\":1}}],[\"跳出循环\",{\"1\":{\"91\":1,\"93\":1}}],[\"跳出循环并返回该节点\",{\"1\":{\"91\":1}}],[\"未压缩的内核映像\",{\"1\":{\"373\":1}}],[\"未被移动或绑定到引用\",{\"1\":{\"264\":1}}],[\"端口\",{\"1\":{\"372\":1}}],[\"监听在\",{\"1\":{\"372\":1}}],[\"断点不能命中\",{\"1\":{\"372\":1}}],[\"断开更加安全\",{\"1\":{\"36\":1}}],[\"附加参数\",{\"1\":{\"372\":1}}],[\"参数用于设置\",{\"1\":{\"374\":1}}],[\"参数必须添加进来\",{\"1\":{\"372\":1}}],[\"参数说明\",{\"1\":{\"372\":1}}],[\"参考\",{\"0\":{\"375\":1},\"1\":{\"246\":2}}],[\"必须设置成可执行文件\",{\"1\":{\"370\":1}}],[\"必要使用链表的情况主要是二叉树和图\",{\"1\":{\"36\":1}}],[\"安装\",{\"0\":{\"371\":1}}],[\"安装完成后生成的相关文件会在\",{\"1\":{\"370\":1}}],[\"安全等级\",{\"1\":{\"72\":1}}],[\"路径\",{\"1\":{\"369\":1}}],[\"路径以及子模块是否是最新的\",{\"1\":{\"333\":1}}],[\"拷贝编译好的镜像备用\",{\"1\":{\"369\":1}}],[\"拷贝构造函数调用了两次\",{\"1\":{\"270\":1}}],[\"拷贝构造函数拷贝指针并增加与之相应的引用计数\",{\"1\":{\"267\":1}}],[\"配置内核\",{\"1\":{\"369\":1}}],[\"配置更改的更新\",{\"0\":{\"363\":1}}],[\"环境准备\",{\"0\":{\"368\":1}}],[\"环形引用\",{\"1\":{\"269\":1}}],[\"环形数组\",{\"1\":{\"44\":1,\"65\":1}}],[\"环形链表常用于需要周期性操作的场景\",{\"1\":{\"27\":1}}],[\"环形链表\",{\"1\":{\"26\":1,\"35\":1}}],[\"做具体的浏览操作\",{\"1\":{\"364\":1}}],[\"做题\",{\"1\":{\"36\":1}}],[\"装载不同\",{\"1\":{\"364\":1}}],[\"装饰器类\",{\"1\":{\"144\":1}}],[\"装饰器模式在需要动态添加功能的场景中非常有用\",{\"1\":{\"145\":1}}],[\"装饰器模式通常涉及以下几个角色\",{\"1\":{\"144\":1}}],[\"装饰器模式主要解决的问题是\",{\"1\":{\"143\":1}}],[\"装饰器模式\",{\"0\":{\"142\":1},\"1\":{\"3\":1,\"143\":1,\"145\":1},\"2\":{\"147\":1}}],[\"绘制参数\",{\"1\":{\"361\":1}}],[\"梳理下在工作中使用到的设计模式\",{\"0\":{\"360\":1}}],[\"库\",{\"1\":{\"354\":1}}],[\"$\",{\"1\":{\"353\":1,\"354\":2,\"370\":1}}],[\"└──\",{\"1\":{\"346\":1}}],[\"├──\",{\"1\":{\"346\":1}}],[\"版本\",{\"1\":{\"344\":1}}],[\"版本要求\",{\"1\":{\"344\":1}}],[\"声明最低\",{\"1\":{\"344\":1}}],[\"声明一个变量\",{\"1\":{\"34\":1}}],[\"项目\",{\"1\":{\"351\":1,\"357\":1}}],[\"项目结构\",{\"0\":{\"346\":1}}],[\"项目采用\",{\"1\":{\"343\":1}}],[\"项目文件\",{\"1\":{\"343\":1,\"357\":1}}],[\"项目都至少需要一个\",{\"1\":{\"343\":1}}],[\"项目的构建管理\",{\"1\":{\"341\":1}}],[\"帮助你快速上手\",{\"1\":{\"341\":1}}],[\"工程文件\",{\"1\":{\"341\":1}}],[\"工厂方法模式\",{\"0\":{\"362\":1}}],[\"工厂接口\",{\"1\":{\"157\":1}}],[\"工厂模式提供了一种创建对象的方式\",{\"1\":{\"156\":1}}],[\"工厂模式和抽象工厂模式都是创建型设计模式\",{\"1\":{\"155\":1}}],[\"工厂模式\",{\"0\":{\"154\":1,\"156\":1},\"1\":{\"3\":1,\"125\":1,\"161\":1},\"2\":{\"163\":1}}],[\"掌握这些操作将帮助你有效地管理项目依赖关系和模块化代码结构\",{\"1\":{\"338\":1}}],[\"掌握一些基本的算法和数据结构\",{\"1\":{\"0\":1}}],[\"正确\",{\"1\":{\"338\":1}}],[\"正在等待某个事件\",{\"1\":{\"215\":1}}],[\"称为嵌套子模块\",{\"1\":{\"337\":1}}],[\"手动删除子模块目录并从版本控制中移除\",{\"1\":{\"335\":1}}],[\"克隆仓库时自动初始化和更新子模块\",{\"1\":{\"332\":1}}],[\"你需要先初始化它们\",{\"1\":{\"332\":1}}],[\"你可能希望子模块保持在特定的\",{\"1\":{\"336\":1}}],[\"你可能会发现一个问题\",{\"1\":{\"44\":1}}],[\"你可以快速上手并使用\",{\"1\":{\"357\":1}}],[\"你可以运行它\",{\"1\":{\"352\":1}}],[\"你可以轻松地添加\",{\"1\":{\"338\":1}}],[\"你可以将子模块更新到最新版本\",{\"1\":{\"334\":1}}],[\"你可以使用\",{\"1\":{\"316\":1,\"353\":1,\"356\":1}}],[\"你可以继承这个类来自定义数据的显示和编辑行为\",{\"1\":{\"189\":1}}],[\"默认生成\",{\"1\":{\"357\":1}}],[\"默认从当前跟踪的远程分支拉取更新\",{\"1\":{\"327\":1}}],[\"默认的委托类是\",{\"1\":{\"189\":1}}],[\"合并分支\",{\"1\":{\"324\":1}}],[\"合并最近几次的commit\",{\"1\":{\"314\":1}}],[\"切换到指定分支\",{\"1\":{\"322\":1}}],[\"切换分支\",{\"1\":{\"322\":1}}],[\"丢弃更改\",{\"1\":{\"320\":1}}],[\"丢弃工作区文件和提交历史\",{\"1\":{\"320\":1}}],[\"丢失的末尾元素都是\",{\"1\":{\"12\":1}}],[\"丢失元素\",{\"1\":{\"12\":1}}],[\"丢失\",{\"1\":{\"11\":1}}],[\"恢复工作\",{\"1\":{\"319\":1}}],[\"恢复工作目录中文件的状态\",{\"1\":{\"318\":1}}],[\"恢复文件\",{\"1\":{\"318\":1}}],[\"暂存区和最新提交之间的差异\",{\"1\":{\"317\":1}}],[\"暂存原哈希表\",{\"1\":{\"63\":1,\"65\":1}}],[\"哪些文件未被跟踪\",{\"1\":{\"315\":1}}],[\"哪些文件被暂存\",{\"1\":{\"315\":1}}],[\"仓库克隆到当前项目的\",{\"1\":{\"331\":1}}],[\"仓库中包含另一个独立的\",{\"1\":{\"330\":1}}],[\"仓库\",{\"1\":{\"311\":1,\"330\":1,\"331\":1}}],[\"作用\",{\"1\":{\"311\":3,\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"327\":1,\"328\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1}}],[\"作为某些搜索算法的底层数据结构\",{\"1\":{\"96\":1}}],[\"作为\",{\"1\":{\"73\":1,\"102\":1,\"103\":1,\"175\":1}}],[\"作为模数\",{\"1\":{\"71\":1}}],[\"作为初始容量\",{\"1\":{\"34\":1}}],[\"广泛用于\",{\"1\":{\"341\":1}}],[\"广泛用于开发和项目管理中\",{\"1\":{\"309\":1}}],[\"广度优先遍历到最底层之前\",{\"1\":{\"113\":1}}],[\"失败时\",{\"1\":{\"301\":1}}],[\"失衡节点的平衡因子\",{\"1\":{\"106\":1}}],[\"失衡节点\",{\"1\":{\"101\":1}}],[\"成功时\",{\"1\":{\"301\":1}}],[\"成为进程之间协调和数据共享的关键手段\",{\"1\":{\"225\":1}}],[\"要等待的子进程的进程\",{\"1\":{\"300\":1}}],[\"优化应用程序性能\",{\"1\":{\"296\":1}}],[\"优点\",{\"0\":{\"179\":1}}],[\"建立连接时的握手状态\",{\"1\":{\"295\":1}}],[\"建立链表分为两步\",{\"1\":{\"20\":1}}],[\"准备接受连接\",{\"1\":{\"294\":1}}],[\"双方都接收到对方的确认包后\",{\"1\":{\"294\":1}}],[\"双方同时发送fin包时会进入这个状态\",{\"1\":{\"292\":1}}],[\"双向绑定\",{\"1\":{\"176\":1}}],[\"双向队列就像是栈和队列的组合或两个栈拼在了一起\",{\"1\":{\"54\":1}}],[\"双向队列像是两个栈拼接在了一起\",{\"1\":{\"54\":1}}],[\"双向队列\",{\"1\":{\"54\":1}}],[\"双向队列是一种具有更高自由度的队列\",{\"1\":{\"53\":1}}],[\"双向队列适合使用链表实现\",{\"1\":{\"36\":1}}],[\"双向链表的特性使得这种操作变得简单\",{\"1\":{\"27\":1}}],[\"双向链表的节点定义同时包含指向后继节点\",{\"1\":{\"26\":1}}],[\"双向链表常用于需要快速查找前一个和后一个元素的场景\",{\"1\":{\"27\":1}}],[\"双向链表节点结构体\",{\"1\":{\"26\":1}}],[\"双向链表更具灵活性\",{\"1\":{\"26\":1}}],[\"双向链表记录了两个方向的引用\",{\"1\":{\"26\":1}}],[\"双向链表\",{\"1\":{\"26\":1,\"35\":1}}],[\"结束\",{\"1\":{\"292\":1}}],[\"结构\",{\"0\":{\"132\":1,\"138\":1,\"144\":1,\"150\":1,\"157\":1,\"160\":1,\"166\":1}}],[\"结构型模式\",{\"1\":{\"125\":1}}],[\"状态的作用\",{\"0\":{\"295\":1}}],[\"状态转换的简要说明\",{\"0\":{\"294\":1}}],[\"状态转换图\",{\"0\":{\"293\":1}}],[\"状态转换示意图\",{\"0\":{\"217\":1}}],[\"状态时进入\",{\"1\":{\"292\":1}}],[\"服务器\",{\"1\":{\"373\":1}}],[\"服务器等待连接请求的状态\",{\"1\":{\"295\":1}}],[\"服务器接收到syn包后\",{\"1\":{\"294\":1}}],[\"服务器调用listen\",{\"1\":{\"294\":1}}],[\"服务器在接收到客户端的syn包后\",{\"1\":{\"292\":1}}],[\"服务器套接字正在监听连接请求\",{\"1\":{\"292\":1}}],[\"服务器中\",{\"1\":{\"168\":1}}],[\"传输数据\",{\"1\":{\"291\":1}}],[\"传入的是子树的根节点\",{\"1\":{\"113\":1}}],[\"逆向\",{\"2\":{\"290\":1}}],[\"逆向工程常通过执行文件的中静态字符串信息找到关键点函数进行逆向\",{\"1\":{\"284\":1}}],[\"演示如何使用\",{\"1\":{\"288\":1}}],[\"简化加密字符串的使用\",{\"1\":{\"288\":1}}],[\"特殊值如下\",{\"1\":{\"300\":1}}],[\"特性\",{\"1\":{\"288\":1}}],[\"特别适合需要在用户界面中展示大量或复杂数据的应用程序\",{\"1\":{\"185\":1}}],[\"特别是在现代前端框架\",{\"1\":{\"177\":1}}],[\"特别是在需要扩展产品种类或改变产品族的实现时\",{\"1\":{\"161\":1}}],[\"密钥是字符的位置索引\",{\"1\":{\"288\":1}}],[\"密码存储\",{\"1\":{\"70\":1}}],[\"敏感信息在编译时就被加密\",{\"1\":{\"286\":1}}],[\"介绍一种利用\",{\"1\":{\"284\":1}}],[\"介绍开放寻址哈希表的工作机制\",{\"1\":{\"64\":1}}],[\"语法糖\",{\"0\":{\"272\":1}}],[\"语言一样的方式\",{\"1\":{\"204\":1}}],[\"you\",{\"1\":{\"382\":4}}],[\"your\",{\"1\":{\"181\":1,\"382\":2}}],[\"y\",{\"1\":{\"274\":2}}],[\"year\",{\"1\":{\"271\":4}}],[\"比之前少了一次拷贝构造和一次析构\",{\"1\":{\"270\":1}}],[\"比如链表节点\",{\"1\":{\"73\":1}}],[\"比如\",{\"1\":{\"36\":2,\"62\":1}}],[\"比如在音频\",{\"1\":{\"27\":1}}],[\"比如在红黑树\",{\"1\":{\"27\":1}}],[\"比如操作系统的资源调度\",{\"1\":{\"27\":1}}],[\"比如以上代码中的链表可记作链表\",{\"1\":{\"20\":1}}],[\"比如数组\",{\"1\":{\"20\":1}}],[\"移动构造函数\",{\"1\":{\"270\":1}}],[\"移除和通知观察者的方法\",{\"1\":{\"132\":1}}],[\"弱引用\",{\"1\":{\"269\":1}}],[\"造成在结束时对同一内存指针多次释放而导致程序崩溃\",{\"1\":{\"268\":1}}],[\"局部变量的返回值除外\",{\"1\":{\"268\":1}}],[\"源指针被置空\",{\"1\":{\"268\":1}}],[\"转移一个unique\",{\"1\":{\"268\":1}}],[\"转化为\",{\"1\":{\"49\":1}}],[\"赋值操作符减少左操作数所指对象的引用计数\",{\"1\":{\"267\":1}}],[\"赋给\",{\"1\":{\"11\":1}}],[\"智能指针将一个计数器与类指向的对象相关联\",{\"1\":{\"267\":1}}],[\"智能指针线程安全\",{\"1\":{\"266\":1}}],[\"智能指针是为没有垃圾回收机制的语言解决可能的内存泄露问题的利器\",{\"1\":{\"266\":1}}],[\"好在这些问题都可以解决\",{\"1\":{\"266\":1}}],[\"性能优化和网络编程都非常有帮助\",{\"1\":{\"291\":1}}],[\"性能优化\",{\"0\":{\"265\":1}}],[\"性能问题\",{\"1\":{\"180\":1}}],[\"异步调用优先使用async取代创建线程\",{\"1\":{\"264\":1}}],[\"异或哈希\",{\"1\":{\"71\":1}}],[\"强制使用std\",{\"1\":{\"264\":1}}],[\"临时量的析构函数等待\",{\"1\":{\"264\":1}}],[\"获得的\",{\"1\":{\"264\":1}}],[\"获取\",{\"1\":{\"369\":1}}],[\"获取thread\",{\"1\":{\"257\":1}}],[\"获取子进程的退出状态后\",{\"1\":{\"218\":1}}],[\"获取数据并显示在界面上\",{\"1\":{\"190\":1}}],[\"获取数据\",{\"1\":{\"190\":1}}],[\"获取或更新数据\",{\"1\":{\"173\":1}}],[\"获取节点\",{\"1\":{\"106\":1}}],[\"获取平衡因子\",{\"1\":{\"100\":1}}],[\"获取中序遍历中\",{\"1\":{\"93\":1}}],[\"获取中序遍历后继节点需要\",{\"1\":{\"93\":1}}],[\"获取所有值\",{\"1\":{\"60\":1}}],[\"获取所有键\",{\"1\":{\"60\":1}}],[\"获取所有键值对\",{\"1\":{\"60\":1}}],[\"获取栈的长度\",{\"1\":{\"47\":1,\"49\":1,\"50\":1}}],[\"获取队列的容量\",{\"1\":{\"44\":1}}],[\"获取队列的长度\",{\"1\":{\"41\":1,\"43\":1,\"44\":1}}],[\"获取并返回随机元素\",{\"1\":{\"10\":1}}],[\"惰性执行在当前线程\",{\"1\":{\"264\":1}}],[\"普通的计数器\",{\"1\":{\"260\":1}}],[\"看一段使用代码\",{\"1\":{\"264\":1}}],[\"看一个计数器的代码\",{\"1\":{\"260\":1}}],[\"看到了\",{\"1\":{\"207\":1}}],[\"别的还真的没用过\",{\"1\":{\"260\":1}}],[\"别的都是类似的使用方式\",{\"1\":{\"258\":1}}],[\"少了一些成员函数\",{\"1\":{\"259\":1}}],[\"防止内核起始地址随机化\",{\"1\":{\"372\":1}}],[\"防止僵尸进程\",{\"1\":{\"305\":1,\"306\":1}}],[\"防止旧数据包干扰\",{\"1\":{\"292\":1}}],[\"防止线程由于编码失误导致一直持有锁\",{\"1\":{\"259\":1}}],[\"防止频繁扩容\",{\"1\":{\"61\":1}}],[\"拿一个std\",{\"1\":{\"258\":1}}],[\"拿二叉搜索树来举例\",{\"1\":{\"113\":1}}],[\"带超时的互斥量\",{\"1\":{\"258\":2}}],[\"带来的性能开销和死锁风险\",{\"1\":{\"247\":1}}],[\"独占的互斥量\",{\"1\":{\"258\":1}}],[\"独立于\",{\"1\":{\"179\":1}}],[\"检查出所需的\",{\"1\":{\"336\":1}}],[\"检查子进程是否被信号终止\",{\"1\":{\"304\":1}}],[\"检查子进程是否正常退出\",{\"1\":{\"304\":1}}],[\"检查weak\",{\"1\":{\"269\":1}}],[\"检查线程可否被join\",{\"1\":{\"257\":1}}],[\"检查取出操作是否成功\",{\"1\":{\"251\":1}}],[\"检查插入操作是否成功\",{\"1\":{\"251\":1}}],[\"检查队列是否为空\",{\"1\":{\"251\":1}}],[\"检查队列是否已满\",{\"1\":{\"251\":1}}],[\"检查条件状态\",{\"1\":{\"240\":1}}],[\"启动服务\",{\"1\":{\"382\":1}}],[\"启动内核\",{\"0\":{\"372\":1},\"1\":{\"372\":1}}],[\"启动文件系统制作\",{\"0\":{\"370\":1}}],[\"启动消费者线程\",{\"1\":{\"250\":1,\"251\":1}}],[\"启动生产者线程\",{\"1\":{\"250\":1,\"251\":1}}],[\"引入的一个关键字\",{\"1\":{\"285\":1}}],[\"引入了\",{\"1\":{\"249\":1}}],[\"引用计数有一个问题就是互相引用形成环\",{\"1\":{\"269\":1}}],[\"引用计数器跟踪共有多少个类对象共享同一指针\",{\"1\":{\"267\":1}}],[\"引用计数会减1\",{\"1\":{\"267\":1}}],[\"引用记录了下一个节点的内存地址\",{\"1\":{\"18\":1}}],[\"引用\",{\"1\":{\"18\":3}}],[\"互相持有其他进程\",{\"1\":{\"246\":1}}],[\"互斥\",{\"1\":{\"246\":1}}],[\"互斥量可以独占\",{\"1\":{\"264\":1}}],[\"互斥量有一个内部状态\",{\"1\":{\"238\":1}}],[\"互斥量的核心原理是通过锁定和解锁机制来控制对共享资源的访问\",{\"1\":{\"238\":1}}],[\"共享\",{\"1\":{\"246\":1}}],[\"共享内存\",{\"1\":{\"232\":1}}],[\"共享内存速度快\",{\"1\":{\"228\":1}}],[\"共享内存是一种高效的进程间通信方式\",{\"1\":{\"228\":1}}],[\"禁止抢占\",{\"1\":{\"246\":1}}],[\"死锁问题的排查\",{\"1\":{\"246\":1}}],[\"死锁的四个条件\",{\"1\":{\"246\":1}}],[\"死锁\",{\"0\":{\"246\":1}}],[\"继续执行程序\",{\"1\":{\"374\":1}}],[\"继续执行\",{\"1\":{\"245\":1}}],[\"继承与多态\",{\"0\":{\"206\":1}}],[\"继承自抽象类\",{\"1\":{\"150\":1}}],[\"继承装饰器类\",{\"1\":{\"144\":1}}],[\"倒数计数器\",{\"1\":{\"245\":1}}],[\"锁存器适用于需要等待一组线程或任务完成后才能继续执行的场景\",{\"1\":{\"245\":1}}],[\"锁存器计数减少\",{\"1\":{\"245\":1}}],[\"锁存器内部维护一个倒数计数器\",{\"1\":{\"245\":1}}],[\"锁存器类似于屏障\",{\"1\":{\"245\":1}}],[\"锁定\",{\"1\":{\"238\":1}}],[\"锁定或未锁定\",{\"1\":{\"238\":1}}],[\"屏障适用于并行计算中需要同步多个线程的场景\",{\"1\":{\"244\":1}}],[\"屏障解除\",{\"1\":{\"244\":1}}],[\"屏障内部维护一个计数器\",{\"1\":{\"244\":1}}],[\"屏障用于同步一组线程\",{\"1\":{\"244\":1}}],[\"屏蔽\",{\"1\":{\"48\":1}}],[\"忙等待\",{\"1\":{\"243\":1}}],[\"计数器加\",{\"1\":{\"242\":1}}],[\"计数器减\",{\"1\":{\"242\":1,\"244\":1,\"245\":1}}],[\"计数器初始值通常为资源的总量\",{\"1\":{\"242\":1}}],[\"计数器\",{\"1\":{\"242\":1,\"244\":1}}],[\"计算插入元素后的尾部指针值\",{\"1\":{\"251\":1}}],[\"计算效率更高\",{\"1\":{\"72\":1}}],[\"计算开销越小\",{\"1\":{\"70\":1}}],[\"计算哈希值的过程应该足够快\",{\"1\":{\"70\":1}}],[\"计算桶索引\",{\"1\":{\"65\":1}}],[\"计算得到哈希值\",{\"1\":{\"60\":1}}],[\"计算队尾指针\",{\"1\":{\"44\":1}}],[\"计算机不仅会加载它\",{\"1\":{\"16\":1}}],[\"硬件支持\",{\"1\":{\"241\":1}}],[\"生成调试符号并编译内核\",{\"1\":{\"369\":1}}],[\"生成\",{\"1\":{\"357\":1}}],[\"生成的可执行文件将位于构建目录中\",{\"1\":{\"352\":1}}],[\"生成构建文件后\",{\"1\":{\"352\":1}}],[\"生成器\",{\"1\":{\"343\":1,\"352\":1}}],[\"生成新的提交\",{\"1\":{\"314\":1}}],[\"生成唯一键\",{\"1\":{\"227\":1,\"228\":1}}],[\"生产者插入数据\",{\"1\":{\"251\":1}}],[\"生产者线程\",{\"1\":{\"251\":1}}],[\"生产者线程通知消费者线程有新数据可用\",{\"1\":{\"240\":1}}],[\"消费者取出数据\",{\"1\":{\"251\":1}}],[\"消费者线程\",{\"1\":{\"251\":1}}],[\"消费者线程等待该通知\",{\"1\":{\"240\":1}}],[\"消费者模型等\",{\"1\":{\"242\":1}}],[\"消费者模型中\",{\"1\":{\"240\":1}}],[\"消息队列\",{\"1\":{\"232\":1}}],[\"消息队列可以实现多个进程之间的消息传递和同步\",{\"1\":{\"227\":1}}],[\"消息队列允许进程以消息为单位进行通信\",{\"1\":{\"227\":1}}],[\"消息传递系统等\",{\"1\":{\"133\":1}}],[\"消息通知\",{\"1\":{\"133\":1}}],[\"唤醒一个线程\",{\"1\":{\"242\":1}}],[\"唤醒一个或所有等待队列中的线程\",{\"1\":{\"240\":1}}],[\"唤醒所有等待的线程\",{\"1\":{\"240\":1}}],[\"变为\",{\"1\":{\"240\":1}}],[\"变量是一个整数\",{\"1\":{\"302\":1}}],[\"变量解释\",{\"0\":{\"302\":1}}],[\"变量的指针\",{\"1\":{\"300\":1}}],[\"变量\",{\"1\":{\"99\":1}}],[\"条件变量需要和锁配合使用\",{\"1\":{\"262\":1}}],[\"条件变量是c++11引入的一种同步机制\",{\"1\":{\"262\":1}}],[\"条件变量常用于线程之间的协调\",{\"1\":{\"240\":1}}],[\"条件变量与一个互斥量和一个条件状态相关联\",{\"1\":{\"240\":1}}],[\"条件变量用于线程之间的等待和通知机制\",{\"1\":{\"240\":1}}],[\"读锁定\",{\"1\":{\"239\":1}}],[\"读写锁包含两个计数器\",{\"1\":{\"239\":1}}],[\"读写锁允许多个线程同时读取\",{\"1\":{\"239\":1}}],[\"维护一个等待队列\",{\"1\":{\"238\":1,\"239\":1,\"240\":1}}],[\"维护一个具体的状态\",{\"1\":{\"132\":1}}],[\"号和套接字\",{\"1\":{\"232\":1}}],[\"信\",{\"1\":{\"232\":1}}],[\"信号后继续运行\",{\"1\":{\"300\":1}}],[\"信号停止\",{\"1\":{\"300\":1}}],[\"信号量适用于控制对资源的并发访问数量\",{\"1\":{\"242\":1}}],[\"信号量内部维护一个计数器\",{\"1\":{\"242\":1}}],[\"信号量是一种控制对共享资源访问的计数器\",{\"1\":{\"242\":1}}],[\"信号量是一种用于进程间同步的机制\",{\"1\":{\"229\":1}}],[\"信号量\",{\"1\":{\"232\":1}}],[\"信号可以用于进程间的简单通信或异常处理\",{\"1\":{\"230\":1}}],[\"信号是一种异步通知机制\",{\"1\":{\"230\":1}}],[\"信号处理\",{\"1\":{\"224\":1}}],[\"信号处理程序\",{\"1\":{\"220\":1}}],[\"信号处理子进程的结束\",{\"1\":{\"220\":1}}],[\"信号\",{\"1\":{\"220\":2}}],[\"套接字\",{\"1\":{\"231\":1}}],[\"套接字是一种网络通信的进程间通信方式\",{\"1\":{\"231\":1}}],[\"销毁共享内存\",{\"1\":{\"228\":1}}],[\"|pid|\",{\"1\":{\"300\":1}}],[\"|\",{\"1\":{\"227\":1,\"228\":1,\"229\":1,\"264\":1,\"370\":1,\"382\":1}}],[\"||\",{\"1\":{\"93\":1,\"109\":1,\"121\":1}}],[\"写锁定\",{\"1\":{\"239\":1}}],[\"写入管道\",{\"1\":{\"226\":1}}],[\"写日志等\",{\"1\":{\"224\":1}}],[\"管道是一种半双工的通信方式\",{\"1\":{\"226\":1}}],[\"管道是最基本的\",{\"1\":{\"226\":1}}],[\"管理你的\",{\"1\":{\"357\":1}}],[\"管理和删除子模块\",{\"1\":{\"338\":1}}],[\"管理\",{\"0\":{\"330\":1}}],[\"管理分支\",{\"1\":{\"323\":1}}],[\"管理远程仓库地址\",{\"1\":{\"311\":1}}],[\"管理多个子进程\",{\"1\":{\"305\":1}}],[\"管理的资源是否被释放\",{\"1\":{\"266\":1}}],[\"管理数据\",{\"1\":{\"187\":1}}],[\"管理应用程序的核心数据\",{\"1\":{\"173\":1}}],[\"权限\",{\"1\":{\"224\":1}}],[\"某些守护进程需要特定的权限\",{\"1\":{\"224\":1}}],[\"某些语言可能没有专门提供栈类\",{\"1\":{\"47\":1}}],[\"日志记录\",{\"1\":{\"224\":1}}],[\"日志处理\",{\"1\":{\"168\":1}}],[\"注意\",{\"1\":{\"264\":1}}],[\"注意事项\",{\"0\":{\"224\":1},\"1\":{\"374\":1}}],[\"注册信号处理程序\",{\"1\":{\"230\":1}}],[\"注册\",{\"1\":{\"220\":1}}],[\"清除文件权限掩码\",{\"1\":{\"223\":1}}],[\"清空列表\",{\"1\":{\"32\":1}}],[\"脱离终端\",{\"1\":{\"222\":1}}],[\"守护进程不能直接输出到终端\",{\"1\":{\"224\":1}}],[\"守护进程不再依赖于终端\",{\"1\":{\"223\":1}}],[\"守护进程通常需要处理系统信号\",{\"1\":{\"224\":1}}],[\"守护进程的其他工作逻辑可以写在这里\",{\"1\":{\"222\":1}}],[\"守护进程的主循环\",{\"1\":{\"222\":1}}],[\"守护进程\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"选项指定生成器\",{\"1\":{\"357\":1}}],[\"选项在克隆时自动初始化并更新所有子模块\",{\"1\":{\"332\":1}}],[\"选项简化输出\",{\"1\":{\"316\":1}}],[\"选项来添加提交信息\",{\"1\":{\"314\":1}}],[\"选项一起使用\",{\"1\":{\"305\":1}}],[\"选择适当的方法管理子进程的生命周期\",{\"1\":{\"220\":1}}],[\"选取一个合理的数组初始容量\",{\"1\":{\"34\":1}}],[\"孙子进程\",{\"1\":{\"220\":1}}],[\"孙子进程则由\",{\"1\":{\"220\":1}}],[\"及时调用\",{\"1\":{\"220\":1}}],[\"及其以下节点形成的树\",{\"1\":{\"79\":2}}],[\"zombie\",{\"1\":{\"218\":1}}],[\"zfooei\",{\"1\":{\"204\":1}}],[\"僵尸进程是因父进程未及时处理子进程的退出状态而产生的\",{\"1\":{\"220\":1}}],[\"僵尸进程的影响\",{\"0\":{\"219\":1}}],[\"僵尸进程的进程描述符才会被完全清除\",{\"1\":{\"218\":1}}],[\"僵尸进程\",{\"0\":{\"218\":1},\"1\":{\"218\":1}}],[\"终止\",{\"1\":{\"215\":1,\"216\":1}}],[\"阻塞直到函数返回\",{\"1\":{\"264\":1}}],[\"阻塞的进程会被移回就绪队列\",{\"1\":{\"216\":1}}],[\"阻塞\",{\"1\":{\"215\":1,\"216\":2}}],[\"资源只能同时分配给一个进程\",{\"1\":{\"246\":1}}],[\"资源占用\",{\"1\":{\"219\":1}}],[\"资源可用\",{\"1\":{\"215\":1}}],[\"资源\",{\"1\":{\"215\":1}}],[\"新增线程编程相关模块\",{\"0\":{\"256\":1}}],[\"新的线程与主线程没有任何关联\",{\"1\":{\"236\":1}}],[\"新建\",{\"1\":{\"215\":1,\"216\":1}}],[\"新特性\",{\"0\":{\"255\":1},\"1\":{\"1\":1}}],[\"另外\",{\"1\":{\"210\":1}}],[\"另一次是在main函数中构造a对象产生的\",{\"1\":{\"270\":1}}],[\"另一个用于记录是否有写线程在等待\",{\"1\":{\"239\":1}}],[\"另一个是调用detach\",{\"1\":{\"257\":1}}],[\"另一个是调用\",{\"1\":{\"236\":1}}],[\"另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题\",{\"1\":{\"72\":1}}],[\"另一方面\",{\"1\":{\"36\":2}}],[\"全部构造函数被调用后才会有最后的vtable\",{\"1\":{\"210\":1}}],[\"能使重载的函数得到相应的调用\",{\"1\":{\"210\":1}}],[\"能找到正确的函数\",{\"1\":{\"207\":1}}],[\"怎么找vtable呢\",{\"1\":{\"210\":1}}],[\"派生类中申请的空间就得不到释放从而产生内存泄漏\",{\"1\":{\"210\":1}}],[\"派生类对象的数据成员已经销毁\",{\"1\":{\"209\":1}}],[\"派生类的虚表指针指向的是自身的虚表\",{\"1\":{\"207\":1}}],[\"派生类的虚表指针指向的是基类的虚表\",{\"1\":{\"207\":1}}],[\"故而c++不会进行动态联编\",{\"1\":{\"209\":1}}],[\"测试结果显示\",{\"1\":{\"208\":1}}],[\"静态成员变量也是全局共享\",{\"1\":{\"208\":1}}],[\"令它指向子类的虚表\",{\"1\":{\"207\":1}}],[\"令它指向父类的虚表\",{\"1\":{\"207\":1}}],[\"父进程使用\",{\"1\":{\"305\":1}}],[\"父进程调用\",{\"1\":{\"304\":1}}],[\"父进程等待子进程结束\",{\"1\":{\"304\":1}}],[\"父进程等待第一个子进程退出\",{\"1\":{\"220\":1}}],[\"父进程\",{\"1\":{\"226\":1,\"227\":1,\"228\":1,\"229\":1}}],[\"父进程只需等待子进程的退出状态\",{\"1\":{\"220\":1}}],[\"父进程通过\",{\"1\":{\"220\":1}}],[\"父进程退出\",{\"1\":{\"220\":1,\"222\":1,\"223\":1}}],[\"父进程继续执行其任务\",{\"1\":{\"220\":1}}],[\"父进程可以在信号处理程序中调用\",{\"1\":{\"220\":1}}],[\"父进程会收到\",{\"1\":{\"220\":1}}],[\"父进程代码\",{\"1\":{\"220\":2,\"303\":1}}],[\"父进程在适当的时机调用\",{\"1\":{\"220\":1}}],[\"父类\",{\"1\":{\"207\":1}}],[\"父节点\",{\"1\":{\"79\":1}}],[\"虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数\",{\"1\":{\"210\":1}}],[\"虚函数主要用于在信息不全的情况下\",{\"1\":{\"210\":1}}],[\"虚函数相应一个指向vtable虚函数表的指针\",{\"1\":{\"210\":1}}],[\"虚函数表vtable在linux\",{\"1\":{\"208\":1}}],[\"虚函数表类似于类中静态成员变量\",{\"1\":{\"208\":1}}],[\"虚函数表类似一个数组\",{\"1\":{\"208\":1}}],[\"虚函数表存储虚函数的地址\",{\"1\":{\"208\":1}}],[\"虚函数表是全局共享的元素\",{\"1\":{\"208\":1}}],[\"虚函数表的缩写\",{\"1\":{\"207\":1}}],[\"虚表里保存了虚函数的入口地址\",{\"1\":{\"207\":1}}],[\"虚表指针vptr的初始化时间\",{\"0\":{\"208\":1}}],[\"虚表指针\",{\"1\":{\"207\":1}}],[\"虚表\",{\"1\":{\"207\":1}}],[\"例子中\",{\"1\":{\"207\":1}}],[\"例如子模块当前指向的\",{\"1\":{\"333\":1}}],[\"例如一个大型项目包含多个子模块\",{\"1\":{\"330\":1}}],[\"例如被\",{\"1\":{\"300\":1}}],[\"例如限制同时访问文件的线程数\",{\"1\":{\"242\":1}}],[\"例如排序\",{\"1\":{\"191\":1}}],[\"例如事件系统\",{\"1\":{\"133\":1}}],[\"例如高度\",{\"1\":{\"113\":1}}],[\"例如在每个计算步骤完成后同步所有线程\",{\"1\":{\"244\":1}}],[\"例如在中断上下文或需要避免线程调度开销的情况下使用\",{\"1\":{\"243\":1}}],[\"例如在生产者\",{\"1\":{\"240\":1}}],[\"例如在二叉搜索树中\",{\"1\":{\"113\":1}}],[\"例如在链式地址中\",{\"1\":{\"75\":1}}],[\"例如在\",{\"1\":{\"61\":1,\"168\":1}}],[\"例如打印机的任务队列\",{\"1\":{\"45\":1}}],[\"例如初始化任务完成后启动主任务\",{\"1\":{\"245\":1}}],[\"例如初始化二维列表\",{\"1\":{\"36\":1}}],[\"例如初始容量\",{\"1\":{\"34\":1}}],[\"例如\",{\"1\":{\"17\":1,\"28\":1,\"34\":1,\"36\":3,\"51\":2,\"61\":1,\"70\":1,\"72\":2,\"74\":1,\"113\":1,\"176\":1,\"220\":1,\"354\":1,\"373\":1}}],[\"运行结束生成\",{\"1\":{\"369\":1}}],[\"运行结果\",{\"1\":{\"207\":1}}],[\"运行时解密的方法\",{\"1\":{\"284\":1}}],[\"运行时将会根据所指对象的实际类型来调用相应的函数\",{\"1\":{\"207\":1}}],[\"运行权限\",{\"1\":{\"224\":1}}],[\"运行\",{\"0\":{\"351\":1},\"1\":{\"215\":1,\"216\":4,\"315\":1}}],[\"运行上述代码后\",{\"1\":{\"167\":1}}],[\"被暂停\",{\"1\":{\"372\":1}}],[\"被动关闭方在发送ack包后进入last\",{\"1\":{\"294\":1}}],[\"被动关闭方在发送ack并等待对方确认后进入这个状态\",{\"1\":{\"292\":1}}],[\"被动关闭方接收到fin包后进入close\",{\"1\":{\"294\":1}}],[\"被动关闭方接收到fin包后\",{\"1\":{\"292\":1}}],[\"被唤醒的线程重新获得互斥量\",{\"1\":{\"240\":1}}],[\"被释放给其他就绪进程\",{\"1\":{\"216\":1}}],[\"被mutable\",{\"1\":{\"205\":1}}],[\"被分配到同一个桶中的概率就越低\",{\"1\":{\"61\":1}}],[\"问题出来了\",{\"1\":{\"210\":1}}],[\"问题\",{\"1\":{\"204\":1}}],[\"技术\",{\"1\":{\"204\":1,\"220\":2}}],[\"宏来加密和解密字符串\",{\"1\":{\"288\":1}}],[\"宏\",{\"1\":{\"288\":1}}],[\"宏定义用于简化加密字符串的使用\",{\"1\":{\"287\":1}}],[\"宏没有类型安全检查\",{\"1\":{\"203\":1}}],[\"宏用于定义常量和简单的代码片段\",{\"1\":{\"203\":1}}],[\"宏与constexpr\",{\"0\":{\"203\":1}}],[\"区别\",{\"0\":{\"203\":1}}],[\"地址值+sizeof\",{\"1\":{\"202\":2}}],[\"三者之间的关系\",{\"1\":{\"263\":1}}],[\"三者做运算时有差异\",{\"1\":{\"202\":1}}],[\"三种情况\",{\"1\":{\"93\":1}}],[\"析构函数为什么要虚函数\",{\"0\":{\"210\":1}}],[\"析构函数是用来销毁一个对象的\",{\"1\":{\"209\":1}}],[\"析构函数\",{\"1\":{\"201\":2}}],[\"析构方法\",{\"1\":{\"63\":1,\"65\":1}}],[\"释放操作\",{\"1\":{\"242\":1}}],[\"释放对象的操作符\",{\"1\":{\"201\":1}}],[\"释放内存的基础上还会额外调用构造\",{\"1\":{\"201\":1}}],[\"释放内存并置为\",{\"1\":{\"60\":1}}],[\"释放内存\",{\"1\":{\"15\":1,\"22\":1,\"43\":2,\"49\":2,\"60\":1,\"63\":3,\"93\":1}}],[\"延长变量的生命周期为整个程序的生命周期\",{\"1\":{\"200\":1}}],[\"限制作用范围\",{\"1\":{\"200\":1}}],[\"修饰除外\",{\"1\":{\"205\":1}}],[\"修饰成员函数表示函数体不会修改类成员\",{\"1\":{\"205\":1}}],[\"修饰局部变量\",{\"1\":{\"200\":1}}],[\"修饰全局变量或函数\",{\"1\":{\"200\":1}}],[\"修改最后一次提交的信息或内容\",{\"1\":{\"314\":1}}],[\"修改commit信息\",{\"1\":{\"314\":1}}],[\"修改管理\",{\"0\":{\"312\":1}}],[\"修改\",{\"1\":{\"28\":1}}],[\"基本使用\",{\"0\":{\"341\":1}}],[\"基本概念\",{\"0\":{\"248\":1}}],[\"基本结构\",{\"1\":{\"238\":1,\"239\":1,\"240\":1}}],[\"基类的虚函数表存放在内存的什么区\",{\"0\":{\"208\":1}}],[\"基础\",{\"0\":{\"199\":1}}],[\"基于对称性\",{\"1\":{\"103\":1}}],[\"基于链式地址实现的哈希表的操作方法发生了以下变化\",{\"1\":{\"63\":1}}],[\"基于链表实现的栈可以提供更加稳定的效率表现\",{\"1\":{\"51\":1}}],[\"基于链表实现的栈\",{\"1\":{\"49\":1}}],[\"基于链表实现的队列\",{\"1\":{\"43\":1}}],[\"基于链表实现栈的入栈出栈操作\",{\"1\":{\"49\":1}}],[\"基于链表实现队列的入队出队操作\",{\"1\":{\"43\":1}}],[\"基于链表的实现\",{\"0\":{\"43\":1,\"49\":1}}],[\"基于数组实现的哈希表\",{\"1\":{\"60\":1}}],[\"基于数组实现的栈可能造成一定的空间浪费\",{\"1\":{\"51\":1}}],[\"基于数组实现的栈在触发扩容时效率会降低\",{\"1\":{\"51\":1}}],[\"基于数组实现的栈\",{\"1\":{\"50\":1}}],[\"基于数组实现栈的入栈出栈操作\",{\"1\":{\"50\":1}}],[\"基于数组的实现\",{\"0\":{\"44\":1,\"50\":1}}],[\"基于环形数组实现的队列\",{\"1\":{\"44\":1}}],[\"基于此设计\",{\"1\":{\"44\":1}}],[\"过滤等操作更加方便\",{\"1\":{\"194\":1}}],[\"过滤或其他转换操作\",{\"1\":{\"194\":1}}],[\"允许你在一个\",{\"1\":{\"330\":1}}],[\"允许父进程灵活地等待和处理子进程的状态变化\",{\"1\":{\"306\":1}}],[\"允许我们在编译时计算表达式的值\",{\"1\":{\"285\":1}}],[\"允许多个智能指针指向同一个对象\",{\"1\":{\"267\":1}}],[\"允许多个进程直接访问同一块内存区域\",{\"1\":{\"228\":1}}],[\"允许不同的进程之间交换数据和信号\",{\"1\":{\"225\":1}}],[\"允许开发者定制数据的显示和编辑\",{\"1\":{\"194\":1}}],[\"允许添加新功能而无需修改现有代码\",{\"1\":{\"126\":1}}],[\"列出所有分支\",{\"1\":{\"323\":1}}],[\"列出分支\",{\"1\":{\"323\":1}}],[\"列出\",{\"1\":{\"323\":1}}],[\"列出当前分支的所有提交\",{\"1\":{\"316\":1}}],[\"列进行升序排序\",{\"1\":{\"194\":1}}],[\"列\",{\"1\":{\"193\":1}}],[\"列表中存储的不是数字本身\",{\"1\":{\"36\":1}}],[\"列表都会设定一个初始长度\",{\"1\":{\"36\":1}}],[\"列表的出现极大地提高了数组的实用性\",{\"1\":{\"36\":1}}],[\"列表的出现大幅提高了数组的实用性\",{\"1\":{\"35\":1}}],[\"列表是一种支持增删查改的元素有序集合\",{\"1\":{\"35\":1}}],[\"列表实现\",{\"0\":{\"34\":1}}],[\"列表可以根据索引遍历\",{\"1\":{\"33\":1}}],[\"列表可以自由地添加与删除元素\",{\"1\":{\"32\":1}}],[\"列表可以基于链表或数组实现\",{\"1\":{\"28\":1}}],[\"列表本质上是数组\",{\"1\":{\"31\":1}}],[\"列表常用操作\",{\"0\":{\"29\":1}}],[\"列表\",{\"0\":{\"28\":1},\"1\":{\"11\":1,\"28\":2}}],[\"行\",{\"1\":{\"193\":1}}],[\"行为型模式\",{\"1\":{\"125\":1}}],[\"经常需要创建自定义模型\",{\"1\":{\"193\":1}}],[\"经过两次删除节点操作\",{\"1\":{\"97\":1}}],[\"经过的节点的数量\",{\"1\":{\"80\":1}}],[\"经过的边的数量\",{\"1\":{\"80\":1,\"113\":1}}],[\"经过哈希函数得到桶索引\",{\"1\":{\"63\":1}}],[\"筛选等操作\",{\"1\":{\"191\":1}}],[\"渲染数据\",{\"1\":{\"189\":2}}],[\"渲染变得更加高效\",{\"1\":{\"182\":1}}],[\"编译后的镜像\",{\"1\":{\"369\":1}}],[\"编译后的执行文件包含有\",{\"1\":{\"287\":1}}],[\"编译后的执行文件中不存在\",{\"1\":{\"287\":1}}],[\"编译\",{\"0\":{\"369\":1}}],[\"编译时加密与运行时解密的工作原理\",{\"0\":{\"286\":1}}],[\"编译时加密可以一定程度上避免这个问题\",{\"1\":{\"284\":1}}],[\"编译器只\",{\"1\":{\"207\":1}}],[\"编译器会在每个对象的前四个字节中保存一个虚表指针\",{\"1\":{\"207\":1}}],[\"编译器会自动生成虚表\",{\"1\":{\"207\":1}}],[\"编译器在发现基类中有虚函数时\",{\"1\":{\"207\":1}}],[\"编辑\",{\"1\":{\"190\":1}}],[\"编辑数据\",{\"1\":{\"189\":1}}],[\"编辑等\",{\"1\":{\"188\":1}}],[\"编程语言通常会为数据类型提供内置哈希算法\",{\"1\":{\"74\":1}}],[\"编程语言通常会为这些数据类型提供内置的哈希算法\",{\"1\":{\"73\":1}}],[\"编程语言通常会预留足够大的哈希表容量\",{\"1\":{\"61\":1}}],[\"编程语言的选择\",{\"0\":{\"68\":1}}],[\"编程同学\",{\"1\":{\"0\":1}}],[\"显示当前仓库中所有子模块的状态\",{\"1\":{\"333\":1}}],[\"显示已暂存但未提交的更改\",{\"1\":{\"317\":1}}],[\"显示未暂存的更改\",{\"1\":{\"317\":1}}],[\"显示仓库的提交历史记录\",{\"1\":{\"316\":1}}],[\"显示工作目录和暂存区的状态\",{\"1\":{\"315\":1}}],[\"显示\",{\"1\":{\"188\":1}}],[\"显示数据\",{\"1\":{\"188\":1}}],[\"显著提升程序的执行效率\",{\"1\":{\"35\":1}}],[\"适合处理复杂的跨平台项目\",{\"1\":{\"357\":1}}],[\"适合管理并发运行的子进程\",{\"1\":{\"305\":1}}],[\"适合做数据的装饰或修改\",{\"1\":{\"194\":1}}],[\"适合树状结构数据\",{\"1\":{\"187\":1}}],[\"适用场景\",{\"1\":{\"177\":1}}],[\"适用于快速构建\",{\"1\":{\"357\":1}}],[\"适用于大多数\",{\"1\":{\"357\":1}}],[\"适用于更新指针操作\",{\"1\":{\"252\":1}}],[\"适用于检查队列是否满或空\",{\"1\":{\"252\":1}}],[\"适用于\",{\"1\":{\"252\":1,\"357\":1}}],[\"适用于分布式系统中的进程间通信\",{\"1\":{\"231\":1}}],[\"适用于需要创建多个产品族的场景\",{\"1\":{\"161\":1}}],[\"适用于高频查找\",{\"1\":{\"111\":1}}],[\"打印变量的值\",{\"1\":{\"374\":1}}],[\"打印哈希表\",{\"1\":{\"60\":1,\"63\":1,\"65\":1}}],[\"打包启动的文件系统\",{\"1\":{\"370\":1}}],[\"打包等\",{\"1\":{\"357\":1}}],[\"打交道\",{\"1\":{\"187\":1}}],[\"委托还负责处理数据的编辑\",{\"1\":{\"189\":1}}],[\"委托负责将\",{\"1\":{\"189\":1}}],[\"委托\",{\"0\":{\"189\":1},\"1\":{\"185\":1}}],[\"虽然僵尸进程不会占用内存或\",{\"1\":{\"219\":1}}],[\"虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定\",{\"1\":{\"210\":1}}],[\"虽然\",{\"1\":{\"182\":1,\"193\":1}}],[\"虽然自定义对象\",{\"1\":{\"73\":1}}],[\"标志时\",{\"1\":{\"302\":1}}],[\"标志位等\",{\"1\":{\"241\":1}}],[\"标准输出和标准错误输出文件描述符\",{\"1\":{\"223\":1}}],[\"标签\",{\"1\":{\"181\":1}}],[\"标记为已删除的空间可以再次使用\",{\"1\":{\"75\":1}}],[\"标记为已删除的空间还能再次使用吗\",{\"1\":{\"75\":1}}],[\"展示了tcp协议在建立连接\",{\"1\":{\"291\":1}}],[\"展示了哈希函数的工作原理\",{\"1\":{\"60\":1}}],[\"展示\",{\"1\":{\"181\":1}}],[\"框架通过将数据和显示逻辑解耦\",{\"1\":{\"194\":1}}],[\"框架能够更加灵活地支持各种数据展示场景\",{\"1\":{\"192\":1}}],[\"框架类似于传统的\",{\"1\":{\"192\":1}}],[\"框架的核心概念\",{\"0\":{\"186\":1}}],[\"框架包含三个主要组件\",{\"1\":{\"185\":1}}],[\"框架提供了更高的灵活性和可维护性\",{\"1\":{\"185\":1}}],[\"框架是一种用于处理和显示数据的灵活机制\",{\"1\":{\"185\":1}}],[\"框架\",{\"0\":{\"185\":1},\"1\":{\"181\":1}}],[\"尤其在现代前端开发框架中广泛应用\",{\"1\":{\"182\":1}}],[\"尤其在数据绑定方面更为自动化和灵活\",{\"1\":{\"177\":1}}],[\"尤其是在数据变更频繁的情况下\",{\"1\":{\"180\":1}}],[\"学习成本高\",{\"1\":{\"180\":1}}],[\"学号和\",{\"1\":{\"60\":1}}],[\"学号\",{\"1\":{\"58\":1}}],[\"业务逻辑和数据处理部分可以通过单元测试进行验证\",{\"1\":{\"179\":1}}],[\"专注于业务逻辑\",{\"1\":{\"177\":1}}],[\"逻辑相关的部分\",{\"1\":{\"177\":1}}],[\"逻辑和交互逻辑\",{\"1\":{\"177\":1}}],[\"逻辑更加清晰\",{\"1\":{\"36\":1}}],[\"控制器\",{\"1\":{\"177\":1}}],[\"响应\",{\"1\":{\"175\":1}}],[\"捕捉用户输入\",{\"1\":{\"174\":1}}],[\"表达式和\",{\"1\":{\"288\":1}}],[\"表示启动后就挂起\",{\"1\":{\"372\":1}}],[\"表示子进程\",{\"1\":{\"304\":1}}],[\"表示连接已经建立\",{\"1\":{\"292\":1}}],[\"表示主动打开\",{\"1\":{\"292\":1}}],[\"表示套接字没有被使用或已经关闭\",{\"1\":{\"292\":1}}],[\"表示需要完成的任务数量\",{\"1\":{\"245\":1}}],[\"表示所有线程都已到达屏障点\",{\"1\":{\"244\":1}}],[\"表示已到达屏障的线程数量\",{\"1\":{\"244\":1}}],[\"表示当前可用资源的数量\",{\"1\":{\"242\":1}}],[\"表示将线程和线程对象分离\",{\"1\":{\"236\":1,\"257\":1}}],[\"表示该节点是叶节点\",{\"1\":{\"93\":1}}],[\"表格和树形数据\",{\"1\":{\"188\":1}}],[\"表单提交等\",{\"1\":{\"174\":1}}],[\"交互\",{\"1\":{\"173\":1,\"177\":1}}],[\"交换位置\",{\"1\":{\"65\":1}}],[\"职责\",{\"1\":{\"173\":1,\"174\":1,\"175\":1}}],[\"类是一个泛型队列\",{\"1\":{\"251\":1}}],[\"类定义与构造函数\",{\"1\":{\"251\":1}}],[\"类的\",{\"1\":{\"210\":1}}],[\"类对象中存储vptr指针\",{\"1\":{\"208\":1}}],[\"类中含有virtual关键字修饰的方法时\",{\"1\":{\"207\":1}}],[\"类成员或函数可以直接通过类名访问无需创建对象\",{\"1\":{\"200\":1}}],[\"类\",{\"1\":{\"187\":1,\"188\":1,\"288\":1}}],[\"类或者数据结构\",{\"1\":{\"173\":1}}],[\"类似地\",{\"1\":{\"109\":1}}],[\"类似于\",{\"1\":{\"113\":1}}],[\"类似于数组扩容\",{\"1\":{\"61\":1}}],[\"类似于双向链表\",{\"1\":{\"27\":1}}],[\"模版方法\",{\"0\":{\"361\":1},\"1\":{\"361\":1}}],[\"模板类用于编译时加密和运行时解密\",{\"1\":{\"287\":1}}],[\"模板类\",{\"1\":{\"249\":1,\"288\":1}}],[\"模板中展示数据的部分\",{\"1\":{\"181\":1}}],[\"模拟一些工作\",{\"1\":{\"303\":1}}],[\"模拟进程在运行\",{\"1\":{\"230\":1}}],[\"模拟周期性任务执行\",{\"1\":{\"223\":1}}],[\"模型会在数据发生变化时发出信号\",{\"1\":{\"187\":1}}],[\"模型通过标准化的接口提供数据给\",{\"1\":{\"187\":1}}],[\"模型负责存储和管理数据\",{\"1\":{\"187\":1}}],[\"模型\",{\"0\":{\"173\":1,\"187\":1},\"1\":{\"172\":1,\"185\":1}}],[\"模式中\",{\"1\":{\"191\":1}}],[\"模式的关键在于数据与\",{\"1\":{\"190\":1}}],[\"模式通过数据绑定机制\",{\"1\":{\"182\":1}}],[\"模式由三部分组成\",{\"1\":{\"172\":1}}],[\"模式是由微软架构师\",{\"1\":{\"171\":1}}],[\"模式\",{\"0\":{\"171\":1},\"1\":{\"192\":1}}],[\"现已广泛应用于各种前端框架和工具\",{\"1\":{\"171\":1}}],[\"现在对象还没有产生\",{\"1\":{\"210\":1}}],[\"现在\",{\"1\":{\"71\":1}}],[\"于\",{\"1\":{\"171\":1}}],[\"远程调试的端口和暂停启动\",{\"1\":{\"374\":1}}],[\"远程调试功能\",{\"1\":{\"372\":1}}],[\"远程日志等\",{\"1\":{\"168\":1}}],[\"远远没有达到哈希算法的设计目标\",{\"1\":{\"72\":1}}],[\"文件config\",{\"1\":{\"374\":1}}],[\"文件内容\",{\"1\":{\"370\":1}}],[\"文件在当前目录\",{\"1\":{\"369\":1}}],[\"文件通常包含以下内容\",{\"1\":{\"344\":1}}],[\"文件\",{\"1\":{\"343\":1,\"348\":1,\"373\":1}}],[\"文件或\",{\"1\":{\"341\":1,\"343\":1}}],[\"文件中移除子模块的配置条目\",{\"1\":{\"335\":1}}],[\"文件中移除子模块条目\",{\"1\":{\"335\":1}}],[\"文件描述符等\",{\"1\":{\"218\":1}}],[\"文件日志\",{\"1\":{\"168\":1}}],[\"文件流\",{\"1\":{\"145\":1}}],[\"事件处理链可以使用责任链模式\",{\"1\":{\"168\":1}}],[\"事件处理系统\",{\"1\":{\"168\":1}}],[\"事件模式\",{\"2\":{\"135\":1}}],[\"由子类实现具体的设置逻辑\",{\"1\":{\"361\":1}}],[\"由\",{\"1\":{\"167\":3}}],[\"由于类不知道谁继承它\",{\"1\":{\"210\":1}}],[\"由于子类会调父类的构造函数\",{\"1\":{\"210\":1}}],[\"由于创建一个对象时我们总是要明白指定对象的类型\",{\"1\":{\"210\":1}}],[\"由于虚表指针vptr跟虚函数密不可分\",{\"1\":{\"208\":1}}],[\"由于节点大小满足\",{\"1\":{\"113\":1}}],[\"由于要保持二叉搜索树\",{\"1\":{\"93\":1}}],[\"由于加法和异或满足交换律\",{\"1\":{\"72\":1}}],[\"由于\",{\"1\":{\"71\":1,\"99\":1,\"177\":1,\"179\":1}}],[\"由于平方的增长\",{\"1\":{\"66\":1}}],[\"由于链表节点需要额外存储指针\",{\"1\":{\"51\":1}}],[\"由于入栈的元素可能会源源不断地增加\",{\"1\":{\"50\":1}}],[\"由于数据绑定是自动化的\",{\"1\":{\"180\":1}}],[\"由于数据不是连续存放的\",{\"1\":{\"36\":1}}],[\"由于数组\",{\"1\":{\"58\":1}}],[\"由于数组具有更高的缓存命中率\",{\"1\":{\"35\":1}}],[\"由于数组的长度不可变\",{\"1\":{\"12\":1}}],[\"由于数组的长度是固定的\",{\"1\":{\"11\":1}}],[\"由于每个元素需要两个额外的指针\",{\"1\":{\"36\":1}}],[\"由于它们采用两种相反的存储策略\",{\"1\":{\"25\":1}}],[\"创建构建目录\",{\"0\":{\"350\":1}}],[\"创建新分支\",{\"1\":{\"323\":2}}],[\"创建新的会话\",{\"1\":{\"222\":1,\"223\":1}}],[\"创建或删除分支\",{\"1\":{\"323\":1}}],[\"创建并切换分支\",{\"1\":{\"322\":1}}],[\"创建了一个\",{\"1\":{\"251\":1}}],[\"创建共享内存\",{\"1\":{\"228\":1}}],[\"创建消息队列\",{\"1\":{\"227\":1}}],[\"创建无名管道\",{\"1\":{\"226\":1}}],[\"创建守护进程\",{\"1\":{\"222\":1}}],[\"创建守护进程的示例代码\",{\"1\":{\"221\":1}}],[\"创建守护进程的步骤包括分离进程\",{\"1\":{\"221\":1}}],[\"创建一个最简单的\",{\"1\":{\"348\":1}}],[\"创建一个简单的项目结构\",{\"1\":{\"346\":1}}],[\"创建一个新的会话\",{\"1\":{\"223\":1}}],[\"创建一个孙子进程\",{\"1\":{\"220\":1}}],[\"创建一个子进程\",{\"1\":{\"220\":1,\"223\":1,\"304\":1}}],[\"创建处理者对象\",{\"1\":{\"167\":1}}],[\"创建型模式\",{\"1\":{\"125\":1}}],[\"请求处理链\",{\"1\":{\"168\":1}}],[\"请求\",{\"1\":{\"166\":1}}],[\"请注意\",{\"1\":{\"12\":1,\"22\":1,\"67\":1,\"70\":1,\"73\":1,\"80\":1,\"85\":1,\"86\":1}}],[\"客户端调用connect\",{\"1\":{\"294\":1}}],[\"客户端在发送syn\",{\"1\":{\"292\":1}}],[\"客户端可以使用这些接口创建具体的产品对象\",{\"1\":{\"161\":1}}],[\"客户端通过调用工厂的方法来获取对象\",{\"1\":{\"156\":1}}],[\"wget\",{\"1\":{\"369\":1,\"370\":1}}],[\"wantedby=default\",{\"1\":{\"382\":1}}],[\"waves\",{\"1\":{\"361\":2}}],[\"wavestyle\",{\"1\":{\"361\":5}}],[\"wave\",{\"1\":{\"361\":7}}],[\"wall\",{\"1\":{\"355\":1}}],[\"wait状态\",{\"1\":{\"294\":2}}],[\"waiting\",{\"1\":{\"230\":1,\"244\":1,\"246\":1}}],[\"waitpid\",{\"0\":{\"299\":1},\"1\":{\"218\":2,\"220\":4,\"299\":1,\"300\":1,\"303\":3,\"304\":2,\"305\":3,\"306\":2}}],[\"wait\",{\"1\":{\"218\":2,\"220\":8,\"228\":1,\"229\":1,\"240\":2,\"242\":1,\"244\":1,\"245\":1,\"246\":1,\"262\":2,\"264\":1,\"292\":4,\"294\":4,\"295\":4,\"300\":1,\"303\":1}}],[\"world\",{\"1\":{\"347\":1}}],[\"working\",{\"1\":{\"242\":1,\"243\":1}}],[\"worker\",{\"1\":{\"242\":2,\"243\":2,\"244\":2,\"245\":2}}],[\"wstopsig\",{\"1\":{\"302\":1,\"303\":1}}],[\"wtermsig\",{\"1\":{\"302\":1,\"303\":1,\"304\":1}}],[\"will\",{\"1\":{\"382\":2}}],[\"width\",{\"1\":{\"361\":1}}],[\"with\",{\"1\":{\"303\":1,\"382\":2}}],[\"wifcontinued\",{\"1\":{\"302\":1,\"303\":1}}],[\"wifstopped\",{\"1\":{\"302\":1,\"303\":1}}],[\"wifsignaled\",{\"1\":{\"302\":1,\"303\":1,\"304\":1}}],[\"wifexited\",{\"1\":{\"302\":1,\"303\":1,\"304\":1}}],[\"wintextbox\",{\"1\":{\"161\":2}}],[\"winbutton\",{\"1\":{\"161\":2}}],[\"windowsfactory\",{\"1\":{\"161\":1}}],[\"windowstextbox\",{\"1\":{\"161\":1}}],[\"windows\",{\"1\":{\"161\":2,\"171\":1,\"342\":1,\"357\":1}}],[\"windowsbutton\",{\"1\":{\"161\":1}}],[\"wcontinued\",{\"1\":{\"300\":1,\"302\":1}}],[\"wuntraced\",{\"1\":{\"300\":1}}],[\"wextra\",{\"1\":{\"355\":1}}],[\"wexitstatus\",{\"1\":{\"302\":1,\"303\":1,\"304\":1}}],[\"weak\",{\"1\":{\"266\":1,\"269\":2}}],[\"webui\",{\"1\":{\"382\":6}}],[\"webtask\",{\"1\":{\"364\":1}}],[\"web\",{\"1\":{\"168\":1}}],[\"writer\",{\"1\":{\"239\":3}}],[\"write\",{\"1\":{\"226\":1,\"239\":1}}],[\"wnohang\",{\"1\":{\"220\":1,\"300\":1,\"301\":1,\"305\":1}}],[\"wpf\",{\"1\":{\"171\":1}}],[\"while\",{\"1\":{\"24\":1,\"65\":1,\"91\":1,\"92\":1,\"93\":2,\"109\":1,\"220\":1,\"222\":1,\"230\":1,\"243\":1,\"250\":2,\"251\":4,\"262\":1}}],[\"产品接口\",{\"1\":{\"157\":1}}],[\"旨在为客户端提供对象的创建方式\",{\"1\":{\"155\":1}}],[\"种组合\",{\"1\":{\"151\":1}}],[\"形状m\",{\"1\":{\"151\":1}}],[\"形成恶性循环\",{\"1\":{\"65\":1}}],[\"颜色n\",{\"1\":{\"151\":1}}],[\"抽象方法\",{\"1\":{\"361\":1}}],[\"抽象处理者类\",{\"1\":{\"167\":1}}],[\"抽象工厂\",{\"1\":{\"160\":1}}],[\"抽象工厂模式通常用于创建不同产品族的对象\",{\"1\":{\"159\":1}}],[\"抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口\",{\"1\":{\"159\":1}}],[\"抽象工厂模式\",{\"0\":{\"159\":1},\"1\":{\"161\":1},\"2\":{\"163\":1}}],[\"抽象产品\",{\"1\":{\"160\":1}}],[\"抽象类\",{\"1\":{\"150\":1}}],[\"抽象不应依赖于细节\",{\"1\":{\"126\":1}}],[\"缓冲文件流\",{\"1\":{\"145\":1}}],[\"缓存不友好\",{\"1\":{\"36\":1}}],[\"缓存通过缓存行\",{\"1\":{\"35\":1}}],[\"缓存局部性\",{\"1\":{\"16\":1}}],[\"解压\",{\"1\":{\"369\":1}}],[\"解密函数在运行时对字符串进行解密\",{\"1\":{\"287\":1}}],[\"解锁\",{\"1\":{\"238\":1,\"239\":1,\"243\":1}}],[\"解耦性好\",{\"1\":{\"179\":1}}],[\"解耦程度\",{\"1\":{\"177\":1}}],[\"解耦抽象与实现\",{\"1\":{\"151\":1}}],[\"解决的问题\",{\"1\":{\"145\":1}}],[\"解释器在每次启动时\",{\"1\":{\"73\":1}}],[\"动态扩展对象的功能\",{\"1\":{\"145\":1}}],[\"动态地添加新的功能\",{\"1\":{\"143\":1}}],[\"动态数组\",{\"1\":{\"28\":2,\"63\":1,\"73\":1}}],[\"避免给逆向提供敏感信息点\",{\"1\":{\"288\":1}}],[\"避免一直阻塞等锁\",{\"1\":{\"264\":1}}],[\"避免没有调用join或者detach可导致程序出错的情况出现\",{\"1\":{\"257\":1}}],[\"避免使用锁机制带来的开销\",{\"1\":{\"241\":1}}],[\"避免僵尸进程的产生\",{\"1\":{\"220\":1}}],[\"避免产生僵尸进程的关键在于确保父进程能够及时处理子进程的退出状态\",{\"1\":{\"220\":1}}],[\"避免了使用继承\",{\"1\":{\"145\":1}}],[\"避免将多个算法逻辑硬编码到一个类中\",{\"1\":{\"139\":1}}],[\"避免运行时错误\",{\"1\":{\"126\":1}}],[\"持有一个策略对象\",{\"1\":{\"138\":1}}],[\"持有观察者对象的引用\",{\"1\":{\"132\":1}}],[\"策略接口\",{\"1\":{\"138\":1,\"139\":1}}],[\"策略模式适用于需要动态选择或更换算法的场景\",{\"1\":{\"139\":1}}],[\"策略模式可以使得算法独立于使用它的客户端而变化\",{\"1\":{\"139\":1}}],[\"策略模式使得算法的变化不会影响到使用算法的客户类\",{\"1\":{\"137\":1}}],[\"策略模式\",{\"0\":{\"136\":1},\"1\":{\"3\":1,\"125\":1,\"137\":1,\"361\":2},\"2\":{\"141\":1}}],[\"示例代码\",{\"0\":{\"303\":1},\"1\":{\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1}}],[\"示例代码如下\",{\"1\":{\"59\":2,\"91\":1,\"93\":1}}],[\"示例\",{\"0\":{\"133\":1,\"139\":1,\"145\":1,\"151\":1,\"158\":1,\"161\":1,\"167\":1,\"347\":1,\"348\":1},\"1\":{\"181\":1,\"187\":1,\"188\":1,\"189\":1,\"193\":1,\"194\":1,\"222\":1,\"331\":1}}],[\"负责展示数据\",{\"1\":{\"188\":1,\"192\":1}}],[\"负责存储和管理数据\",{\"1\":{\"187\":1}}],[\"负责与\",{\"1\":{\"181\":1}}],[\"负责响应用户交互并更新模型\",{\"1\":{\"177\":1}}],[\"负责处理数据的呈现和编辑\",{\"1\":{\"192\":1}}],[\"负责处理逻辑\",{\"1\":{\"177\":1}}],[\"负责处理界面显示逻辑\",{\"1\":{\"175\":1}}],[\"负责处理具体的请求\",{\"1\":{\"166\":1}}],[\"负责界面的展示\",{\"1\":{\"174\":1}}],[\"负责呈现数据和处理用户的输入\",{\"1\":{\"174\":1}}],[\"负责将\",{\"1\":{\"174\":1}}],[\"负责具体产品的实例化\",{\"1\":{\"157\":1}}],[\"负责在接收到主题的通知后进行相应的更新操作\",{\"1\":{\"132\":1}}],[\"负载因子定义为哈希表中元素数量除以桶数量\",{\"1\":{\"74\":1}}],[\"负载因子\",{\"1\":{\"61\":1,\"63\":1,\"65\":1}}],[\"主动关闭方在发送最后的ack包后进入time\",{\"1\":{\"294\":1}}],[\"主动关闭方在发送最后的ack后\",{\"1\":{\"292\":1}}],[\"主动关闭方发送fin包后进入fin\",{\"1\":{\"294\":1}}],[\"主动关闭方接收到ack后\",{\"1\":{\"292\":1}}],[\"主函数中的生产者和消费者\",{\"1\":{\"251\":1}}],[\"主循环\",{\"1\":{\"223\":1}}],[\"主题\",{\"1\":{\"132\":1}}],[\"主要看方法的使用范围\",{\"1\":{\"113\":1}}],[\"主要有std\",{\"1\":{\"263\":1}}],[\"主要有两个原因\",{\"1\":{\"36\":1}}],[\"主要有以下几部分\",{\"1\":{\"0\":1}}],[\"主要包含一些基本的\",{\"1\":{\"0\":1}}],[\"订阅者发布者模型等\",{\"1\":{\"131\":1}}],[\"订单将加入队列中\",{\"1\":{\"45\":1}}],[\"让临时右值的生命周期延长了\",{\"1\":{\"270\":1}}],[\"让c++\",{\"1\":{\"204\":1}}],[\"让多个观察者对象同时监听某一个主题对象\",{\"1\":{\"131\":1}}],[\"让输出值落在数组索引范围内\",{\"1\":{\"75\":1}}],[\"概述\",{\"0\":{\"131\":1,\"137\":1,\"143\":1,\"149\":1,\"155\":1,\"165\":1}}],[\"找出系统中可预计的变化\",{\"1\":{\"127\":1}}],[\"找到待删除节点\",{\"1\":{\"93\":1}}],[\"找到待删除节点在\",{\"1\":{\"93\":1}}],[\"找到重复节点\",{\"1\":{\"92\":1}}],[\"找到目标节点\",{\"1\":{\"91\":1}}],[\"稳定\",{\"1\":{\"127\":1}}],[\"隔离变化\",{\"1\":{\"127\":1}}],[\"调试内核\",{\"0\":{\"373\":1}}],[\"调试信息输出到终端与参数\",{\"1\":{\"372\":1}}],[\"调试时会用到它\",{\"1\":{\"369\":1}}],[\"调试\",{\"1\":{\"367\":1}}],[\"调试难度增加\",{\"1\":{\"180\":1}}],[\"调度器选择一个就绪的进程并将其分配给\",{\"1\":{\"216\":1}}],[\"调度算法\",{\"1\":{\"27\":1}}],[\"调用析构函数时\",{\"1\":{\"267\":1}}],[\"调用get或者wait时才会执行\",{\"1\":{\"264\":1}}],[\"调用join函数将会阻塞主线程\",{\"1\":{\"257\":1}}],[\"调用\",{\"1\":{\"223\":2,\"236\":1}}],[\"调用实现部分的功能\",{\"1\":{\"150\":1}}],[\"调用模块只依赖抽象接口\",{\"1\":{\"127\":1}}],[\"降低耦合性\",{\"1\":{\"127\":1}}],[\"细节应该依赖于抽象\",{\"1\":{\"126\":1}}],[\"细心的你可能发现在不同控制台中运行程序时\",{\"1\":{\"73\":1}}],[\"依次处理日志信息\",{\"1\":{\"168\":1}}],[\"依次访问所有节点\",{\"1\":{\"20\":1}}],[\"依赖倒置原则\",{\"1\":{\"126\":1}}],[\"保留工作区文件\",{\"1\":{\"320\":1}}],[\"保持这个状态2倍的最大报文段寿命时间\",{\"1\":{\"292\":1}}],[\"保持与c\",{\"1\":{\"204\":1}}],[\"保证在并发环境下操作的不可分割性\",{\"1\":{\"241\":1}}],[\"保证线程函数的生命周期和线程对象的生命周期相同\",{\"1\":{\"236\":1,\"257\":1}}],[\"保证继承层次的正确性\",{\"1\":{\"126\":1}}],[\"保存当前工作目录的更改\",{\"1\":{\"319\":1}}],[\"保存和更新等\",{\"1\":{\"173\":1}}],[\"保存上一轮循环的节点\",{\"1\":{\"92\":1}}],[\"里氏替换原则\",{\"1\":{\"126\":1}}],[\"里面的\",{\"1\":{\"36\":1}}],[\"软件实体应对扩展开放\",{\"1\":{\"126\":1}}],[\"软件中的撤销与反撤销\",{\"1\":{\"52\":1}}],[\"目录下\",{\"1\":{\"370\":1}}],[\"目录\",{\"1\":{\"311\":1,\"331\":1}}],[\"目的是避免传统锁机制\",{\"1\":{\"247\":1}}],[\"目的是防止守护进程重新获取控制终端\",{\"1\":{\"223\":1}}],[\"目的\",{\"1\":{\"126\":5}}],[\"目标节点在\",{\"1\":{\"91\":2}}],[\"组合使用\",{\"1\":{\"372\":1}}],[\"组合爆炸\",{\"1\":{\"145\":1}}],[\"组合模式\",{\"1\":{\"125\":1}}],[\"组件接口\",{\"1\":{\"144\":1}}],[\"组织和存储大型数据\",{\"1\":{\"111\":1}}],[\"关键字符串信息\",{\"1\":{\"287\":2}}],[\"关键字的作用\",{\"0\":{\"200\":1,\"205\":1}}],[\"关闭连接过程中可能的状态及其转换\",{\"1\":{\"291\":1}}],[\"关闭写端\",{\"1\":{\"226\":2}}],[\"关闭读端\",{\"1\":{\"226\":2}}],[\"关闭标准输入\",{\"1\":{\"223\":1}}],[\"关闭标准文件描述符\",{\"1\":{\"221\":1,\"222\":1,\"223\":1}}],[\"关于async启动策略这里网上和各种书籍介绍的五花八门\",{\"1\":{\"264\":1}}],[\"关于线程操作应该优先使用async\",{\"1\":{\"264\":1}}],[\"关于条件变量其实还涉及到通知丢失和虚假唤醒问题\",{\"1\":{\"262\":1}}],[\"关于架构设计的一点思考\",{\"0\":{\"127\":1}}],[\"关于c++\",{\"1\":{\"122\":1}}],[\"关注对象间通信\",{\"1\":{\"125\":1}}],[\"关注对象组合\",{\"1\":{\"125\":1}}],[\"关注对象创建\",{\"1\":{\"125\":1}}],[\"深入理解计算机系统\",{\"1\":{\"122\":1}}],[\"深度\",{\"1\":{\"80\":1}}],[\"国内有大佬把它翻译成了中文书籍\",{\"1\":{\"122\":1}}],[\"英文不错的朋友可以直接看原文\",{\"1\":{\"122\":1}}],[\"想提升c++达到进阶水平的朋友学习\",{\"1\":{\"122\":1}}],[\"唯一的缺点\",{\"1\":{\"121\":1}}],[\"唯一的区别在于\",{\"1\":{\"108\":1}}],[\"本地初始化一个新的\",{\"1\":{\"311\":1}}],[\"本文展示了该技术的一个具体实现示例\",{\"1\":{\"288\":1}}],[\"本文将介绍这一技术\",{\"1\":{\"284\":1}}],[\"本身并不操作或者管理资源\",{\"1\":{\"266\":1}}],[\"本书介绍的多是c++11的新特性\",{\"1\":{\"122\":1}}],[\"本书都有涉及\",{\"1\":{\"121\":1}}],[\"本站是一个面向\",{\"1\":{\"0\":1}}],[\"缺点\",{\"0\":{\"180\":1}}],[\"缺点也很明显\",{\"1\":{\"121\":1}}],[\"缺点是不能删除元素\",{\"1\":{\"74\":1}}],[\"到\",{\"1\":{\"176\":2,\"294\":1}}],[\"到实战\",{\"1\":{\"120\":1}}],[\"到进阶\",{\"1\":{\"120\":1}}],[\"推荐深入学习并灵活运用\",{\"1\":{\"357\":1}}],[\"推荐使用\",{\"1\":{\"350\":1}}],[\"推荐阅读\",{\"1\":{\"122\":1}}],[\"推荐学习这本书\",{\"1\":{\"122\":1}}],[\"推荐几本c++书籍\",{\"1\":{\"120\":1}}],[\"推出时间\",{\"1\":{\"72\":1}}],[\"书籍\",{\"2\":{\"119\":1}}],[\"书籍推荐\",{\"0\":{\"118\":1,\"120\":1}}],[\"至于根节点的选择\",{\"1\":{\"113\":1}}],[\"函数进入listen状态\",{\"1\":{\"294\":1}}],[\"函数在运行时对字符串进行解密\",{\"1\":{\"288\":1}}],[\"函数对输入字符串进行加密\",{\"1\":{\"288\":1}}],[\"函数来实现字符的加密和解密\",{\"1\":{\"286\":1}}],[\"函数来计算各种数据类型的哈希值\",{\"1\":{\"73\":1}}],[\"函数内部创建的对象返回后构造一个临时对象产生的\",{\"1\":{\"270\":1}}],[\"函数func和func1运行在线程对象t和tt中\",{\"1\":{\"257\":1}}],[\"函数中\",{\"1\":{\"251\":1}}],[\"函数将会阻塞主线程\",{\"1\":{\"236\":1}}],[\"函数\",{\"1\":{\"220\":1,\"236\":3,\"288\":2,\"354\":1,\"356\":1,\"373\":1}}],[\"函数回收子进程的退出状态信息\",{\"1\":{\"218\":1}}],[\"函数时会失败\",{\"1\":{\"204\":1}}],[\"函数名被修饰成\",{\"1\":{\"204\":1}}],[\"函数return\",{\"1\":{\"200\":1}}],[\"函数分别放在\",{\"1\":{\"113\":1}}],[\"函数和\",{\"1\":{\"113\":1}}],[\"函数被划分到\",{\"1\":{\"113\":1}}],[\"原因在于右值引用绑定了右值\",{\"1\":{\"270\":1}}],[\"原子地加载当前的头部指针\",{\"1\":{\"251\":1}}],[\"原子地加载当前的尾部指针\",{\"1\":{\"251\":1}}],[\"原子比较并交换\",{\"1\":{\"249\":1}}],[\"原子交换\",{\"1\":{\"249\":1}}],[\"原子递增和递减\",{\"1\":{\"249\":1}}],[\"原子加载和存储\",{\"1\":{\"249\":1}}],[\"原子操作是不可分割的\",{\"1\":{\"248\":1}}],[\"原子操作适用于需要高效并发访问的场景\",{\"1\":{\"241\":1}}],[\"原子操作\",{\"1\":{\"241\":1,\"248\":1}}],[\"原子操作直接操作共享变量\",{\"1\":{\"241\":1}}],[\"原子操作依赖于硬件提供的原子指令\",{\"1\":{\"241\":1}}],[\"原子操作通过硬件支持的指令集实现\",{\"1\":{\"241\":1}}],[\"原来的连接不需要维护吗\",{\"1\":{\"113\":1}}],[\"原先落在同一个桶的多个\",{\"1\":{\"75\":1}}],[\"原先末尾的元素变得\",{\"1\":{\"12\":1}}],[\"就不需要使用std\",{\"1\":{\"260\":1}}],[\"就不能正确识别对象类型从而不能正确调用析构函数\",{\"1\":{\"210\":1}}],[\"就会进入就绪状态\",{\"1\":{\"216\":1}}],[\"就绪\",{\"1\":{\"215\":1,\"216\":4}}],[\"就须要通过\",{\"1\":{\"210\":1}}],[\"就可以根据派生类对虚函数重写情况动态的进行调用\",{\"1\":{\"207\":1}}],[\"就可以获得有序的节点序列\",{\"1\":{\"113\":1}}],[\"就调用基类的函数\",{\"1\":{\"207\":1}}],[\"就调用派生类的函数\",{\"1\":{\"207\":1}}],[\"就是有点厚\",{\"1\":{\"121\":1}}],[\"就是是书太厚了\",{\"1\":{\"121\":1}}],[\"就得到了栈这种数据结构\",{\"1\":{\"46\":1}}],[\"吗\",{\"1\":{\"113\":2}}],[\"前些年这本书可以说是c++入门必备\",{\"1\":{\"121\":1}}],[\"前序\",{\"1\":{\"112\":1,\"113\":1}}],[\"前两节介绍了哈希表的工作原理和哈希冲突的处理方法\",{\"1\":{\"69\":1}}],[\"层\",{\"1\":{\"112\":1}}],[\"层的节点数量\",{\"1\":{\"88\":1}}],[\"体现\",{\"1\":{\"112\":1}}],[\"体现了\",{\"1\":{\"79\":1}}],[\"重置当前分支的提交历史或工作目录状态\",{\"1\":{\"320\":1}}],[\"重定向标准文件描述符\",{\"1\":{\"223\":1}}],[\"重复节点不插入\",{\"1\":{\"108\":1}}],[\"重点回顾\",{\"0\":{\"35\":1,\"53\":1,\"74\":1,\"112\":1}}],[\"辅助方法\",{\"1\":{\"108\":1,\"109\":1}}],[\"递归互斥量\",{\"1\":{\"258\":1}}],[\"递归插入节点\",{\"1\":{\"108\":1}}],[\"递归删除节点\",{\"1\":{\"93\":1,\"109\":1}}],[\"≤0\",{\"1\":{\"106\":1}}],[\"≥0\",{\"1\":{\"106\":1}}],[\"替换为\",{\"1\":{\"103\":2}}],[\"替换为质数\",{\"1\":{\"71\":1}}],[\"镜像\",{\"1\":{\"103\":1}}],[\"旋转的选择\",{\"0\":{\"106\":1}}],[\"旋转操作分为四种\",{\"1\":{\"101\":1}}],[\"旋转操作既能保持\",{\"1\":{\"101\":1}}],[\"旋转\",{\"1\":{\"101\":1}}],[\"旋转哈希\",{\"1\":{\"71\":2}}],[\"方便异步调用\",{\"1\":{\"263\":1}}],[\"方便后续使用\",{\"1\":{\"100\":1}}],[\"方式\",{\"1\":{\"232\":1}}],[\"方法用于从队列中取出一个元素\",{\"1\":{\"251\":1}}],[\"方法用于将一个元素插入队列\",{\"1\":{\"251\":1}}],[\"方法中给出\",{\"1\":{\"113\":1}}],[\"方法是将节点值和空位按层序遍历顺序排列\",{\"1\":{\"112\":1}}],[\"方法\",{\"1\":{\"47\":1,\"113\":1,\"251\":2}}],[\"方法名\",{\"1\":{\"41\":1}}],[\"utils\",{\"1\":{\"371\":2}}],[\"up\",{\"1\":{\"382\":1}}],[\"uptime\",{\"1\":{\"370\":1}}],[\"update\",{\"1\":{\"332\":1,\"334\":1,\"336\":1,\"363\":1}}],[\"updateheight\",{\"1\":{\"99\":1,\"102\":2,\"103\":2,\"108\":1,\"109\":1,\"113\":2}}],[\"ubuntu\",{\"1\":{\"342\":1,\"368\":3}}],[\"usr\",{\"1\":{\"382\":7}}],[\"use\",{\"1\":{\"382\":1}}],[\"useie\",{\"1\":{\"364\":1}}],[\"user=ollama\",{\"1\":{\"382\":1}}],[\"user\",{\"1\":{\"311\":3,\"370\":1}}],[\"using\",{\"1\":{\"207\":1,\"257\":1,\"258\":2,\"259\":1,\"263\":2,\"264\":1,\"270\":1,\"271\":1,\"382\":2}}],[\"url>\",{\"1\":{\"331\":1,\"332\":1}}],[\"url\",{\"1\":{\"311\":1,\"338\":1,\"364\":2}}],[\"u\",{\"1\":{\"274\":2}}],[\"udp\",{\"1\":{\"231\":1}}],[\"umask\",{\"1\":{\"222\":1,\"223\":1}}],[\"uint32\",{\"1\":{\"262\":4}}],[\"ui\",{\"1\":{\"174\":1,\"177\":3,\"179\":1,\"182\":2,\"187\":1,\"190\":1,\"194\":1}}],[\"unqi\",{\"1\":{\"266\":1}}],[\"unlock\",{\"1\":{\"238\":1,\"239\":1,\"243\":2,\"258\":2}}],[\"until\",{\"1\":{\"236\":2}}],[\"unit\",{\"1\":{\"382\":1}}],[\"uniq\",{\"1\":{\"266\":1}}],[\"unique\",{\"1\":{\"239\":1,\"240\":1,\"259\":5,\"262\":4,\"264\":1,\"268\":1}}],[\"union\",{\"1\":{\"229\":4}}],[\"unix\",{\"1\":{\"218\":2,\"299\":1,\"357\":2}}],[\"unix中存放在可执行文件的只读数据段中\",{\"1\":{\"208\":1}}],[\"unsigned\",{\"1\":{\"71\":1,\"229\":1,\"287\":3}}],[\"unordered\",{\"1\":{\"59\":1}}],[\"undo\",{\"1\":{\"54\":1}}],[\"级别\",{\"1\":{\"97\":1}}],[\"确保以下文件准备好\",{\"1\":{\"372\":1}}],[\"确保已经安装qemu\",{\"1\":{\"372\":1}}],[\"确保子模块的\",{\"1\":{\"338\":1}}],[\"确保更新完子模块后\",{\"1\":{\"338\":1}}],[\"确保更新操作一定在取值之后\",{\"1\":{\"250\":1}}],[\"确保所有数据正确传输\",{\"1\":{\"295\":1}}],[\"确保所有线程都到达某个同步点后才能继续执行\",{\"1\":{\"244\":1}}],[\"确保双方都准备好通信\",{\"1\":{\"295\":1}}],[\"确保对方接收并释放资源\",{\"1\":{\"294\":1}}],[\"确保对方收到了ack\",{\"1\":{\"292\":1}}],[\"确保主线程在两个子线程结束后才退出\",{\"1\":{\"251\":1}}],[\"确保在不同平台上实现一致的原子操作行为\",{\"1\":{\"241\":1}}],[\"确保在持续添加和删除节点后\",{\"1\":{\"97\":1}}],[\"确保守护进程不能重新打开控制终端\",{\"1\":{\"222\":1}}],[\"确保与\",{\"1\":{\"188\":1}}],[\"确定性\",{\"1\":{\"70\":1}}],[\"论文中详细描述了一系列操作\",{\"1\":{\"97\":1}}],[\"年提出的\",{\"1\":{\"171\":1}}],[\"年\",{\"1\":{\"97\":1}}],[\"劣化为\",{\"1\":{\"97\":1}}],[\"利用qemu+gdb调试linux内核\",{\"0\":{\"367\":1}}],[\"利用\",{\"1\":{\"288\":2}}],[\"利用中序遍历升序的性质\",{\"1\":{\"94\":1}}],[\"利用乘法的不相关性\",{\"1\":{\"71\":1}}],[\"右偏树\",{\"1\":{\"106\":3}}],[\"右旋和左旋操作在逻辑上是镜像对称的\",{\"1\":{\"103\":1}}],[\"右旋操作后岂不是断掉了\",{\"1\":{\"113\":1}}],[\"右旋操作是处理失衡节点\",{\"1\":{\"113\":1}}],[\"右旋操作\",{\"1\":{\"102\":1,\"113\":1}}],[\"右旋操作步骤\",{\"1\":{\"102\":1}}],[\"右旋\",{\"0\":{\"102\":1},\"1\":{\"101\":1,\"102\":1,\"104\":1,\"105\":1,\"106\":2}}],[\"右\",{\"1\":{\"94\":1,\"112\":2,\"113\":1}}],[\"右子节点值\",{\"1\":{\"113\":1}}],[\"右子节点\",{\"1\":{\"94\":1,\"99\":1}}],[\"右子节点指针\",{\"1\":{\"79\":1}}],[\"右子树高度\",{\"1\":{\"100\":1}}],[\"右子树\",{\"1\":{\"92\":1,\"93\":2}}],[\"右子树也是二叉搜索树\",{\"1\":{\"89\":1}}],[\"右子树中所有节点的值\",{\"1\":{\"89\":1}}],[\"右子树是\",{\"1\":{\"79\":1}}],[\"→\",{\"1\":{\"94\":2,\"113\":2,\"216\":6}}],[\"左偏树\",{\"1\":{\"106\":3}}],[\"左旋的操作\",{\"1\":{\"106\":1}}],[\"左旋操作\",{\"1\":{\"103\":2}}],[\"左旋\",{\"0\":{\"103\":1},\"1\":{\"101\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":2,\"112\":1}}],[\"左\",{\"1\":{\"94\":1,\"113\":1}}],[\"左子树高度\",{\"1\":{\"100\":1}}],[\"左子树\",{\"1\":{\"92\":1,\"93\":2}}],[\"左子树中所有节点的值\",{\"1\":{\"89\":1}}],[\"左子树是\",{\"1\":{\"79\":1}}],[\"左子节点值\",{\"1\":{\"113\":1}}],[\"左子节点\",{\"1\":{\"94\":1,\"99\":1}}],[\"左子节点指针\",{\"1\":{\"79\":1}}],[\"左子节点引用和右子节点引用\",{\"1\":{\"79\":1}}],[\"覆盖\",{\"1\":{\"93\":1}}],[\"待删除节点在\",{\"1\":{\"93\":2}}],[\"用dark\",{\"1\":{\"361\":1}}],[\"用法\",{\"1\":{\"311\":3,\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"327\":1,\"328\":1,\"329\":1}}],[\"用户在\",{\"1\":{\"190\":1}}],[\"用户在表单中输入数据时\",{\"1\":{\"176\":1}}],[\"用户交互\",{\"1\":{\"188\":1,\"190\":1}}],[\"用户单独调用\",{\"1\":{\"113\":1}}],[\"用来定义常量和函数\",{\"1\":{\"203\":1}}],[\"用来对比两个对象的值是否相等\",{\"1\":{\"113\":1}}],[\"用来比较两个变量是否指向同一个对象\",{\"1\":{\"113\":1}}],[\"用作系统中的多级索引\",{\"1\":{\"96\":1}}],[\"用\",{\"1\":{\"93\":2}}],[\"用于查找系统中已安装的库\",{\"1\":{\"354\":1}}],[\"用于轮询多个子进程的状态\",{\"1\":{\"305\":1}}],[\"用于在编译时加密字符串\",{\"1\":{\"288\":1}}],[\"用于在父子进程之间传递数据\",{\"1\":{\"226\":1}}],[\"用于字符加密和解密的constexpr函数\",{\"1\":{\"287\":1}}],[\"用于解决\",{\"1\":{\"266\":1}}],[\"用于保存子进程的终止状态\",{\"1\":{\"300\":1}}],[\"用于保存多线程同时操作的共享数据\",{\"1\":{\"258\":1}}],[\"用于保存等待条件的线程\",{\"1\":{\"240\":1}}],[\"用于保存等待的线程\",{\"1\":{\"239\":1}}],[\"用于保存等待锁的线程\",{\"1\":{\"238\":1}}],[\"用于加载操作\",{\"1\":{\"252\":1}}],[\"用于没有数据依赖的地方\",{\"1\":{\"252\":1}}],[\"用于通知进程某个事件发生\",{\"1\":{\"230\":1}}],[\"用于优雅地终止进程\",{\"1\":{\"224\":1}}],[\"用于函数穿参数\",{\"1\":{\"205\":1}}],[\"用于修改指定索引处的数据\",{\"1\":{\"193\":1}}],[\"用于定制数据的显示和编辑\",{\"1\":{\"189\":1}}],[\"用于显示树形结构数据\",{\"1\":{\"188\":1}}],[\"用于显示表格数据\",{\"1\":{\"188\":1}}],[\"用于显示列表数据\",{\"1\":{\"188\":1}}],[\"用于二维表格数据的基类\",{\"1\":{\"187\":1}}],[\"用于一维列表数据的基类\",{\"1\":{\"187\":1}}],[\"用于创建频繁的对象\",{\"0\":{\"362\":1}}],[\"用于创建一系列相关或相互依赖的对象\",{\"1\":{\"161\":1}}],[\"用于创建单一类型的对象\",{\"1\":{\"161\":1}}],[\"用于对数据进行排序和过滤\",{\"1\":{\"194\":1}}],[\"用于对象之间的\",{\"1\":{\"133\":1}}],[\"用于对比两个变量的值是否相等\",{\"1\":{\"113\":1}}],[\"用于接收主题的通知\",{\"1\":{\"132\":1}}],[\"用于构建数据库中的索引系统\",{\"1\":{\"111\":1}}],[\"用于存储仓库的元数据\",{\"1\":{\"311\":1}}],[\"用于存储操作\",{\"1\":{\"252\":1}}],[\"用于存储数据流\",{\"1\":{\"96\":1}}],[\"用于存储队列元素的数组\",{\"1\":{\"44\":1}}],[\"用于计算哈希表中的桶索引\",{\"1\":{\"73\":1,\"74\":1}}],[\"用于衡量哈希冲突的严重程度\",{\"1\":{\"61\":1}}],[\"用于反撤销\",{\"1\":{\"54\":1}}],[\"用于撤销\",{\"1\":{\"54\":1}}],[\"用于记录函数的上下文信息\",{\"1\":{\"52\":1}}],[\"用于记录队列长度\",{\"1\":{\"44\":1}}],[\"用于记录列表当前元素数量\",{\"1\":{\"34\":1}}],[\"记录日志\",{\"1\":{\"224\":1}}],[\"记录遇到的首个删除标记\",{\"1\":{\"65\":1}}],[\"记为\",{\"1\":{\"93\":1,\"102\":1,\"103\":1}}],[\"度\",{\"1\":{\"112\":1}}],[\"度为\",{\"1\":{\"93\":3}}],[\"度的取值范围是\",{\"1\":{\"80\":1}}],[\"执行守护进程的任务\",{\"1\":{\"222\":1}}],[\"执行旋转操作\",{\"1\":{\"106\":1,\"108\":1,\"109\":1}}],[\"执行\",{\"1\":{\"102\":1,\"104\":2,\"105\":2,\"338\":1}}],[\"执行对应的删除节点操作\",{\"1\":{\"93\":1}}],[\"执行扩容\",{\"1\":{\"63\":1,\"65\":1}}],[\"否则将违反其定义\",{\"1\":{\"92\":1}}],[\"循环引用和返回\",{\"1\":{\"266\":1}}],[\"循环等待\",{\"1\":{\"246\":1}}],[\"循环等待不可抢占的互斥资源\",{\"1\":{\"246\":1}}],[\"循环查找\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"循环次数最多为二叉树的高度\",{\"1\":{\"91\":1}}],[\"循环比较节点值\",{\"1\":{\"91\":1}}],[\"满足以下条件\",{\"1\":{\"89\":1}}],[\"满足均匀分布不一定满足抗碰撞性\",{\"1\":{\"70\":1}}],[\"−1≤f≤1\",{\"1\":{\"100\":1}}],[\"−1\",{\"1\":{\"88\":1,\"99\":1}}],[\"达到\",{\"1\":{\"88\":1}}],[\"达到最佳查询效率\",{\"1\":{\"69\":1}}],[\"平衡树\",{\"1\":{\"106\":1}}],[\"平衡\",{\"1\":{\"95\":1}}],[\"平衡二叉树\",{\"0\":{\"87\":1},\"1\":{\"87\":2,\"101\":1}}],[\"平方探测和多次哈希\",{\"1\":{\"67\":1}}],[\"平方探测和多次哈希等\",{\"1\":{\"64\":1}}],[\"平方探测也可能无法访问到它\",{\"1\":{\"66\":1}}],[\"平方探测可能不会探测整个哈希表\",{\"1\":{\"66\":1}}],[\"平方探测并不是完美的\",{\"1\":{\"66\":1}}],[\"平方探测会跳过更大的距离来寻找空位置\",{\"1\":{\"66\":1}}],[\"平方探测通过跳过探测次数平方的距离\",{\"1\":{\"66\":1}}],[\"平方探测主要具有以下优势\",{\"1\":{\"66\":1}}],[\"平方探测不是简单地跳过一个固定的步数\",{\"1\":{\"66\":1}}],[\"平方探测与线性探测类似\",{\"1\":{\"66\":1}}],[\"平方探测\",{\"0\":{\"66\":1}}],[\"完成前不开始\",{\"1\":{\"264\":1}}],[\"完成或资源可用\",{\"1\":{\"216\":1}}],[\"完成\",{\"1\":{\"215\":1}}],[\"完成右旋后\",{\"1\":{\"102\":1}}],[\"完满二叉树和平衡二叉树\",{\"1\":{\"112\":1}}],[\"完全二叉树\",{\"0\":{\"86\":1},\"1\":{\"86\":2,\"112\":1}}],[\"完美二叉树是最理想的状态\",{\"1\":{\"112\":1}}],[\"完美二叉树是理想情况\",{\"1\":{\"88\":1}}],[\"完美二叉树也是一棵完全二叉树\",{\"1\":{\"86\":1}}],[\"完美二叉树常被称为满二叉树\",{\"1\":{\"85\":1}}],[\"完美二叉树\",{\"0\":{\"85\":1},\"1\":{\"85\":2,\"88\":2}}],[\"呈现标准的指数级关系\",{\"1\":{\"85\":1}}],[\"边\",{\"1\":{\"80\":1,\"99\":1,\"112\":1}}],[\"没有子节点的节点\",{\"1\":{\"80\":1}}],[\"没有父节点\",{\"1\":{\"80\":1}}],[\"叶节点的高度为\",{\"1\":{\"99\":1}}],[\"叶节点的度为\",{\"1\":{\"85\":1}}],[\"叶节点\",{\"1\":{\"80\":1,\"112\":1}}],[\"位于二叉树顶层的节点\",{\"1\":{\"80\":1}}],[\"根\",{\"1\":{\"94\":1,\"113\":1}}],[\"根节点的选择是不是很重要\",{\"1\":{\"113\":1}}],[\"根节点的值\",{\"1\":{\"89\":1}}],[\"根节点值\",{\"1\":{\"113\":1}}],[\"根节点所在层为\",{\"1\":{\"80\":1}}],[\"根节点\",{\"1\":{\"80\":1,\"92\":1,\"93\":2,\"94\":1}}],[\"根据配置\",{\"1\":{\"364\":1}}],[\"根据装载的mstyle\",{\"1\":{\"361\":1}}],[\"根据应用场景的不同\",{\"1\":{\"232\":1}}],[\"根据以上特征\",{\"1\":{\"208\":1}}],[\"根据对象的类型去初始化虚指针vptr\",{\"1\":{\"207\":1}}],[\"根据操作更新数据\",{\"1\":{\"190\":1}}],[\"根据节点失衡情况的不同\",{\"1\":{\"101\":1}}],[\"根据当前节点值和\",{\"1\":{\"92\":1}}],[\"根据此哈希函数\",{\"1\":{\"65\":1}}],[\"根据此变量\",{\"1\":{\"34\":1}}],[\"根据哈希函数的结果访问链表头部\",{\"1\":{\"63\":1}}],[\"根据索引实现随机抽样\",{\"1\":{\"17\":1}}],[\"子模块无法初始化或更新\",{\"1\":{\"338\":1}}],[\"子模块指针未更新\",{\"1\":{\"338\":1}}],[\"子模块本身也可以包含子模块\",{\"1\":{\"337\":1}}],[\"子模块不会自动被克隆\",{\"1\":{\"332\":1}}],[\"子进程的退出状态码\",{\"1\":{\"303\":1}}],[\"子进程\",{\"1\":{\"226\":1,\"227\":1,\"228\":1,\"229\":1}}],[\"子进程成为新的会话组长\",{\"1\":{\"223\":1}}],[\"子进程继续运行\",{\"1\":{\"223\":1}}],[\"子进程继续执行\",{\"1\":{\"220\":1}}],[\"子进程并退出父进程\",{\"1\":{\"223\":1}}],[\"子进程再\",{\"1\":{\"220\":1}}],[\"子进程被\",{\"1\":{\"220\":1}}],[\"子进程会被\",{\"1\":{\"220\":1}}],[\"子进程代码\",{\"1\":{\"220\":2,\"303\":1}}],[\"子进程终止后\",{\"1\":{\"218\":1}}],[\"子类2继承基类但没有重写基类的函数\",{\"1\":{\"207\":1}}],[\"子类1继承并重写了基类的函数\",{\"1\":{\"207\":1}}],[\"子类对象必须能够替换其父类对象且行为一致\",{\"1\":{\"126\":1}}],[\"子树的根节点和其父节点的连接是在该函数返回后完成的\",{\"1\":{\"113\":1}}],[\"子树恢复平衡\",{\"1\":{\"102\":1}}],[\"子树\",{\"1\":{\"79\":1,\"112\":1}}],[\"子节点及其以下形成的树被称为该节点的左\",{\"1\":{\"112\":1}}],[\"子节点的平衡因子\",{\"1\":{\"106\":1}}],[\"子节点数量\",{\"1\":{\"93\":2,\"109\":3}}],[\"子节点\",{\"1\":{\"79\":1}}],[\"祖先\",{\"1\":{\"79\":1}}],[\"发送fin\",{\"1\":{\"292\":1}}],[\"发送syn\",{\"1\":{\"292\":1}}],[\"发送消息\",{\"1\":{\"227\":1}}],[\"发送不同天数的请假请求\",{\"1\":{\"167\":1}}],[\"发生\",{\"1\":{\"215\":1}}],[\"发生变化\",{\"1\":{\"75\":1}}],[\"发生冲突\",{\"1\":{\"61\":1}}],[\"发现\",{\"1\":{\"75\":1}}],[\"又能保证哈希表的空间使用率\",{\"1\":{\"75\":1}}],[\"又称散列表\",{\"1\":{\"58\":1}}],[\"冲突比较平均时\",{\"1\":{\"75\":1}}],[\"冲突就越少\",{\"1\":{\"61\":1}}],[\"常与共享内存结合使用\",{\"1\":{\"229\":1}}],[\"常用\",{\"0\":{\"310\":1,\"374\":1}}],[\"常用命令\",{\"0\":{\"282\":1,\"309\":1}}],[\"常用的代理模型有\",{\"1\":{\"194\":1}}],[\"常用的更新信号包括\",{\"1\":{\"191\":1}}],[\"常用的视图类包括\",{\"1\":{\"188\":1}}],[\"常用于安全应用与协议\",{\"1\":{\"74\":1}}],[\"常用于校验文件完整性\",{\"1\":{\"74\":1}}],[\"常用作触发哈希表扩容的条件\",{\"1\":{\"74\":1}}],[\"常见需要实现的方法\",{\"1\":{\"193\":1}}],[\"常见二叉树类型\",{\"0\":{\"84\":1}}],[\"常见的进程间通信方式包括\",{\"1\":{\"225\":1}}],[\"常见的二叉树类型有完美二叉树\",{\"1\":{\"112\":1}}],[\"常见的哈希算法包括\",{\"1\":{\"74\":1}}],[\"常见的哈希表操作包括查询\",{\"1\":{\"74\":1}}],[\"常见的链表类型包括单向链表\",{\"1\":{\"35\":1}}],[\"常见的链表类型包括三种\",{\"1\":{\"26\":1}}],[\"常见哈希算法\",{\"0\":{\"72\":1}}],[\"常见链表种类\",{\"1\":{\"26\":1}}],[\"常见链表类型\",{\"0\":{\"26\":1}}],[\"反映了自然界中常见的细胞分裂现象\",{\"1\":{\"85\":1}}],[\"反映了哈希冲突的严重程度\",{\"1\":{\"74\":1}}],[\"反撤销\",{\"1\":{\"54\":1}}],[\"导致查询结果出错\",{\"1\":{\"74\":1}}],[\"导致该次入栈操作的时间复杂度变为\",{\"1\":{\"51\":1}}],[\"映射为数组索引\",{\"1\":{\"74\":1}}],[\"攻击\",{\"1\":{\"73\":1}}],[\"布尔量\",{\"1\":{\"73\":1}}],[\"得到单一的哈希值\",{\"1\":{\"73\":1}}],[\"得到值\",{\"1\":{\"59\":1}}],[\"元组的哈希值是对其中每一个元素进行哈希\",{\"1\":{\"73\":1}}],[\"元素会被移动至距离理想位置\",{\"1\":{\"65\":1}}],[\"元素出栈\",{\"1\":{\"47\":1}}],[\"元素出队\",{\"1\":{\"41\":1}}],[\"元素入栈\",{\"1\":{\"47\":2}}],[\"元素入队\",{\"1\":{\"41\":2}}],[\"元素索引\",{\"1\":{\"36\":1}}],[\"元素内存地址\",{\"1\":{\"36\":1}}],[\"元素长度\",{\"1\":{\"36\":2}}],[\"元素占用内存多\",{\"1\":{\"25\":1}}],[\"元素占用内存少\",{\"1\":{\"25\":1}}],[\"浮点数和字符串的哈希值计算较为复杂\",{\"1\":{\"73\":1}}],[\"整形有这种原子变量已经足够方便\",{\"1\":{\"260\":1}}],[\"整数\",{\"1\":{\"73\":1}}],[\"整数和布尔量的哈希值就是其本身\",{\"1\":{\"73\":1}}],[\"整除的\",{\"1\":{\"71\":1}}],[\"整除\",{\"1\":{\"71\":1}}],[\"加载\",{\"1\":{\"373\":1}}],[\"加\",{\"1\":{\"327\":1}}],[\"加密+缓冲\",{\"1\":{\"145\":1}}],[\"加密文件流\",{\"1\":{\"145\":1}}],[\"加密货币交易验证\",{\"1\":{\"72\":1}}],[\"加法哈希\",{\"1\":{\"71\":1}}],[\"低频增删的场景\",{\"1\":{\"111\":1}}],[\"低频查找删除数据的场景下\",{\"1\":{\"95\":1}}],[\"低\",{\"1\":{\"72\":2}}],[\"很少\",{\"1\":{\"72\":2}}],[\"很差\",{\"1\":{\"63\":1}}],[\"较多\",{\"1\":{\"72\":2}}],[\"仍用于数据完整性检查\",{\"1\":{\"72\":1}}],[\"仍未出现成功的攻击案例\",{\"1\":{\"72\":1}}],[\"仍然保留在系统中\",{\"1\":{\"218\":1}}],[\"仍然有退化至\",{\"1\":{\"75\":1}}],[\"仍然存在聚集现象\",{\"1\":{\"66\":1}}],[\"仍然指向\",{\"1\":{\"22\":1}}],[\"系列函数\",{\"1\":{\"220\":1}}],[\"系列\",{\"1\":{\"72\":1}}],[\"系列中的\",{\"1\":{\"72\":1}}],[\"系统环境\",{\"1\":{\"368\":1}}],[\"系统资源不能被强制从一个进程\",{\"1\":{\"246\":1}}],[\"系统中用于等待子进程状态变化的系统调用\",{\"1\":{\"299\":1}}],[\"系统中\",{\"1\":{\"221\":1}}],[\"系统管理的麻烦\",{\"1\":{\"219\":1}}],[\"系统\",{\"1\":{\"218\":1,\"357\":1}}],[\"系统将其从内存中清除\",{\"1\":{\"216\":1}}],[\"系统将其从内存中移除\",{\"1\":{\"215\":1}}],[\"系统需求变动导致的修改尽可能的不会扩散的稳定的模块\",{\"1\":{\"127\":1}}],[\"系统通常不会直接存储用户的明文密码\",{\"1\":{\"70\":1}}],[\"系统都会在栈顶添加一个栈帧\",{\"1\":{\"52\":1}}],[\"系统会对输入的密码计算哈希值\",{\"1\":{\"70\":1}}],[\"系统会将哈希表扩容至原先的\",{\"1\":{\"61\":1}}],[\"系统会为列表分配\",{\"1\":{\"51\":1}}],[\"系统会申请一块新的内存\",{\"1\":{\"36\":1}}],[\"系统随后会根据顺序处理队列中的订单\",{\"1\":{\"45\":1}}],[\"系统可以利用这些信息来优化数据结构的操作效率\",{\"1\":{\"16\":1}}],[\"已被弃用\",{\"1\":{\"72\":2}}],[\"已被成功攻击\",{\"1\":{\"72\":2}}],[\"已多次被成功攻击\",{\"1\":{\"72\":1}}],[\"已经连接到\",{\"1\":{\"373\":1}}],[\"已经启动并等待\",{\"1\":{\"372\":1}}],[\"已经获得的资源在未使用完之前不能被抢占\",{\"1\":{\"246\":1}}],[\"已经实现了双向链表\",{\"1\":{\"36\":1}}],[\"已经从链表中删除了\",{\"1\":{\"36\":1}}],[\"已经不再属于该链表了\",{\"1\":{\"22\":1}}],[\"近一个世纪以来\",{\"1\":{\"72\":1}}],[\"脆弱\",{\"1\":{\"72\":1}}],[\"提交更改\",{\"1\":{\"335\":1}}],[\"提交子模块的更新\",{\"1\":{\"334\":1}}],[\"提交暂存区的更改\",{\"1\":{\"314\":1}}],[\"提倡不在构造函数和析构函数中调用虚函数\",{\"1\":{\"209\":1}}],[\"提供的\",{\"1\":{\"373\":1}}],[\"提供的数据\",{\"1\":{\"188\":1}}],[\"提供逆袭的信息点\",{\"1\":{\"287\":1}}],[\"提供自定义的编辑控件和逻辑\",{\"1\":{\"189\":1}}],[\"提供标准的项目模型\",{\"1\":{\"187\":1}}],[\"提供接口\",{\"1\":{\"187\":1}}],[\"提供了\",{\"1\":{\"354\":1}}],[\"提供了一组内存序列模型\",{\"1\":{\"248\":1}}],[\"提供了一些代理模型\",{\"1\":{\"194\":1}}],[\"提供了对不同内存模型的支持\",{\"1\":{\"241\":1}}],[\"提供了更高的灵活性和可维护性\",{\"1\":{\"194\":1}}],[\"提供了多种现成的模型类\",{\"1\":{\"193\":1}}],[\"提供了几个现成的模型类\",{\"1\":{\"187\":1}}],[\"提供了很好的解耦性和可维护性\",{\"1\":{\"182\":1}}],[\"提供访问这些数据的接口\",{\"1\":{\"187\":1}}],[\"提供\",{\"1\":{\"175\":1}}],[\"提供具体的实现逻辑\",{\"1\":{\"150\":1}}],[\"提供注册\",{\"1\":{\"132\":1}}],[\"提供快速数据访问\",{\"1\":{\"35\":1}}],[\"提高了\",{\"1\":{\"177\":1}}],[\"提高了代码的可扩展性\",{\"1\":{\"139\":1}}],[\"提高系统扩展性\",{\"1\":{\"151\":1}}],[\"提高系统的灵活性\",{\"1\":{\"126\":1}}],[\"提高系统的灵活性和可扩展性\",{\"1\":{\"126\":1}}],[\"提高代码的可维护性和可读性\",{\"1\":{\"126\":1}}],[\"提示\",{\"1\":{\"83\":1,\"85\":1,\"284\":1,\"369\":1,\"372\":1}}],[\"提升哈希算法的安全性\",{\"1\":{\"73\":1}}],[\"提升哈希算法的稳健性\",{\"1\":{\"71\":1}}],[\"总结\",{\"0\":{\"182\":1,\"232\":1,\"296\":1,\"306\":1},\"1\":{\"133\":1,\"139\":1,\"145\":1,\"151\":1,\"161\":1,\"168\":1,\"194\":1,\"264\":1,\"338\":1,\"357\":1}}],[\"总是会优先遍历下一个最小节点\",{\"1\":{\"94\":1}}],[\"总而言之\",{\"1\":{\"71\":1}}],[\"总的来看\",{\"1\":{\"12\":1}}],[\"7\",{\"0\":{\"319\":1,\"337\":1,\"354\":1},\"1\":{\"71\":1,\"167\":2,\"222\":1}}],[\"75\",{\"1\":{\"61\":1}}],[\"恰好满足这种等差数列的数据分布\",{\"1\":{\"71\":1}}],[\"​\",{\"1\":{\"71\":2}}],[\"举个例子\",{\"1\":{\"71\":1,\"207\":1}}],[\"^\",{\"1\":{\"71\":2,\"287\":1}}],[\"乘法哈希\",{\"1\":{\"71\":1}}],[\"雪崩效应\",{\"1\":{\"70\":1}}],[\"抗碰撞性\",{\"1\":{\"70\":2}}],[\"接下来你可以逐步执行代码\",{\"1\":{\"373\":1}}],[\"接收消息\",{\"1\":{\"227\":1}}],[\"接收方可以重新计算接收到的数据的哈希值\",{\"1\":{\"70\":1}}],[\"接管\",{\"1\":{\"220\":2}}],[\"接口或抽象类\",{\"1\":{\"166\":1}}],[\"接口应尽量细化\",{\"1\":{\"126\":1,\"127\":1}}],[\"接口隔离原则\",{\"1\":{\"126\":1}}],[\"接着遍历链表以查找目标节点并将其删除\",{\"1\":{\"63\":1}}],[\"均匀分布\",{\"1\":{\"70\":2}}],[\"效率非常高\",{\"1\":{\"74\":1}}],[\"效率高\",{\"1\":{\"70\":1}}],[\"效率很高\",{\"1\":{\"31\":1}}],[\"既不是为基类\",{\"1\":{\"210\":1}}],[\"既快又稳\",{\"1\":{\"70\":1}}],[\"既频繁应用在各类算法之中\",{\"1\":{\"17\":1}}],[\"决定了输出值\",{\"1\":{\"69\":1}}],[\"固定时\",{\"1\":{\"69\":1}}],[\"回到主项目\",{\"1\":{\"336\":1}}],[\"回到主项目后\",{\"1\":{\"334\":1}}],[\"回到头部继续遍历\",{\"1\":{\"65\":1}}],[\"回退一提交\",{\"1\":{\"320\":1}}],[\"回退到之前的某个提交点\",{\"1\":{\"320\":1}}],[\"回收子进程的退出状态\",{\"1\":{\"305\":1}}],[\"回收子进程的资源\",{\"1\":{\"220\":1}}],[\"回复syn\",{\"1\":{\"294\":1}}],[\"回忆哈希函数的计算步骤\",{\"1\":{\"69\":1}}],[\"理论上这个t可以是任意类型\",{\"1\":{\"260\":1}}],[\"理论上一定存在\",{\"1\":{\"61\":1}}],[\"理解这些状态对于调试网络问题\",{\"1\":{\"296\":1}}],[\"理解\",{\"1\":{\"180\":1}}],[\"理想情况下键值对均匀分布在各个桶中\",{\"1\":{\"69\":1}}],[\"超出容量则连接一个溢出桶\",{\"1\":{\"68\":1}}],[\"超出数组长度范围的元素会丢失\",{\"1\":{\"12\":1}}],[\"规定每个桶最多存储\",{\"1\":{\"68\":1}}],[\"规定队尾仅可添加节点\",{\"1\":{\"43\":1}}],[\"内核编译时需要启用调试符号\",{\"1\":{\"374\":1}}],[\"内核源码\",{\"0\":{\"369\":1},\"1\":{\"369\":1}}],[\"内核\",{\"1\":{\"367\":1}}],[\"内核是一种非常强大的方法\",{\"1\":{\"367\":1}}],[\"内部有一个调度器\",{\"1\":{\"264\":1}}],[\"内容在下面\",{\"1\":{\"370\":1}}],[\"内容质量很高\",{\"1\":{\"122\":1}}],[\"内容丰富且有条理有深度\",{\"1\":{\"121\":1}}],[\"内置\",{\"1\":{\"73\":1}}],[\"内数组长度达到\",{\"1\":{\"68\":1}}],[\"内存池\",{\"0\":{\"362\":1}}],[\"内存也会被释放\",{\"1\":{\"269\":1}}],[\"内存序列模型\",{\"1\":{\"248\":1}}],[\"内存模型\",{\"1\":{\"241\":1}}],[\"内存地址偏移一个数组的位置\",{\"1\":{\"202\":1}}],[\"内存效率\",{\"1\":{\"25\":1}}],[\"内存可能无法提供如此大的连续空间\",{\"1\":{\"18\":1}}],[\"内存空间是所有程序的公共资源\",{\"1\":{\"18\":1}}],[\"内存浪费\",{\"1\":{\"12\":1}}],[\"自旋等待\",{\"1\":{\"243\":1}}],[\"自旋锁适用于锁定时间非常短的场景\",{\"1\":{\"243\":1}}],[\"自旋锁通常通过硬件的原子操作实现\",{\"1\":{\"243\":1}}],[\"自旋锁是一种忙等待锁\",{\"1\":{\"243\":1}}],[\"自旋锁\",{\"0\":{\"243\":1}}],[\"自动加锁和解锁\",{\"1\":{\"238\":1}}],[\"自动刷新显示\",{\"1\":{\"190\":1}}],[\"自动更新\",{\"1\":{\"176\":1}}],[\"自定义一个简单的表格模型\",{\"1\":{\"193\":1}}],[\"自定义模型需要继承\",{\"1\":{\"193\":1}}],[\"自定义模型\",{\"0\":{\"193\":1}}],[\"自定义绘制逻辑\",{\"1\":{\"189\":1}}],[\"自定义委托\",{\"1\":{\"189\":1}}],[\"自底向上执行旋转操作\",{\"1\":{\"108\":1}}],[\"自\",{\"1\":{\"68\":1}}],[\"采用引用计数器的方法\",{\"1\":{\"267\":1}}],[\"采用\",{\"1\":{\"220\":1}}],[\"采用链式地址\",{\"1\":{\"68\":2}}],[\"采用开放寻址\",{\"1\":{\"68\":1,\"74\":1}}],[\"说明队列为空\",{\"1\":{\"251\":1}}],[\"说明队列已满\",{\"1\":{\"251\":1}}],[\"说明找到目标节点\",{\"1\":{\"91\":1}}],[\"说明目标节点在\",{\"1\":{\"91\":2}}],[\"说明目标元素不在哈希表中\",{\"1\":{\"65\":1}}],[\"说明哈希表中不存在该元素\",{\"1\":{\"67\":1}}],[\"试图缓解线性探测的聚集效应\",{\"1\":{\"66\":1}}],[\"步骤\",{\"1\":{\"335\":1}}],[\"步\",{\"1\":{\"66\":1}}],[\"步长通常为\",{\"1\":{\"65\":1}}],[\"9\",{\"0\":{\"356\":1},\"1\":{\"66\":1,\"71\":4,\"139\":1}}],[\"搜索\",{\"1\":{\"65\":4}}],[\"搜索时间也会增加\",{\"1\":{\"65\":1}}],[\"探测次数的平方\",{\"1\":{\"66\":1}}],[\"探测起始点\",{\"1\":{\"65\":1}}],[\"探测方式主要包括线性探测\",{\"1\":{\"64\":1}}],[\"考虑在线性探测中记录遇到的首个\",{\"1\":{\"65\":1}}],[\"才能找到目标元素\",{\"1\":{\"65\":1}}],[\"才执行扩容操作\",{\"1\":{\"62\":1}}],[\"懒删除可能会加速哈希表的性能退化\",{\"1\":{\"65\":1}}],[\"机制相互通信\",{\"1\":{\"172\":1}}],[\"机制\",{\"1\":{\"65\":1,\"226\":1}}],[\"机器学习\",{\"1\":{\"17\":1}}],[\"最初用于\",{\"1\":{\"171\":1}}],[\"最终\",{\"1\":{\"113\":1}}],[\"最终导致增删查改操作效率劣化\",{\"1\":{\"65\":1}}],[\"最差情况下所有键值对都存储到同一个桶中\",{\"1\":{\"69\":1}}],[\"最后\",{\"1\":{\"75\":1,\"251\":1}}],[\"最后两位相同的\",{\"1\":{\"65\":1}}],[\"最后一个节点被称为\",{\"1\":{\"18\":1}}],[\"聚集现象\",{\"1\":{\"65\":1}}],[\"都是一个指针代表一个内存\",{\"1\":{\"202\":1}}],[\"都是每轮排除一半情况\",{\"1\":{\"91\":1}}],[\"都是开放寻址的常见策略之一\",{\"1\":{\"66\":1}}],[\"都会被操作系统回收\",{\"1\":{\"218\":1}}],[\"都会被映射到\",{\"1\":{\"71\":1}}],[\"都会被映射到相同的桶\",{\"1\":{\"65\":1}}],[\"都会为字符串哈希函数加入一个随机的盐\",{\"1\":{\"73\":1}}],[\"都可以放置键值对\",{\"1\":{\"65\":1}}],[\"都代表空桶\",{\"1\":{\"65\":1}}],[\"都在向右移动\",{\"1\":{\"44\":1}}],[\"来调试\",{\"1\":{\"367\":1}}],[\"来存储元素\",{\"1\":{\"251\":1}}],[\"来存储和操作数据\",{\"1\":{\"187\":1}}],[\"来定义队列元素的类型\",{\"1\":{\"251\":1}}],[\"来避免数据竞争\",{\"1\":{\"228\":1}}],[\"来对原始模型的数据进行转换或过滤\",{\"1\":{\"194\":1}}],[\"来自定义模型\",{\"1\":{\"187\":1}}],[\"来为原始对象提供新的行为\",{\"1\":{\"143\":1}}],[\"来比较两个字符串的内容\",{\"1\":{\"113\":1}}],[\"来确定失衡节点属于上图中的哪种情况\",{\"1\":{\"106\":1}}],[\"来标记这个桶\",{\"1\":{\"65\":1}}],[\"来处理哈希冲突\",{\"1\":{\"64\":1}}],[\"来实现\",{\"1\":{\"44\":1}}],[\"来实现列表\",{\"1\":{\"28\":1}}],[\"红黑树的平衡条件更宽松\",{\"1\":{\"111\":1}}],[\"红黑树也是一种常见的平衡二叉搜索树\",{\"1\":{\"111\":1}}],[\"红黑树\",{\"1\":{\"63\":1}}],[\"树会从底向顶执行旋转操作\",{\"1\":{\"112\":1}}],[\"树典型应用\",{\"0\":{\"111\":1}}],[\"树常用操作\",{\"0\":{\"107\":1}}],[\"树常见术语\",{\"0\":{\"98\":1}}],[\"树旋转\",{\"0\":{\"101\":1}}],[\"树的高度和根节点的深度都是\",{\"1\":{\"113\":1}}],[\"树的旋转操作包括右旋\",{\"1\":{\"112\":1}}],[\"树的节点查找操作与二叉搜索树一致\",{\"1\":{\"110\":1}}],[\"树的节点插入操作与二叉搜索树在主体上类似\",{\"1\":{\"108\":1}}],[\"树的四种旋转情况\",{\"1\":{\"106\":1}}],[\"树的特点在于\",{\"1\":{\"101\":1}}],[\"树的任意节点的平衡因子皆满足\",{\"1\":{\"100\":1}}],[\"树的相关操作需要获取节点高度\",{\"1\":{\"99\":1}}],[\"树节点类\",{\"1\":{\"99\":1}}],[\"树既是二叉搜索树\",{\"1\":{\"98\":1}}],[\"树能始终保持高效的数据操作性能\",{\"1\":{\"97\":1}}],[\"树不会退化\",{\"1\":{\"97\":1}}],[\"树在插入节点后发生退化\",{\"1\":{\"97\":1}}],[\"树在删除节点后发生退化\",{\"1\":{\"97\":1}}],[\"树将严重向左倾斜\",{\"1\":{\"97\":1}}],[\"树\",{\"0\":{\"97\":1},\"1\":{\"63\":1,\"97\":1,\"111\":1,\"112\":1}}],[\"树中插入节点后\",{\"1\":{\"108\":1}}],[\"树中\",{\"1\":{\"27\":1}}],[\"桶数组\",{\"1\":{\"63\":1,\"65\":1}}],[\"触发扩容的负载因子阈值\",{\"1\":{\"63\":1,\"65\":1}}],[\"代理模型\",{\"0\":{\"194\":1}}],[\"代码\",{\"1\":{\"347\":1}}],[\"代码详解\",{\"0\":{\"288\":1}}],[\"代码结构和作用\",{\"0\":{\"251\":1}}],[\"代码解释\",{\"0\":{\"223\":1,\"304\":1}}],[\"代码示例\",{\"0\":{\"222\":1},\"1\":{\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1}}],[\"代码的存在的link\",{\"1\":{\"204\":1}}],[\"代码编译时不使用name\",{\"1\":{\"204\":1}}],[\"代码link\",{\"1\":{\"204\":1}}],[\"代码更具模块化\",{\"1\":{\"179\":1}}],[\"代码维护\",{\"1\":{\"177\":1}}],[\"代码如下所示\",{\"1\":{\"15\":1,\"24\":1,\"44\":1,\"102\":1,\"106\":1,\"108\":1,\"109\":1}}],[\"代表应用程序的数据和业务逻辑\",{\"1\":{\"173\":1}}],[\"代表\",{\"1\":{\"79\":1}}],[\"代替链表\",{\"1\":{\"63\":1}}],[\"占用空间增大\",{\"1\":{\"63\":1}}],[\"占用内存较多\",{\"1\":{\"35\":1}}],[\"占用内存较少\",{\"1\":{\"35\":1}}],[\"改良哈希表数据结构\",{\"1\":{\"62\":1}}],[\"改变\",{\"1\":{\"61\":1}}],[\"严重影响哈希表的可用性\",{\"1\":{\"62\":1}}],[\"非常有用\",{\"1\":{\"161\":1}}],[\"非常耗时\",{\"1\":{\"61\":1}}],[\"非常高效\",{\"1\":{\"58\":1,\"94\":1}}],[\"越过叶节点后跳出\",{\"1\":{\"91\":1,\"92\":1,\"93\":1}}],[\"越过尾部则返回头部\",{\"1\":{\"65\":1}}],[\"越过数组尾部后回到头部\",{\"1\":{\"44\":1}}],[\"越大\",{\"1\":{\"61\":1}}],[\"容器新增\",{\"0\":{\"271\":1}}],[\"容量为\",{\"1\":{\"251\":1}}],[\"容量设置比较合理\",{\"1\":{\"75\":1}}],[\"容量扩展\",{\"1\":{\"25\":1}}],[\"容易想到\",{\"1\":{\"61\":1}}],[\"ghcr\",{\"1\":{\"382\":1}}],[\"gateway\",{\"1\":{\"382\":1}}],[\"games\",{\"1\":{\"382\":2}}],[\"gnu\",{\"1\":{\"368\":1}}],[\"gcc\",{\"1\":{\"368\":1}}],[\"gdb\",{\"0\":{\"373\":1,\"374\":1},\"1\":{\"367\":2,\"368\":1,\"369\":1,\"372\":5,\"373\":9,\"374\":1},\"2\":{\"377\":1}}],[\"gitmodules\",{\"1\":{\"335\":1}}],[\"github\",{\"1\":{\"311\":3,\"331\":1}}],[\"git\",{\"0\":{\"309\":1,\"310\":1},\"1\":{\"309\":2,\"311\":18,\"313\":3,\"314\":4,\"315\":2,\"316\":4,\"317\":4,\"318\":3,\"319\":3,\"320\":4,\"322\":3,\"323\":6,\"324\":2,\"325\":2,\"327\":4,\"328\":2,\"329\":2,\"330\":4,\"331\":4,\"332\":3,\"333\":1,\"334\":3,\"335\":3,\"336\":3,\"338\":3},\"2\":{\"340\":1}}],[\"group=ollama\",{\"1\":{\"382\":1}}],[\"graph\",{\"1\":{\"316\":2}}],[\"grandchild\",{\"1\":{\"102\":2,\"103\":2}}],[\"grand\",{\"1\":{\"102\":3,\"103\":3,\"113\":1}}],[\"green\",{\"1\":{\"277\":3}}],[\"g++\",{\"1\":{\"270\":3}}],[\"gurad相比于std\",{\"1\":{\"259\":1}}],[\"guard和std\",{\"1\":{\"259\":1,\"264\":1}}],[\"guard\",{\"1\":{\"238\":1,\"257\":1,\"259\":1}}],[\"guard<std\",{\"1\":{\"238\":1,\"240\":1,\"259\":1,\"260\":3}}],[\"gui\",{\"1\":{\"168\":1,\"382\":1}}],[\"guifactory\",{\"1\":{\"161\":3}}],[\"guidelines解析\",{\"1\":{\"122\":1}}],[\"g\",{\"1\":{\"97\":1,\"264\":1,\"357\":1}}],[\"getvideourl\",{\"1\":{\"364\":1}}],[\"getscript\",{\"1\":{\"364\":1}}],[\"getwaves\",{\"1\":{\"361\":1}}],[\"getpid\",{\"1\":{\"303\":1}}],[\"geta\",{\"1\":{\"270\":3}}],[\"getcount\",{\"1\":{\"262\":1}}],[\"getfinalprice\",{\"1\":{\"139\":3}}],[\"get\",{\"1\":{\"60\":1,\"63\":1,\"65\":1,\"257\":2,\"260\":2,\"263\":4,\"264\":1,\"342\":1}}],[\"gossman\",{\"1\":{\"171\":1}}],[\"go\",{\"1\":{\"18\":1,\"68\":2,\"382\":1}}],[\"键值对的分布情况由哈希函数决定\",{\"1\":{\"69\":1}}],[\"键值对数量\",{\"1\":{\"63\":1,\"65\":1}}],[\"键值对\",{\"1\":{\"60\":1,\"63\":1}}],[\"封装成一个类\",{\"1\":{\"60\":1}}],[\"易得哈希函数为\",{\"1\":{\"60\":1}}],[\"随着\",{\"1\":{\"65\":1}}],[\"随后\",{\"1\":{\"60\":1}}],[\"随机访问\",{\"1\":{\"17\":1}}],[\"随机访问元素\",{\"1\":{\"10\":1}}],[\"取余\",{\"1\":{\"75\":1}}],[\"取余操作\",{\"1\":{\"44\":1}}],[\"取模\",{\"1\":{\"60\":1,\"71\":1,\"75\":1}}],[\"哈希值仍然是不变的\",{\"1\":{\"73\":1}}],[\"哈希冲突的概率就越低\",{\"1\":{\"70\":1,\"74\":1}}],[\"哈希冲突的最佳情况与最差情况\",{\"1\":{\"69\":1}}],[\"哈希冲突会导致查询结果错误\",{\"1\":{\"62\":1}}],[\"哈希冲突\",{\"0\":{\"62\":1},\"1\":{\"72\":1}}],[\"哈希冲突示例\",{\"1\":{\"61\":1}}],[\"哈希冲突与扩容\",{\"0\":{\"61\":1}}],[\"哈希函数下\",{\"1\":{\"75\":1}}],[\"哈希函数将\",{\"1\":{\"74\":1}}],[\"哈希函数\",{\"1\":{\"60\":1,\"63\":1,\"65\":1,\"70\":1}}],[\"哈希函数工作原理\",{\"1\":{\"60\":1}}],[\"哈希函数的最后一步往往是对数组长度\",{\"1\":{\"75\":1}}],[\"哈希函数的输出结果也相同\",{\"1\":{\"61\":1}}],[\"哈希函数的作用是将所有\",{\"1\":{\"61\":1}}],[\"哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间\",{\"1\":{\"60\":1}}],[\"哈希函数的计算过程分为以下两步\",{\"1\":{\"60\":1}}],[\"哈希算法通常采用大质数作为模数\",{\"1\":{\"74\":1}}],[\"哈希算法还应该具备抗碰撞性和雪崩效应\",{\"1\":{\"74\":1}}],[\"哈希算法处在不断升级与优化的过程中\",{\"1\":{\"72\":1}}],[\"哈希算法的设计是一个需要考虑许多因素的复杂问题\",{\"1\":{\"71\":1}}],[\"哈希算法的设计\",{\"0\":{\"71\":1}}],[\"哈希算法的目标\",{\"0\":{\"70\":1}}],[\"哈希算法需要具备更高等级的安全特性\",{\"1\":{\"70\":1}}],[\"哈希算法除了可以用于实现哈希表\",{\"1\":{\"70\":1}}],[\"哈希算法应使得键值对均匀分布在哈希表中\",{\"1\":{\"70\":1}}],[\"哈希算法应始终产生相同的输出\",{\"1\":{\"70\":1}}],[\"哈希算法应具备以下特点\",{\"1\":{\"70\":1}}],[\"哈希算法\",{\"0\":{\"69\":1},\"1\":{\"60\":1,\"69\":1}}],[\"哈希表有相当一部分内存未使用\",{\"1\":{\"75\":1}}],[\"哈希表有三种常用的遍历方式\",{\"1\":{\"59\":1}}],[\"哈希表底层实现是数组\",{\"1\":{\"75\":1}}],[\"哈希表能够在\",{\"1\":{\"74\":1}}],[\"哈希表都存在\",{\"1\":{\"67\":1}}],[\"哈希表扩容操作的开销很大\",{\"1\":{\"74\":1}}],[\"哈希表扩容需将所有键值对从原哈希表迁移至新哈希表\",{\"1\":{\"61\":1}}],[\"哈希表扩容\",{\"1\":{\"61\":1}}],[\"哈希表容量越大\",{\"1\":{\"74\":1}}],[\"哈希表容量\",{\"1\":{\"61\":1,\"63\":1,\"65\":1}}],[\"哈希表简单实现\",{\"0\":{\"60\":1}}],[\"哈希表的时间效率变高\",{\"1\":{\"75\":1}}],[\"哈希表的时间复杂度可能发生劣化\",{\"1\":{\"75\":1}}],[\"哈希表的时间复杂度会退化至\",{\"1\":{\"75\":1}}],[\"哈希表的时间复杂度在什么情况下是\",{\"1\":{\"75\":1}}],[\"哈希表的目标是将一个较大的状态空间映射到一个较小的空间\",{\"1\":{\"75\":1}}],[\"哈希表的\",{\"1\":{\"73\":1}}],[\"哈希表的实用性越高\",{\"1\":{\"70\":1}}],[\"哈希表的性能则会急剧劣化\",{\"1\":{\"69\":1}}],[\"哈希表的键值对分布\",{\"1\":{\"65\":2}}],[\"哈希表的结构改良方法主要包括\",{\"1\":{\"62\":1}}],[\"哈希表的常见操作包括\",{\"1\":{\"59\":1}}],[\"哈希表的抽象表示\",{\"1\":{\"58\":1}}],[\"哈希表常用操作\",{\"0\":{\"59\":1}}],[\"哈希表和图等数据结构\",{\"1\":{\"27\":1}}],[\"哈希表\",{\"0\":{\"57\":1,\"58\":1},\"1\":{\"2\":1,\"17\":1,\"27\":1,\"58\":2,\"63\":1,\"65\":1},\"2\":{\"77\":1}}],[\"kernel\",{\"1\":{\"369\":2,\"370\":1,\"372\":2,\"373\":3},\"2\":{\"377\":1}}],[\"keyset\",{\"1\":{\"60\":4}}],[\"key\",{\"1\":{\"58\":2,\"59\":5,\"60\":25,\"61\":3,\"63\":18,\"65\":19,\"69\":1,\"70\":4,\"71\":7,\"73\":3,\"74\":3,\"75\":3,\"227\":3,\"228\":3,\"229\":3,\"287\":2}}],[\"killed\",{\"1\":{\"303\":1}}],[\"k\",{\"1\":{\"257\":2,\"258\":4,\"259\":2}}],[\"kvm\",{\"1\":{\"371\":1}}],[\"kv\",{\"1\":{\"59\":3,\"60\":3}}],[\"向队列中插入元素\",{\"1\":{\"251\":1}}],[\"向左旋转\",{\"1\":{\"103\":1}}],[\"向右旋转\",{\"1\":{\"102\":2}}],[\"向哈希表中输入键\",{\"1\":{\"59\":1}}],[\"向下递推阶段会不断执行入栈操作\",{\"1\":{\"52\":1}}],[\"小数\",{\"1\":{\"73\":1}}],[\"小数或字符串等数据类型\",{\"1\":{\"73\":1}}],[\"小鸭\",{\"1\":{\"59\":1}}],[\"小法\",{\"1\":{\"59\":1}}],[\"小算\",{\"1\":{\"59\":1}}],[\"小啰\",{\"1\":{\"59\":1}}],[\"小哈\",{\"1\":{\"59\":1}}],[\"查看指定地址的内存内容\",{\"1\":{\"374\":1}}],[\"查看当前设置的断点\",{\"1\":{\"374\":1}}],[\"查看当前的远程仓库\",{\"1\":{\"311\":1}}],[\"查看变量的值等\",{\"1\":{\"373\":1}}],[\"查看工作目录\",{\"1\":{\"317\":1}}],[\"查看分支图形\",{\"1\":{\"316\":1}}],[\"查看哪些文件有更改\",{\"1\":{\"315\":1}}],[\"查看远程仓库\",{\"1\":{\"311\":1}}],[\"查询效率\",{\"1\":{\"63\":1}}],[\"查询效率降低\",{\"1\":{\"63\":1}}],[\"查询学号为\",{\"1\":{\"61\":1}}],[\"查询操作就是找到\",{\"1\":{\"60\":1}}],[\"查询操作\",{\"1\":{\"59\":2,\"60\":1,\"63\":1,\"65\":1}}],[\"查询元素\",{\"1\":{\"58\":1,\"63\":1}}],[\"查找并使用\",{\"1\":{\"354\":1}}],[\"查找操作的时间复杂度也随之劣化\",{\"1\":{\"97\":1}}],[\"查找插入位置并插入节点\",{\"1\":{\"108\":1}}],[\"查找插入位置\",{\"1\":{\"92\":1}}],[\"查找的时候通过哈希函数找到对应的桶和键值对\",{\"1\":{\"75\":1}}],[\"查找其中值为\",{\"1\":{\"24\":1}}],[\"查找节点并删除\",{\"1\":{\"109\":1}}],[\"查找节点\",{\"0\":{\"24\":1,\"91\":1,\"110\":1},\"1\":{\"91\":1}}],[\"查找表\",{\"1\":{\"17\":1}}],[\"查找元素的时候会出现哈希冲突呢\",{\"1\":{\"75\":1}}],[\"查找元素\",{\"0\":{\"14\":1},\"1\":{\"58\":1,\"65\":1,\"67\":1,\"95\":1}}],[\"仅仅读取尾部的值\",{\"1\":{\"251\":1}}],[\"仅仅要它是最后的构造函数调用\",{\"1\":{\"210\":1}}],[\"仅处理与\",{\"1\":{\"177\":1}}],[\"仅使用左旋或右旋都无法使子树恢复平衡\",{\"1\":{\"104\":1}}],[\"仅提供基本数据类型的哈希值计算\",{\"1\":{\"73\":1}}],[\"仅在必要时\",{\"1\":{\"62\":1}}],[\"仅用一个数组来实现哈希表\",{\"1\":{\"60\":1}}],[\"仅需将元素添加至数组\",{\"1\":{\"58\":1}}],[\"仅转换有效长度范围内的列表元素\",{\"1\":{\"44\":1}}],[\"除叶节点外\",{\"1\":{\"79\":1}}],[\"除哈希表外\",{\"1\":{\"58\":1}}],[\"除了包含值\",{\"1\":{\"18\":1}}],[\"输出中会显示子模块的哈希\",{\"1\":{\"333\":1}}],[\"输出结果如下\",{\"1\":{\"167\":1}}],[\"输出的哈希值是不同的\",{\"1\":{\"73\":1}}],[\"输出长度\",{\"1\":{\"72\":1}}],[\"输出空间为数组容量大小\",{\"1\":{\"62\":1}}],[\"输出空间是所有桶\",{\"1\":{\"60\":1}}],[\"输出该节点在链表中的索引\",{\"1\":{\"24\":1}}],[\"输入的微小变化应当导致输出的显著且不可预测的变化\",{\"1\":{\"70\":1}}],[\"输入\",{\"1\":{\"63\":1,\"74\":1}}],[\"输入空间通常远大于输出空间\",{\"1\":{\"75\":1}}],[\"输入空间为全体整数\",{\"1\":{\"62\":1}}],[\"输入空间是所有\",{\"1\":{\"60\":1}}],[\"输入一个\",{\"1\":{\"60\":2}}],[\"输入一个学号\",{\"1\":{\"58\":1}}],[\"姓名为例\",{\"1\":{\"60\":1}}],[\"姓名\",{\"1\":{\"58\":1}}],[\"host\",{\"1\":{\"382\":1}}],[\"host=host\",{\"1\":{\"382\":1}}],[\"host=0\",{\"1\":{\"382\":1}}],[\"home\",{\"1\":{\"382\":2}}],[\"homebrew\",{\"1\":{\"342\":1}}],[\"hold\",{\"1\":{\"246\":1}}],[\"h>\",{\"1\":{\"220\":3,\"222\":6,\"226\":1,\"227\":2,\"228\":2,\"229\":2,\"230\":1,\"231\":6,\"303\":2}}],[\"http\",{\"1\":{\"382\":1}}],[\"https\",{\"1\":{\"181\":1,\"311\":3,\"331\":1,\"369\":1,\"370\":1,\"382\":1}}],[\"htons\",{\"1\":{\"231\":2}}],[\"html\",{\"1\":{\"174\":1,\"181\":1}}],[\"hard\",{\"1\":{\"320\":2}}],[\"hardware\",{\"1\":{\"257\":1}}],[\"handle可用于pthread相关操作\",{\"1\":{\"257\":1}}],[\"handle\",{\"1\":{\"257\":3}}],[\"handlerequest\",{\"1\":{\"167\":4}}],[\"handler\",{\"1\":{\"166\":2,\"167\":2,\"220\":2}}],[\"has\",{\"1\":{\"245\":1,\"274\":4}}],[\"hash>\",{\"1\":{\"336\":1}}],[\"hashdos\",{\"1\":{\"73\":1}}],[\"hashdec\",{\"1\":{\"73\":1}}],[\"hashstr\",{\"1\":{\"73\":1}}],[\"hash<string>\",{\"1\":{\"73\":1}}],[\"hash<double>\",{\"1\":{\"73\":1}}],[\"hash<bool>\",{\"1\":{\"73\":1}}],[\"hash<int>\",{\"1\":{\"73\":1}}],[\"hashbol\",{\"1\":{\"73\":1}}],[\"hashnum\",{\"1\":{\"73\":1}}],[\"hashmap\",{\"1\":{\"68\":1,\"74\":1}}],[\"hashmapopenaddressing\",{\"1\":{\"65\":2}}],[\"hashmapchaining\",{\"1\":{\"63\":2}}],[\"hashfunc\",{\"1\":{\"60\":4,\"63\":4,\"65\":2}}],[\"hash\",{\"1\":{\"58\":1,\"60\":4,\"61\":1,\"69\":3,\"71\":5,\"73\":2},\"2\":{\"77\":1}}],[\"h=2\",{\"1\":{\"113\":1}}],[\"hi\",{\"1\":{\"113\":2}}],[\"h+1\",{\"1\":{\"88\":1}}],[\"h\",{\"1\":{\"85\":1,\"88\":2}}],[\"heng\",{\"1\":{\"287\":4}}],[\"height\",{\"1\":{\"80\":2,\"99\":4,\"100\":2,\"113\":2}}],[\"helloworld\",{\"1\":{\"344\":1,\"348\":1}}],[\"hello\",{\"1\":{\"73\":2,\"226\":1,\"227\":1,\"228\":1,\"231\":1,\"344\":1,\"347\":1,\"348\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1}}],[\"head~1\",{\"1\":{\"320\":2}}],[\"head～n\",{\"1\":{\"314\":1}}],[\"headerdata\",{\"1\":{\"193\":1}}],[\"head\",{\"1\":{\"23\":5,\"24\":5,\"250\":5,\"251\":11,\"252\":1}}],[\"时返回其状态\",{\"1\":{\"300\":1}}],[\"时跳出循环\",{\"1\":{\"92\":1}}],[\"时应该继续遍历\",{\"1\":{\"65\":1}}],[\"时\",{\"1\":{\"54\":2,\"61\":1,\"63\":1,\"68\":1,\"92\":1,\"93\":4,\"102\":1,\"103\":1,\"216\":1,\"240\":1,\"242\":2,\"373\":1}}],[\"时间的风险\",{\"1\":{\"75\":1}}],[\"时间\",{\"1\":{\"58\":3,\"91\":1,\"92\":1,\"93\":3,\"94\":1}}],[\"时间效率\",{\"1\":{\"51\":1}}],[\"时间片轮转调度算法是一种常见的\",{\"1\":{\"27\":1}}],[\"时间片轮转调度算法\",{\"1\":{\"27\":1}}],[\"时间下访问数组中的任意元素\",{\"1\":{\"23\":1}}],[\"时间复杂度的常数项更大\",{\"1\":{\"75\":1}}],[\"时间复杂度是\",{\"1\":{\"75\":1}}],[\"时间复杂度退化至\",{\"1\":{\"69\":1,\"88\":1}}],[\"时间复杂度都为\",{\"1\":{\"50\":1}}],[\"时间复杂度均为\",{\"1\":{\"44\":1}}],[\"时间复杂度\",{\"1\":{\"41\":1,\"47\":1}}],[\"时间复杂度确实是\",{\"1\":{\"36\":1}}],[\"时间复杂度为\",{\"1\":{\"21\":1,\"23\":1,\"32\":1}}],[\"时间复杂度高\",{\"1\":{\"12\":1}}],[\"时间内查询到\",{\"1\":{\"74\":1}}],[\"时间内获取对应的值\",{\"1\":{\"58\":1}}],[\"时间内获取节点内存地址\",{\"1\":{\"36\":1}}],[\"时间内访问和更新元素\",{\"1\":{\"31\":1}}],[\"时间内访问任何元素\",{\"1\":{\"16\":1}}],[\"时间内随机访问数组中的任意一个元素\",{\"1\":{\"10\":1}}],[\"撤销\",{\"1\":{\"54\":2}}],[\"章节中我们提到\",{\"1\":{\"97\":1}}],[\"章节中讨论\",{\"1\":{\"11\":1}}],[\"章节有提到\",{\"1\":{\"54\":1}}],[\"综上\",{\"1\":{\"51\":1}}],[\"综上所述\",{\"1\":{\"51\":1}}],[\"进入函数内部\",{\"1\":{\"374\":1}}],[\"进入子模块目录\",{\"1\":{\"334\":1,\"336\":1}}],[\"进入established状态\",{\"1\":{\"294\":1}}],[\"进入syn\",{\"1\":{\"294\":1}}],[\"进入这个状态\",{\"1\":{\"292\":3}}],[\"进程通信\",{\"2\":{\"234\":1}}],[\"进程是独立的实体\",{\"1\":{\"225\":1}}],[\"进程间通信是操作系统中用于协调和共享数据的重要机制\",{\"1\":{\"232\":1}}],[\"进程间通信\",{\"0\":{\"225\":1},\"1\":{\"225\":1}}],[\"进程接管孤儿进程或采用\",{\"1\":{\"220\":1}}],[\"进程接管\",{\"1\":{\"220\":1}}],[\"进程会自动调用\",{\"1\":{\"220\":1}}],[\"进程\",{\"1\":{\"220\":3}}],[\"进程表项的数量是有限的\",{\"1\":{\"219\":1}}],[\"进程进入终止状态\",{\"1\":{\"216\":1}}],[\"进程进入阻塞状态\",{\"1\":{\"216\":1}}],[\"进程进入运行状态\",{\"1\":{\"216\":1}}],[\"进程在其生命周期内可以在不同状态之间进行转换\",{\"1\":{\"216\":1}}],[\"进程已完成执行或因某种原因被强制终止\",{\"1\":{\"215\":1}}],[\"进程已经被创建并准备好执行\",{\"1\":{\"215\":1}}],[\"进程无法继续执行\",{\"1\":{\"215\":1}}],[\"进程正在\",{\"1\":{\"215\":1}}],[\"进程正在被创建\",{\"1\":{\"215\":1}}],[\"进程的基本状态\",{\"0\":{\"215\":1}}],[\"进程状态之间的转换\",{\"0\":{\"216\":1}}],[\"进程状态\",{\"0\":{\"214\":1}}],[\"进程编程\",{\"0\":{\"213\":1},\"1\":{\"1\":1}}],[\"进阶篇\",{\"1\":{\"122\":1}}],[\"进阶推荐\",{\"0\":{\"122\":1}}],[\"进而决定了键值对在哈希表中的分布情况\",{\"1\":{\"69\":1}}],[\"进行静态编译\",{\"1\":{\"370\":1}}],[\"进行排序\",{\"1\":{\"194\":1}}],[\"进行沟通\",{\"1\":{\"179\":1}}],[\"进行解耦\",{\"1\":{\"177\":1,\"182\":1}}],[\"进行业务逻辑的实现\",{\"1\":{\"127\":1}}],[\"进行探测\",{\"1\":{\"67\":1}}],[\"进行扩容的\",{\"1\":{\"51\":1}}],[\"该表是一个一维数组\",{\"1\":{\"207\":1}}],[\"该模式将这些对象连成一条链\",{\"1\":{\"165\":1}}],[\"该子节点\",{\"1\":{\"93\":1}}],[\"该节点被称为这两个子节点的父节点\",{\"1\":{\"79\":1}}],[\"该位置可以被新元素使用\",{\"1\":{\"75\":1}}],[\"该页面会从栈顶弹出\",{\"1\":{\"54\":1}}],[\"该页面会被添加到栈顶\",{\"1\":{\"54\":1}}],[\"该容量可能超出实际需求\",{\"1\":{\"51\":1}}],[\"该示意图只是定性表示\",{\"1\":{\"36\":1}}],[\"具有很好的应用价值\",{\"1\":{\"97\":1}}],[\"具有很好的缓存本地性\",{\"1\":{\"51\":1}}],[\"具有稳定且高效的性能\",{\"1\":{\"95\":1}}],[\"具体绘制延后到子类实现\",{\"1\":{\"361\":1}}],[\"具体关于条件变量后面会讲到\",{\"1\":{\"259\":1}}],[\"具体地说\",{\"1\":{\"210\":1}}],[\"具体处理者\",{\"1\":{\"166\":1}}],[\"具体工厂\",{\"1\":{\"157\":1,\"160\":1}}],[\"具体产品\",{\"1\":{\"157\":1,\"160\":1}}],[\"具体的绘制由子类实现\",{\"1\":{\"361\":1}}],[\"具体的创建逻辑被封装在工厂类中\",{\"1\":{\"156\":1}}],[\"具体的方法名需要根据所使用的编程语言来确定\",{\"1\":{\"47\":1}}],[\"具体实现步骤如下\",{\"1\":{\"238\":1}}],[\"具体实现类\",{\"1\":{\"150\":1}}],[\"具体实现要添加的功能\",{\"1\":{\"144\":1}}],[\"具体装饰器\",{\"1\":{\"144\":1}}],[\"具体组件\",{\"1\":{\"144\":1}}],[\"具体策略\",{\"1\":{\"139\":1}}],[\"具体策略类\",{\"1\":{\"138\":1}}],[\"具体观察者\",{\"1\":{\"132\":1}}],[\"具体主题\",{\"1\":{\"132\":1}}],[\"具体来说\",{\"1\":{\"65\":1,\"218\":1}}],[\"具体而言\",{\"1\":{\"58\":1}}],[\"具体是如何实现的\",{\"1\":{\"54\":1}}],[\"返回导致停止的信号编号\",{\"1\":{\"302\":1}}],[\"返回导致终止的信号编号\",{\"1\":{\"302\":1}}],[\"返回子进程的退出状态码\",{\"1\":{\"302\":1}}],[\"返回子树的根节点\",{\"1\":{\"108\":1,\"109\":1}}],[\"返回等待的子进程的\",{\"1\":{\"301\":1}}],[\"返回到初始状态\",{\"1\":{\"292\":1}}],[\"返回的结果会保存在future中\",{\"1\":{\"264\":1}}],[\"返回指定索引处的数据\",{\"1\":{\"193\":1}}],[\"返回模型的表头数据\",{\"1\":{\"193\":1}}],[\"返回模型的列数\",{\"1\":{\"193\":1}}],[\"返回模型的行数\",{\"1\":{\"193\":1}}],[\"返回旋转之后的子树的根节点\",{\"1\":{\"113\":1}}],[\"返回旋转后子树的根节点\",{\"1\":{\"102\":1,\"103\":1}}],[\"返回目标节点\",{\"1\":{\"91\":1}}],[\"返回桶索引\",{\"1\":{\"65\":1}}],[\"返回移动后的桶索引\",{\"1\":{\"65\":1}}],[\"返回对应的桶索引\",{\"1\":{\"65\":1}}],[\"返回对应的姓名\",{\"1\":{\"58\":1}}],[\"返回\",{\"1\":{\"50\":1,\"65\":2,\"301\":1}}],[\"返回扩展后的新数组\",{\"1\":{\"15\":1}}],[\"头插法\",{\"1\":{\"49\":1}}],[\"头节点\",{\"1\":{\"18\":1,\"43\":2}}],[\"使其继续执行\",{\"1\":{\"242\":1}}],[\"使其尝试重新锁定互斥量\",{\"1\":{\"238\":1}}],[\"使其对外表现的逻辑符合栈的特性\",{\"1\":{\"48\":1}}],[\"使子进程在后台运行\",{\"1\":{\"222\":1}}],[\"使它们可以独立地变化\",{\"1\":{\"149\":1}}],[\"使树重新恢复平衡\",{\"1\":{\"112\":1}}],[\"使所有失衡节点恢复平衡\",{\"1\":{\"108\":1,\"109\":1}}],[\"使该子树重新恢复平衡\",{\"1\":{\"106\":1,\"108\":1,\"109\":1}}],[\"使失衡节点重新恢复平衡\",{\"1\":{\"101\":1,\"106\":1}}],[\"使得线程休眠等功能\",{\"1\":{\"257\":1}}],[\"使得数据的排序\",{\"1\":{\"194\":1}}],[\"使得前端开发中的数据管理和\",{\"1\":{\"182\":1}}],[\"使得\",{\"1\":{\"175\":1,\"194\":1}}],[\"使得系统更具扩展性和灵活性\",{\"1\":{\"149\":1}}],[\"使得系统更容易维护和扩展\",{\"1\":{\"145\":1}}],[\"使得它们可以互相替换\",{\"1\":{\"137\":1}}],[\"使得它们的哈希值相同\",{\"1\":{\"70\":1}}],[\"使得对象可以独立变化而不影响彼此\",{\"1\":{\"133\":1}}],[\"使得哈希表可以在出现哈希冲突时正常工作\",{\"1\":{\"62\":1}}],[\"使用默认配置\",{\"1\":{\"369\":1}}],[\"使用以下命令克隆并更新子模块到最新提交\",{\"1\":{\"332\":1}}],[\"使用模板类在编译时对字符串进行加密\",{\"1\":{\"286\":1}}],[\"使用模板参数\",{\"1\":{\"251\":1}}],[\"使用时如何选择\",{\"1\":{\"266\":1}}],[\"使用原子变量的计数器\",{\"1\":{\"260\":1}}],[\"使用原子变量实现无锁队列\",{\"0\":{\"250\":1}}],[\"使用方式都类似\",{\"1\":{\"259\":1}}],[\"使用取模操作来实现循环队列\",{\"1\":{\"251\":1}}],[\"使用场景\",{\"1\":{\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1}}],[\"使用代理模型可以在不修改原始模型的情况下\",{\"1\":{\"194\":1}}],[\"使用macos工厂创建产品\",{\"1\":{\"161\":1}}],[\"使用windows工厂创建产品\",{\"1\":{\"161\":1}}],[\"使用链式地址\",{\"1\":{\"74\":1}}],[\"使用链表实现栈时\",{\"1\":{\"49\":1}}],[\"使用大质数作为模数\",{\"1\":{\"71\":1}}],[\"使用伪随机数进行探测\",{\"1\":{\"68\":1}}],[\"使用列表\",{\"1\":{\"63\":1}}],[\"使用迭代器遍历\",{\"1\":{\"59\":1}}],[\"使用\",{\"0\":{\"181\":1,\"372\":1,\"373\":1},\"1\":{\"58\":3,\"91\":1,\"187\":1,\"188\":1,\"194\":1,\"220\":2,\"223\":1,\"250\":1,\"251\":3,\"288\":1,\"302\":1,\"314\":2,\"342\":1,\"353\":3,\"367\":1,\"372\":1,\"373\":1}}],[\"使用两个栈\",{\"1\":{\"54\":1}}],[\"使用双向队列可以方便地实现一些额外操作\",{\"1\":{\"54\":1}}],[\"使用数组实现栈时\",{\"1\":{\"50\":1}}],[\"换句话说\",{\"1\":{\"48\":1,\"60\":1,\"75\":1,\"97\":1,\"101\":1}}],[\"判断栈是否为空\",{\"1\":{\"49\":1,\"50\":1}}],[\"判断是否为空\",{\"1\":{\"47\":1}}],[\"判断队列是否为空\",{\"1\":{\"41\":1,\"43\":1,\"44\":1}}],[\"命名为例\",{\"1\":{\"47\":1}}],[\"命令继续运行内核\",{\"1\":{\"373\":1}}],[\"命令连接到\",{\"1\":{\"373\":1}}],[\"命令及其说明\",{\"0\":{\"310\":1}}],[\"命令及其详细说明\",{\"1\":{\"309\":1}}],[\"命令\",{\"0\":{\"351\":1,\"374\":1},\"1\":{\"4\":1,\"331\":1,\"333\":1,\"334\":1,\"336\":1,\"373\":1},\"2\":{\"283\":1}}],[\"出发\",{\"1\":{\"91\":1}}],[\"出现冲突\",{\"1\":{\"67\":1}}],[\"出栈\",{\"1\":{\"46\":1,\"49\":1,\"50\":1}}],[\"出队操作\",{\"1\":{\"44\":1}}],[\"出队\",{\"1\":{\"40\":1,\"43\":1,\"44\":1}}],[\"入门推荐\",{\"0\":{\"121\":1}}],[\"入栈操作需要初始化节点对象并修改指针\",{\"1\":{\"51\":1}}],[\"入栈和出栈操作都在预先分配好的连续内存中进行\",{\"1\":{\"51\":1}}],[\"入栈与出栈操作分别对应在数组尾部添加元素与删除元素\",{\"1\":{\"50\":1}}],[\"入栈\",{\"1\":{\"46\":1,\"49\":1,\"50\":1}}],[\"入队和出队操作都只需进行一次操作\",{\"1\":{\"44\":1}}],[\"入队操作\",{\"1\":{\"44\":1}}],[\"入队\",{\"1\":{\"40\":1,\"43\":1,\"44\":1}}],[\"底部称为\",{\"1\":{\"46\":1}}],[\"字段\",{\"1\":{\"181\":1}}],[\"字典\",{\"1\":{\"68\":1}}],[\"字符串对比是否一定要用\",{\"1\":{\"113\":1}}],[\"字符串\",{\"1\":{\"73\":1}}],[\"字符\",{\"1\":{\"46\":1}}],[\"字节或\",{\"1\":{\"36\":1}}],[\"字节\",{\"1\":{\"36\":3}}],[\"餐厅的出餐队列等\",{\"1\":{\"45\":1}}],[\"功能的场景\",{\"1\":{\"45\":1}}],[\"先调用子类的析构函数\",{\"1\":{\"209\":1}}],[\"先左旋再右旋\",{\"1\":{\"112\":1}}],[\"先左旋后右旋\",{\"0\":{\"104\":1},\"1\":{\"101\":1,\"104\":1,\"106\":3}}],[\"先右旋再左旋\",{\"1\":{\"112\":1}}],[\"先右旋后左旋\",{\"0\":{\"105\":1},\"1\":{\"101\":1,\"105\":1,\"106\":3}}],[\"先走到尽头\",{\"1\":{\"112\":1}}],[\"先在二叉树中查找到目标节点\",{\"1\":{\"93\":1}}],[\"先抛出结论\",{\"1\":{\"71\":1}}],[\"先计算哈希值\",{\"1\":{\"69\":1}}],[\"先来后到\",{\"1\":{\"45\":1}}],[\"先根据扩容倍数创建一个更大的数组\",{\"1\":{\"34\":1}}],[\"任意节点的左\",{\"1\":{\"89\":1}}],[\"任意节点都可以视作头节点\",{\"1\":{\"26\":1}}],[\"任何需要实现\",{\"1\":{\"45\":1}}],[\"高层模块不应依赖于低层模块\",{\"1\":{\"126\":1}}],[\"高度和深度等\",{\"1\":{\"112\":1}}],[\"高度和深度都需要加\",{\"1\":{\"80\":1}}],[\"高度为\",{\"1\":{\"88\":2}}],[\"高度等达到极大值或极小值\",{\"1\":{\"88\":1}}],[\"高度\",{\"1\":{\"80\":1}}],[\"高效率和均匀分布的特点\",{\"1\":{\"74\":1}}],[\"高\",{\"1\":{\"72\":2}}],[\"高并发成为工程师们需要重点攻克的问题\",{\"1\":{\"45\":1}}],[\"高级数据结构\",{\"1\":{\"27\":1}}],[\"短时间内会产生海量订单\",{\"1\":{\"45\":1}}],[\"购物者下单后\",{\"1\":{\"45\":1}}],[\"淘宝订单\",{\"1\":{\"45\":1}}],[\"有多个状态\",{\"1\":{\"292\":1}}],[\"有std\",{\"1\":{\"264\":1}}],[\"有时候我们如果想真正执行异步操作可以对async进行封装\",{\"1\":{\"264\":1}}],[\"有名管道\",{\"1\":{\"226\":1}}],[\"有了这个函数\",{\"1\":{\"106\":1}}],[\"有左子节点\",{\"1\":{\"103\":1}}],[\"有\",{\"1\":{\"102\":1,\"103\":1}}],[\"有右子节点\",{\"1\":{\"102\":1}}],[\"有兴趣的读者请自行学习\",{\"1\":{\"73\":1}}],[\"有兴趣的读者可以尝试自行实现\",{\"1\":{\"44\":1}}],[\"有助于数据分布得更加均匀\",{\"1\":{\"66\":1}}],[\"有初始值\",{\"1\":{\"30\":2}}],[\"j$\",{\"1\":{\"369\":1}}],[\"joinable\",{\"1\":{\"257\":3}}],[\"join\",{\"1\":{\"236\":5,\"238\":1,\"239\":4,\"240\":2,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":2,\"251\":3,\"257\":5,\"258\":2,\"259\":1,\"261\":1,\"263\":1}}],[\"john\",{\"1\":{\"171\":1,\"187\":1}}],[\"jsdelivr\",{\"1\":{\"181\":1}}],[\"js\",{\"0\":{\"181\":1},\"1\":{\"171\":1,\"181\":2}}],[\"jdk\",{\"1\":{\"68\":1}}],[\"j++\",{\"1\":{\"44\":1}}],[\"j\",{\"1\":{\"44\":2}}],[\"javascript\",{\"1\":{\"173\":1}}],[\"java\",{\"1\":{\"18\":1,\"28\":1,\"34\":1,\"54\":1,\"61\":1,\"68\":1,\"74\":1,\"113\":2}}],[\"~a\",{\"1\":{\"270\":1}}],[\"~arrayhashmap\",{\"1\":{\"60\":1}}],[\"~arrayqueue\",{\"1\":{\"44\":1}}],[\"~threadguard\",{\"1\":{\"257\":1}}],[\"~textbox\",{\"1\":{\"161\":1}}],[\"~lockfreequeue\",{\"1\":{\"250\":1,\"251\":1}}],[\"~linkedliststack\",{\"1\":{\"49\":1}}],[\"~linkedlistqueue\",{\"1\":{\"43\":1}}],[\"~guifactory\",{\"1\":{\"161\":1}}],[\"~button\",{\"1\":{\"161\":1}}],[\"~vehiclefactory\",{\"1\":{\"158\":1}}],[\"~vehicle\",{\"1\":{\"158\":1}}],[\"~shape\",{\"1\":{\"151\":1}}],[\"~color\",{\"1\":{\"151\":1}}],[\"~hashmapopenaddressing\",{\"1\":{\"65\":1}}],[\"~hashmapchaining\",{\"1\":{\"63\":1}}],[\"或使用\",{\"1\":{\"313\":1}}],[\"或类\",{\"1\":{\"218\":1}}],[\"或者下列标志的组合\",{\"1\":{\"300\":1}}],[\"或者系统cpu个数\",{\"1\":{\"257\":1}}],[\"或者\",{\"1\":{\"236\":1,\"316\":1}}],[\"或者由于其他更高优先级的进程需要\",{\"1\":{\"216\":1}}],[\"或者说对合数取模的弊端是什么\",{\"1\":{\"71\":1}}],[\"或\",{\"1\":{\"44\":1,\"47\":1,\"51\":1,\"63\":1,\"187\":1,\"193\":1,\"218\":2,\"220\":4,\"240\":1,\"242\":2,\"351\":1,\"373\":1}}],[\"减少内存拷贝\",{\"1\":{\"270\":1}}],[\"减少读计数器\",{\"1\":{\"239\":1}}],[\"减少信号量\",{\"1\":{\"229\":1}}],[\"减少了手动操作\",{\"1\":{\"179\":1}}],[\"减少客户端与具体类的耦合\",{\"1\":{\"161\":1}}],[\"减少类的数量\",{\"1\":{\"145\":1}}],[\"减少类的复杂性\",{\"1\":{\"126\":1}}],[\"减少耦合\",{\"1\":{\"127\":1}}],[\"减少代码的复杂性\",{\"1\":{\"126\":1}}],[\"减少模块之间的耦合性\",{\"1\":{\"126\":1}}],[\"减少引入新\",{\"1\":{\"126\":1}}],[\"减少哈希冲突\",{\"1\":{\"74\":1}}],[\"减少\",{\"1\":{\"44\":1}}],[\"增强了系统的灵活性和可扩展性\",{\"1\":{\"168\":1}}],[\"增加信号量\",{\"1\":{\"229\":1}}],[\"增加\",{\"1\":{\"44\":2}}],[\"增删的优势可以在其他应用上得到体现\",{\"1\":{\"36\":1}}],[\"索引处\",{\"1\":{\"44\":1}}],[\"索引本质上是内存地址的偏移量\",{\"1\":{\"10\":1}}],[\"各自拥有独立的内存空间\",{\"1\":{\"225\":1}}],[\"各项时间复杂度会劣化至\",{\"1\":{\"112\":1}}],[\"各项操作都变为线性操作\",{\"1\":{\"88\":1}}],[\"各种编程语言采取了不同的哈希表实现策略\",{\"1\":{\"68\":1}}],[\"各种操作的实现方法如下图所示\",{\"1\":{\"44\":1}}],[\"各类待办事项\",{\"1\":{\"45\":1}}],[\"各个节点可以存储不同类型的数据\",{\"1\":{\"36\":1}}],[\"各个节点通过\",{\"1\":{\"18\":1}}],[\"各个参数的设定也非常考究\",{\"1\":{\"34\":1}}],[\"定位对应的桶呢\",{\"1\":{\"60\":1}}],[\"定义一个可执行文件\",{\"1\":{\"344\":1}}],[\"定义一个接口\",{\"1\":{\"132\":1}}],[\"定义项目的名称和版本信息\",{\"1\":{\"344\":1}}],[\"定义项目名称和语言\",{\"1\":{\"344\":1}}],[\"定义常量\",{\"1\":{\"205\":1}}],[\"定义创建产品族中各产品的接口\",{\"1\":{\"160\":1}}],[\"定义创建产品的方法\",{\"1\":{\"157\":1}}],[\"定义产品家族中的各个产品的接口\",{\"1\":{\"160\":1}}],[\"定义实现类的接口\",{\"1\":{\"150\":1}}],[\"定义了处理请求的抽象方法\",{\"1\":{\"166\":1}}],[\"定义了工厂所要创建的对象的接口或抽象类\",{\"1\":{\"157\":1}}],[\"定义了抽象的接口\",{\"1\":{\"150\":1}}],[\"定义了一种一对多的依赖关系\",{\"1\":{\"131\":1}}],[\"定义对象的接口\",{\"1\":{\"144\":1}}],[\"定义算法的通用接口\",{\"1\":{\"138\":1}}],[\"定义为节点左子树的高度减去右子树的高度\",{\"1\":{\"100\":1}}],[\"定义为\",{\"1\":{\"80\":1}}],[\"定义\",{\"1\":{\"44\":1,\"126\":5}}],[\"定量表示需要根据具体情况进行分析\",{\"1\":{\"36\":1}}],[\"描述本次提交的内容\",{\"1\":{\"314\":1}}],[\"描述\",{\"1\":{\"41\":1,\"47\":1}}],[\"尾部称为\",{\"1\":{\"40\":1}}],[\"尾节点视为栈底\",{\"1\":{\"49\":1}}],[\"尾节点都指向该节点\",{\"1\":{\"43\":1}}],[\"尾节点指向空\",{\"1\":{\"26\":1}}],[\"尾节点指向的是\",{\"1\":{\"18\":1}}],[\"尾节点\",{\"1\":{\"18\":1,\"36\":1,\"43\":2}}],[\"队尾\",{\"1\":{\"40\":1,\"43\":1}}],[\"队首指针向后移动一位\",{\"1\":{\"44\":1}}],[\"队首指针\",{\"1\":{\"44\":1}}],[\"队首仅可删除节点\",{\"1\":{\"43\":1}}],[\"队首元素出队\",{\"1\":{\"41\":1}}],[\"队首\",{\"1\":{\"40\":1,\"43\":1}}],[\"队列使用一个动态分配的数组\",{\"1\":{\"251\":1}}],[\"队列中的节点数量是\",{\"1\":{\"113\":1}}],[\"队列是一种遵循先入先出原则的数据结构\",{\"1\":{\"53\":1}}],[\"队列在这些场景中可以有效地维护处理顺序\",{\"1\":{\"45\":1}}],[\"队列典型应用\",{\"0\":{\"45\":1}}],[\"队列已满\",{\"1\":{\"44\":1,\"250\":1,\"251\":1}}],[\"队列容量\",{\"1\":{\"44\":1}}],[\"队列长度\",{\"1\":{\"44\":1}}],[\"队列为空\",{\"1\":{\"43\":1,\"44\":1,\"250\":1,\"251\":1}}],[\"队列实现\",{\"0\":{\"42\":1}}],[\"队列的逻辑\",{\"1\":{\"54\":1}}],[\"队列的结论与前述栈的结论相似\",{\"1\":{\"53\":1}}],[\"队列的常见操作如下表所示\",{\"1\":{\"41\":1}}],[\"队列的先入先出规则\",{\"1\":{\"40\":1}}],[\"队列常用操作\",{\"0\":{\"41\":1}}],[\"队列模拟了排队现象\",{\"1\":{\"40\":1}}],[\"队列和栈\",{\"0\":{\"39\":1}}],[\"队列\",{\"0\":{\"40\":1},\"1\":{\"17\":1,\"27\":1,\"40\":1},\"2\":{\"56\":1}}],[\"队列与栈\",{\"1\":{\"2\":1}}],[\"顾名思义\",{\"1\":{\"40\":1,\"67\":1}}],[\"会暂停并命中断点\",{\"1\":{\"373\":1}}],[\"会下载远程仓库的所有更改\",{\"1\":{\"329\":1}}],[\"会创建一个\",{\"1\":{\"311\":1}}],[\"会根据实际情况决定采用哪种策略\",{\"1\":{\"264\":1}}],[\"会根据这些信号自动更新显示内容\",{\"1\":{\"191\":1}}],[\"会先调用父类的构造函数\",{\"1\":{\"207\":1}}],[\"会自动为每个含有虚函数的类生成一份虚表\",{\"1\":{\"207\":1}}],[\"会自动更新显示\",{\"1\":{\"188\":1}}],[\"会自动更新\",{\"1\":{\"176\":1,\"181\":1}}],[\"会同步更新到页面上\",{\"1\":{\"181\":1}}],[\"会通知所有观察者\",{\"1\":{\"132\":1}}],[\"会通知所有已注册的观察者\",{\"1\":{\"132\":1}}],[\"会执行一次特殊的等量扩容操作\",{\"1\":{\"68\":1}}],[\"会触发扩容机制\",{\"1\":{\"51\":1}}],[\"会导致\",{\"1\":{\"36\":1}}],[\"会发现它们每个元素的\",{\"1\":{\"36\":1}}],[\"操作和使用场景的详细介绍\",{\"1\":{\"330\":1}}],[\"操作对字符进行加密和解密\",{\"1\":{\"288\":1}}],[\"操作减少内存拷贝和移动\",{\"0\":{\"271\":1}}],[\"操作或等待某个事件发生\",{\"1\":{\"216\":1}}],[\"操作系统我只推荐这一本书\",{\"1\":{\"122\":1}}],[\"操作\",{\"0\":{\"311\":1},\"1\":{\"36\":1,\"101\":1,\"102\":1,\"103\":1,\"242\":6}}],[\"一次是geta\",{\"1\":{\"270\":1}}],[\"一系列进程\",{\"1\":{\"246\":1}}],[\"一言以蔽之就是\",{\"1\":{\"207\":1}}],[\"一个包含调试符号的未压缩内核映像\",{\"1\":{\"369\":1}}],[\"一个简单的\",{\"1\":{\"344\":1}}],[\"一个非空的unique\",{\"1\":{\"268\":1}}],[\"一个进程\",{\"1\":{\"246\":1}}],[\"一个是调用join\",{\"1\":{\"257\":1}}],[\"一个是调用\",{\"1\":{\"236\":1}}],[\"一个模块只实现其功能的最小集\",{\"1\":{\"127\":1}}],[\"一个类应只有一个引起其变化的原因\",{\"1\":{\"126\":1}}],[\"一个用于记录当前正在读取的线程数\",{\"1\":{\"239\":1}}],[\"一个用于后一个元素\",{\"1\":{\"36\":1}}],[\"一个用于前一个元素\",{\"1\":{\"36\":1}}],[\"一网打尽\",{\"1\":{\"120\":1}}],[\"一套操作\",{\"1\":{\"113\":1}}],[\"一圈一圈向外扩展\",{\"1\":{\"112\":1}}],[\"一分为二\",{\"1\":{\"79\":1,\"112\":1}}],[\"一部分研究人员努力提升哈希算法的性能\",{\"1\":{\"72\":1}}],[\"一般情况下\",{\"1\":{\"36\":1}}],[\"一方面\",{\"1\":{\"36\":2}}],[\"mtasklist\",{\"1\":{\"364\":2}}],[\"mtx\",{\"1\":{\"238\":2,\"239\":3,\"240\":3}}],[\"mbrower\",{\"1\":{\"364\":2}}],[\"mbrowser\",{\"1\":{\"364\":2}}],[\"mkdir\",{\"1\":{\"350\":1,\"370\":3}}],[\"mylib\",{\"1\":{\"353\":1}}],[\"my\",{\"1\":{\"346\":1,\"353\":4}}],[\"minimum\",{\"1\":{\"344\":2,\"348\":1}}],[\"milliseconds\",{\"1\":{\"258\":1,\"262\":1}}],[\"miprogress\",{\"1\":{\"133\":4}}],[\"mutable\",{\"1\":{\"262\":1,\"287\":1}}],[\"mutual\",{\"1\":{\"246\":1}}],[\"mutex通过多种方式保证了线程安全\",{\"1\":{\"264\":1}}],[\"mutex来保护该变量啦\",{\"1\":{\"260\":1}}],[\"mutex举例吧\",{\"1\":{\"258\":1}}],[\"mutex和std\",{\"1\":{\"258\":1}}],[\"mutex分为四种\",{\"1\":{\"258\":1}}],[\"mutex是一种线程同步的手段\",{\"1\":{\"258\":1}}],[\"mutex相关\",{\"0\":{\"258\":1},\"1\":{\"256\":1}}],[\"mutex>\",{\"1\":{\"238\":1,\"239\":3,\"240\":2,\"259\":2,\"260\":3,\"262\":3}}],[\"mutex\",{\"1\":{\"238\":1,\"239\":1,\"240\":1,\"258\":14,\"259\":4,\"260\":5,\"262\":5}}],[\"menuconfig\",{\"1\":{\"370\":1}}],[\"mem\",{\"1\":{\"362\":6}}],[\"memory\",{\"1\":{\"243\":2,\"248\":3,\"250\":7,\"251\":15,\"252\":6}}],[\"memorystream\",{\"1\":{\"145\":2}}],[\"merge\",{\"1\":{\"324\":2,\"327\":1}}],[\"message\",{\"1\":{\"227\":4,\"231\":1,\"314\":1}}],[\"mstyle\",{\"1\":{\"361\":2}}],[\"mstlye\",{\"1\":{\"361\":1}}],[\"msteam\",{\"1\":{\"145\":6}}],[\"ms\",{\"1\":{\"262\":3}}],[\"msgctl\",{\"1\":{\"227\":1}}],[\"msgrcv\",{\"1\":{\"227\":1}}],[\"msgsnd\",{\"1\":{\"227\":1}}],[\"msgget\",{\"1\":{\"227\":1}}],[\"msgid\",{\"1\":{\"227\":4}}],[\"msg\",{\"1\":{\"226\":3,\"227\":17,\"231\":3}}],[\"mvalue\",{\"1\":{\"363\":3}}],[\"mvp\",{\"0\":{\"177\":1},\"1\":{\"177\":3}}],[\"mvc\",{\"0\":{\"177\":1,\"192\":1},\"1\":{\"177\":4,\"192\":1}}],[\"mvvm\",{\"0\":{\"171\":1,\"172\":1,\"176\":1,\"177\":1,\"178\":1,\"181\":1},\"1\":{\"171\":2,\"172\":1,\"176\":1,\"177\":5,\"180\":1,\"181\":2,\"182\":2},\"2\":{\"184\":1}}],[\"mount\",{\"1\":{\"370\":4}}],[\"mobservers\",{\"1\":{\"363\":3}}],[\"moved\",{\"1\":{\"271\":6}}],[\"move\",{\"1\":{\"151\":3,\"257\":1,\"263\":1,\"270\":1,\"271\":1}}],[\"models\",{\"1\":{\"382\":3}}],[\"model=\",{\"1\":{\"181\":1}}],[\"model\",{\"0\":{\"173\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1},\"1\":{\"171\":1,\"172\":1,\"173\":1,\"175\":5,\"176\":1,\"177\":8,\"179\":1,\"181\":2,\"182\":1,\"185\":4,\"187\":7,\"188\":4,\"189\":2,\"190\":6,\"191\":2,\"192\":3,\"194\":3,\"382\":1},\"2\":{\"196\":1}}],[\"modern\",{\"1\":{\"122\":1}}],[\"moduluskeyhash​=13=\",{\"1\":{\"71\":1}}],[\"moduluskeyhash​=9=\",{\"1\":{\"71\":1}}],[\"modulus\",{\"1\":{\"71\":4}}],[\"mdev\",{\"1\":{\"370\":1}}],[\"mdiscountstrategy\",{\"1\":{\"139\":4}}],[\"md5\",{\"1\":{\"72\":3,\"74\":2}}],[\"mangling\",{\"1\":{\"204\":2}}],[\"managerhandler\",{\"1\":{\"167\":1}}],[\"manager\",{\"1\":{\"167\":7,\"371\":1}}],[\"malloc\",{\"1\":{\"201\":2}}],[\"mactextbox\",{\"1\":{\"161\":2}}],[\"macbutton\",{\"1\":{\"161\":2}}],[\"macosfactory\",{\"1\":{\"161\":1}}],[\"macostextbox\",{\"1\":{\"161\":1}}],[\"macos\",{\"1\":{\"161\":2,\"342\":1}}],[\"macosbutton\",{\"1\":{\"161\":1}}],[\"makefiles\",{\"1\":{\"343\":1,\"357\":1}}],[\"makefile\",{\"1\":{\"341\":1,\"351\":1,\"352\":1,\"357\":1}}],[\"make\",{\"1\":{\"151\":4,\"158\":4,\"161\":6,\"167\":3,\"271\":1,\"352\":1,\"369\":2,\"370\":3}}],[\"main\",{\"1\":{\"133\":1,\"139\":1,\"145\":1,\"151\":1,\"158\":1,\"161\":1,\"167\":1,\"207\":1,\"220\":1,\"222\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":2,\"236\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":1,\"251\":2,\"257\":2,\"258\":2,\"259\":1,\"261\":1,\"263\":2,\"264\":1,\"270\":1,\"271\":1,\"277\":1,\"287\":1,\"288\":1,\"303\":1,\"325\":1,\"327\":1,\"328\":1,\"334\":1,\"344\":1,\"346\":1,\"347\":2,\"348\":1,\"382\":1}}],[\"mainform\",{\"1\":{\"133\":2}}],[\"max\",{\"1\":{\"99\":1}}],[\"map\",{\"1\":{\"59\":11}}],[\"map<int\",{\"1\":{\"59\":1,\"271\":1}}],[\"m\",{\"1\":{\"36\":2,\"97\":2,\"271\":3,\"287\":7,\"288\":1,\"314\":3,\"334\":1,\"335\":1,\"336\":1}}],[\"个键值对\",{\"1\":{\"68\":1}}],[\"个桶\",{\"1\":{\"60\":1}}],[\"个学生\",{\"1\":{\"58\":1}}],[\"个节点对象也分散存储在内存各处\",{\"1\":{\"36\":1}}],[\"个节点需要循环\",{\"1\":{\"23\":1}}],[\"个元素的地址是相连的\",{\"1\":{\"36\":1}}],[\"×1\",{\"1\":{\"36\":1}}],[\"长度\",{\"1\":{\"36\":1}}],[\"长度不可变的性质会导致列表的实用性降低\",{\"1\":{\"28\":1}}],[\"长度不可变\",{\"1\":{\"16\":1,\"25\":1}}],[\"浅蓝色的存储节点指针是占用一块内存地址吗\",{\"1\":{\"36\":1}}],[\"再到连接关闭的整个过程\",{\"1\":{\"296\":1}}],[\"再次\",{\"1\":{\"223\":1}}],[\"再更新\",{\"1\":{\"176\":1}}],[\"再递归地构建左右子树\",{\"1\":{\"113\":1}}],[\"再回溯继续\",{\"1\":{\"112\":1}}],[\"再对\",{\"1\":{\"104\":1,\"105\":1}}],[\"再对数组长度取模\",{\"1\":{\"69\":1}}],[\"再例如\",{\"1\":{\"97\":1}}],[\"再将其删除\",{\"1\":{\"93\":1}}],[\"再将当前数组的所有元素依次移动至新数组\",{\"1\":{\"34\":1}}],[\"再从数组\",{\"1\":{\"58\":1}}],[\"再删除元素\",{\"1\":{\"36\":1}}],[\"那我们就再也无法控制线程什么时候结束了\",{\"1\":{\"236\":1,\"257\":1}}],[\"那使用虚函数也没有实际意义呀\",{\"1\":{\"210\":1}}],[\"那\",{\"1\":{\"113\":1}}],[\"那为什么时间复杂度不是\",{\"1\":{\"36\":1}}],[\"那么拷贝结束后\",{\"1\":{\"268\":1}}],[\"那么在这种情况下\",{\"1\":{\"210\":1}}],[\"那么在这个对象的生命期内\",{\"1\":{\"210\":1}}],[\"那么为什么会出现多态性\",{\"1\":{\"207\":1}}],[\"那么就设计为\",{\"1\":{\"113\":1}}],[\"那么通常比哈希表更快\",{\"1\":{\"75\":1}}],[\"那么选择质数或者合数作为模数都可以\",{\"1\":{\"71\":1}}],[\"那么哈希值就会出现聚堆\",{\"1\":{\"71\":1}}],[\"那么所有可以被\",{\"1\":{\"71\":1}}],[\"那么数据就被视为完整\",{\"1\":{\"70\":1}}],[\"那么密码就被视为正确\",{\"1\":{\"70\":1}}],[\"那么需要两个栈来配合实现\",{\"1\":{\"52\":1}}],[\"那么可以省去初始化步骤\",{\"1\":{\"51\":1}}],[\"那么可以用数组存储\",{\"1\":{\"17\":1}}],[\"那么\",{\"1\":{\"36\":1,\"60\":1}}],[\"那么它会影响后继节点的内存回收\",{\"1\":{\"36\":1}}],[\"那么多余的空间就被浪费了\",{\"1\":{\"16\":1}}],[\"不启动图形界面\",{\"1\":{\"372\":1}}],[\"不管还有没有weak\",{\"1\":{\"269\":1}}],[\"不计数\",{\"1\":{\"269\":1}}],[\"不带超时功能\",{\"1\":{\"258\":2}}],[\"不需要使用互斥量\",{\"1\":{\"264\":1}}],[\"不需要像packaged\",{\"1\":{\"264\":1}}],[\"不需要同步内存顺序\",{\"1\":{\"252\":1}}],[\"不需要加锁解锁\",{\"1\":{\"241\":1}}],[\"不能用在stl标准容器中\",{\"1\":{\"268\":1}}],[\"不能递归\",{\"1\":{\"258\":1}}],[\"不能递归使用\",{\"1\":{\"258\":1}}],[\"不能再通过join来等待线程执行完\",{\"1\":{\"257\":1}}],[\"不能再通过join来等待线程执行完成\",{\"1\":{\"236\":1}}],[\"不能直接删除元素\",{\"1\":{\"67\":1}}],[\"不是对象的动态行为\",{\"1\":{\"210\":1}}],[\"不是程序代码\",{\"1\":{\"208\":1}}],[\"不可能通过父类的指针或者引用去调用\",{\"1\":{\"210\":1}}],[\"不可能存储在代码段\",{\"1\":{\"208\":1}}],[\"不必动态分配内存空间存储虚函数表\",{\"1\":{\"208\":1}}],[\"不易跟踪数据的流动\",{\"1\":{\"180\":1}}],[\"不直接与\",{\"1\":{\"187\":1}}],[\"不直接依赖\",{\"1\":{\"177\":1}}],[\"不直接操作\",{\"1\":{\"175\":1}}],[\"不希望通过修改已有代码或继承来实现\",{\"1\":{\"143\":1}}],[\"不应强迫一个类依赖于它不需要的接口\",{\"1\":{\"126\":1}}],[\"不属于右旋操作的维护范围\",{\"1\":{\"113\":1}}],[\"不匹配\",{\"1\":{\"75\":1}}],[\"不难发现\",{\"1\":{\"72\":1}}],[\"不存在\",{\"1\":{\"65\":1}}],[\"不存在上述数组扩容时效率降低的问题\",{\"1\":{\"51\":1}}],[\"不引入额外的数据结构\",{\"1\":{\"64\":1}}],[\"不过这本书我更推荐有一定基础\",{\"1\":{\"122\":1}}],[\"不过\",{\"1\":{\"51\":1}}],[\"不同编程语言采取了不同的哈希表实现\",{\"1\":{\"74\":1}}],[\"不同编程语言的内置哈希值计算函数的定义和方法不同\",{\"1\":{\"73\":1}}],[\"不同编程语言的方法名称可能会有所不同\",{\"1\":{\"41\":1}}],[\"不同类型的节点值占用的空间是不同的\",{\"1\":{\"36\":1}}],[\"不会创建线程\",{\"1\":{\"264\":1}}],[\"不会引起数据竞争\",{\"1\":{\"248\":1}}],[\"不会\",{\"1\":{\"36\":1}}],[\"不断开没有关系\",{\"1\":{\"36\":1}}],[\"不修改\",{\"1\":{\"36\":1}}],[\"从内存中申请一个对象\",{\"1\":{\"362\":2}}],[\"从项目中移除子模块\",{\"1\":{\"335\":1}}],[\"从远程仓库获取最新的提交和分支信息\",{\"1\":{\"329\":1}}],[\"从远程仓库拉取更改并合并到本地分支\",{\"1\":{\"327\":1}}],[\"从远程仓库克隆一个仓库到本地\",{\"1\":{\"311\":1}}],[\"从队列中取出元素\",{\"1\":{\"251\":1}}],[\"从刚创建对象开始就会新建一个线程用于执行函数\",{\"1\":{\"236\":1,\"257\":1}}],[\"从管道读取\",{\"1\":{\"226\":1}}],[\"从实现上看\",{\"1\":{\"210\":1}}],[\"从使用角度\",{\"1\":{\"210\":1}}],[\"从存储空间角度\",{\"1\":{\"210\":1}}],[\"从结果分析子类体现了多态性\",{\"1\":{\"207\":1}}],[\"从\",{\"1\":{\"188\":1,\"335\":2}}],[\"从入门\",{\"1\":{\"120\":1}}],[\"从该节点到根节点的路径上可能会出现一系列失衡节点\",{\"1\":{\"108\":1}}],[\"从该链表的角度看\",{\"1\":{\"36\":1}}],[\"从底至顶看\",{\"1\":{\"102\":1}}],[\"从根节点出发\",{\"1\":{\"92\":1}}],[\"从根节点到该节点所经过的边的数量\",{\"1\":{\"80\":1}}],[\"从根节点到最远叶节点所经过的边的数量\",{\"1\":{\"80\":1}}],[\"从二叉树的根节点\",{\"1\":{\"91\":1}}],[\"从距离该节点最远的叶节点到该节点所经过的边的数量\",{\"1\":{\"80\":1}}],[\"从顶至底递增\",{\"1\":{\"80\":1}}],[\"从中删除键值对\",{\"1\":{\"63\":2}}],[\"从本质上看\",{\"1\":{\"61\":1}}],[\"从栈\",{\"1\":{\"54\":2}}],[\"从标准库的角度看\",{\"1\":{\"36\":1}}],[\"从数据结构与算法\",{\"1\":{\"36\":1}}],[\"从头节点遍历到尾节点已经不会遇到\",{\"1\":{\"36\":1}}],[\"从而保持线性历史\",{\"1\":{\"325\":1}}],[\"从而不会以明文形式出现在可执行文件中\",{\"1\":{\"286\":1}}],[\"从而提高运行时性能\",{\"1\":{\"285\":1}}],[\"从而提高效率\",{\"1\":{\"51\":1}}],[\"从而脱离控制终端\",{\"1\":{\"223\":1}}],[\"从而防止僵尸进程的产生\",{\"1\":{\"220\":1}}],[\"从而导致的进程状态\",{\"1\":{\"218\":1}}],[\"从而导致以下不同点\",{\"1\":{\"36\":1}}],[\"从而实现进程在后台运行\",{\"1\":{\"223\":1}}],[\"从而实现多态性\",{\"1\":{\"207\":1}}],[\"从而实现哈希冲突的缓解\",{\"1\":{\"75\":1}}],[\"从而在调用虚函数时\",{\"1\":{\"207\":1}}],[\"从而让vptr指向正确的虚表\",{\"1\":{\"207\":1}}],[\"从而使代码更具可维护性和可测试性\",{\"1\":{\"171\":1}}],[\"从而使得各种操作的时间复杂度保持在\",{\"1\":{\"97\":1}}],[\"从而避免请求的发送者和接收者之间的耦合\",{\"1\":{\"165\":1}}],[\"从而避免哈希冲突\",{\"1\":{\"71\":1}}],[\"从而得出一个重要性质\",{\"1\":{\"94\":1}}],[\"从而完成节点插入操作\",{\"1\":{\"92\":1}}],[\"从而访问对应桶并获取\",{\"1\":{\"74\":1}}],[\"从而访问到对应的节点\",{\"1\":{\"36\":1}}],[\"从而加重哈希冲突\",{\"1\":{\"71\":1}}],[\"从而破解密码\",{\"1\":{\"70\":1}}],[\"从而优化查询效率\",{\"1\":{\"65\":1}}],[\"从而进一步促使该位置的聚堆生长\",{\"1\":{\"65\":1}}],[\"从而将查询操作的时间复杂度优化至\",{\"1\":{\"63\":1}}],[\"从而简化代码\",{\"1\":{\"63\":1}}],[\"从而获取\",{\"1\":{\"60\":1}}],[\"从而获取该\",{\"1\":{\"60\":1}}],[\"从而引入扩容机制\",{\"1\":{\"44\":1}}],[\"从而难以选择合适的列表长度\",{\"1\":{\"28\":1}}],[\"从而借助高速缓存来提升后续操作的执行速度\",{\"1\":{\"16\":1}}],[\"从而无法安全地扩展数组容量\",{\"1\":{\"15\":1}}],[\"从而直接访问该元素\",{\"1\":{\"10\":1}}],[\"呢\",{\"1\":{\"36\":2,\"75\":1}}],[\"设置变量\",{\"1\":{\"353\":1}}],[\"设置文件权限掩码\",{\"1\":{\"222\":1,\"223\":1}}],[\"设置新的会话等\",{\"1\":{\"221\":1}}],[\"设置模型\",{\"1\":{\"190\":1}}],[\"设置责任链\",{\"1\":{\"167\":1}}],[\"设置下一个处理者\",{\"1\":{\"167\":1}}],[\"设平衡因子为\",{\"1\":{\"100\":1}}],[\"设数组长度\",{\"1\":{\"60\":1}}],[\"设为\",{\"1\":{\"36\":1}}],[\"设计健壮的网络服务非常重要\",{\"1\":{\"296\":1}}],[\"设计模式是解决常见软件设计问题的通用解决方案\",{\"1\":{\"125\":1}}],[\"设计模式\",{\"0\":{\"125\":1},\"2\":{\"5\":1,\"129\":1,\"135\":1,\"141\":1,\"147\":1,\"153\":1,\"163\":1,\"170\":1,\"184\":1,\"196\":1,\"366\":1}}],[\"设计原则是指导代码设计的基本准则\",{\"1\":{\"126\":1}}],[\"设计原则\",{\"0\":{\"124\":1,\"126\":1},\"1\":{\"3\":1},\"2\":{\"129\":1}}],[\"后跟要合并的分支名称\",{\"1\":{\"324\":1}}],[\"后跟分支名称\",{\"1\":{\"322\":1}}],[\"后跟文件\",{\"1\":{\"318\":1}}],[\"后跟文件路径\",{\"1\":{\"313\":1}}],[\"后跟仓库\",{\"1\":{\"311\":1}}],[\"后发送syn包\",{\"1\":{\"294\":1}}],[\"后使父进程退出\",{\"1\":{\"220\":1}}],[\"后变量不会释放\",{\"1\":{\"200\":1}}],[\"后序遍历是三种二叉树遍历方法\",{\"1\":{\"113\":1}}],[\"后序遍历皆属于深度优先搜索\",{\"1\":{\"112\":1}}],[\"后三种顺序\",{\"1\":{\"113\":1}}],[\"后代\",{\"1\":{\"79\":1}}],[\"后两位相同时\",{\"1\":{\"61\":1}}],[\"后退操作实际上是在执行出栈\",{\"1\":{\"52\":1}}],[\"后\",{\"1\":{\"36\":2}}],[\"8b\",{\"1\":{\"382\":1}}],[\"8080\",{\"1\":{\"231\":2,\"382\":1}}],[\"8\",{\"0\":{\"320\":1,\"338\":1,\"355\":1},\"1\":{\"36\":2,\"68\":3,\"71\":1}}],[\"单步执行代码\",{\"1\":{\"374\":2}}],[\"单一职责\",{\"1\":{\"127\":1}}],[\"单一职责原则\",{\"1\":{\"126\":1}}],[\"单向绑定\",{\"1\":{\"176\":1}}],[\"单向性\",{\"1\":{\"70\":1}}],[\"单向链表通常用于实现栈\",{\"1\":{\"27\":1}}],[\"单向链表的节点包含值和指向下一节点的引用两项数据\",{\"1\":{\"26\":1}}],[\"单向链表\",{\"1\":{\"26\":1}}],[\"单次入栈操作的时间复杂度会劣化至\",{\"1\":{\"53\":1}}],[\"单个元素分别占用\",{\"1\":{\"36\":1}}],[\"两个线程同时运行\",{\"1\":{\"251\":1}}],[\"两个不同的\",{\"1\":{\"74\":1}}],[\"两个学号指向了同一个姓名\",{\"1\":{\"61\":1}}],[\"两项数据\",{\"1\":{\"58\":1}}],[\"两种模式\",{\"1\":{\"231\":1}}],[\"两种符号的工作原理是不同的\",{\"1\":{\"113\":1}}],[\"两种实现都支持栈定义中的各项操作\",{\"1\":{\"51\":1}}],[\"两种实现对比\",{\"0\":{\"51\":1}}],[\"两种实现的对比结论与栈一致\",{\"1\":{\"44\":1}}],[\"两种类型\",{\"1\":{\"36\":1}}],[\"两者的特点呈现出互补的特性\",{\"1\":{\"35\":1}}],[\"连接关闭时的状态\",{\"1\":{\"295\":1}}],[\"连接已建立\",{\"1\":{\"295\":1}}],[\"连接彻底关闭\",{\"1\":{\"292\":1}}],[\"连接的主动关闭方\",{\"1\":{\"292\":1}}],[\"连接状态\",{\"0\":{\"291\":1}}],[\"连接共享内存\",{\"1\":{\"228\":2}}],[\"连接两个节点的线段\",{\"1\":{\"80\":1}}],[\"连接\",{\"1\":{\"36\":1,\"372\":1}}],[\"连续空间存储和分散空间存储\",{\"1\":{\"35\":1}}],[\"连续空间存储是一把双刃剑\",{\"1\":{\"16\":1}}],[\"连续内存空间\",{\"1\":{\"25\":1}}],[\"灵活性高\",{\"1\":{\"145\":1}}],[\"灵活性\",{\"1\":{\"36\":1}}],[\"大家有需要可以留言\",{\"1\":{\"262\":1}}],[\"大量僵尸进程可能会让系统管理者难以管理和监控系统状态\",{\"1\":{\"219\":1}}],[\"大量的数据绑定可能会引起性能问题\",{\"1\":{\"180\":1}}],[\"大小确定\",{\"1\":{\"208\":1}}],[\"大小限制\",{\"1\":{\"36\":1}}],[\"大多为\",{\"1\":{\"36\":1}}],[\"大多数编程语言会将数组元素初始化为\",{\"1\":{\"9\":1}}],[\"更方便实现实现保护\",{\"1\":{\"264\":1}}],[\"更改工作目录\",{\"1\":{\"222\":1,\"223\":1}}],[\"更适合需要复杂数据绑定和动态\",{\"1\":{\"177\":1}}],[\"更新\",{\"1\":{\"338\":1}}],[\"更新子模块\",{\"1\":{\"332\":1}}],[\"更新头部指针\",{\"1\":{\"251\":1}}],[\"更新显示\",{\"1\":{\"187\":1}}],[\"更新的应用\",{\"1\":{\"177\":1}}],[\"更新节点高度\",{\"1\":{\"99\":1,\"102\":1,\"103\":1,\"108\":1,\"109\":1}}],[\"更新元素\",{\"1\":{\"31\":1}}],[\"更近的桶\",{\"1\":{\"65\":1}}],[\"更占用空间\",{\"1\":{\"36\":1}}],[\"更容易碎片化\",{\"1\":{\"36\":1}}],[\"栈是一种遵循先入后出原则的数据结构\",{\"1\":{\"53\":1}}],[\"栈是一块较小的内存\",{\"1\":{\"36\":1}}],[\"栈为空\",{\"1\":{\"49\":1,\"50\":1}}],[\"栈遵循先入后出的原则\",{\"1\":{\"48\":1}}],[\"栈的数组实现可能导致一定程度的空间浪费\",{\"1\":{\"53\":1}}],[\"栈的数组实现具有较高的平均效率\",{\"1\":{\"53\":1}}],[\"栈的链表实现具有更为稳定的效率表现\",{\"1\":{\"53\":1}}],[\"栈的典型应用\",{\"0\":{\"52\":1}}],[\"栈的长度\",{\"1\":{\"49\":1}}],[\"栈的实现\",{\"0\":{\"48\":1}}],[\"栈的常用操作如下表所示\",{\"1\":{\"47\":1}}],[\"栈的常用操作\",{\"0\":{\"47\":1}}],[\"栈的先入后出规则\",{\"1\":{\"46\":1}}],[\"栈底\",{\"1\":{\"46\":1}}],[\"栈顶元素出栈\",{\"1\":{\"47\":1}}],[\"栈顶\",{\"1\":{\"46\":1}}],[\"栈\",{\"0\":{\"46\":1},\"1\":{\"46\":1,\"54\":3},\"2\":{\"56\":1}}],[\"栈和队列往往会使用编程语言提供的\",{\"1\":{\"36\":1}}],[\"栈和堆具有各自的特点\",{\"1\":{\"36\":1}}],[\"栈上的数组的大小需要在编译时确定\",{\"1\":{\"36\":1}}],[\"栈内存相对较小\",{\"1\":{\"36\":1}}],[\"栈与队列\",{\"1\":{\"27\":1}}],[\"然后使用\",{\"1\":{\"373\":1}}],[\"然后拉取最新的更改\",{\"1\":{\"334\":1}}],[\"然后\",{\"1\":{\"286\":1}}],[\"然后子进程立即退出\",{\"1\":{\"220\":1}}],[\"然后再调用基类的析构函数\",{\"1\":{\"209\":1}}],[\"然后构建引用\",{\"1\":{\"82\":1}}],[\"然后将中点元素作为根节点\",{\"1\":{\"113\":1}}],[\"然后将这些哈希值组合起来\",{\"1\":{\"73\":1}}],[\"然后将节点\",{\"1\":{\"63\":1}}],[\"然后与存储的哈希值进行比较\",{\"1\":{\"70\":1}}],[\"然后遍历链表并对比\",{\"1\":{\"63\":1}}],[\"然后把原数组元素依次复制到新数组\",{\"1\":{\"15\":1}}],[\"然而virtual\",{\"1\":{\"210\":1}}],[\"然而对于某些要求不高的场景\",{\"1\":{\"71\":1}}],[\"然而该哈希算法过于简单\",{\"1\":{\"70\":1}}],[\"然而无论是开放寻址还是链式地址\",{\"1\":{\"69\":1}}],[\"然而\",{\"1\":{\"36\":3,\"44\":2,\"47\":1,\"48\":1,\"51\":2,\"65\":2,\"66\":1,\"74\":1,\"75\":1,\"95\":1,\"113\":1}}],[\"qemu\",{\"0\":{\"371\":1,\"372\":1},\"1\":{\"367\":2,\"371\":3,\"372\":4,\"373\":2,\"374\":1},\"2\":{\"377\":1}}],[\"qidentityproxymodel\",{\"1\":{\"194\":1}}],[\"qsortfilterproxymodel\",{\"1\":{\"194\":4}}],[\"qstring\",{\"1\":{\"193\":1}}],[\"qstringlistmodel\",{\"1\":{\"187\":1}}],[\"qstyleoptionviewitem\",{\"1\":{\"189\":1}}],[\"qstyleditemdelegate\",{\"1\":{\"189\":4}}],[\"qstandarditem\",{\"1\":{\"187\":4}}],[\"qstandarditemmodel\",{\"1\":{\"187\":5,\"188\":1}}],[\"qvariant\",{\"1\":{\"193\":2}}],[\"qmodelindex\",{\"1\":{\"189\":1,\"193\":5}}],[\"qpainter\",{\"1\":{\"189\":1}}],[\"qobject\",{\"1\":{\"189\":1,\"193\":1}}],[\"qlistview\",{\"1\":{\"188\":2}}],[\"qabstractlistmodel\",{\"1\":{\"187\":2,\"193\":1}}],[\"qabstracttablemodel\",{\"1\":{\"187\":2,\"193\":3}}],[\"qabstractitemmodel\",{\"1\":{\"187\":2,\"193\":1}}],[\"qtreeview\",{\"1\":{\"188\":2}}],[\"qtableview\",{\"1\":{\"188\":5}}],[\"qt\",{\"0\":{\"192\":1},\"1\":{\"185\":2,\"187\":2,\"188\":1,\"189\":2,\"191\":1,\"192\":3,\"193\":3,\"194\":4},\"2\":{\"196\":1}}],[\"quecapacity\",{\"1\":{\"44\":7}}],[\"quesize++\",{\"1\":{\"43\":1,\"44\":1}}],[\"quesize\",{\"1\":{\"43\":5,\"44\":8}}],[\"queue<int>\",{\"1\":{\"41\":1}}],[\"queue\",{\"1\":{\"36\":1,\"40\":1,\"41\":10,\"43\":2,\"250\":5,\"251\":8}}],[\"q\",{\"0\":{\"36\":1,\"54\":1,\"75\":1,\"113\":1},\"1\":{\"36\":10,\"54\":4,\"75\":6,\"113\":8,\"189\":1,\"193\":1}}],[\"应该没谁比c++之父更有发言权吧\",{\"1\":{\"122\":1}}],[\"应采用的旋转方法\",{\"1\":{\"106\":1}}],[\"应用示例\",{\"0\":{\"181\":1}}],[\"应用场景\",{\"0\":{\"168\":1}}],[\"应用\",{\"1\":{\"72\":1}}],[\"应当极难找到两个不同的输入\",{\"1\":{\"70\":1}}],[\"应根据具体需求和场景做出恰当选择\",{\"1\":{\"35\":1}}],[\"应被替换为\",{\"1\":{\"18\":1}}],[\"预取机制以及空间局部性和时间局部性等数据加载机制\",{\"1\":{\"35\":1}}],[\"同步\",{\"1\":{\"292\":1}}],[\"同时\",{\"1\":{\"176\":1}}],[\"同时维护一个指向下一个处理者的引用\",{\"1\":{\"166\":1}}],[\"同时避免类爆炸问题\",{\"1\":{\"151\":1}}],[\"同时规定空节点的平衡因子为\",{\"1\":{\"100\":1}}],[\"同时满足这两类二叉树的所有性质\",{\"1\":{\"98\":1}}],[\"同时可以灵活调整长度\",{\"1\":{\"35\":1}}],[\"同样可以通过数组或链表来实现\",{\"1\":{\"53\":1}}],[\"同理可得右子树\",{\"1\":{\"79\":1}}],[\"同理\",{\"1\":{\"12\":1,\"103\":1}}],[\"通知\",{\"1\":{\"187\":1,\"190\":1,\"240\":1}}],[\"通知数据变更\",{\"1\":{\"187\":1}}],[\"通常\",{\"1\":{\"343\":1}}],[\"通常跟\",{\"1\":{\"314\":1}}],[\"通常用布尔值或整数表示\",{\"1\":{\"238\":1}}],[\"通常会使用日志文件或\",{\"1\":{\"224\":1}}],[\"通常不与任何终端关联\",{\"1\":{\"221\":1}}],[\"通常是2分钟\",{\"1\":{\"292\":1}}],[\"通常是客户端\",{\"1\":{\"292\":1}}],[\"通常是纯粹的\",{\"1\":{\"173\":1}}],[\"通常是具体的业务逻辑类\",{\"1\":{\"150\":1}}],[\"通常包含一个实现部分的引用\",{\"1\":{\"150\":1}}],[\"通常使用递归来实现\",{\"1\":{\"112\":1}}],[\"通常通过队列来实现\",{\"1\":{\"112\":1}}],[\"通常认为时间复杂度是\",{\"1\":{\"75\":1}}],[\"通常情况下哈希函数的输入空间远大于输出空间\",{\"1\":{\"62\":1}}],[\"通常情况下\",{\"1\":{\"47\":1,\"74\":1}}],[\"通常情况下这\",{\"1\":{\"36\":1}}],[\"通常比\",{\"1\":{\"36\":1}}],[\"通常基于动态数组实现\",{\"1\":{\"35\":1}}],[\"通过以上基本操作和命令\",{\"1\":{\"357\":1}}],[\"通过上述命令\",{\"1\":{\"338\":1}}],[\"通过正确使用\",{\"1\":{\"306\":1}}],[\"通过传递特定的\",{\"1\":{\"305\":1}}],[\"通过分析tcp连接的状态\",{\"1\":{\"296\":1}}],[\"通过右值引用\",{\"1\":{\"270\":1}}],[\"通过async可以直接创建异步的任务\",{\"1\":{\"264\":1}}],[\"通过get\",{\"1\":{\"263\":1}}],[\"通过及时调用\",{\"1\":{\"220\":1}}],[\"通过这种方式\",{\"1\":{\"288\":1}}],[\"通过这种设计\",{\"1\":{\"192\":1}}],[\"通过这种模式\",{\"1\":{\"151\":1}}],[\"通过信号通知\",{\"1\":{\"190\":1}}],[\"通过委托机制\",{\"1\":{\"194\":1}}],[\"通过委托\",{\"1\":{\"189\":1}}],[\"通过访问\",{\"1\":{\"188\":1}}],[\"通过将数据和显示逻辑解耦\",{\"1\":{\"185\":1}}],[\"通过数据绑定机制进行通信\",{\"1\":{\"177\":1}}],[\"通过定义一组工厂接口\",{\"1\":{\"161\":1}}],[\"通过桥接模式\",{\"1\":{\"151\":1}}],[\"通过继承的方式会导致子类的\",{\"1\":{\"145\":1}}],[\"通过在方法中调用组件对象的方法\",{\"1\":{\"144\":1}}],[\"通过使用观察者模式\",{\"1\":{\"133\":1}}],[\"通过添加抽象接口层\",{\"1\":{\"127\":1}}],[\"通过多个特定接口来代替单一的总接口\",{\"1\":{\"126\":1}}],[\"通过抽象和接口\",{\"1\":{\"126\":1}}],[\"通过\",{\"1\":{\"113\":1,\"189\":1,\"190\":1,\"191\":1,\"251\":1,\"342\":1,\"355\":1}}],[\"通过重写对象的哈希方法\",{\"1\":{\"73\":1}}],[\"通过哈希函数计算桶索引\",{\"1\":{\"65\":1}}],[\"通过某种哈希算法\",{\"1\":{\"60\":1}}],[\"通过取余操作实现\",{\"1\":{\"44\":1}}],[\"通过索引遍历列表\",{\"1\":{\"33\":1}}],[\"通过索引遍历数组\",{\"1\":{\"13\":1}}],[\"通过引用指向\",{\"1\":{\"20\":1}}],[\"通过它可以从当前节点访问到下一个节点\",{\"1\":{\"18\":1}}],[\"且没有立即可用的子进程终止状态\",{\"1\":{\"301\":1}}],[\"且值相同\",{\"1\":{\"202\":1}}],[\"且最底层节点尽量靠左填充\",{\"1\":{\"86\":1}}],[\"且容易产生聚集\",{\"1\":{\"74\":1}}],[\"且链表长度达到\",{\"1\":{\"68\":1}}],[\"且可以灵活调整长度\",{\"1\":{\"35\":1}}],[\"且初始化后长度不可变\",{\"1\":{\"35\":1}}],[\"且元素类型相同\",{\"1\":{\"16\":1}}],[\"分离任务逻辑和执行实现\",{\"1\":{\"364\":1}}],[\"分离共享内存\",{\"1\":{\"228\":2}}],[\"分支管理\",{\"0\":{\"321\":1}}],[\"分为计数信号量和二进制信号量\",{\"1\":{\"242\":1}}],[\"分\",{\"1\":{\"93\":1}}],[\"分治\",{\"1\":{\"88\":1}}],[\"分布越均匀\",{\"1\":{\"70\":1}}],[\"分别运行在线程对象\",{\"1\":{\"236\":1}}],[\"分别有什么用呢\",{\"1\":{\"113\":1}}],[\"分别指向其左子节点和右子节点\",{\"1\":{\"112\":1}}],[\"分别指向左子节点\",{\"1\":{\"79\":1}}],[\"分别需要采用右旋\",{\"1\":{\"106\":1}}],[\"分别用于获取和更新节点的高度\",{\"1\":{\"99\":1}}],[\"分别视为\",{\"1\":{\"43\":1}}],[\"分别代表数据在计算机内存中的两种存储方式\",{\"1\":{\"35\":1}}],[\"分配了必要的资源后\",{\"1\":{\"216\":1}}],[\"分配由编译器自动完成\",{\"1\":{\"36\":1}}],[\"分配和释放效率\",{\"1\":{\"36\":1}}],[\"分散内存空间\",{\"1\":{\"25\":1}}],[\"倍\",{\"1\":{\"34\":1,\"51\":1,\"61\":1,\"63\":1}}],[\"初始状态\",{\"1\":{\"292\":1}}],[\"初始容量\",{\"1\":{\"34\":1,\"51\":1}}],[\"初始化绘制参数op\",{\"1\":{\"361\":1}}],[\"初始化op\",{\"1\":{\"361\":2}}],[\"初始化之后\",{\"1\":{\"332\":1}}],[\"初始化指针并将引用计数置为1\",{\"1\":{\"267\":1}}],[\"初始化信号量\",{\"1\":{\"229\":1}}],[\"初始化的字符串都存储在字符串常量池中\",{\"1\":{\"113\":1}}],[\"初始化节点\",{\"1\":{\"82\":1,\"92\":1}}],[\"初始化二叉树\",{\"0\":{\"82\":1},\"1\":{\"82\":1}}],[\"初始化扩容后的新哈希表\",{\"1\":{\"63\":1,\"65\":1}}],[\"初始化哈希表\",{\"1\":{\"59\":1}}],[\"初始化\",{\"1\":{\"59\":1,\"332\":1}}],[\"初始化栈\",{\"1\":{\"47\":1}}],[\"初始化队列\",{\"1\":{\"41\":1}}],[\"初始化列表\",{\"0\":{\"30\":1},\"1\":{\"30\":1,\"36\":1}}],[\"初始化各个节点\",{\"1\":{\"20\":1}}],[\"初始化完成后\",{\"1\":{\"20\":1}}],[\"初始化链表\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"初始化一个扩展长度后的数组\",{\"1\":{\"15\":1}}],[\"初始化数组\",{\"0\":{\"9\":1},\"1\":{\"9\":1,\"44\":1,\"60\":1}}],[\"包后进入这个状态\",{\"1\":{\"292\":2}}],[\"包括对数据的增删改查操作\",{\"1\":{\"187\":1}}],[\"包括以下三个重点设计\",{\"1\":{\"34\":1}}],[\"包含目录\",{\"1\":{\"353\":1}}],[\"包含构建系统的配置和构建指令\",{\"1\":{\"343\":1}}],[\"包含子进程的状态信息\",{\"1\":{\"302\":1}}],[\"包含退出状态信息等\",{\"1\":{\"218\":1}}],[\"包含了\",{\"1\":{\"177\":1}}],[\"包含多个桶\",{\"1\":{\"63\":1}}],[\"包含\",{\"1\":{\"60\":1}}],[\"包含元素\",{\"1\":{\"20\":1}}],[\"感兴趣的读者可以查阅源码进行学习\",{\"1\":{\"34\":1}}],[\"许多编程语言内置了列表\",{\"1\":{\"34\":1}}],[\"许多编程语言中的标准库提供的列表是基于动态数组实现的\",{\"1\":{\"28\":1}}],[\"直到下一个断点\",{\"1\":{\"374\":1}}],[\"直到指定的子进程终止或者发生了其他指定的状态变化\",{\"1\":{\"299\":1}}],[\"直到有线程通知或者超时才会唤醒正在阻塞的线程\",{\"1\":{\"262\":1}}],[\"直到有对象处理它为止\",{\"1\":{\"165\":1}}],[\"直到锁可用为止\",{\"1\":{\"243\":1}}],[\"直到互斥量被解锁\",{\"1\":{\"238\":1}}],[\"直到线程函数执行结束\",{\"1\":{\"236\":1,\"257\":1}}],[\"直到最后的构造函数结束\",{\"1\":{\"210\":1}}],[\"直到某个组件处理该事件\",{\"1\":{\"168\":1}}],[\"直到越过叶节点\",{\"1\":{\"92\":1}}],[\"直到找到能够处理请求的对象\",{\"1\":{\"166\":1}}],[\"直到找到目标元素时返回\",{\"1\":{\"67\":1}}],[\"直到找到空位后插入元素\",{\"1\":{\"67\":1}}],[\"直到找到对应元素\",{\"1\":{\"65\":1}}],[\"直至找到正确的键值对或无法找到跳出为止\",{\"1\":{\"75\":1}}],[\"直至找到空桶\",{\"1\":{\"65\":1}}],[\"直至找到目标节点\",{\"1\":{\"23\":1}}],[\"直至冲突消失为止\",{\"1\":{\"62\":1}}],[\"直接看使用代码吧\",{\"1\":{\"261\":1}}],[\"直接看代码\",{\"1\":{\"236\":1,\"257\":1}}],[\"直接的讲\",{\"1\":{\"210\":1}}],[\"直接映射原始模型\",{\"1\":{\"194\":1}}],[\"直接绑定到\",{\"1\":{\"176\":1}}],[\"直接删除\",{\"1\":{\"109\":2}}],[\"直接提前返回\",{\"1\":{\"93\":1}}],[\"直接返回\",{\"1\":{\"92\":2,\"106\":1,\"108\":1}}],[\"直接回到数组头部继续遍历\",{\"1\":{\"44\":1}}],[\"直接遍历列表元素\",{\"1\":{\"33\":1}}],[\"与头部指针\",{\"1\":{\"251\":1}}],[\"与服务层\",{\"1\":{\"173\":1}}],[\"与顺序和逆序遍历数组类似\",{\"1\":{\"113\":1}}],[\"与插入节点类似\",{\"1\":{\"93\":1}}],[\"与查找节点相同\",{\"1\":{\"92\":1}}],[\"与查找操作相似\",{\"1\":{\"92\":1}}],[\"与链表类似\",{\"1\":{\"79\":1,\"82\":1,\"83\":1}}],[\"与数组扩容类似\",{\"1\":{\"74\":1}}],[\"与数组一样\",{\"1\":{\"33\":1}}],[\"与\",{\"0\":{\"177\":1,\"192\":1,\"202\":1},\"1\":{\"70\":1,\"79\":1,\"202\":1,\"251\":1}}],[\"与线性探测相比\",{\"1\":{\"67\":1}}],[\"与值\",{\"1\":{\"58\":1}}],[\"与许多语言不同\",{\"1\":{\"36\":1}}],[\"与单向链表相比\",{\"1\":{\"26\":1}}],[\"65\",{\"1\":{\"227\":1,\"228\":1,\"229\":1}}],[\"64\",{\"1\":{\"68\":1,\"372\":1}}],[\"6\",{\"0\":{\"205\":1,\"231\":1,\"243\":1,\"318\":1,\"336\":1,\"353\":1},\"1\":{\"32\":2,\"71\":8,\"222\":1,\"274\":1,\"369\":10,\"372\":4}}],[\"需要使用weak\",{\"1\":{\"269\":1}}],[\"需要持有相关的互斥量\",{\"1\":{\"240\":1}}],[\"需要根据需求进行选择\",{\"1\":{\"232\":1}}],[\"需要沿着责任链传递的请求\",{\"1\":{\"166\":1}}],[\"需要从底至顶执行旋转操作\",{\"1\":{\"109\":1}}],[\"需要先对\",{\"1\":{\"105\":1}}],[\"需要先查询到元素\",{\"1\":{\"58\":1}}],[\"需要在左旋中添加一步\",{\"1\":{\"103\":1}}],[\"需要在右旋中添加一步\",{\"1\":{\"102\":1}}],[\"需要特别注意的是\",{\"1\":{\"99\":1}}],[\"需要通过标记删除\",{\"1\":{\"75\":1}}],[\"需要注意以下两点\",{\"1\":{\"92\":1}}],[\"需要注意两点\",{\"1\":{\"63\":1}}],[\"需要注意的是\",{\"1\":{\"41\":1,\"83\":1}}],[\"需要针对具体情况进行分析\",{\"1\":{\"51\":1}}],[\"需要手动释放空间\",{\"1\":{\"9\":1}}],[\"需注意\",{\"1\":{\"30\":1}}],[\"视图的用户输入会通过绑定机制传递给\",{\"1\":{\"176\":1}}],[\"视图会自动更新\",{\"1\":{\"176\":1}}],[\"视图层\",{\"1\":{\"176\":1}}],[\"视图模型\",{\"0\":{\"175\":1},\"1\":{\"172\":1}}],[\"视图\",{\"0\":{\"174\":1,\"188\":1},\"1\":{\"172\":1,\"177\":1,\"185\":1}}],[\"视为父节点\",{\"1\":{\"79\":1}}],[\"视为等同的概念\",{\"1\":{\"28\":1}}],[\"视频播放器中\",{\"1\":{\"27\":1}}],[\"实际应用中可以根据需求扩展守护进程的功能\",{\"1\":{\"224\":1}}],[\"实际上相当于同步操作\",{\"1\":{\"264\":1}}],[\"实际上需要通过修改节点指针来实现\",{\"1\":{\"102\":1}}],[\"实际上\",{\"1\":{\"28\":1,\"70\":1}}],[\"实例管理的数据和行为\",{\"1\":{\"181\":1}}],[\"实现preference\",{\"0\":{\"363\":1}}],[\"实现示例\",{\"0\":{\"287\":1}}],[\"实现生产者\",{\"1\":{\"242\":1}}],[\"实现原理\",{\"1\":{\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"267\":1}}],[\"实现双向数据绑定\",{\"1\":{\"175\":1}}],[\"实现界面和数据的自动同步\",{\"1\":{\"172\":1}}],[\"实现了表格和树状结构的支持\",{\"1\":{\"187\":1}}],[\"实现了请求的解耦处理\",{\"1\":{\"168\":1}}],[\"实现了处理者接口\",{\"1\":{\"166\":1}}],[\"实现创建具体产品族的方法\",{\"1\":{\"160\":1}}],[\"实现具体的产品类\",{\"1\":{\"160\":1}}],[\"实现工厂接口\",{\"1\":{\"157\":1}}],[\"实现产品接口的具体类\",{\"1\":{\"157\":1}}],[\"实现类和抽象类之间可以自由组合\",{\"1\":{\"151\":1}}],[\"实现类接口与抽象类没有继承关系\",{\"1\":{\"150\":1}}],[\"实现类接口\",{\"1\":{\"150\":1}}],[\"实现类接口类型\",{\"1\":{\"150\":1}}],[\"实现实现类接口\",{\"1\":{\"150\":1}}],[\"实现功能的叠加\",{\"1\":{\"144\":1}}],[\"实现组件接口\",{\"1\":{\"144\":1}}],[\"实现组件接口的具体类\",{\"1\":{\"144\":1}}],[\"实现策略接口的不同算法\",{\"1\":{\"138\":1}}],[\"实现观察者接口\",{\"1\":{\"132\":1}}],[\"实现主题接口\",{\"1\":{\"132\":1}}],[\"实现模块基于抽象接口实现具体的底层细节\",{\"1\":{\"127\":1}}],[\"实现的基础\",{\"1\":{\"201\":1}}],[\"实现的请假流程处理的责任链模式示例\",{\"1\":{\"167\":1}}],[\"实现的\",{\"1\":{\"60\":1}}],[\"实现高效的查找\",{\"1\":{\"96\":1}}],[\"实现高效的元素查询\",{\"1\":{\"58\":1}}],[\"实现高效的节点插入与删除\",{\"1\":{\"35\":1}}],[\"实现编译时加密和运行时解密是一种有效保护敏感信息的方法\",{\"1\":{\"288\":1}}],[\"实现编译时加密\",{\"0\":{\"284\":1},\"1\":{\"4\":1,\"284\":1,\"285\":1}}],[\"ds\",{\"1\":{\"229\":1}}],[\"dup\",{\"1\":{\"222\":2}}],[\"darkwavestyle\",{\"1\":{\"361\":1}}],[\"daemon\",{\"1\":{\"221\":1,\"371\":1}}],[\"datachanged\",{\"1\":{\"191\":2}}],[\"data\",{\"1\":{\"172\":1,\"181\":3,\"189\":1,\"190\":1,\"193\":2,\"239\":3,\"287\":7,\"288\":1,\"382\":1}}],[\"days\",{\"1\":{\"167\":20}}],[\"driving\",{\"1\":{\"158\":1}}],[\"drive\",{\"1\":{\"158\":3}}],[\"drawwaves\",{\"1\":{\"361\":1}}],[\"drawoption\",{\"1\":{\"361\":9}}],[\"drawing\",{\"1\":{\"151\":2}}],[\"draw\",{\"1\":{\"151\":3,\"361\":4}}],[\"docker\",{\"1\":{\"382\":4}}],[\"docrypto\",{\"1\":{\"145\":3}}],[\"dodraw\",{\"1\":{\"361\":4}}],[\"downloaded\",{\"1\":{\"382\":1}}],[\"downloading\",{\"1\":{\"382\":1}}],[\"downloads\",{\"1\":{\"370\":1}}],[\"down\",{\"1\":{\"245\":1}}],[\"do\",{\"1\":{\"236\":2,\"361\":3,\"362\":2,\"364\":7}}],[\"dom\",{\"1\":{\"179\":1}}],[\"dobuffer\",{\"1\":{\"145\":3}}],[\"doprogress\",{\"1\":{\"133\":2}}],[\"double\",{\"1\":{\"36\":2,\"51\":1,\"63\":4,\"65\":3,\"73\":1,\"139\":8,\"220\":2,\"273\":1,\"274\":1}}],[\"directly\",{\"1\":{\"382\":1}}],[\"directories\",{\"1\":{\"353\":2,\"354\":1}}],[\"directory\",{\"1\":{\"222\":1}}],[\"directorhandler\",{\"1\":{\"167\":1}}],[\"director\",{\"1\":{\"167\":6}}],[\"dirs\",{\"1\":{\"354\":1}}],[\"diff\",{\"1\":{\"317\":4}}],[\"diagram\",{\"1\":{\"291\":1}}],[\"displayrole\",{\"1\":{\"193\":2}}],[\"discounts\",{\"1\":{\"139\":1}}],[\"discountstrategy\",{\"1\":{\"139\":7}}],[\"div>\",{\"1\":{\"181\":1}}],[\"dip\",{\"1\":{\"126\":1}}],[\"dict\",{\"1\":{\"68\":1,\"74\":1}}],[\"dfs\",{\"1\":{\"113\":1}}],[\"debug\",{\"1\":{\"370\":1,\"374\":1}}],[\"debugfs\",{\"1\":{\"370\":1}}],[\"debian\",{\"1\":{\"342\":1}}],[\"description=ollama\",{\"1\":{\"382\":1}}],[\"destination\",{\"1\":{\"356\":1}}],[\"destruct\",{\"1\":{\"270\":7}}],[\"desaction\",{\"1\":{\"257\":5}}],[\"defconfig\",{\"1\":{\"369\":1}}],[\"define\",{\"1\":{\"287\":1}}],[\"deferred表示延迟执行任务\",{\"1\":{\"264\":1}}],[\"deferred\",{\"1\":{\"264\":1}}],[\"default\",{\"1\":{\"99\":1,\"151\":2,\"158\":2,\"161\":3,\"257\":2}}],[\"dequeue\",{\"1\":{\"250\":2,\"251\":5}}],[\"detach\",{\"1\":{\"236\":3,\"257\":3,\"263\":1}}],[\"dev\",{\"1\":{\"222\":2,\"223\":1}}],[\"delegate\",{\"0\":{\"189\":1},\"1\":{\"185\":1,\"189\":2,\"192\":2}}],[\"delele\",{\"1\":{\"139\":2}}],[\"deletion\",{\"1\":{\"65\":1}}],[\"delete是c++语言标准库提供的一组用于动态创建\",{\"1\":{\"201\":1}}],[\"delete与malloc\",{\"0\":{\"201\":1}}],[\"delete\",{\"1\":{\"15\":1,\"22\":1,\"43\":1,\"44\":1,\"49\":1,\"60\":2,\"63\":3,\"65\":4,\"93\":1,\"109\":2,\"201\":1,\"207\":1,\"250\":1,\"251\":1}}],[\"depth\",{\"1\":{\"80\":1}}],[\"degree\",{\"1\":{\"80\":1}}],[\"decrypt\",{\"1\":{\"287\":2,\"288\":1}}],[\"decorator\",{\"1\":{\"143\":1,\"144\":2}}],[\"dec\",{\"1\":{\"73\":2}}],[\"d\",{\"1\":{\"61\":1,\"239\":2,\"323\":2,\"370\":1,\"382\":1}}],[\"dynamic\",{\"1\":{\"28\":1}}],[\"为内核启动的初始化程序\",{\"1\":{\"370\":1}}],[\"为编译器指定自定义编译选项\",{\"1\":{\"355\":1}}],[\"为目标\",{\"1\":{\"353\":1}}],[\"为下次提交做准备\",{\"1\":{\"313\":1}}],[\"为正表示父进程\",{\"1\":{\"304\":1}}],[\"为实现无锁编程提供了基础设施\",{\"1\":{\"249\":1}}],[\"为子类对象初始化虚表指针\",{\"1\":{\"207\":1}}],[\"为支持函数重载引入了name\",{\"1\":{\"204\":1}}],[\"为数组的指针\",{\"1\":{\"202\":1}}],[\"为数组名指向首元素地址即与\",{\"1\":{\"202\":1}}],[\"为数组长度\",{\"1\":{\"12\":1}}],[\"为原点\",{\"1\":{\"102\":1,\"103\":1}}],[\"为例\",{\"1\":{\"73\":1}}],[\"为什么要将\",{\"1\":{\"113\":1}}],[\"为什么要强调对质数取模\",{\"1\":{\"71\":1}}],[\"为什么\",{\"1\":{\"113\":1}}],[\"为什么哈希表扩容能够缓解哈希冲突\",{\"1\":{\"75\":1}}],[\"为什么在线性探测中\",{\"1\":{\"75\":1}}],[\"为什么不使用哈希函数\",{\"1\":{\"75\":1}}],[\"为什么数组要求相同类型的元素\",{\"1\":{\"36\":1}}],[\"为此\",{\"1\":{\"61\":1,\"65\":1}}],[\"为了便于使用\",{\"1\":{\"106\":1}}],[\"为了保持二叉搜索树\",{\"1\":{\"92\":1}}],[\"为了保护用户密码的安全\",{\"1\":{\"70\":1}}],[\"为了防止这种情况的发生\",{\"1\":{\"210\":1}}],[\"为了防止从哈希值推导出原始密码等逆向工程\",{\"1\":{\"70\":1}}],[\"为了防止频繁扩容\",{\"1\":{\"36\":1}}],[\"为了实现插入节点\",{\"1\":{\"92\":1}}],[\"为了实现\",{\"1\":{\"70\":1}}],[\"为了实现队列\",{\"1\":{\"42\":1}}],[\"为了降低哈希冲突的发生概率\",{\"1\":{\"69\":1}}],[\"为了更加充分地使用哈希表的空间\",{\"1\":{\"65\":1}}],[\"为了提升效率\",{\"1\":{\"62\":1}}],[\"为了解决该问题\",{\"1\":{\"62\":1,\"65\":1}}],[\"为了解决此问题\",{\"1\":{\"44\":1}}],[\"为了深入了解栈的运行机制\",{\"1\":{\"48\":1}}],[\"为了加深对列表工作原理的理解\",{\"1\":{\"34\":1}}],[\"为\",{\"1\":{\"35\":1,\"220\":1,\"300\":1,\"304\":1}}],[\"为解决此问题\",{\"1\":{\"28\":1}}],[\"并开始调试\",{\"1\":{\"373\":1}}],[\"并开启\",{\"1\":{\"372\":1}}],[\"并可以控制虚拟机的执行\",{\"1\":{\"373\":1}}],[\"并初始化\",{\"1\":{\"362\":2}}],[\"并指定源文件\",{\"1\":{\"344\":1}}],[\"并获取其退出状态\",{\"1\":{\"304\":1}}],[\"并设置\",{\"1\":{\"301\":1}}],[\"并采取相应的措施来修复或优化\",{\"1\":{\"296\":1}}],[\"并正确关闭连接\",{\"1\":{\"295\":1}}],[\"并进入syn\",{\"1\":{\"294\":1}}],[\"并进入这个状态\",{\"1\":{\"292\":1}}],[\"并详细解释了其工作原理\",{\"1\":{\"288\":1}}],[\"并存储在\",{\"1\":{\"288\":1}}],[\"并展示一个具体的实现示例\",{\"1\":{\"284\":1}}],[\"并增加右操作数所指对象的引用计数\",{\"1\":{\"267\":1}}],[\"并输出相应的信息\",{\"1\":{\"251\":1}}],[\"并使用\",{\"1\":{\"251\":2}}],[\"并释放互斥量\",{\"1\":{\"240\":1}}],[\"并为父类对象初始化虚表指针\",{\"1\":{\"207\":1}}],[\"并实现相关的接口方法\",{\"1\":{\"193\":1}}],[\"并处理用户交互\",{\"1\":{\"192\":1}}],[\"并通过模型的标准接口\",{\"1\":{\"190\":1}}],[\"并向\",{\"1\":{\"187\":1}}],[\"并与\",{\"1\":{\"177\":1}}],[\"并与接收到的哈希值进行比较\",{\"1\":{\"70\":1}}],[\"并根据模型的变化进行更新\",{\"1\":{\"177\":1}}],[\"并根据父节点与子节点之间的索引映射关系来实现指针\",{\"1\":{\"112\":1}}],[\"并沿着这条链传递请求\",{\"1\":{\"165\":1}}],[\"并持有一个组件对象的引用\",{\"1\":{\"144\":1}}],[\"并简化代码结构\",{\"1\":{\"133\":1}}],[\"并用该节点替换当前节点\",{\"1\":{\"109\":1}}],[\"并声明一个成员变量\",{\"1\":{\"90\":1}}],[\"并提供\",{\"1\":{\"75\":1}}],[\"并引起一些安全问题\",{\"1\":{\"72\":1}}],[\"并清空栈\",{\"1\":{\"54\":1}}],[\"并在运行时对其进行解密\",{\"1\":{\"286\":1}}],[\"并在运行时决定使用哪种策略\",{\"1\":{\"138\":1}}],[\"并在其析构函数中对这些内存空间进行释放\",{\"1\":{\"210\":1}}],[\"并在树中递归删除节点\",{\"1\":{\"93\":1}}],[\"并在桶中获取\",{\"1\":{\"60\":1}}],[\"并在程序逻辑上忽略与栈无关的操作\",{\"1\":{\"47\":1}}],[\"并在另一端删除元素\",{\"1\":{\"42\":1}}],[\"并将解密后的字符串输出\",{\"1\":{\"288\":1}}],[\"并将互斥量状态设置为锁定\",{\"1\":{\"238\":1}}],[\"并将这些数据渲染到屏幕上\",{\"1\":{\"188\":1}}],[\"并将操作传递给\",{\"1\":{\"175\":1}}],[\"并将其作为子模块添加\",{\"1\":{\"331\":1}}],[\"并将其传递给\",{\"1\":{\"174\":1,\"175\":1}}],[\"并将其压入栈\",{\"1\":{\"54\":2}}],[\"并将每个算法封装在独立的策略类中\",{\"1\":{\"137\":1}}],[\"并将搜索到的目标元素与该\",{\"1\":{\"65\":1}}],[\"并将\",{\"1\":{\"44\":2,\"251\":1}}],[\"并将原列表的所有元素搬运过去\",{\"1\":{\"36\":1}}],[\"并维护一个变量\",{\"1\":{\"44\":1}}],[\"并返回\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"63\":1,\"65\":1,\"109\":1}}],[\"并且你有相应的权限克隆子模块\",{\"1\":{\"338\":1}}],[\"并且其状态尚未报告\",{\"1\":{\"300\":1}}],[\"并且构造函数的作用是提供初始化\",{\"1\":{\"210\":1}}],[\"并且存在对象内存布局的最前面\",{\"1\":{\"208\":1}}],[\"并且由于数据绑定\",{\"1\":{\"181\":1}}],[\"并且由于哈希表容量\",{\"1\":{\"61\":1}}],[\"并且需要将这些维度解耦的场景中使用\",{\"1\":{\"151\":1}}],[\"并且仍然保持二叉搜索树的性质\",{\"1\":{\"102\":1}}],[\"并且通过哈希函数找到标记为已删除的位置时\",{\"1\":{\"75\":1}}],[\"并且这个质数最好足够大\",{\"1\":{\"71\":1}}],[\"并且这些数字的内存地址无须连续\",{\"1\":{\"36\":1}}],[\"并且更加灵活\",{\"1\":{\"54\":1}}],[\"并且\",{\"1\":{\"51\":1,\"210\":1}}],[\"并且可以在程序运行过程中进行动态扩容\",{\"1\":{\"28\":1}}],[\"并且可以灵活动态扩容\",{\"1\":{\"28\":1}}],[\"并不是连续的\",{\"1\":{\"36\":1}}],[\"并随着元素插入和删除实时更新\",{\"1\":{\"34\":1}}],[\"并生成一个随机序列\",{\"1\":{\"17\":1}}],[\"添加依赖库\",{\"1\":{\"353\":1}}],[\"添加静态或动态库\",{\"1\":{\"353\":1}}],[\"添加库\",{\"1\":{\"353\":1}}],[\"添加可执行文件\",{\"1\":{\"344\":1}}],[\"添加并提交子模块的状态\",{\"1\":{\"336\":1}}],[\"添加当前目录下的所有更改\",{\"1\":{\"313\":1}}],[\"添加远程仓库\",{\"1\":{\"311\":1}}],[\"添加新的远程仓库\",{\"1\":{\"311\":1}}],[\"添加字符串结束符\",{\"1\":{\"287\":2}}],[\"添加键值对\",{\"1\":{\"74\":1}}],[\"添加键值对和删除键值对等\",{\"1\":{\"59\":1}}],[\"添加到链表中\",{\"1\":{\"63\":1}}],[\"添加操作\",{\"1\":{\"59\":1,\"60\":1,\"63\":1,\"65\":1}}],[\"添加至栈顶\",{\"1\":{\"47\":1}}],[\"添加至队尾\",{\"1\":{\"44\":1}}],[\"添加\",{\"1\":{\"28\":1}}],[\"添加元素\",{\"1\":{\"25\":1,\"58\":2,\"63\":1}}],[\"支持多平台\",{\"1\":{\"342\":1}}],[\"支持对线程join或者detach\",{\"1\":{\"236\":1,\"257\":1}}],[\"支持广播通信\",{\"1\":{\"133\":1}}],[\"支持操作\",{\"1\":{\"51\":1}}],[\"支持元素访问\",{\"1\":{\"28\":1}}],[\"支持随机访问\",{\"1\":{\"16\":1}}],[\"以指示错误\",{\"1\":{\"301\":1}}],[\"以控制并发操作的顺序性\",{\"1\":{\"248\":1}}],[\"以防止多个进程同时访问共享资源\",{\"1\":{\"229\":1}}],[\"以避免守护进程占用可卸载的文件系统\",{\"1\":{\"223\":1}}],[\"以回收子进程的资源\",{\"1\":{\"220\":1}}],[\"以获取并处理子进程的退出状态\",{\"1\":{\"220\":1}}],[\"以适应复杂的数据结构和特定的业务需求\",{\"1\":{\"193\":1}}],[\"以便稍后恢复\",{\"1\":{\"319\":1}}],[\"以便接收更新\",{\"1\":{\"132\":1}}],[\"以便使用调试符号\",{\"1\":{\"373\":1}}],[\"以便使用\",{\"1\":{\"113\":1}}],[\"以便实现无缝播放\",{\"1\":{\"27\":1}}],[\"以保持其有序状态\",{\"1\":{\"96\":1}}],[\"以实现有实际意义的操作\",{\"1\":{\"83\":1}}],[\"以最大化地保证哈希值均匀分布\",{\"1\":{\"74\":1}}],[\"以\",{\"1\":{\"73\":1,\"102\":1,\"103\":1}}],[\"以上两个都不是async的默认策略\",{\"1\":{\"264\":1}}],[\"以上代码创建了一个简单的守护进程\",{\"1\":{\"224\":1}}],[\"以上介绍的简单哈希算法都比较\",{\"1\":{\"72\":1}}],[\"以上实现的队列仍然具有局限性\",{\"1\":{\"44\":1}}],[\"以尽可能消除周期性模式\",{\"1\":{\"71\":1}}],[\"以确保在此之前的所有操作不会被重排序到\",{\"1\":{\"252\":1}}],[\"以确保在没有锁的情况下实现线程安全\",{\"1\":{\"247\":1}}],[\"以确保加载的结果及其后续的操作不会被重排序到\",{\"1\":{\"252\":1}}],[\"以确保取出操作完成后\",{\"1\":{\"251\":1}}],[\"以确保插入操作完成后\",{\"1\":{\"251\":1}}],[\"以确保守护进程创建的新文件有正确的权限\",{\"1\":{\"223\":1}}],[\"以确保哈希值在合适的范围内\",{\"1\":{\"71\":1}}],[\"以确保性能\",{\"1\":{\"68\":1}}],[\"以来\",{\"1\":{\"68\":1}}],[\"以此类推\",{\"1\":{\"67\":1}}],[\"以查找目标键值对\",{\"1\":{\"63\":1}}],[\"以表示键值对\",{\"1\":{\"60\":1}}],[\"以下实现包含哈希表扩容方法\",{\"1\":{\"63\":1}}],[\"以下代码实现了一个包含懒删除的开放寻址\",{\"1\":{\"65\":1}}],[\"以下代码实现了一个简单哈希表\",{\"1\":{\"60\":1}}],[\"以下代码给出了链式地址哈希表的简单实现\",{\"1\":{\"63\":1}}],[\"以下为示例代码\",{\"1\":{\"50\":1}}],[\"以下是不同系统的安装方式\",{\"1\":{\"342\":1}}],[\"以下是\",{\"1\":{\"341\":1}}],[\"以下是常见的\",{\"1\":{\"330\":1}}],[\"以下是常见的状态转换路径\",{\"1\":{\"216\":1}}],[\"以下是一些常用的\",{\"1\":{\"309\":1}}],[\"以下是一个使用\",{\"1\":{\"303\":1}}],[\"以下是一个完整的实现示例\",{\"1\":{\"287\":1}}],[\"以下是tcp连接状态的转换图\",{\"1\":{\"293\":1}}],[\"以下是主要的tcp连接状态及其转换\",{\"1\":{\"292\":1}}],[\"以下是几种常用的方法\",{\"1\":{\"220\":1}}],[\"以下是基于链表实现栈的示例代码\",{\"1\":{\"49\":1}}],[\"以下是用链表实现队列的代码\",{\"1\":{\"43\":1}}],[\"以及判断是否需要扩容\",{\"1\":{\"34\":1}}],[\"以及支持快速添加和删除节点\",{\"1\":{\"27\":1}}],[\"以及之后的所有元素向后移动一位\",{\"1\":{\"11\":1}}],[\"算法中\",{\"1\":{\"27\":1}}],[\"算法\",{\"1\":{\"27\":1,\"73\":2}}],[\"llama3\",{\"1\":{\"382\":1}}],[\"llama\",{\"1\":{\"382\":1}}],[\"lucas\",{\"1\":{\"382\":2}}],[\"ls\",{\"1\":{\"372\":1}}],[\"lsp\",{\"1\":{\"126\":1}}],[\"languages\",{\"1\":{\"344\":1}}],[\"landis\",{\"1\":{\"97\":1}}],[\"last\",{\"1\":{\"292\":1,\"294\":1,\"295\":1}}],[\"lambda\",{\"1\":{\"288\":1}}],[\"launch\",{\"1\":{\"264\":8}}],[\"latch\",{\"1\":{\"245\":2}}],[\"layoutchanged\",{\"1\":{\"191\":1}}],[\"lazy\",{\"1\":{\"65\":1}}],[\"leaving\",{\"1\":{\"229\":2}}],[\"leavedays3\",{\"1\":{\"167\":2}}],[\"leavedays2\",{\"1\":{\"167\":2}}],[\"leavedays1\",{\"1\":{\"167\":2}}],[\"leave\",{\"1\":{\"167\":6}}],[\"leavehandler\",{\"1\":{\"167\":4}}],[\"leader\",{\"1\":{\"167\":4}}],[\"leaf\",{\"1\":{\"80\":1}}],[\"level\",{\"1\":{\"80\":1}}],[\"leftrotate\",{\"1\":{\"103\":1,\"106\":3}}],[\"left\",{\"1\":{\"79\":4,\"91\":1,\"99\":1,\"103\":2}}],[\"localhost\",{\"1\":{\"382\":1}}],[\"local\",{\"1\":{\"382\":6}}],[\"lock通过raii技术方便了加锁和解锁调用\",{\"1\":{\"264\":1}}],[\"lock使用\",{\"1\":{\"259\":1}}],[\"lock类有unlock函数\",{\"1\":{\"259\":1}}],[\"lock更加轻量级\",{\"1\":{\"259\":1}}],[\"lock两种方式\",{\"1\":{\"259\":1}}],[\"lock相关\",{\"0\":{\"259\":1},\"1\":{\"256\":1}}],[\"lockfreequeue<int>\",{\"1\":{\"250\":1,\"251\":1}}],[\"lockfreequeue\",{\"1\":{\"250\":2,\"251\":4}}],[\"lock<std\",{\"1\":{\"239\":2,\"240\":1,\"259\":1,\"262\":3}}],[\"lock\",{\"1\":{\"238\":2,\"239\":4,\"240\":4,\"243\":2,\"247\":1,\"258\":2,\"259\":6,\"260\":6,\"262\":6,\"264\":2}}],[\"log\",{\"1\":{\"316\":4}}],[\"log2​\",{\"1\":{\"88\":1}}],[\"logn\",{\"1\":{\"63\":1,\"91\":1,\"92\":1,\"93\":3,\"95\":4,\"97\":2,\"112\":1}}],[\"loadfactor\",{\"1\":{\"63\":2,\"65\":2}}],[\"loadthres\",{\"1\":{\"63\":3,\"65\":2}}],[\"load\",{\"1\":{\"61\":1,\"250\":4,\"251\":8,\"252\":3,\"260\":1}}],[\"long\",{\"1\":{\"36\":2,\"71\":2,\"227\":1}}],[\"lru\",{\"1\":{\"27\":2}}],[\"like\",{\"1\":{\"382\":1}}],[\"light\",{\"1\":{\"361\":1}}],[\"lightwavestyle\",{\"1\":{\"361\":1}}],[\"libvirt\",{\"1\":{\"371\":2}}],[\"libraries\",{\"1\":{\"353\":2,\"354\":2}}],[\"library\",{\"1\":{\"353\":4}}],[\"libs\",{\"1\":{\"331\":2,\"334\":2,\"335\":1,\"336\":2,\"370\":1}}],[\"listen\",{\"1\":{\"231\":1,\"292\":1,\"294\":1,\"295\":1}}],[\"listnode\",{\"1\":{\"18\":4,\"20\":10,\"21\":3,\"22\":3,\"23\":2,\"24\":1,\"26\":4,\"43\":5,\"49\":5}}],[\"list\",{\"1\":{\"18\":1,\"28\":3,\"36\":3,\"49\":1}}],[\"line\",{\"1\":{\"382\":1}}],[\"link\",{\"1\":{\"353\":2,\"354\":1}}],[\"linkedliststack\",{\"1\":{\"49\":2}}],[\"linkedlistqueue\",{\"1\":{\"43\":2}}],[\"linkedlist\",{\"1\":{\"43\":2,\"49\":2}}],[\"linked\",{\"1\":{\"18\":1}}],[\"linux\",{\"0\":{\"282\":1,\"369\":1},\"1\":{\"4\":1,\"218\":1,\"221\":1,\"299\":1,\"357\":1,\"367\":2,\"369\":6,\"372\":2},\"2\":{\"283\":1,\"308\":1,\"377\":1}}],[\"浏览器的前进后退功能本质上是\",{\"1\":{\"54\":1}}],[\"浏览器的前进后退是否是双向链表实现\",{\"1\":{\"54\":1}}],[\"浏览器就会对上一个网页执行入栈\",{\"1\":{\"52\":1}}],[\"浏览器中的后退与前进\",{\"1\":{\"52\":1}}],[\"浏览器需要知道用户访问过的前一个和后一个网页\",{\"1\":{\"27\":1}}],[\"浏览器历史\",{\"1\":{\"27\":1}}],[\"bz2\",{\"1\":{\"370\":2,\"372\":1}}],[\"bzimage\",{\"1\":{\"369\":4,\"372\":4}}],[\"by\",{\"1\":{\"275\":1,\"303\":2}}],[\"be\",{\"1\":{\"271\":1,\"382\":1}}],[\"begindraw\",{\"1\":{\"361\":2}}],[\"begin\",{\"1\":{\"32\":2,\"59\":1,\"63\":1}}],[\"blocked\",{\"1\":{\"215\":1}}],[\"bluesquare\",{\"1\":{\"151\":2}}],[\"blue\",{\"1\":{\"151\":3,\"277\":4}}],[\"bluecolor\",{\"1\":{\"151\":1}}],[\"browser\",{\"1\":{\"364\":8,\"382\":2}}],[\"brew\",{\"1\":{\"342\":1}}],[\"breakpoints\",{\"1\":{\"374\":1}}],[\"break\",{\"1\":{\"91\":1,\"93\":1,\"277\":3}}],[\"branch\",{\"1\":{\"318\":1,\"322\":2,\"323\":10,\"324\":1}}],[\"bridge\",{\"1\":{\"149\":1,\"371\":1}}],[\"bfs\",{\"1\":{\"145\":3}}],[\"busybox\",{\"1\":{\"370\":5,\"372\":2}}],[\"bus\",{\"1\":{\"361\":1}}],[\"buswav\",{\"1\":{\"361\":1}}],[\"buf\",{\"1\":{\"229\":2}}],[\"buffer\",{\"1\":{\"145\":1,\"226\":4,\"231\":4,\"250\":5,\"251\":7}}],[\"bufferedstream\",{\"1\":{\"145\":4}}],[\"button\",{\"1\":{\"161\":5}}],[\"bug\",{\"1\":{\"126\":1}}],[\"build\",{\"1\":{\"113\":1,\"350\":2,\"370\":2}}],[\"bucketstmp\",{\"1\":{\"63\":2,\"65\":2}}],[\"buckets\",{\"1\":{\"60\":11,\"63\":11,\"65\":23}}],[\"bucket\",{\"1\":{\"60\":3,\"63\":12}}],[\"bst\",{\"1\":{\"91\":3,\"93\":3}}],[\"barrier\",{\"1\":{\"244\":1}}],[\"bar\",{\"1\":{\"236\":6}}],[\"base为基类\",{\"1\":{\"207\":1}}],[\"base\",{\"1\":{\"207\":12}}],[\"balancefactor\",{\"1\":{\"100\":1,\"106\":6}}],[\"balance\",{\"1\":{\"100\":1}}],[\"balanced\",{\"1\":{\"87\":1,\"98\":1}}],[\"backend\",{\"1\":{\"382\":1}}],[\"back\",{\"1\":{\"32\":5,\"50\":3,\"60\":3,\"63\":1,\"239\":1,\"244\":1,\"245\":1,\"271\":6,\"363\":1}}],[\"bin\",{\"1\":{\"356\":1,\"370\":3,\"382\":7}}],[\"bind\",{\"1\":{\"231\":1}}],[\"binding\",{\"1\":{\"172\":1}}],[\"binarysearchtree\",{\"1\":{\"90\":1}}],[\"binary\",{\"1\":{\"79\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"98\":1,\"370\":1}}],[\"bikefactory\",{\"1\":{\"158\":3}}],[\"bike\",{\"1\":{\"158\":4}}],[\"bitwav\",{\"1\":{\"361\":1}}],[\"bit\",{\"1\":{\"72\":4,\"361\":1}}],[\"boot\",{\"1\":{\"369\":2,\"370\":1}}],[\"boost\",{\"1\":{\"354\":4}}],[\"book\",{\"2\":{\"123\":1}}],[\"bool\",{\"1\":{\"41\":1,\"43\":1,\"44\":1,\"47\":1,\"49\":1,\"50\":1,\"73\":1,\"167\":2,\"240\":1,\"250\":2,\"251\":2}}],[\"bol\",{\"1\":{\"73\":2}}],[\"b\",{\"1\":{\"27\":1,\"54\":4,\"113\":2,\"322\":1,\"373\":1,\"374\":2}}],[\"邻接表是表示图的一种常用方式\",{\"1\":{\"27\":1}}],[\"所需要的资源\",{\"1\":{\"246\":1}}],[\"所需的数据\",{\"1\":{\"175\":1}}],[\"所谓的合适时机\",{\"1\":{\"207\":1}}],[\"所有资源释放后\",{\"1\":{\"292\":1}}],[\"所有等待的线程被唤醒\",{\"1\":{\"245\":1}}],[\"所有等待的线程继续执行\",{\"1\":{\"244\":1}}],[\"所有自定义模型的基类\",{\"1\":{\"187\":1}}],[\"所有观察者都可以自动接收到通知\",{\"1\":{\"133\":1}}],[\"所有具体的观察者类实现该接口\",{\"1\":{\"132\":1}}],[\"所有依赖于它的观察者对象都会收到通知并自动更新\",{\"1\":{\"131\":1}}],[\"所有操作的时间复杂度将从\",{\"1\":{\"97\":1}}],[\"所有层的节点都被完全填满\",{\"1\":{\"85\":1}}],[\"所有后两位相等的\",{\"1\":{\"70\":1}}],[\"所有冲突的元素都会被放到一个链表中\",{\"1\":{\"27\":1}}],[\"所以weak\",{\"1\":{\"269\":1}}],[\"所以unique\",{\"1\":{\"268\":1}}],[\"所以条件变量都配合std\",{\"1\":{\"259\":1}}],[\"所以它使用的vptr必须是对于这个类的vtable\",{\"1\":{\"210\":1}}],[\"所以构造函数没有必要是虚函数\",{\"1\":{\"210\":1}}],[\"所以构造函数不能是虚函数\",{\"1\":{\"210\":1}}],[\"所以在调用基类的析构函数时\",{\"1\":{\"209\":1}}],[\"所以不在堆中\",{\"1\":{\"208\":1}}],[\"所以\",{\"1\":{\"36\":1,\"210\":1}}],[\"所以上述查找操作被称为\",{\"1\":{\"14\":1}}],[\"所以我们无须特意去修改它\",{\"1\":{\"12\":1}}],[\"链接库\",{\"1\":{\"353\":1}}],[\"链式地址通过将单个元素转化为链表\",{\"1\":{\"74\":1}}],[\"链式地址存在以下局限性\",{\"1\":{\"63\":1}}],[\"链式地址哈希表\",{\"1\":{\"63\":2}}],[\"链式地址\",{\"0\":{\"63\":1},\"1\":{\"62\":1,\"63\":1}}],[\"链式地址是解决哈希冲突的主流方案之一\",{\"1\":{\"27\":1}}],[\"链表则是另一个极端\",{\"1\":{\"88\":1}}],[\"链表则不然\",{\"1\":{\"23\":1}}],[\"链表过长会降低查询效率\",{\"1\":{\"74\":1}}],[\"链表会转换为红黑树以提升查找性能\",{\"1\":{\"68\":1}}],[\"链表包含节点指针\",{\"1\":{\"63\":1}}],[\"链表和数组都符合要求\",{\"1\":{\"42\":1}}],[\"链表由节点组成\",{\"1\":{\"36\":1}}],[\"链表通过更改引用\",{\"1\":{\"35\":1}}],[\"链表天然可以看作一个列表\",{\"1\":{\"28\":1}}],[\"链表中的每个元素都代表与该顶点相连的其他顶点\",{\"1\":{\"27\":1}}],[\"链表典型应用\",{\"0\":{\"27\":1}}],[\"链表删除节点\",{\"1\":{\"22\":1}}],[\"链表插入节点示例\",{\"1\":{\"21\":1}}],[\"链表常用操作\",{\"0\":{\"19\":1}}],[\"链表比数组占用更多的内存空间\",{\"1\":{\"18\":1}}],[\"链表节点所占用的内存空间比数组元素更大\",{\"1\":{\"53\":1}}],[\"链表节点结构体\",{\"1\":{\"18\":1}}],[\"链表节点\",{\"1\":{\"18\":1}}],[\"链表的扩容非常灵活\",{\"1\":{\"51\":1}}],[\"链表的\",{\"1\":{\"36\":1}}],[\"链表的首个节点被称为\",{\"1\":{\"18\":1}}],[\"链表的组成单位是节点\",{\"1\":{\"18\":1}}],[\"链表的设计使得各个节点可以分散存储在内存各处\",{\"1\":{\"18\":1}}],[\"链表定义与存储方式\",{\"1\":{\"18\":1,\"36\":1}}],[\"链表\",{\"0\":{\"18\":1,\"25\":1},\"1\":{\"18\":1,\"25\":1,\"47\":1,\"58\":4,\"75\":1,\"88\":2},\"2\":{\"38\":1}}],[\"上执行代码\",{\"1\":{\"215\":1}}],[\"上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型\",{\"1\":{\"207\":1}}],[\"上下文类\",{\"1\":{\"138\":1,\"139\":1}}],[\"上一个节点\",{\"1\":{\"26\":1}}],[\"上述代码中\",{\"1\":{\"236\":1,\"257\":1}}],[\"上述\",{\"1\":{\"18\":1}}],[\"即构建文件和源文件分离\",{\"1\":{\"343\":1}}],[\"即等效于\",{\"1\":{\"300\":1}}],[\"即避免临时对象的拷贝构造和析构\",{\"1\":{\"270\":1}}],[\"即在执行时不会被其他线程打断\",{\"1\":{\"248\":1}}],[\"即使守护进程尝试读取或写入标准输入输出\",{\"1\":{\"223\":1}}],[\"即使对象的内容发生了变化\",{\"1\":{\"73\":1}}],[\"即进程描述符\",{\"1\":{\"219\":1}}],[\"即进程控制块\",{\"1\":{\"218\":1}}],[\"即大小是在编译时期确定的\",{\"1\":{\"208\":1}}],[\"即虚函数表的大小可以确定\",{\"1\":{\"208\":1}}],[\"即虚函数表的元素是指向类成员函数的指针\",{\"1\":{\"208\":1}}],[\"即虚函数表不是函数\",{\"1\":{\"208\":1}}],[\"即全局仅有一个\",{\"1\":{\"208\":1}}],[\"即vptr\",{\"1\":{\"207\":1}}],[\"即被修饰变量不可以被修改\",{\"1\":{\"205\":1}}],[\"即指向第二个元素a\",{\"1\":{\"202\":1}}],[\"即一个类只负责一项职责\",{\"1\":{\"126\":1}}],[\"即它们在内存中的位置是否相同\",{\"1\":{\"113\":1}}],[\"即所经过的\",{\"1\":{\"99\":1}}],[\"即同样满足条件\",{\"1\":{\"89\":1}}],[\"即节点引用\",{\"1\":{\"80\":1}}],[\"即某些位置比其他位置更容易被占用\",{\"1\":{\"66\":1}}],[\"即\",{\"1\":{\"66\":1}}],[\"即当哈希冲突比较严重时\",{\"1\":{\"62\":1}}],[\"即将元素添加至队尾\",{\"1\":{\"41\":1}}],[\"即新来的人不断加入队列尾部\",{\"1\":{\"40\":1}}],[\"即是本文描述的\",{\"1\":{\"30\":1}}],[\"即前面介绍的普通链表\",{\"1\":{\"26\":1}}],[\"即可得到左旋的实现代码\",{\"1\":{\"103\":1}}],[\"即可访问链表头节点\",{\"1\":{\"63\":1}}],[\"即可\",{\"1\":{\"21\":1,\"22\":1,\"65\":1}}],[\"可阻塞一个或多个线程\",{\"1\":{\"264\":1}}],[\"可用于实现单例\",{\"1\":{\"264\":1}}],[\"可用于替代\",{\"1\":{\"72\":1}}],[\"可重入\",{\"1\":{\"258\":1}}],[\"可是\",{\"1\":{\"210\":1}}],[\"可测试性强\",{\"1\":{\"179\":1}}],[\"可能会忘记将更新提交到主仓库\",{\"1\":{\"338\":1}}],[\"可能会导致系统无法创建新进程\",{\"1\":{\"219\":1}}],[\"可能导致调试过程变得更加复杂\",{\"1\":{\"180\":1}}],[\"可能导致二叉树退化为下图所示的链表\",{\"1\":{\"95\":1}}],[\"可能在经过哈希函数后得到相同的数组索引\",{\"1\":{\"74\":1}}],[\"可实现基于内容生成哈希值\",{\"1\":{\"73\":1}}],[\"可通过数组或链表来实现\",{\"1\":{\"53\":1}}],[\"可以设置断点在\",{\"1\":{\"373\":1}}],[\"可以帮助开发人员调试和分析内核的行为\",{\"1\":{\"367\":1}}],[\"可以为不同平台生成相应的构建系统\",{\"1\":{\"343\":1}}],[\"可以让你更好地组织代码\",{\"1\":{\"338\":1}}],[\"可以让你的提交历史保持整洁\",{\"1\":{\"325\":1}}],[\"可以将远程仓库复制到本地\",{\"1\":{\"311\":1}}],[\"可以防止僵尸进程的产生\",{\"1\":{\"305\":1}}],[\"可以与\",{\"1\":{\"305\":1}}],[\"可以识别出哪些连接处于非正常状态\",{\"1\":{\"296\":1}}],[\"可以提高应用程序的安全性\",{\"1\":{\"288\":1}}],[\"可以用\",{\"1\":{\"266\":2}}],[\"可以用于等待和管理某个特定子进程的状态变化\",{\"1\":{\"305\":1}}],[\"可以用于不同主机之间的进程通信\",{\"1\":{\"231\":1}}],[\"可以用于无亲缘关系的进程之间\",{\"1\":{\"226\":1}}],[\"可以很方便的获取线程函数的返回值\",{\"1\":{\"263\":1}}],[\"可以很容易地增加新的形状或颜色\",{\"1\":{\"151\":1}}],[\"可以手动释放锁\",{\"1\":{\"259\":1}}],[\"可以动态的释放锁资源\",{\"1\":{\"259\":1}}],[\"可以递归使用\",{\"1\":{\"258\":1}}],[\"可以调用线程对象的detach函数\",{\"1\":{\"257\":1}}],[\"可以调用线程对象的\",{\"1\":{\"236\":1}}],[\"可以选择不同的\",{\"1\":{\"232\":1}}],[\"可以使用生成的构建系统工具进行编译\",{\"1\":{\"352\":1}}],[\"可以使用一系列宏来解析这个状态值\",{\"1\":{\"302\":1}}],[\"可以使用std\",{\"1\":{\"263\":2}}],[\"可以使用\",{\"1\":{\"223\":1,\"332\":1}}],[\"可以使用数组作为查找表\",{\"1\":{\"17\":1}}],[\"可以有效地管理并发进程\",{\"1\":{\"306\":1}}],[\"可以有效地管理对象之间的依赖关系\",{\"1\":{\"133\":1}}],[\"可以有效避免僵尸进程的产生\",{\"1\":{\"220\":1}}],[\"可以通过\",{\"1\":{\"357\":1}}],[\"可以通过调用\",{\"1\":{\"220\":1}}],[\"可以通过进一步将链表转换为红黑树来提高效率\",{\"1\":{\"74\":1}}],[\"可以取代宏的功能\",{\"1\":{\"203\":1}}],[\"可以组成责任链\",{\"1\":{\"168\":1}}],[\"可以生产不同操作系统环境下的按钮和文本框\",{\"1\":{\"161\":1}}],[\"可以生产汽车和自行车\",{\"1\":{\"158\":1}}],[\"可以保持系统的灵活性\",{\"1\":{\"151\":1}}],[\"可以保持代码的开放封闭原则\",{\"1\":{\"145\":1}}],[\"可以保持代码的灵活性和可扩展性\",{\"1\":{\"139\":1}}],[\"可以独立地扩展抽象类和实现类\",{\"1\":{\"151\":1}}],[\"可以是\",{\"1\":{\"300\":1}}],[\"可以是抽象类或接口\",{\"1\":{\"144\":1}}],[\"可以是整数\",{\"1\":{\"73\":1}}],[\"可以避免使用条件语句来选择不同的算法\",{\"1\":{\"139\":1}}],[\"可以理解为资源的子节点的资源释放吗\",{\"1\":{\"113\":1}}],[\"可以观察到\",{\"1\":{\"103\":1}}],[\"可以直接删除\",{\"1\":{\"93\":1}}],[\"可以根据二叉搜索树的性质来查找\",{\"1\":{\"91\":1}}],[\"可以充分发挥二叉树\",{\"1\":{\"88\":1}}],[\"可以减少因取模操作而产生的周期性模式\",{\"1\":{\"71\":1}}],[\"可以最大化地保证哈希值的均匀分布\",{\"1\":{\"71\":1}}],[\"可以产生均匀分布的输出\",{\"1\":{\"70\":1}}],[\"可以看到当前分支的状态信息\",{\"1\":{\"315\":1}}],[\"可以看到\",{\"1\":{\"44\":1}}],[\"可以在内核的特定位置设置断点\",{\"1\":{\"373\":1}}],[\"可以在不提交代码的情况下保存未完成的工作\",{\"1\":{\"319\":1}}],[\"可以在一端添加元素\",{\"1\":{\"42\":1}}],[\"可以在代码中动态分配\",{\"1\":{\"36\":1}}],[\"可以朝两个方向遍历链表\",{\"1\":{\"26\":1}}],[\"可灵活扩展\",{\"1\":{\"25\":1}}],[\"下载安装程序\",{\"1\":{\"342\":1}}],[\"下表展示了在实际应用中常见的哈希算法\",{\"1\":{\"72\":1}}],[\"下表总结了数组和链表的各项特点并对比了操作效率\",{\"1\":{\"25\":1}}],[\"下\",{\"1\":{\"70\":1}}],[\"下面将详细介绍如何设置和使用\",{\"1\":{\"367\":1}}],[\"下面阐述实现多态的过程\",{\"1\":{\"207\":1}}],[\"下面展示了一个简单的\",{\"1\":{\"181\":1}}],[\"下面是一个简单的无锁单生产者单消费者队列的实现示例\",{\"1\":{\"250\":1}}],[\"下面是一个用\",{\"1\":{\"167\":1,\"221\":1}}],[\"下面是各个部分的详细解释\",{\"1\":{\"172\":1}}],[\"下面详细介绍这些旋转操作\",{\"1\":{\"101\":1}}],[\"下面举几个例子\",{\"1\":{\"68\":1}}],[\"下面以线性探测为例\",{\"1\":{\"64\":1}}],[\"下图展示的四种失衡情况与上述案例逐个对应\",{\"1\":{\"106\":1}}],[\"下图展示了二叉树的理想结构与退化结构\",{\"1\":{\"88\":1}}],[\"下图展示了开放寻址\",{\"1\":{\"65\":1}}],[\"下图展示了一个链式地址哈希表的例子\",{\"1\":{\"63\":1}}],[\"下图展示了数组的主要概念和存储方式\",{\"1\":{\"7\":1}}],[\"下图给出了一个示例\",{\"1\":{\"83\":1}}],[\"下图以\",{\"1\":{\"60\":1}}],[\"下一个节点\",{\"1\":{\"26\":1}}],[\"此方法简单粗暴且有效\",{\"1\":{\"62\":1}}],[\"此时线程对象的生命周期结束调用析构函数清理资源\",{\"1\":{\"236\":1,\"257\":1}}],[\"此时子进程的父进程是\",{\"1\":{\"220\":1}}],[\"此时子类部分的数据成员还未初始化\",{\"1\":{\"209\":1}}],[\"此时\",{\"1\":{\"207\":1,\"372\":1,\"373\":1}}],[\"此时需要先对\",{\"1\":{\"104\":1}}],[\"此时可以将链表转换为\",{\"1\":{\"63\":1}}],[\"此时节点\",{\"1\":{\"36\":1}}],[\"此时就不能用以下公式计算偏移量了\",{\"1\":{\"36\":1}}],[\"此时链表的灵活性优势就体现出来了\",{\"1\":{\"18\":1}}],[\"此过程也属于线性查找\",{\"1\":{\"24\":1}}],[\"遍历二叉树有前\",{\"1\":{\"113\":1}}],[\"遍历至\",{\"1\":{\"92\":1}}],[\"遍历桶\",{\"1\":{\"63\":3}}],[\"遍历哈希表\",{\"1\":{\"59\":1}}],[\"遍历键和遍历值\",{\"1\":{\"59\":1}}],[\"遍历键值对\",{\"1\":{\"59\":2}}],[\"遍历列表\",{\"0\":{\"33\":1}}],[\"遍历链表删除节点\",{\"1\":{\"43\":1,\"49\":1}}],[\"遍历链表\",{\"1\":{\"24\":1}}],[\"遍历数组\",{\"0\":{\"13\":1},\"1\":{\"13\":1}}],[\"轮循环内查找任意节点\",{\"1\":{\"95\":1}}],[\"轮\",{\"1\":{\"23\":1}}],[\"也不会有任何操作\",{\"1\":{\"223\":1}}],[\"也不是为它的派生类\",{\"1\":{\"210\":1}}],[\"也不同意是虚函数\",{\"1\":{\"210\":1}}],[\"也没有必要成为虚函数\",{\"1\":{\"210\":1}}],[\"也就是内存空间还没有\",{\"1\":{\"210\":1}}],[\"也就是说\",{\"1\":{\"23\":1,\"269\":1}}],[\"也称平衡二叉搜索树\",{\"1\":{\"112\":1}}],[\"也能使树重新变为\",{\"1\":{\"101\":1}}],[\"也是平衡二叉树\",{\"1\":{\"98\":1}}],[\"也常作为哈希表扩容的触发条件\",{\"1\":{\"61\":1}}],[\"也会出现很多空位\",{\"1\":{\"36\":1}}],[\"也可以重入\",{\"1\":{\"264\":1}}],[\"也可以\",{\"1\":{\"36\":1}}],[\"也可以直接遍历各元素\",{\"1\":{\"33\":1}}],[\"也可以直接遍历获取数组中的每个元素\",{\"1\":{\"13\":1}}],[\"也可能会使用环形链表\",{\"1\":{\"27\":1}}],[\"也可用于实现各种复杂数据结构\",{\"1\":{\"17\":1}}],[\"逐个向后遍历\",{\"1\":{\"23\":1}}],[\"访问变量\",{\"1\":{\"353\":1}}],[\"访问栈顶元素\",{\"1\":{\"47\":2,\"49\":1,\"50\":1}}],[\"访问队首元素\",{\"1\":{\"41\":2,\"43\":1,\"44\":1}}],[\"访问索引\",{\"1\":{\"31\":1}}],[\"访问链表中索引为\",{\"1\":{\"23\":1}}],[\"访问链表的第\",{\"1\":{\"23\":1}}],[\"访问节点\",{\"0\":{\"23\":1}}],[\"访问元素\",{\"0\":{\"10\":1,\"31\":1},\"1\":{\"25\":1,\"31\":1}}],[\"尽管在删除操作完成后节点\",{\"1\":{\"22\":1}}],[\"只回退提交\",{\"1\":{\"320\":1}}],[\"只是监视\",{\"1\":{\"266\":1}}],[\"只是在特定使用场景下时间效率变高了\",{\"1\":{\"75\":1}}],[\"只要求操作是原子的\",{\"1\":{\"252\":1}}],[\"只要保证程序的逻辑是正确的就行\",{\"1\":{\"36\":1}}],[\"只能用于有亲缘关系的进程\",{\"1\":{\"226\":1}}],[\"只可以在当前文件访问\",{\"1\":{\"200\":1}}],[\"只关注界面展示\",{\"1\":{\"177\":1}}],[\"只有在高频添加\",{\"1\":{\"95\":1}}],[\"只有最底层的节点未被填满\",{\"1\":{\"86\":1}}],[\"只有不可变对象是可哈希的\",{\"1\":{\"74\":1}}],[\"只有不可变对象才可作为哈希表的\",{\"1\":{\"73\":1}}],[\"只需增加一个具体策略类\",{\"1\":{\"139\":1}}],[\"只需将头节点从链表中删除即可\",{\"1\":{\"49\":1}}],[\"只需将\",{\"1\":{\"44\":1}}],[\"只需改变一个节点的引用\",{\"1\":{\"22\":1}}],[\"只用前面一部分\",{\"1\":{\"12\":1}}],[\"相当于\",{\"1\":{\"327\":1}}],[\"相等\",{\"1\":{\"251\":2}}],[\"相同\",{\"1\":{\"202\":1}}],[\"相应地\",{\"1\":{\"103\":1}}],[\"相较线性探测更不易产生聚集\",{\"1\":{\"74\":1}}],[\"相较\",{\"1\":{\"72\":1}}],[\"相较于\",{\"1\":{\"111\":1}}],[\"相较于数组\",{\"1\":{\"32\":1}}],[\"相较于单向链表\",{\"1\":{\"26\":1}}],[\"相关信息\",{\"1\":{\"67\":1,\"73\":1,\"80\":1,\"100\":1,\"256\":1,\"266\":1}}],[\"相对地\",{\"1\":{\"36\":1}}],[\"相比之下\",{\"1\":{\"21\":1,\"53\":1}}],[\"相连接\",{\"1\":{\"18\":1}}],[\"play\",{\"1\":{\"364\":3}}],[\"placeholder=\",{\"1\":{\"181\":1}}],[\"ptr是否为空指针\",{\"1\":{\"269\":1}}],[\"ptr是一个弱引用\",{\"1\":{\"269\":1}}],[\"ptr不保证它指向的内存一定是有效的\",{\"1\":{\"269\":1}}],[\"ptr不支持普通的拷贝和赋值操作\",{\"1\":{\"268\":1}}],[\"ptr引用该内存\",{\"1\":{\"269\":1}}],[\"ptr析构了之后\",{\"1\":{\"269\":1}}],[\"ptr同时引用\",{\"1\":{\"269\":1}}],[\"ptr和weak\",{\"1\":{\"269\":1}}],[\"ptr管理的对象而不影响所指对象的生命周期\",{\"1\":{\"269\":1}}],[\"ptr而引入的一种智能指针\",{\"1\":{\"269\":1}}],[\"ptr打破环形引用\",{\"1\":{\"269\":1}}],[\"ptr都会指向相同的资源\",{\"1\":{\"268\":1}}],[\"ptr将会把所有权全部从源指针转移给目标指针\",{\"1\":{\"268\":1}}],[\"ptr总是拥有它所指向的资源\",{\"1\":{\"268\":1}}],[\"ptr采用的是独享所有权语义\",{\"1\":{\"268\":1}}],[\"ptr\",{\"1\":{\"266\":8,\"268\":1,\"269\":1}}],[\"ptr<leavehandler>\",{\"1\":{\"167\":5}}],[\"ptr<guifactory>\",{\"1\":{\"161\":1}}],[\"ptr<textbox>\",{\"1\":{\"161\":5}}],[\"ptr<button>\",{\"1\":{\"161\":5}}],[\"ptr<vehiclefactory>\",{\"1\":{\"158\":2}}],[\"ptr<vehicle>\",{\"1\":{\"158\":5}}],[\"ptr<shape>\",{\"1\":{\"151\":2}}],[\"ptr<color>\",{\"1\":{\"151\":6}}],[\"pool\",{\"1\":{\"362\":2}}],[\"point\",{\"1\":{\"244\":2,\"245\":4}}],[\"pop\",{\"1\":{\"41\":2,\"43\":2,\"44\":1,\"47\":3,\"49\":2,\"50\":3,\"319\":1}}],[\"pipe\",{\"1\":{\"226\":1}}],[\"pipes\",{\"1\":{\"226\":2}}],[\"pid2\",{\"1\":{\"220\":2}}],[\"pid\",{\"1\":{\"220\":14,\"222\":8,\"226\":3,\"300\":9,\"301\":1,\"303\":7,\"304\":3,\"305\":1}}],[\"p>\",{\"1\":{\"181\":1}}],[\"perfect\",{\"1\":{\"85\":1}}],[\"peek\",{\"1\":{\"41\":1,\"43\":2,\"44\":2,\"47\":2}}],[\"path=\",{\"1\":{\"382\":1}}],[\"pattern\",{\"1\":{\"131\":1,\"137\":1,\"143\":1,\"149\":1,\"165\":1}}],[\"package\",{\"1\":{\"354\":2}}],[\"packaged\",{\"1\":{\"263\":7,\"264\":1}}],[\"passive\",{\"1\":{\"292\":1}}],[\"params\",{\"1\":{\"264\":2}}],[\"parent\",{\"1\":{\"79\":1,\"189\":2,\"193\":4,\"226\":1,\"227\":1,\"228\":1,\"229\":2}}],[\"pauses\",{\"1\":{\"236\":2}}],[\"pause\",{\"1\":{\"220\":1}}],[\"painter\",{\"1\":{\"189\":4}}],[\"paint\",{\"1\":{\"189\":1}}],[\"pairset\",{\"1\":{\"60\":5}}],[\"pair\",{\"1\":{\"60\":24,\"63\":22,\"65\":21,\"271\":1}}],[\"pub\",{\"1\":{\"369\":1}}],[\"public\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"60\":2,\"63\":1,\"65\":1,\"113\":3,\"133\":4,\"139\":6,\"145\":11,\"151\":10,\"158\":10,\"161\":15,\"167\":7,\"189\":2,\"193\":2,\"207\":4,\"243\":1,\"250\":1,\"251\":1,\"257\":1,\"262\":1,\"287\":1,\"361\":9,\"362\":2,\"363\":2,\"364\":11}}],[\"pull\",{\"1\":{\"327\":2,\"334\":1}}],[\"put\",{\"1\":{\"60\":1,\"63\":2,\"65\":2}}],[\"push\",{\"1\":{\"32\":5,\"41\":6,\"43\":2,\"44\":1,\"47\":7,\"49\":2,\"50\":3,\"60\":3,\"63\":1,\"239\":1,\"271\":3,\"328\":2,\"363\":1}}],[\"proc\",{\"1\":{\"370\":4}}],[\"proceeding\",{\"1\":{\"244\":1,\"245\":1}}],[\"process\",{\"1\":{\"218\":1,\"226\":1,\"227\":2,\"228\":1,\"229\":4,\"303\":3}}],[\"project\",{\"1\":{\"344\":2,\"346\":1,\"348\":1}}],[\"prom\",{\"1\":{\"263\":3}}],[\"promise更高级的东西\",{\"1\":{\"264\":1}}],[\"promise\",{\"1\":{\"263\":1}}],[\"promise包装的是一个值\",{\"1\":{\"263\":1}}],[\"promise<int>\",{\"1\":{\"263\":1}}],[\"promise与std\",{\"1\":{\"263\":1}}],[\"promise用来包装一个值\",{\"1\":{\"263\":1}}],[\"promise和std\",{\"1\":{\"263\":2}}],[\"produced\",{\"1\":{\"250\":1,\"251\":1}}],[\"producer\",{\"1\":{\"250\":2,\"251\":3}}],[\"product\",{\"1\":{\"157\":2,\"160\":2}}],[\"programming\",{\"1\":{\"247\":1}}],[\"progress\",{\"1\":{\"133\":2}}],[\"progfile\",{\"1\":{\"227\":1}}],[\"proxymodel\",{\"1\":{\"194\":4}}],[\"proxy\",{\"1\":{\"194\":1}}],[\"protected\",{\"1\":{\"151\":1,\"167\":1,\"287\":2,\"288\":2,\"361\":3,\"364\":1}}],[\"prefer\",{\"1\":{\"382\":1}}],[\"preferenceobserver\",{\"1\":{\"363\":2}}],[\"preference\",{\"1\":{\"363\":1}}],[\"preemption\",{\"1\":{\"246\":1}}],[\"presenter\",{\"1\":{\"177\":3}}],[\"presentation\",{\"1\":{\"171\":1}}],[\"pre\",{\"1\":{\"92\":6,\"93\":5}}],[\"prev\",{\"1\":{\"26\":2}}],[\"price\",{\"1\":{\"139\":7}}],[\"primer\",{\"1\":{\"121\":1}}],[\"prints\",{\"1\":{\"277\":1}}],[\"print\",{\"1\":{\"60\":1,\"63\":1,\"65\":1,\"238\":2,\"240\":2,\"374\":1}}],[\"private\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"60\":1,\"63\":1,\"65\":1,\"113\":3,\"133\":1,\"145\":4,\"250\":1,\"257\":1,\"262\":1,\"287\":1,\"355\":1,\"361\":2,\"363\":1,\"364\":1}}],[\"p\",{\"1\":{\"21\":5,\"22\":7,\"36\":6,\"83\":5,\"181\":1,\"242\":3,\"382\":1}}],[\"python\",{\"1\":{\"18\":1,\"28\":1,\"34\":1,\"36\":2,\"54\":1,\"68\":1,\"73\":2,\"74\":1}}],[\"之前\",{\"1\":{\"252\":1}}],[\"之间\",{\"1\":{\"226\":1}}],[\"之间没有直接的依赖关系\",{\"1\":{\"179\":1}}],[\"之间保持同步\",{\"1\":{\"175\":1}}],[\"之间的中介\",{\"1\":{\"189\":1}}],[\"之间的同步更加方便\",{\"1\":{\"179\":1}}],[\"之间的桥梁\",{\"1\":{\"175\":1}}],[\"之间的关系\",{\"1\":{\"113\":1}}],[\"之间的大小关系\",{\"1\":{\"91\":1}}],[\"之间的派生关系\",{\"1\":{\"79\":1}}],[\"之间的映射\",{\"1\":{\"58\":1}}],[\"之间不存在公约数\",{\"1\":{\"71\":1}}],[\"之间插入一个新节点\",{\"1\":{\"21\":1}}],[\"之后\",{\"1\":{\"252\":1}}],[\"之后插入节点\",{\"1\":{\"21\":1}}],[\"之后的首个节点\",{\"1\":{\"22\":1}}],[\"之后的所有元素向前移动一位\",{\"1\":{\"12\":1}}],[\"之后的元素都向前移动一位\",{\"1\":{\"12\":1}}],[\"之后再把元素赋值给该索引\",{\"1\":{\"11\":1}}],[\"假如线程函数执行时间较长\",{\"1\":{\"236\":1,\"257\":1}}],[\"假如我们将列表\",{\"1\":{\"73\":1}}],[\"假如我们希望实现\",{\"1\":{\"58\":1}}],[\"假如我们想实现字符到\",{\"1\":{\"17\":1}}],[\"假如把列表元素换成链表节点\",{\"1\":{\"36\":1}}],[\"假设基类中采用的是非虚析构函数\",{\"1\":{\"210\":1}}],[\"假设函数调用使用虚机制\",{\"1\":{\"210\":1}}],[\"假设构造函数是虚的\",{\"1\":{\"210\":1}}],[\"假设有数组\",{\"0\":{\"202\":1}}],[\"假设将\",{\"1\":{\"71\":1}}],[\"假设我们有一个操作系统的工厂\",{\"1\":{\"161\":1}}],[\"假设我们有一个交通工具的工厂\",{\"1\":{\"158\":1}}],[\"假设我们选择右子树的最小节点\",{\"1\":{\"93\":1}}],[\"假设我们选择合数\",{\"1\":{\"71\":1}}],[\"假设我们想在相邻的两个节点\",{\"1\":{\"21\":1}}],[\"假设被删除节点未被正常回收\",{\"1\":{\"36\":1}}],[\"而std\",{\"1\":{\"263\":3}}],[\"而全然忽视这个对象后面是否还有继承者\",{\"1\":{\"210\":1}}],[\"而构造函数是在创建对象时自己主动调用的\",{\"1\":{\"210\":1}}],[\"而类中虚函数的个数在编译时期可以确定\",{\"1\":{\"208\":1}}],[\"而constexpr有\",{\"1\":{\"203\":1}}],[\"而代理模型则进一步扩展了数据处理的能力\",{\"1\":{\"194\":1}}],[\"而无需指定它们的具体类\",{\"1\":{\"159\":1}}],[\"而无需了解具体的创建过程\",{\"1\":{\"156\":1}}],[\"而无法减少哈希冲突的发生\",{\"1\":{\"69\":1}}],[\"而抽象工厂模式适用于创建相关产品的家族\",{\"1\":{\"155\":1}}],[\"而不影响当前的代码提交历史\",{\"1\":{\"319\":1}}],[\"而不阻塞\",{\"1\":{\"300\":1}}],[\"而不是跟随最新的更改\",{\"1\":{\"336\":1}}],[\"而不是等到子进程终止\",{\"1\":{\"300\":1}}],[\"而不是std\",{\"1\":{\"259\":1}}],[\"而不是最后的vtable\",{\"1\":{\"210\":1}}],[\"而不会阻塞或挂起\",{\"1\":{\"243\":1}}],[\"而不会调用派生类的析构函数\",{\"1\":{\"210\":1}}],[\"而不会相互影响\",{\"1\":{\"151\":1}}],[\"而不依赖于实际的\",{\"1\":{\"179\":1}}],[\"而不需要指定创建的具体类\",{\"1\":{\"155\":1}}],[\"而不需要修改现有代码\",{\"1\":{\"139\":1}}],[\"而空节点的高度为\",{\"1\":{\"99\":1}}],[\"而二叉搜索树满足\",{\"1\":{\"94\":1}}],[\"而需要使用一个节点替换该节点\",{\"1\":{\"93\":1}}],[\"而删除节点通常意味着删除该节点及其所有子树\",{\"1\":{\"83\":1}}],[\"而\",{\"1\":{\"74\":1,\"75\":1,\"113\":1}}],[\"而当所有节点都偏向一侧时\",{\"1\":{\"88\":1}}],[\"而当\",{\"1\":{\"71\":1}}],[\"而当查询元素时\",{\"1\":{\"65\":1}}],[\"而当数组非常大时\",{\"1\":{\"18\":1}}],[\"而通过线性探测\",{\"1\":{\"65\":1}}],[\"而输入空间往往远大于输出空间\",{\"1\":{\"61\":1}}],[\"而向上回溯阶段则会不断执行出栈操作\",{\"1\":{\"52\":1}}],[\"而对于出栈操作\",{\"1\":{\"49\":1}}],[\"而位于队列头部的人逐个离开\",{\"1\":{\"40\":1}}],[\"而非链表\",{\"1\":{\"36\":1}}],[\"而非节点本身\",{\"1\":{\"36\":1}}],[\"而只在必要时才使用链表\",{\"1\":{\"36\":1}}],[\"而是未定义\",{\"1\":{\"264\":1}}],[\"而是希望通过动态组合的方式进行扩展\",{\"1\":{\"143\":1}}],[\"而是存储密码的哈希值\",{\"1\":{\"70\":1}}],[\"而是跳过\",{\"1\":{\"66\":1}}],[\"而是利用一个常量\",{\"1\":{\"65\":1}}],[\"而是通过信号和槽机制通知\",{\"1\":{\"187\":1}}],[\"而是通过数据绑定和命令机制进行交互\",{\"1\":{\"175\":1}}],[\"而是通过\",{\"1\":{\"64\":1}}],[\"而是对数字的引用\",{\"1\":{\"36\":1}}],[\"而是分别跟\",{\"1\":{\"36\":1}}],[\"而在链表中却没有强调相同类型呢\",{\"1\":{\"36\":1}}],[\"而堆上的数组的大小可以在运行时动态确定\",{\"1\":{\"36\":1}}],[\"而堆内存相对更大\",{\"1\":{\"36\":1}}],[\"而链表是退化后的最差状态\",{\"1\":{\"112\":1}}],[\"而链表是由多个独立的节点对象组成的\",{\"1\":{\"20\":1}}],[\"而链表则在内存使用上更加灵活\",{\"1\":{\"35\":1}}],[\"等于\",{\"1\":{\"300\":1}}],[\"等待任何子进程\",{\"1\":{\"300\":1}}],[\"等待任何属于与调用进程相同进程组的子进程\",{\"1\":{\"300\":1}}],[\"等待进程组\",{\"1\":{\"300\":1}}],[\"等待进程\",{\"1\":{\"300\":1}}],[\"等待最后的确认\",{\"1\":{\"294\":1}}],[\"等待应用程序关闭连接\",{\"1\":{\"292\":1,\"294\":1}}],[\"等待对方发送fin包\",{\"1\":{\"292\":1}}],[\"等待对方的ack\",{\"1\":{\"292\":2}}],[\"等待客户端的ack确认\",{\"1\":{\"292\":1}}],[\"等待服务器的syn\",{\"1\":{\"292\":1}}],[\"等待其它线程通知后唤醒\",{\"1\":{\"264\":1}}],[\"等待线程完成\",{\"1\":{\"251\":1}}],[\"等待和保持\",{\"1\":{\"246\":1}}],[\"等待所有线程到达锁存器\",{\"1\":{\"245\":1}}],[\"等待所有线程到达屏障点\",{\"1\":{\"244\":1}}],[\"等待所有已终止的子进程\",{\"1\":{\"220\":1}}],[\"等待机制\",{\"1\":{\"244\":1,\"245\":1}}],[\"等待操作\",{\"1\":{\"242\":1}}],[\"等待条件变量的通知\",{\"1\":{\"240\":1}}],[\"等待\",{\"1\":{\"240\":2,\"250\":2,\"251\":2,\"372\":1}}],[\"等待子进程终止\",{\"1\":{\"303\":1,\"304\":1}}],[\"等待子进程终止的示例代码\",{\"1\":{\"303\":1}}],[\"等待子进程完成\",{\"1\":{\"228\":1,\"229\":1}}],[\"等待子进程结束并回收资源\",{\"1\":{\"220\":1}}],[\"等待信号\",{\"1\":{\"220\":1}}],[\"等待再次被调度\",{\"1\":{\"216\":1}}],[\"等待资源释放\",{\"1\":{\"242\":1}}],[\"等待资源\",{\"1\":{\"216\":1}}],[\"等待下一次调度\",{\"1\":{\"216\":1}}],[\"等待调度器的调度\",{\"1\":{\"216\":1}}],[\"等待被调度器分配\",{\"1\":{\"215\":1}}],[\"等信号通知\",{\"1\":{\"191\":1}}],[\"等构建而成\",{\"1\":{\"174\":1}}],[\"等语言拥有自动垃圾回收机制\",{\"1\":{\"54\":1}}],[\"等\",{\"1\":{\"20\":1,\"28\":1,\"34\":1,\"36\":1,\"72\":1,\"74\":1,\"171\":1,\"210\":1,\"241\":1,\"243\":1,\"248\":1}}],[\"等支持指针的语言中\",{\"1\":{\"18\":1}}],[\"构成了一条责任链\",{\"1\":{\"168\":1}}],[\"构成的输入空间映射到数组所有索引构成的输出空间\",{\"1\":{\"61\":1}}],[\"构建项目\",{\"0\":{\"352\":1}}],[\"构建\",{\"1\":{\"343\":1,\"350\":1,\"352\":2}}],[\"构建目录\",{\"1\":{\"343\":1}}],[\"构建树的方法已在二叉搜索树代码中的\",{\"1\":{\"113\":1}}],[\"构建节点之间的引用\",{\"1\":{\"20\":1,\"82\":1}}],[\"构造方法\",{\"1\":{\"63\":1,\"65\":1}}],[\"构造函数通过\",{\"1\":{\"288\":1}}],[\"构造函数在编译时对字符串进行加密\",{\"1\":{\"287\":1}}],[\"构造函数减少引用计数\",{\"1\":{\"267\":1}}],[\"构造函数初始化队列的容量\",{\"1\":{\"251\":1}}],[\"构造函数不须要是虚函数\",{\"1\":{\"210\":1}}],[\"构造函数本身就是要初始化实例\",{\"1\":{\"210\":1}}],[\"构造函数为什么不能为虚函数\",{\"0\":{\"210\":1}}],[\"构造函数和析构函数调用虚函数时都不使用动态联编\",{\"1\":{\"209\":1}}],[\"构造函数和析构函数可以调用虚函数\",{\"0\":{\"209\":1}}],[\"构造函数\",{\"1\":{\"18\":1,\"26\":1,\"201\":1}}],[\"第二次的destruct是因为临时对象在构造a对象之后就销毁了\",{\"1\":{\"270\":1}}],[\"第二个子进程继续运行\",{\"1\":{\"223\":1}}],[\"第二个子进程\",{\"1\":{\"223\":1}}],[\"第二步是构建节点之间的引用关系\",{\"1\":{\"20\":1}}],[\"第一个参数是创建策略\",{\"1\":{\"264\":1}}],[\"第一个子进程退出\",{\"1\":{\"220\":1,\"222\":1,\"223\":1}}],[\"第一个子进程\",{\"1\":{\"220\":1}}],[\"第一步是初始化各个节点对象\",{\"1\":{\"20\":1}}],[\"第\",{\"1\":{\"88\":1}}],[\"x86\",{\"1\":{\"369\":2,\"372\":1}}],[\"xvf\",{\"1\":{\"369\":1,\"370\":1}}],[\"xz\",{\"1\":{\"369\":2,\"372\":1}}],[\"xor\",{\"1\":{\"287\":3,\"288\":3}}],[\"x\",{\"1\":{\"18\":2,\"26\":2,\"67\":5,\"75\":2,\"79\":2,\"99\":2,\"236\":1,\"263\":2,\"274\":3,\"369\":1,\"374\":1}}],[\"指定启动的文件系统\",{\"1\":{\"372\":1}}],[\"指定启用的内核镜像\",{\"1\":{\"372\":1}}],[\"指定最低\",{\"1\":{\"344\":1}}],[\"指什么呢\",{\"1\":{\"113\":1}}],[\"指向一个\",{\"1\":{\"300\":1}}],[\"指向该对象的所有智能指针内部的引用计数加1\",{\"1\":{\"267\":1}}],[\"指向下一个元素的位置\",{\"1\":{\"251\":1}}],[\"指向下一节点的指针\",{\"1\":{\"18\":1}}],[\"指向虚函数表\",{\"1\":{\"208\":1}}],[\"指向对象所属类的虚表\",{\"1\":{\"207\":1}}],[\"指向树的根节点\",{\"1\":{\"90\":1}}],[\"指向队尾索引\",{\"1\":{\"44\":1}}],[\"指向队尾元素之后的下一个位置\",{\"1\":{\"44\":1}}],[\"指向队首元素\",{\"1\":{\"44\":1}}],[\"指向队首元素的索引\",{\"1\":{\"44\":1}}],[\"指向哪里都不会对该链表产生影响\",{\"1\":{\"36\":1}}],[\"指向前驱节点的指针\",{\"1\":{\"26\":1}}],[\"指向后继节点的指针\",{\"1\":{\"26\":1}}],[\"指针的问题\",{\"1\":{\"266\":1}}],[\"指针初始化为\",{\"1\":{\"251\":1}}],[\"指针变量占用的内存空间大小根据所使用的操作系统及编译环境而定\",{\"1\":{\"36\":1}}],[\"指针\",{\"1\":{\"18\":2,\"21\":1,\"22\":1,\"26\":1,\"35\":1,\"36\":1,\"79\":1,\"80\":1,\"82\":2}}],[\"节点插入和节点删除操作与链表操作方法类似\",{\"1\":{\"112\":1}}],[\"节点增删操作的平均效率更高\",{\"1\":{\"111\":1}}],[\"节点下方为平衡因子\",{\"1\":{\"102\":1}}],[\"节点平衡因子\",{\"0\":{\"100\":1},\"1\":{\"100\":1}}],[\"节点高度等于最高子树高度\",{\"1\":{\"99\":1}}],[\"节点高度\",{\"0\":{\"99\":1},\"1\":{\"99\":2}}],[\"节点总数为\",{\"1\":{\"88\":1}}],[\"节点总数\",{\"1\":{\"88\":1}}],[\"节点所在的层\",{\"1\":{\"80\":1}}],[\"节点\",{\"1\":{\"79\":5,\"102\":1}}],[\"节点之间通过引用\",{\"1\":{\"36\":1}}],[\"节点值\",{\"1\":{\"18\":1,\"26\":1,\"79\":1,\"99\":1}}],[\"节点的平衡因子\",{\"1\":{\"100\":1}}],[\"节点的高度\",{\"1\":{\"80\":1}}],[\"节点的深度\",{\"1\":{\"80\":1}}],[\"节点的子节点的数量\",{\"1\":{\"80\":1}}],[\"节点的度\",{\"1\":{\"80\":1}}],[\"节点的\",{\"1\":{\"18\":1}}],[\"vmlinux\",{\"1\":{\"369\":3,\"372\":2,\"373\":2}}],[\"v6\",{\"1\":{\"369\":1}}],[\"variable提供等待的同步机制\",{\"1\":{\"264\":1}}],[\"variable相关\",{\"0\":{\"262\":1},\"1\":{\"256\":1}}],[\"variable\",{\"1\":{\"240\":1,\"262\":1,\"353\":2}}],[\"variable>\",{\"1\":{\"240\":1}}],[\"valueset\",{\"1\":{\"60\":4}}],[\"value\",{\"1\":{\"58\":2,\"59\":3,\"60\":4,\"65\":1,\"73\":1,\"74\":2,\"133\":3,\"239\":2,\"241\":1,\"263\":2,\"353\":1,\"363\":3}}],[\"val\",{\"1\":{\"18\":2,\"26\":2,\"60\":5,\"63\":5,\"65\":5,\"79\":2,\"91\":4,\"99\":2,\"108\":6,\"109\":5,\"229\":2}}],[\"vptr的状态是由被最后调用的构造函数确定的\",{\"1\":{\"210\":1}}],[\"vptr将保持被初始化为指向这个vtable\",{\"1\":{\"210\":1}}],[\"vtable\",{\"1\":{\"210\":1}}],[\"vtable来调用\",{\"1\":{\"210\":1}}],[\"vbtl在构造函数调用后才建立\",{\"1\":{\"210\":1}}],[\"v\",{\"1\":{\"181\":2,\"242\":3,\"271\":3,\"274\":2,\"275\":2,\"311\":2,\"382\":1}}],[\"vue\",{\"0\":{\"181\":1},\"1\":{\"171\":1,\"177\":1,\"181\":5}}],[\"virt\",{\"1\":{\"371\":1}}],[\"virtual函数是在不同类型的对象产生不同的动作\",{\"1\":{\"210\":1}}],[\"virtual\",{\"1\":{\"133\":1,\"139\":1,\"145\":3,\"151\":4,\"158\":4,\"161\":7,\"167\":1,\"207\":2,\"361\":3,\"363\":1,\"364\":2}}],[\"vim\",{\"1\":{\"370\":1,\"382\":1}}],[\"videotask\",{\"1\":{\"364\":1}}],[\"visual\",{\"1\":{\"341\":1,\"343\":1,\"351\":1,\"357\":2}}],[\"viewmodel\",{\"0\":{\"175\":1},\"1\":{\"171\":1,\"172\":1,\"174\":3,\"175\":2,\"176\":8,\"177\":4,\"179\":3,\"181\":1}}],[\"view\",{\"0\":{\"174\":1,\"185\":1,\"186\":1,\"188\":1,\"190\":1,\"192\":1},\"1\":{\"171\":1,\"172\":1,\"174\":1,\"175\":6,\"176\":4,\"177\":8,\"179\":3,\"181\":2,\"182\":1,\"185\":4,\"187\":4,\"188\":10,\"189\":2,\"190\":7,\"191\":3,\"192\":5,\"194\":2},\"2\":{\"196\":1}}],[\"version\",{\"1\":{\"344\":2,\"348\":1}}],[\"vehiclefactory\",{\"1\":{\"158\":3}}],[\"vehicle\",{\"1\":{\"158\":3}}],[\"velsky\",{\"1\":{\"97\":1}}],[\"vector<task\",{\"1\":{\"364\":1}}],[\"vector<preferenceobserver\",{\"1\":{\"363\":1}}],[\"vector<pair\",{\"1\":{\"60\":4,\"65\":3}}],[\"vector<complicated>\",{\"1\":{\"271\":1}}],[\"vector<std\",{\"1\":{\"244\":1,\"245\":1}}],[\"vector<string>\",{\"1\":{\"60\":2}}],[\"vector<vector<pair\",{\"1\":{\"63\":2}}],[\"vector<int>\",{\"1\":{\"30\":2,\"43\":2,\"44\":2,\"49\":2,\"50\":2,\"60\":2,\"239\":1,\"275\":1}}],[\"vector\",{\"1\":{\"28\":1,\"30\":1,\"36\":2,\"43\":1,\"44\":1,\"50\":1,\"113\":1}}],[\"vs\",{\"0\":{\"25\":1}}],[\"void\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"21\":1,\"22\":1,\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"60\":3,\"63\":4,\"65\":4,\"92\":1,\"93\":1,\"99\":1,\"133\":4,\"139\":1,\"151\":6,\"158\":3,\"161\":6,\"167\":3,\"189\":1,\"207\":2,\"220\":1,\"222\":1,\"228\":2,\"229\":2,\"230\":1,\"236\":2,\"238\":1,\"239\":2,\"240\":2,\"241\":1,\"242\":1,\"243\":3,\"244\":1,\"245\":1,\"260\":4,\"261\":1,\"262\":2,\"263\":1,\"273\":1,\"361\":11,\"362\":2,\"363\":4,\"364\":8}}],[\"snap\",{\"1\":{\"382\":1}}],[\"script\",{\"1\":{\"364\":5,\"370\":1}}],[\"script>\",{\"1\":{\"181\":2}}],[\"scopeoption\",{\"1\":{\"362\":1}}],[\"scope\",{\"1\":{\"362\":5}}],[\"scoped\",{\"1\":{\"277\":1}}],[\"switch\",{\"1\":{\"277\":1}}],[\"swap\",{\"1\":{\"241\":1,\"243\":1,\"248\":1}}],[\"syn\",{\"1\":{\"292\":2,\"294\":2,\"295\":2}}],[\"sync\",{\"1\":{\"244\":2,\"245\":3}}],[\"synchronize\",{\"1\":{\"236\":1}}],[\"systemctl\",{\"1\":{\"382\":1}}],[\"system\",{\"1\":{\"371\":1,\"372\":1,\"382\":1}}],[\"systemd\",{\"1\":{\"220\":1,\"382\":1}}],[\"sysfs\",{\"1\":{\"370\":1}}],[\"sys\",{\"1\":{\"370\":3}}],[\"syslog\",{\"1\":{\"224\":1}}],[\"specific\",{\"1\":{\"336\":1}}],[\"spinlock\",{\"0\":{\"243\":1},\"1\":{\"243\":5}}],[\"spawn\",{\"1\":{\"236\":2}}],[\"spliter\",{\"1\":{\"133\":3}}],[\"splitfile\",{\"1\":{\"133\":2}}],[\"something\",{\"1\":{\"361\":3,\"362\":2,\"364\":7}}],[\"source\",{\"1\":{\"343\":1,\"350\":1}}],[\"soft\",{\"1\":{\"320\":2}}],[\"sockaddr\",{\"1\":{\"231\":4}}],[\"sock\",{\"1\":{\"231\":6}}],[\"socket\",{\"1\":{\"231\":7}}],[\"son2\",{\"1\":{\"207\":2}}],[\"son1\",{\"1\":{\"207\":4}}],[\"sbin\",{\"1\":{\"382\":3}}],[\"sb\",{\"1\":{\"229\":4}}],[\"sh\",{\"1\":{\"370\":2,\"382\":2}}],[\"should\",{\"1\":{\"271\":1}}],[\"short\",{\"1\":{\"229\":1}}],[\"shmctl\",{\"1\":{\"228\":1}}],[\"shmdt\",{\"1\":{\"228\":2}}],[\"shmat\",{\"1\":{\"228\":2}}],[\"shmget\",{\"1\":{\"228\":1}}],[\"shmid\",{\"1\":{\"228\":4}}],[\"shmfile\",{\"1\":{\"228\":1}}],[\"shm\",{\"1\":{\"228\":1}}],[\"shared<directorhandler>\",{\"1\":{\"167\":1}}],[\"shared<managerhandler>\",{\"1\":{\"167\":1}}],[\"shared<macosfactory>\",{\"1\":{\"161\":1}}],[\"shared<macostextbox>\",{\"1\":{\"161\":1}}],[\"shared<macosbutton>\",{\"1\":{\"161\":1}}],[\"shared<teamleaderhandler>\",{\"1\":{\"167\":1}}],[\"shared<windowsfactory>\",{\"1\":{\"161\":1}}],[\"shared<windowstextbox>\",{\"1\":{\"161\":1}}],[\"shared<windowsbutton>\",{\"1\":{\"161\":1}}],[\"shared<bikefactory>\",{\"1\":{\"158\":1}}],[\"shared<bike>\",{\"1\":{\"158\":1}}],[\"shared<bluecolor>\",{\"1\":{\"151\":1}}],[\"shared<carfactory>\",{\"1\":{\"158\":1}}],[\"shared<car>\",{\"1\":{\"158\":1}}],[\"shared<circle>\",{\"1\":{\"151\":1}}],[\"shared<square>\",{\"1\":{\"151\":1}}],[\"shared<redcolor>\",{\"1\":{\"151\":1}}],[\"shared\",{\"1\":{\"151\":8,\"158\":7,\"161\":11,\"167\":5,\"239\":4,\"263\":1,\"266\":5,\"370\":1}}],[\"shape\",{\"1\":{\"151\":6}}],[\"sha\",{\"1\":{\"72\":13,\"74\":4}}],[\"sleep\",{\"1\":{\"222\":1,\"223\":1,\"229\":2,\"230\":1,\"240\":1,\"242\":1,\"243\":1,\"257\":1,\"303\":1}}],[\"such\",{\"1\":{\"382\":1}}],[\"success\",{\"1\":{\"222\":2}}],[\"sudo\",{\"1\":{\"342\":1,\"382\":2}}],[\"subsequent\",{\"1\":{\"382\":1}}],[\"submodules\",{\"1\":{\"332\":2}}],[\"submodule\",{\"0\":{\"330\":1},\"1\":{\"330\":2,\"331\":2,\"332\":2,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1}}],[\"sub\",{\"1\":{\"260\":2}}],[\"subject\",{\"1\":{\"132\":2}}],[\"subtree\",{\"1\":{\"79\":2}}],[\"src\",{\"1\":{\"353\":1}}],[\"src=\",{\"1\":{\"181\":1}}],[\"srp\",{\"1\":{\"126\":1}}],[\"sigcont\",{\"1\":{\"300\":1}}],[\"sigchld\",{\"1\":{\"220\":8}}],[\"sigstop\",{\"1\":{\"300\":1}}],[\"sigint\",{\"1\":{\"230\":2}}],[\"sigterm\",{\"1\":{\"224\":1}}],[\"signaloption\",{\"1\":{\"362\":1}}],[\"signalhandler\",{\"1\":{\"230\":2}}],[\"signal\",{\"1\":{\"220\":1,\"230\":3,\"242\":1,\"303\":2,\"362\":5}}],[\"signum\",{\"1\":{\"220\":1,\"230\":3}}],[\"silverlight\",{\"1\":{\"171\":1}}],[\"size>\",{\"1\":{\"287\":1}}],[\"sizeof\",{\"1\":{\"226\":1,\"227\":2,\"231\":3,\"362\":2}}],[\"size++\",{\"1\":{\"63\":1,\"65\":1}}],[\"size\",{\"1\":{\"10\":3,\"11\":2,\"12\":2,\"13\":2,\"14\":2,\"15\":3,\"33\":1,\"34\":1,\"36\":2,\"41\":2,\"43\":4,\"44\":6,\"47\":2,\"49\":4,\"50\":3,\"63\":6,\"65\":5,\"73\":4,\"113\":1,\"250\":5,\"251\":4,\"287\":5}}],[\"square\",{\"1\":{\"151\":3}}],[\"s\",{\"1\":{\"145\":4,\"370\":1,\"372\":4,\"374\":2}}],[\"salt\",{\"1\":{\"73\":1}}],[\"serve\",{\"1\":{\"382\":1}}],[\"server\",{\"1\":{\"231\":8}}],[\"service\",{\"1\":{\"382\":3}}],[\"serv\",{\"1\":{\"231\":3}}],[\"send\",{\"1\":{\"231\":1}}],[\"sent状态\",{\"1\":{\"294\":1}}],[\"sent\",{\"1\":{\"227\":1,\"292\":1,\"294\":1,\"295\":1}}],[\"section\",{\"1\":{\"229\":4}}],[\"seconds\",{\"1\":{\"240\":1,\"242\":1,\"243\":1,\"257\":1,\"370\":1}}],[\"second\",{\"1\":{\"59\":1,\"236\":4}}],[\"semctl\",{\"1\":{\"229\":2}}],[\"semget\",{\"1\":{\"229\":1}}],[\"semfile\",{\"1\":{\"229\":1}}],[\"semaphore<1>\",{\"1\":{\"242\":1}}],[\"semaphoresignal\",{\"1\":{\"229\":3}}],[\"semaphorewait\",{\"1\":{\"229\":3}}],[\"semop\",{\"1\":{\"229\":2}}],[\"sembuf\",{\"1\":{\"229\":2}}],[\"seminfo\",{\"1\":{\"229\":1}}],[\"semid\",{\"1\":{\"229\":12}}],[\"semun\",{\"1\":{\"229\":2}}],[\"sem\",{\"1\":{\"229\":4,\"242\":3}}],[\"session\",{\"1\":{\"222\":1}}],[\"setuidgid\",{\"1\":{\"370\":1}}],[\"settings\",{\"1\":{\"370\":1}}],[\"setbrowser\",{\"1\":{\"364\":1}}],[\"setwavestyle\",{\"1\":{\"361\":1}}],[\"set\",{\"1\":{\"240\":2,\"243\":2,\"263\":1,\"353\":1,\"382\":1}}],[\"setvalue\",{\"1\":{\"363\":1}}],[\"setval\",{\"1\":{\"229\":1}}],[\"setsid\",{\"1\":{\"222\":1,\"223\":1,\"370\":1}}],[\"setdata\",{\"1\":{\"193\":1}}],[\"setdiscountstrategy\",{\"1\":{\"139\":2}}],[\"setmodel\",{\"1\":{\"190\":1}}],[\"setnexthandler\",{\"1\":{\"167\":1}}],[\"setprogress\",{\"1\":{\"133\":2}}],[\"seasonaldiscount\",{\"1\":{\"139\":2}}],[\"search\",{\"1\":{\"89\":1,\"91\":4,\"98\":1}}],[\"separate\",{\"1\":{\"63\":1}}],[\"self\",{\"1\":{\"36\":2}}],[\"style\",{\"1\":{\"361\":4}}],[\"studio\",{\"1\":{\"341\":1,\"343\":1,\"351\":1,\"357\":2}}],[\"stuff\",{\"1\":{\"236\":2}}],[\"stopped\",{\"1\":{\"303\":1}}],[\"store\",{\"1\":{\"250\":2,\"251\":4,\"252\":2,\"260\":2}}],[\"start\",{\"1\":{\"373\":3,\"382\":2}}],[\"stash\",{\"1\":{\"319\":3}}],[\"staged\",{\"1\":{\"317\":2}}],[\"stage\",{\"1\":{\"313\":1}}],[\"status\",{\"1\":{\"300\":2,\"302\":8,\"303\":10,\"304\":5,\"315\":2,\"333\":1}}],[\"state\",{\"1\":{\"291\":1}}],[\"stat\",{\"1\":{\"222\":1}}],[\"static\",{\"0\":{\"200\":1},\"1\":{\"274\":1,\"277\":1,\"353\":1,\"362\":2,\"370\":2}}],[\"stacktop\",{\"1\":{\"49\":10}}],[\"stack<int>\",{\"1\":{\"47\":1}}],[\"stack\",{\"1\":{\"36\":1,\"46\":1,\"47\":10,\"49\":2,\"50\":9}}],[\"step\",{\"1\":{\"373\":1,\"374\":1}}],[\"step4\",{\"1\":{\"91\":1,\"93\":1,\"102\":1}}],[\"step3\",{\"1\":{\"91\":1,\"93\":1,\"102\":1}}],[\"step2\",{\"1\":{\"91\":1,\"93\":1,\"102\":1}}],[\"stksize++\",{\"1\":{\"49\":1}}],[\"stksize\",{\"1\":{\"49\":4}}],[\"stderr\",{\"1\":{\"222\":2}}],[\"stdout\",{\"1\":{\"222\":2}}],[\"stdin\",{\"1\":{\"222\":2}}],[\"std\",{\"0\":{\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1,\"263\":1},\"1\":{\"36\":5,\"73\":1,\"133\":2,\"139\":4,\"145\":20,\"151\":21,\"158\":15,\"161\":25,\"167\":14,\"207\":1,\"222\":8,\"226\":2,\"227\":4,\"228\":2,\"229\":8,\"230\":2,\"231\":2,\"236\":6,\"238\":6,\"239\":11,\"240\":11,\"241\":6,\"242\":7,\"243\":9,\"244\":6,\"245\":6,\"249\":1,\"250\":14,\"251\":18,\"252\":3,\"256\":7,\"257\":15,\"258\":16,\"259\":8,\"260\":6,\"261\":4,\"262\":6,\"263\":18,\"264\":24,\"270\":2,\"271\":6,\"275\":2,\"277\":4,\"287\":4,\"303\":18,\"347\":2,\"363\":1,\"364\":1}}],[\"stl\",{\"1\":{\"36\":1}}],[\"strcpy\",{\"1\":{\"227\":1,\"228\":1}}],[\"strlen\",{\"1\":{\"226\":1,\"231\":1}}],[\"stream\",{\"1\":{\"145\":10,\"231\":2}}],[\"strategy\",{\"1\":{\"137\":1,\"139\":10}}],[\"str\",{\"1\":{\"73\":2,\"228\":6,\"287\":7,\"288\":2}}],[\"string>\",{\"1\":{\"59\":1}}],[\"string\",{\"1\":{\"36\":1,\"59\":1,\"60\":4,\"63\":2,\"65\":2,\"71\":1,\"73\":1,\"113\":2,\"145\":10,\"271\":3}}],[\"struct\",{\"1\":{\"18\":1,\"26\":1,\"60\":1,\"79\":1,\"99\":1,\"227\":1,\"229\":4,\"231\":2,\"260\":2,\"270\":1,\"271\":1}}],[\"还支持很多高级功能\",{\"1\":{\"357\":1}}],[\"还支持安装可执行文件和库\",{\"1\":{\"356\":1}}],[\"还可以设置互斥量的超时时间\",{\"1\":{\"264\":1}}],[\"还可以获取线程id等信息\",{\"1\":{\"264\":1}}],[\"还未进入准备就绪队列\",{\"1\":{\"215\":1}}],[\"还处理用户的输入\",{\"1\":{\"175\":1}}],[\"还需要对操作系统有深刻的理解\",{\"1\":{\"122\":1}}],[\"还需额外保存一个引用\",{\"1\":{\"18\":1}}],[\"还广泛应用于其他领域中\",{\"1\":{\"70\":1}}],[\"还是通过自定义模型\",{\"1\":{\"194\":1}}],[\"还是数组吗\",{\"1\":{\"36\":1}}],[\"还是和节点值各占一半呢\",{\"1\":{\"36\":1}}],[\"还会缓存其周围的其他数据\",{\"1\":{\"16\":1}}],[\"中编写简单的\",{\"1\":{\"347\":1}}],[\"中退出\",{\"1\":{\"246\":1}}],[\"中进行操作\",{\"1\":{\"190\":1}}],[\"中获取数据并进行显示\",{\"1\":{\"188\":1}}],[\"中获取数据并提供给\",{\"1\":{\"175\":1}}],[\"中常用的\",{\"1\":{\"187\":1,\"188\":1}}],[\"中应用广泛\",{\"1\":{\"177\":1}}],[\"中呢\",{\"1\":{\"113\":1}}],[\"中序\",{\"1\":{\"112\":1,\"113\":1}}],[\"中序遍历有序\",{\"0\":{\"94\":1}}],[\"中序遍历序列\",{\"1\":{\"93\":1}}],[\"中序遍历的下一个节点\",{\"1\":{\"93\":1}}],[\"中提出了\",{\"1\":{\"97\":1}}],[\"中任意节点的左子树和右子树的高度之差的绝对值不超过\",{\"1\":{\"87\":1}}],[\"中间插入节点\",{\"1\":{\"83\":1}}],[\"中删除\",{\"1\":{\"58\":1}}],[\"中弹出最近的操作\",{\"1\":{\"54\":2}}],[\"中需要手动释放内存\",{\"1\":{\"54\":1}}],[\"中初始化\",{\"1\":{\"36\":1}}],[\"中\",{\"1\":{\"30\":1,\"36\":1,\"61\":1,\"73\":1,\"113\":5,\"168\":1,\"171\":1,\"177\":2,\"192\":1,\"218\":1,\"236\":1,\"251\":1,\"373\":1}}],[\"中的原子操作\",{\"0\":{\"249\":1}}],[\"中的属性\",{\"1\":{\"176\":1}}],[\"中的数据渲染为可视化的控件或元素\",{\"1\":{\"189\":1}}],[\"中的数据发生变化时\",{\"1\":{\"176\":2}}],[\"中的数据展示给用户\",{\"1\":{\"174\":1}}],[\"中的数字也被包装为对象\",{\"1\":{\"36\":1}}],[\"中的下一个节点\",{\"1\":{\"93\":1}}],[\"中的相同\",{\"1\":{\"36\":1}}],[\"中的\",{\"0\":{\"192\":1},\"1\":{\"28\":4,\"181\":1,\"241\":1}}],[\"中分别被记为\",{\"1\":{\"18\":1}}],[\"中随机抽取一个数字\",{\"1\":{\"10\":1}}],[\"它指向另一个\",{\"1\":{\"331\":1}}],[\"它指向一个由shared\",{\"1\":{\"269\":1}}],[\"它只引用\",{\"1\":{\"269\":1}}],[\"它只是插入\",{\"1\":{\"113\":1}}],[\"它是为了配合shared\",{\"1\":{\"269\":1}}],[\"它是为这个类的构造函数产生代码\",{\"1\":{\"210\":1}}],[\"它是一个基于任务的程序设计\",{\"1\":{\"264\":1}}],[\"它是基于任务的异步操作\",{\"1\":{\"264\":1}}],[\"它可以生成适用于不同编译器和操作系统的构建系统文件\",{\"1\":{\"341\":1}}],[\"它可以阻塞一个线程或者个线程\",{\"1\":{\"262\":1}}],[\"它可以被\",{\"1\":{\"71\":1}}],[\"它需要配合std\",{\"1\":{\"261\":1}}],[\"它需要对一组进程进行循环\",{\"1\":{\"27\":1}}],[\"它检查一个变量是否有特定的值\",{\"1\":{\"248\":1}}],[\"它支持以下操作\",{\"1\":{\"249\":1}}],[\"它支持\",{\"1\":{\"231\":1}}],[\"它仅仅能知道它是\",{\"1\":{\"210\":1}}],[\"它做的首要的事情之中的一个是初始化它的vptr\",{\"1\":{\"210\":1}}],[\"它非常适合需要频繁更新\",{\"1\":{\"182\":1}}],[\"它将仅仅产生通过它自己的vtable的调用\",{\"1\":{\"210\":1}}],[\"它将\",{\"1\":{\"177\":1}}],[\"它将用户界面逻辑和业务逻辑进行分离\",{\"1\":{\"171\":1}}],[\"它从\",{\"1\":{\"175\":1}}],[\"它通常由\",{\"1\":{\"174\":1}}],[\"它通过旋转操作确保在不断插入和删除节点后树仍然保持平衡\",{\"1\":{\"112\":1}}],[\"它通过建立键\",{\"1\":{\"58\":1}}],[\"它负责处理与业务逻辑相关的所有操作\",{\"1\":{\"173\":1}}],[\"它使得请求的发送者和接收者之间不再紧耦合\",{\"1\":{\"168\":1}}],[\"它允许父进程挂起执行\",{\"1\":{\"299\":1}}],[\"它允许多个对象都有机会处理请求\",{\"1\":{\"165\":1}}],[\"它允许你通过将对象放入包含行为的特殊封装对象中\",{\"1\":{\"143\":1}}],[\"它允许在两端进行元素的添加和删除操作\",{\"1\":{\"53\":1}}],[\"它定义了一系列算法\",{\"1\":{\"137\":1}}],[\"它体现了\",{\"1\":{\"112\":1}}],[\"它能够在不影响二叉树的中序遍历序列的前提下\",{\"1\":{\"101\":1}}],[\"它的所有资源\",{\"1\":{\"218\":1}}],[\"它的主要目的是将抽象部分与实现部分分离\",{\"1\":{\"149\":1}}],[\"它的前身c++之父的很多心得经验的博客\",{\"1\":{\"122\":1}}],[\"它的哈希值也随之改变\",{\"1\":{\"73\":1}}],[\"它的用途是什么\",{\"1\":{\"54\":1}}],[\"它不直接从哈希表中移除元素\",{\"1\":{\"65\":1}}],[\"它相比数组更加耗费内存空间\",{\"1\":{\"63\":1}}],[\"它保留了数组的优势\",{\"1\":{\"35\":1}}],[\"它继承了数组的各项优点\",{\"1\":{\"28\":1}}],[\"它表现的是栈\",{\"1\":{\"54\":1}}],[\"它表现的特性为先进先出\",{\"1\":{\"27\":1}}],[\"它表现的特性为先进后出\",{\"1\":{\"27\":1}}],[\"它表示元素的有序集合\",{\"1\":{\"28\":1}}],[\"它在\",{\"1\":{\"18\":1}}],[\"它们内部都有一个future\",{\"1\":{\"263\":1}}],[\"它们分别用于显示列表\",{\"1\":{\"188\":1}}],[\"它们分别解决的两种失衡情况也是对称的\",{\"1\":{\"103\":1}}],[\"它们分为三大类\",{\"1\":{\"125\":1}}],[\"它们指向同一个对象\",{\"1\":{\"113\":1}}],[\"它们体现了\",{\"1\":{\"112\":1}}],[\"它们可以将任意长度的输入数据映射到恒定长度的哈希值\",{\"1\":{\"72\":1}}],[\"它们都能输出均匀分布的哈希值\",{\"1\":{\"71\":1}}],[\"它们只能保证哈希表可以在发生冲突时正常工作\",{\"1\":{\"69\":1}}],[\"它们被依次存储在该桶以及之下的桶中\",{\"1\":{\"65\":1}}],[\"它们的主要区别在于工厂模式适用于创建单一产品\",{\"1\":{\"155\":1}}],[\"它们的效率对比如下表所示\",{\"1\":{\"58\":1}}],[\"它们的实现比较复杂\",{\"1\":{\"34\":1}}],[\"它们的内存地址无须连续\",{\"1\":{\"18\":1}}],[\"它们之间没有空间再存放任何数据\",{\"1\":{\"11\":1}}],[\"和右子节点\",{\"1\":{\"79\":1}}],[\"和反撤销\",{\"1\":{\"54\":1}}],[\"和实例对象等\",{\"1\":{\"36\":1}}],[\"和前驱节点\",{\"1\":{\"26\":1}}],[\"和\",{\"0\":{\"270\":1},\"1\":{\"18\":3,\"20\":1,\"21\":1,\"28\":2,\"30\":1,\"36\":3,\"43\":2,\"44\":1,\"54\":2,\"58\":1,\"60\":1,\"61\":2,\"62\":1,\"65\":1,\"71\":1,\"72\":2,\"74\":1,\"79\":1,\"80\":1,\"91\":1,\"93\":1,\"97\":1,\"113\":2,\"171\":1,\"175\":2,\"177\":4,\"179\":2,\"181\":1,\"182\":1,\"185\":1,\"187\":1,\"188\":1,\"189\":1,\"192\":1,\"202\":1,\"231\":1,\"236\":2,\"251\":1,\"252\":1,\"266\":1,\"338\":1,\"367\":2,\"374\":1}}],[\"和指向下一节点的\",{\"1\":{\"18\":1}}],[\"和某个元素的索引\",{\"1\":{\"10\":1}}],[\"值得说明的是\",{\"1\":{\"71\":1}}],[\"值得思考的是\",{\"1\":{\"71\":1}}],[\"值得注意的是\",{\"1\":{\"11\":1,\"63\":1,\"65\":1}}],[\"值\",{\"1\":{\"18\":1,\"73\":1}}],[\"每种通信方式都有其优缺点和适用场景\",{\"1\":{\"232\":1}}],[\"每种哈希算法的最后一步都是对大质数\",{\"1\":{\"71\":1}}],[\"每隔10秒执行一次任务\",{\"1\":{\"222\":1}}],[\"每一个构造函数都已经设置vptr指向它自己的vtable\",{\"1\":{\"210\":1}}],[\"每轮乘以一个常数\",{\"1\":{\"71\":1}}],[\"每轮判断元素值是否匹配\",{\"1\":{\"14\":1}}],[\"每当减少一个智能指针指向对象时\",{\"1\":{\"267\":1}}],[\"每当多一个指针指向该对象时\",{\"1\":{\"267\":1}}],[\"每当一个线程到达屏障点时\",{\"1\":{\"244\":1}}],[\"每当遇到哈希冲突时\",{\"1\":{\"62\":1}}],[\"每当用户执行一个操作\",{\"1\":{\"54\":1}}],[\"每当我们打开新的网页\",{\"1\":{\"52\":1}}],[\"每次创建类的新对象时\",{\"1\":{\"267\":1}}],[\"每次完成任务时\",{\"1\":{\"245\":1}}],[\"每次累积之前都会对哈希值进行旋转操作\",{\"1\":{\"71\":1}}],[\"每次调用函数时\",{\"1\":{\"52\":1}}],[\"每次插入与删除操作都是\",{\"1\":{\"36\":1}}],[\"每个\",{\"1\":{\"343\":1}}],[\"每个过滤器负责处理特定类型的请求\",{\"1\":{\"168\":1}}],[\"每个链上的对象都有机会处理请求\",{\"1\":{\"166\":1}}],[\"每个二叉树节点包含一个值以及两个指针\",{\"1\":{\"112\":1}}],[\"每个节点都有两个引用\",{\"1\":{\"79\":1}}],[\"每个节点都包含两项数据\",{\"1\":{\"18\":1}}],[\"每个节点包含值\",{\"1\":{\"79\":1}}],[\"每个元素对应唯一的桶索引\",{\"1\":{\"75\":1}}],[\"每个桶都是一个列表\",{\"1\":{\"63\":1}}],[\"每个桶仅能存储一个键值对\",{\"1\":{\"63\":1}}],[\"每个桶可存储一个键值对\",{\"1\":{\"60\":1}}],[\"每个学生都有\",{\"1\":{\"58\":1}}],[\"每个进程被赋予一个时间片\",{\"1\":{\"27\":1}}],[\"对一个对象进行赋值时\",{\"1\":{\"267\":1}}],[\"对已获得的资源保持不放\",{\"1\":{\"246\":1}}],[\"对该类进行实例化时\",{\"1\":{\"208\":1}}],[\"对第\",{\"1\":{\"194\":1}}],[\"对数据进行排序\",{\"1\":{\"194\":1}}],[\"对比总结\",{\"1\":{\"177\":1}}],[\"对修改封闭\",{\"1\":{\"145\":1}}],[\"对修改关闭\",{\"1\":{\"126\":1}}],[\"对扩展开放\",{\"1\":{\"145\":1}}],[\"对外提供尽可能少的接口\",{\"1\":{\"127\":1}}],[\"对合数取模更容易出现聚集现象\",{\"1\":{\"71\":1}}],[\"对输入的每个字符的\",{\"1\":{\"71\":1}}],[\"对于保持系统的稳定性和资源利用率至关重要\",{\"1\":{\"220\":1}}],[\"对于有虚函数或者继承于拥有虚函数的基类\",{\"1\":{\"208\":1}}],[\"对于初学者来说\",{\"1\":{\"180\":1}}],[\"对于引用类型\",{\"1\":{\"113\":1}}],[\"对于基本数据类型\",{\"1\":{\"113\":1}}],[\"对于只有一个节点的二叉树\",{\"1\":{\"113\":1}}],[\"对于二叉树中的某个节点\",{\"1\":{\"112\":1}}],[\"对于上述失衡二叉树的镜像情况\",{\"1\":{\"105\":1}}],[\"对于上述示例中的哈希函数\",{\"1\":{\"61\":1}}],[\"对于下图中的失衡节点\",{\"1\":{\"104\":1}}],[\"对于根节点\",{\"1\":{\"89\":1}}],[\"对于密码学的相关应用\",{\"1\":{\"70\":1}}],[\"对于相同的输入\",{\"1\":{\"70\":1}}],[\"对于链式地址哈希表\",{\"1\":{\"69\":1}}],[\"对于入栈操作\",{\"1\":{\"49\":1}}],[\"对于环形数组\",{\"1\":{\"44\":1}}],[\"对缓存的利用率较低\",{\"1\":{\"36\":1}}],[\"对时间效率和空间效率是否有影响\",{\"1\":{\"36\":1}}],[\"对应的索引也可能发生变化\",{\"1\":{\"75\":1}}],[\"对应的数组索引\",{\"1\":{\"60\":1}}],[\"对应的键值对在数组中的存储位置\",{\"1\":{\"60\":1}}],[\"对应的桶索引\",{\"1\":{\"65\":4}}],[\"对应的桶\",{\"1\":{\"60\":1}}],[\"对应的元素存放在数组中的对应位置\",{\"1\":{\"17\":1}}],[\"对应队列\",{\"1\":{\"27\":1}}],[\"对应栈\",{\"1\":{\"27\":1}}],[\"对象地址的前四个字节存储的指向虚表的指针\",{\"1\":{\"207\":1}}],[\"对象中存储的\",{\"1\":{\"181\":1}}],[\"对象的哈希值计算需要自行实现\",{\"1\":{\"73\":1}}],[\"对象的哈希值基于其内存地址生成\",{\"1\":{\"73\":1}}],[\"对象等\",{\"1\":{\"46\":1}}],[\"对象\",{\"1\":{\"18\":1,\"173\":1,\"251\":1}}],[\"存储方式\",{\"1\":{\"25\":1}}],[\"存储数组的内存空间必须是连续的\",{\"1\":{\"18\":1}}],[\"存储在堆上\",{\"1\":{\"9\":1}}],[\"存储在栈上和堆上的数组都被存储在连续内存空间内\",{\"1\":{\"36\":1}}],[\"存储在栈上\",{\"1\":{\"9\":1}}],[\"空节点平衡因子为\",{\"1\":{\"100\":1}}],[\"空\",{\"1\":{\"18\":1}}],[\"空闲的内存空间可能散落在内存各处\",{\"1\":{\"18\":1}}],[\"空间效率\",{\"1\":{\"51\":1}}],[\"空间效率高\",{\"1\":{\"16\":1}}],[\"空间开销\",{\"1\":{\"36\":1}}],[\"空间浪费\",{\"1\":{\"16\":1}}],[\"图\",{\"1\":{\"27\":1,\"36\":1}}],[\"图的邻接矩阵表示实际上是一个二维数组\",{\"1\":{\"17\":1}}],[\"图等数据结构\",{\"1\":{\"17\":1}}],[\"堆的大小一般受限于可用内存\",{\"1\":{\"36\":1}}],[\"堆上的分配和释放操作通常比栈上的慢\",{\"1\":{\"36\":1}}],[\"堆\",{\"1\":{\"17\":1}}],[\"张量之间的线性代数运算\",{\"1\":{\"17\":1}}],[\"矩阵\",{\"1\":{\"17\":1}}],[\"神经网络中大量使用了向量\",{\"1\":{\"17\":1}}],[\"码累积到一个哈希值中\",{\"1\":{\"71\":1}}],[\"码累积到哈希值中\",{\"1\":{\"71\":1}}],[\"码进行相加\",{\"1\":{\"71\":1}}],[\"码值作为索引\",{\"1\":{\"17\":1}}],[\"码的映射\",{\"1\":{\"17\":1}}],[\"则立即返回\",{\"1\":{\"300\":1}}],[\"则删除基础对象\",{\"1\":{\"267\":1}}],[\"则删除对象\",{\"1\":{\"267\":1}}],[\"则删除操作流程如下图所示\",{\"1\":{\"93\":1}}],[\"则在完整表达式结尾\",{\"1\":{\"264\":1}}],[\"则唤醒所有读线程\",{\"1\":{\"239\":1}}],[\"则唤醒一个写线程\",{\"1\":{\"239\":2}}],[\"则唤醒一个线程\",{\"1\":{\"238\":1}}],[\"则锁定成功\",{\"1\":{\"239\":1}}],[\"则线程进入等待队列\",{\"1\":{\"239\":2}}],[\"则线程成功锁定\",{\"1\":{\"238\":1}}],[\"则增加读计数器\",{\"1\":{\"239\":1}}],[\"则该线程进入等待队列并挂起\",{\"1\":{\"238\":1}}],[\"则该进程被挂起并返回到就绪队列中\",{\"1\":{\"216\":1}}],[\"则运行的是为构造函数或析构函数自身类型定义的版本\",{\"1\":{\"209\":1}}],[\"则底层节点数量\",{\"1\":{\"113\":1}}],[\"则一棵\",{\"1\":{\"100\":1}}],[\"则重新指定根节点\",{\"1\":{\"93\":1}}],[\"则直接返回\",{\"1\":{\"93\":1}}],[\"则初始化根节点\",{\"1\":{\"92\":1}}],[\"则不执行插入\",{\"1\":{\"92\":1}}],[\"则不需要释放内存\",{\"1\":{\"54\":1}}],[\"则节点总数为\",{\"1\":{\"85\":1}}],[\"则其左子节点和右子节点分别是\",{\"1\":{\"79\":1}}],[\"则尝试\",{\"1\":{\"67\":1}}],[\"则用删除标记覆盖它\",{\"1\":{\"65\":1}}],[\"则添加该键值对\",{\"1\":{\"65\":1}}],[\"则覆盖\",{\"1\":{\"65\":1}}],[\"则使用相同步长向后进行线性遍历\",{\"1\":{\"65\":1}}],[\"则从冲突位置向后线性遍历\",{\"1\":{\"65\":1}}],[\"则将其更改为新值\",{\"1\":{\"248\":1}}],[\"则将其传递给下一个对象\",{\"1\":{\"166\":1}}],[\"则将互斥量状态设置为未锁定\",{\"1\":{\"238\":1}}],[\"则将中序遍历的下个节点删除\",{\"1\":{\"109\":1}}],[\"则将键值对移动至该索引处\",{\"1\":{\"65\":1}}],[\"则将键值对添加至尾部\",{\"1\":{\"63\":1}}],[\"则将该节点添加到尾节点后\",{\"1\":{\"43\":1}}],[\"则更新对应\",{\"1\":{\"63\":1}}],[\"则返回非零值\",{\"1\":{\"302\":4}}],[\"则返回其状态\",{\"1\":{\"300\":1}}],[\"则返回\",{\"1\":{\"67\":1,\"301\":1}}],[\"则返回添加点的索引\",{\"1\":{\"65\":1}}],[\"则返回空字符串\",{\"1\":{\"63\":1,\"65\":1}}],[\"则返回对应\",{\"1\":{\"63\":1,\"65\":1}}],[\"则返回到数组头部\",{\"1\":{\"44\":1}}],[\"则必然有多个整数映射至同一桶索引\",{\"1\":{\"62\":1}}],[\"则可以采用下图所示的哈希表来实现\",{\"1\":{\"58\":1}}],[\"则可以在\",{\"1\":{\"58\":1}}],[\"则可以将字符的\",{\"1\":{\"17\":1}}],[\"则令头\",{\"1\":{\"43\":1}}],[\"则多次引用了同一个列表\",{\"1\":{\"36\":1}}],[\"则会造成内存空间浪费\",{\"1\":{\"28\":1}}],[\"则很可能无法满足使用需求\",{\"1\":{\"28\":1}}],[\"则得到一个环形链表\",{\"1\":{\"26\":1}}],[\"则只需改变两个节点引用\",{\"1\":{\"21\":1}}],[\"则需重新建立一个更大的数组\",{\"1\":{\"15\":1}}],[\"则需要执行下图所示的\",{\"1\":{\"103\":1}}],[\"则需要先将上面的盘子依次移走\",{\"1\":{\"46\":1}}],[\"则需要先扩容列表再添加\",{\"1\":{\"36\":1}}],[\"则需要进行扩容\",{\"1\":{\"34\":1}}],[\"则需要把索引\",{\"1\":{\"12\":1}}],[\"则需要将该元素之后的所有元素都向后移动一位\",{\"1\":{\"11\":1}}],[\"amend\",{\"1\":{\"314\":2}}],[\"await\",{\"1\":{\"262\":1}}],[\"as\",{\"1\":{\"382\":1}}],[\"astring\",{\"1\":{\"271\":5}}],[\"async更方便的实现了异步调用\",{\"1\":{\"264\":1}}],[\"async策略来调用async\",{\"1\":{\"264\":1}}],[\"async表示任务执行在另一线程\",{\"1\":{\"264\":1}}],[\"async具体语法如下\",{\"1\":{\"264\":1}}],[\"async\",{\"1\":{\"264\":10}}],[\"async是比future\",{\"1\":{\"264\":1}}],[\"async相关\",{\"0\":{\"264\":1},\"1\":{\"256\":1}}],[\"ascendingorder\",{\"1\":{\"194\":1}}],[\"ascii\",{\"1\":{\"17\":2,\"71\":3}}],[\"active\",{\"1\":{\"292\":1}}],[\"action\",{\"1\":{\"257\":3}}],[\"ack状态\",{\"1\":{\"294\":1}}],[\"ack\",{\"1\":{\"292\":3,\"294\":2,\"295\":1}}],[\"acquire\",{\"1\":{\"242\":2,\"243\":1,\"248\":1,\"250\":2,\"251\":4,\"252\":3}}],[\"accept\",{\"1\":{\"231\":1}}],[\"access\",{\"1\":{\"23\":1,\"275\":1}}],[\"atomic提供了原子变量\",{\"1\":{\"264\":1}}],[\"atomic相关\",{\"0\":{\"260\":1},\"1\":{\"256\":1}}],[\"atomic<t>\",{\"1\":{\"260\":1}}],[\"atomic<size\",{\"1\":{\"250\":2}}],[\"atomic<int>\",{\"1\":{\"241\":1,\"260\":1}}],[\"atomic\",{\"1\":{\"241\":1,\"243\":2,\"249\":1}}],[\"after=network\",{\"1\":{\"382\":1}}],[\"af\",{\"1\":{\"231\":4}}],[\"a+1\",{\"1\":{\"202\":2}}],[\"arch\",{\"1\":{\"369\":2}}],[\"argument\",{\"1\":{\"273\":1}}],[\"arguments\",{\"1\":{\"273\":2}}],[\"args>\",{\"1\":{\"264\":1}}],[\"args\",{\"1\":{\"264\":2,\"273\":4}}],[\"arg\",{\"1\":{\"193\":2}}],[\"arrive\",{\"1\":{\"244\":1}}],[\"arr1\",{\"1\":{\"9\":1}}],[\"arr\",{\"1\":{\"9\":1,\"44\":3}}],[\"arrayhashmap\",{\"1\":{\"60\":2}}],[\"arraystack\",{\"1\":{\"50\":1}}],[\"arrayqueue\",{\"1\":{\"44\":2}}],[\"arraylist\",{\"1\":{\"28\":1}}],[\"array\",{\"1\":{\"7\":1,\"28\":1,\"49\":1,\"50\":2,\"229\":1}}],[\"always\",{\"1\":{\"382\":1}}],[\"all\",{\"1\":{\"240\":2,\"262\":1}}],[\"aligncenter\",{\"1\":{\"189\":1}}],[\"algorithm\",{\"1\":{\"97\":1}}],[\"age\",{\"1\":{\"187\":1}}],[\"apt\",{\"1\":{\"342\":1,\"371\":1}}],[\"api\",{\"1\":{\"173\":1}}],[\"append\",{\"1\":{\"372\":2}}],[\"app\",{\"1\":{\"181\":2,\"382\":1}}],[\"approved\",{\"1\":{\"167\":6}}],[\"applying\",{\"1\":{\"151\":2}}],[\"applycolor\",{\"1\":{\"151\":3}}],[\"abstract\",{\"1\":{\"160\":2}}],[\"abstraction\",{\"1\":{\"150\":2}}],[\"anaconda3\",{\"1\":{\"382\":1}}],[\"anint\",{\"1\":{\"271\":5}}],[\"and\",{\"1\":{\"236\":2,\"241\":2,\"243\":3,\"244\":1,\"246\":1,\"248\":1,\"273\":1,\"382\":3}}],[\"any\",{\"1\":{\"231\":1}}],[\"anonymous\",{\"1\":{\"226\":1}}],[\"angular\",{\"1\":{\"171\":1,\"177\":1}}],[\"an\",{\"1\":{\"97\":1}}],[\"addobserver\",{\"1\":{\"363\":1}}],[\"add\",{\"1\":{\"241\":1,\"260\":2,\"311\":2,\"313\":3,\"314\":1,\"331\":2,\"334\":1,\"336\":1,\"338\":1,\"344\":2,\"348\":1,\"353\":2,\"382\":1}}],[\"addr\",{\"1\":{\"231\":4}}],[\"address\",{\"1\":{\"231\":3}}],[\"addressing\",{\"1\":{\"64\":1}}],[\"adelson\",{\"1\":{\"97\":1}}],[\"avltree\",{\"1\":{\"102\":3}}],[\"avl\",{\"0\":{\"97\":1,\"98\":1,\"101\":1,\"107\":1,\"111\":1},\"1\":{\"63\":1,\"97\":5,\"98\":1,\"99\":2,\"100\":1,\"101\":1,\"106\":1,\"108\":2,\"110\":1,\"111\":1,\"112\":3}}],[\"auto\",{\"1\":{\"59\":2,\"60\":1,\"63\":4,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"257\":3,\"258\":4,\"259\":2,\"261\":1,\"264\":2,\"274\":3,\"276\":1,\"361\":2,\"363\":1,\"364\":3}}],[\"a\",{\"0\":{\"36\":1,\"54\":1,\"75\":1,\"113\":1,\"202\":4},\"1\":{\"54\":4,\"61\":1,\"113\":2,\"151\":2,\"158\":2,\"202\":6,\"257\":2,\"270\":14,\"271\":3,\"382\":3}}],[\"二者通过\",{\"1\":{\"179\":1}}],[\"二者都应该依赖于抽象\",{\"1\":{\"126\":1}}],[\"二叉搜索树可能退化为链表\",{\"1\":{\"97\":1}}],[\"二叉搜索树常见应用\",{\"0\":{\"96\":1}}],[\"二叉搜索树退化\",{\"1\":{\"95\":1}}],[\"二叉搜索树是一种高效的元素查找数据结构\",{\"1\":{\"112\":1}}],[\"二叉搜索树是\",{\"1\":{\"95\":1}}],[\"二叉搜索树不允许存在重复节点\",{\"1\":{\"92\":1}}],[\"二叉搜索树的各项操作的时间复杂度都是对数阶\",{\"1\":{\"95\":1}}],[\"二叉搜索树的效率\",{\"0\":{\"95\":1}}],[\"二叉搜索树的中序遍历序列\",{\"1\":{\"94\":1}}],[\"二叉搜索树的中序遍历序列是升序的\",{\"1\":{\"94\":1}}],[\"二叉搜索树的\",{\"1\":{\"93\":1}}],[\"二叉搜索树的查找操作与二分查找算法的工作原理一致\",{\"1\":{\"91\":1}}],[\"二叉搜索树的操作\",{\"0\":{\"90\":1}}],[\"二叉搜索树查找节点示例\",{\"1\":{\"91\":1}}],[\"二叉搜索树\",{\"0\":{\"89\":1},\"1\":{\"89\":2,\"95\":1,\"97\":1,\"101\":1}}],[\"二叉树中的插入与删除一般由一套操作配合完成\",{\"1\":{\"113\":1}}],[\"二叉树中首个失衡节点是\",{\"1\":{\"102\":1}}],[\"二叉树可以用数组表示\",{\"1\":{\"112\":1}}],[\"二叉树是一种非线性数据结构\",{\"1\":{\"112\":1}}],[\"二叉树退化为\",{\"1\":{\"88\":1}}],[\"二叉树基本操作\",{\"0\":{\"81\":1}}],[\"二叉树的层序遍历是一种广度优先搜索方法\",{\"1\":{\"112\":1}}],[\"二叉树的初始化\",{\"1\":{\"112\":1}}],[\"二叉树的相关术语包括根节点\",{\"1\":{\"112\":1}}],[\"二叉树的中序遍历遵循\",{\"1\":{\"94\":1}}],[\"二叉树的叶节点数量\",{\"1\":{\"88\":1}}],[\"二叉树的最佳结构与最差结构\",{\"1\":{\"88\":1}}],[\"二叉树的退化\",{\"0\":{\"88\":1}}],[\"二叉树的常用术语\",{\"1\":{\"80\":1}}],[\"二叉树的常用术语如下图所示\",{\"1\":{\"80\":1}}],[\"二叉树的高度\",{\"1\":{\"80\":1}}],[\"二叉树的基本单元是节点\",{\"1\":{\"79\":1}}],[\"二叉树常见术语\",{\"0\":{\"80\":1}}],[\"二叉树节点结构体\",{\"1\":{\"79\":1}}],[\"二叉树\",{\"0\":{\"78\":1,\"79\":1},\"1\":{\"2\":1,\"75\":1,\"79\":1}}],[\"二分查找等都主要在数组上进行\",{\"1\":{\"17\":1}}],[\"归并排序\",{\"1\":{\"17\":1}}],[\"快速排序\",{\"1\":{\"17\":1}}],[\"排序和搜索\",{\"1\":{\"17\":1}}],[\"开始数据传输\",{\"1\":{\"294\":1}}],[\"开始计数会更自然\",{\"1\":{\"10\":1}}],[\"开发者都能够以更清晰的方式管理复杂的数据展示和用户交互\",{\"1\":{\"194\":1}}],[\"开发者可以更自由地定制数据的显示和交互行为\",{\"1\":{\"192\":1}}],[\"开发者可以控制单元格的外观和编辑方式\",{\"1\":{\"189\":1}}],[\"开发者也可以通过继承\",{\"1\":{\"187\":1}}],[\"开闭原则\",{\"1\":{\"126\":1}}],[\"开放寻址法都有不能直接删除元素的缺陷\",{\"1\":{\"75\":1}}],[\"开放寻址通过多次探测来处理哈希冲突\",{\"1\":{\"74\":1}}],[\"开放寻址哈希表\",{\"1\":{\"65\":1}}],[\"开放寻址\",{\"0\":{\"64\":1},\"1\":{\"62\":1,\"64\":1,\"65\":1,\"67\":1}}],[\"开销很大\",{\"1\":{\"16\":1}}],[\"当内核运行到\",{\"1\":{\"373\":1}}],[\"当你更新子模块后\",{\"1\":{\"338\":1}}],[\"当你克隆包含子模块的仓库时\",{\"1\":{\"332\":1}}],[\"当所有shared\",{\"1\":{\"269\":1}}],[\"当对象作为另一对象的副本而创建时\",{\"1\":{\"267\":1}}],[\"当计数为0的时候会自动的释放动态分配的资源\",{\"1\":{\"267\":1}}],[\"当计数器减为零时\",{\"1\":{\"245\":1}}],[\"当计数器达到零时\",{\"1\":{\"244\":1}}],[\"当需要获取线程函数返回值\",{\"1\":{\"263\":1}}],[\"当需要获取线程中的某个值\",{\"1\":{\"263\":1}}],[\"当需要快速查找一个元素或其对应关系时\",{\"1\":{\"17\":1}}],[\"当持有锁的线程释放自旋锁时\",{\"1\":{\"243\":1}}],[\"当写线程解锁时\",{\"1\":{\"239\":1}}],[\"当读线程解锁时\",{\"1\":{\"239\":1}}],[\"当子进程结束时\",{\"1\":{\"220\":1}}],[\"当子节点数量\",{\"1\":{\"93\":1}}],[\"当父进程调用\",{\"1\":{\"218\":1}}],[\"当一个子进程停止\",{\"1\":{\"300\":1}}],[\"当一个子进程结束时\",{\"1\":{\"218\":1}}],[\"当一个线程尝试获取自旋锁时\",{\"1\":{\"243\":1}}],[\"当一个线程尝试锁定互斥量时\",{\"1\":{\"238\":1}}],[\"当一个线程执行\",{\"1\":{\"242\":2}}],[\"当一个线程修改条件状态并调用\",{\"1\":{\"240\":1}}],[\"当一个线程请求写锁定时\",{\"1\":{\"239\":1}}],[\"当一个线程请求读锁定时\",{\"1\":{\"239\":1}}],[\"当一个线程解锁互斥量时\",{\"1\":{\"238\":1}}],[\"当一个构造函数被调用时\",{\"1\":{\"210\":1}}],[\"当等待的事件发生\",{\"1\":{\"216\":1}}],[\"当进程完成其任务或被强制终止时\",{\"1\":{\"216\":1}}],[\"当进程执行\",{\"1\":{\"216\":1}}],[\"当进程创建完成\",{\"1\":{\"216\":1}}],[\"当删除基类指针指向的派生类对象时就不会触发动态绑定\",{\"1\":{\"210\":1}}],[\"当这一系列构造函数调用正发生时\",{\"1\":{\"210\":1}}],[\"当编译器为这个构造函数产生代码时\",{\"1\":{\"210\":1}}],[\"当前目录文件\",{\"1\":{\"372\":1}}],[\"当前cpu个数\",{\"1\":{\"257\":1}}],[\"当前线程id\",{\"1\":{\"257\":1}}],[\"当前\",{\"1\":{\"210\":1}}],[\"当派生类中有自己的虚函数时\",{\"1\":{\"207\":1}}],[\"当派生类对基类的虚函数重写时\",{\"1\":{\"207\":1}}],[\"当派生类对基类的虚函数没有重写时\",{\"1\":{\"207\":1}}],[\"当调用子类的构造函数时\",{\"1\":{\"207\":1}}],[\"当模型的布局发生变化时发出\",{\"1\":{\"191\":1}}],[\"当模型中的某个数据项发生变化时发出\",{\"1\":{\"191\":1}}],[\"当系统中出现新的功能需求时\",{\"1\":{\"143\":1}}],[\"当有新的策略出现时\",{\"1\":{\"139\":1}}],[\"当状态改变时\",{\"1\":{\"132\":1}}],[\"当主题状态改变时\",{\"1\":{\"132\":1,\"133\":1}}],[\"当主题对象的状态发生变化时\",{\"1\":{\"131\":1}}],[\"当二叉搜索树退化为链表时\",{\"1\":{\"112\":1}}],[\"当二叉树平衡时\",{\"1\":{\"91\":1}}],[\"当二叉树的每层节点都被填满时\",{\"1\":{\"88\":1}}],[\"当节点\",{\"1\":{\"102\":1,\"103\":1}}],[\"当待删除节点的度为\",{\"1\":{\"93\":3}}],[\"当给定一个二叉树的节点时\",{\"1\":{\"79\":1}}],[\"当将新元素插入哈希表\",{\"1\":{\"75\":1}}],[\"当哈希函数设计得比较好\",{\"1\":{\"75\":1}}],[\"当哈希冲突比较严重时\",{\"1\":{\"75\":1}}],[\"当哈希表容量\",{\"1\":{\"69\":1}}],[\"当列表的内容发生变化时\",{\"1\":{\"73\":1}}],[\"当溢出桶过多时\",{\"1\":{\"68\":1}}],[\"当\",{\"1\":{\"68\":1,\"176\":1,\"190\":1}}],[\"当发生冲突时\",{\"1\":{\"66\":1}}],[\"当遇到空桶时跳出\",{\"1\":{\"65\":1}}],[\"当越过数组尾部时\",{\"1\":{\"65\":1}}],[\"当链表很长时\",{\"1\":{\"63\":1}}],[\"当负载因子超过阈值时\",{\"1\":{\"63\":1,\"65\":1}}],[\"当负载因子超过\",{\"1\":{\"61\":1,\"63\":1}}],[\"当输入的\",{\"1\":{\"61\":1}}],[\"当用户在输入框中输入数据时\",{\"1\":{\"181\":1}}],[\"当用户输入密码时\",{\"1\":{\"70\":1}}],[\"当用户执行\",{\"1\":{\"54\":2}}],[\"当用户点击后退按钮时\",{\"1\":{\"54\":1}}],[\"当用户点击前进或后退按钮时\",{\"1\":{\"27\":1}}],[\"当用户访问一个新页面时\",{\"1\":{\"54\":1}}],[\"当入栈与出栈操作的元素是基本数据类型时\",{\"1\":{\"51\":1}}],[\"当作栈来使用\",{\"1\":{\"47\":1}}],[\"当它们到达数组尾部时就无法继续移动了\",{\"1\":{\"44\":1}}],[\"当使用数组实现列表时\",{\"1\":{\"28\":1}}],[\"当时间片用完时\",{\"1\":{\"27\":1}}],[\"当插入或删除行时发出\",{\"1\":{\"191\":1}}],[\"当插入操作在链表的一端进行\",{\"1\":{\"27\":1}}],[\"当插入和删除操作都在链表的一端进行时\",{\"1\":{\"27\":1}}],[\"当数组中元素较多时\",{\"1\":{\"16\":1}}],[\"当访问数组元素时\",{\"1\":{\"16\":1}}],[\"插入和删除操作的时间复杂度均为\",{\"1\":{\"112\":1}}],[\"插入\",{\"1\":{\"96\":1}}],[\"插入位置在\",{\"1\":{\"92\":2}}],[\"插入操作流程如下图所示\",{\"1\":{\"92\":1}}],[\"插入节点使用\",{\"1\":{\"92\":1}}],[\"插入节点可能会改变二叉树的原有逻辑结构\",{\"1\":{\"83\":1}}],[\"插入节点\",{\"0\":{\"21\":1,\"92\":1,\"108\":1},\"1\":{\"92\":2}}],[\"插入与删除通常是由一套操作配合完成的\",{\"1\":{\"83\":1}}],[\"插入与删除节点所需的旋转操作更少\",{\"1\":{\"111\":1}}],[\"插入与删除节点\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"插入与删除元素\",{\"0\":{\"32\":1}}],[\"插入与删除操作需要移动大量的元素\",{\"1\":{\"16\":1}}],[\"插入与删除效率低\",{\"1\":{\"16\":1}}],[\"插入元素\",{\"0\":{\"11\":1},\"1\":{\"65\":1,\"67\":1,\"95\":1}}],[\"etc\",{\"1\":{\"382\":1}}],[\"echo\",{\"1\":{\"370\":2}}],[\"established\",{\"1\":{\"292\":1,\"294\":1,\"295\":1}}],[\"errno\",{\"1\":{\"301\":1}}],[\"error\",{\"1\":{\"277\":1}}],[\"erase\",{\"1\":{\"32\":1,\"59\":1,\"63\":1}}],[\"easier\",{\"1\":{\"271\":1}}],[\"emplace\",{\"1\":{\"244\":1,\"245\":1,\"271\":6}}],[\"empty\",{\"1\":{\"41\":2,\"47\":2}}],[\"elide\",{\"1\":{\"270\":2}}],[\"el\",{\"1\":{\"181\":1}}],[\"else\",{\"1\":{\"43\":1,\"65\":2,\"91\":2,\"92\":2,\"93\":4,\"106\":2,\"108\":2,\"109\":4,\"167\":6,\"220\":4,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"257\":1,\"262\":1,\"303\":6,\"364\":1}}],[\"effective\",{\"1\":{\"122\":1}}],[\"equals\",{\"1\":{\"113\":3}}],[\"execstart=\",{\"1\":{\"382\":1}}],[\"executable\",{\"1\":{\"344\":2,\"348\":1}}],[\"execute\",{\"1\":{\"236\":1}}],[\"exclusion\",{\"1\":{\"246\":1}}],[\"example\",{\"1\":{\"236\":1,\"331\":1}}],[\"exited\",{\"1\":{\"303\":1}}],[\"exit\",{\"1\":{\"220\":5,\"222\":12,\"230\":1}}],[\"extern\",{\"0\":{\"204\":1},\"1\":{\"204\":1}}],[\"extendratio\",{\"1\":{\"63\":3,\"65\":2}}],[\"extend\",{\"1\":{\"15\":1,\"63\":2,\"65\":2}}],[\"explicit\",{\"1\":{\"99\":1,\"262\":1}}],[\"e\",{\"1\":{\"97\":1,\"287\":2,\"370\":1}}],[\"edge\",{\"1\":{\"80\":1}}],[\"ensure\",{\"1\":{\"382\":1}}],[\"environment=\",{\"1\":{\"382\":3}}],[\"encryptstring<sizeof\",{\"1\":{\"287\":1}}],[\"encryptstring\",{\"1\":{\"287\":2,\"288\":1}}],[\"enum\",{\"1\":{\"257\":1,\"277\":2}}],[\"enqueue\",{\"1\":{\"250\":2,\"251\":5}}],[\"enter\",{\"1\":{\"181\":1}}],[\"enddraw\",{\"1\":{\"361\":2}}],[\"end\",{\"1\":{\"59\":1}}],[\"endl\",{\"1\":{\"44\":1,\"59\":2,\"60\":1,\"65\":3,\"133\":1,\"139\":2,\"145\":5,\"151\":2,\"158\":2,\"161\":4,\"167\":3,\"222\":4,\"226\":1,\"227\":2,\"228\":1,\"229\":4,\"231\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":2,\"250\":2,\"251\":2,\"257\":5,\"258\":2,\"259\":1,\"261\":1,\"263\":2,\"264\":1,\"287\":2,\"303\":9,\"347\":1}}],[\"enlarge\",{\"1\":{\"15\":2}}],[\"扩展抽象类\",{\"1\":{\"150\":1}}],[\"扩展数组长度\",{\"1\":{\"15\":1}}],[\"扩容哈希表\",{\"1\":{\"63\":1,\"65\":1}}],[\"扩容后冲突消失\",{\"1\":{\"61\":1}}],[\"扩容后的容量也可能超出实际需求\",{\"1\":{\"51\":1}}],[\"扩容前键值对\",{\"1\":{\"61\":1}}],[\"扩容一般会乘以一个系数\",{\"1\":{\"36\":1}}],[\"扩容倍数\",{\"1\":{\"63\":1,\"65\":1}}],[\"扩容倍数所占的内存吗\",{\"1\":{\"36\":1}}],[\"扩容倍数等\",{\"1\":{\"34\":1}}],[\"扩容机制通常是按照特定倍率\",{\"1\":{\"51\":1}}],[\"扩容机制\",{\"1\":{\"34\":1}}],[\"扩容数组需要将所有数据复制到新数组\",{\"1\":{\"16\":1}}],[\"扩容数组\",{\"0\":{\"15\":1}}],[\"程序运行会自动调用构造函数\",{\"1\":{\"207\":1}}],[\"程序运行时\",{\"1\":{\"35\":1}}],[\"程序可能误判这些元素不存在\",{\"1\":{\"65\":1}}],[\"程序内存管理\",{\"1\":{\"52\":1}}],[\"程序需要从头节点出发\",{\"1\":{\"23\":1}}],[\"程序难以保证数组之后的内存空间是可用的\",{\"1\":{\"15\":1}}],[\"程序员的知识库\",{\"1\":{\"0\":1}}],[\"txt\",{\"1\":{\"313\":1,\"318\":1,\"343\":2,\"344\":1,\"346\":1,\"348\":1}}],[\"two\",{\"1\":{\"273\":1}}],[\"time\",{\"1\":{\"262\":3,\"292\":1,\"294\":1,\"295\":1,\"382\":1}}],[\"timed\",{\"1\":{\"258\":8}}],[\"tt\",{\"1\":{\"257\":3}}],[\"t>\",{\"1\":{\"250\":3,\"251\":1}}],[\"t4\",{\"1\":{\"239\":2}}],[\"t3\",{\"1\":{\"239\":2}}],[\"t2\",{\"1\":{\"239\":2}}],[\"t1\",{\"1\":{\"239\":2}}],[\"tcp连接状态图详细展示了从连接建立到数据传输\",{\"1\":{\"296\":1}}],[\"tcp连接的状态图\",{\"1\":{\"291\":1}}],[\"tcp状态图解释\",{\"0\":{\"292\":1}}],[\"tcp\",{\"0\":{\"291\":1},\"1\":{\"231\":2,\"291\":1},\"2\":{\"298\":1}}],[\"typing\",{\"1\":{\"161\":2}}],[\"typename\",{\"1\":{\"264\":1}}],[\"types>\",{\"1\":{\"273\":1}}],[\"types\",{\"1\":{\"222\":1,\"273\":1}}],[\"type\",{\"1\":{\"161\":3,\"227\":2,\"274\":4}}],[\"terminating\",{\"1\":{\"303\":1}}],[\"terminated\",{\"1\":{\"215\":1,\"303\":1}}],[\"test\",{\"1\":{\"243\":2,\"270\":3}}],[\"text\",{\"1\":{\"227\":5}}],[\"textbox\",{\"1\":{\"161\":5}}],[\"teamleader\",{\"1\":{\"167\":5}}],[\"teamleaderhandler\",{\"1\":{\"167\":1}}],[\"team\",{\"1\":{\"167\":4}}],[\"template<unsigned\",{\"1\":{\"287\":1}}],[\"template<class\",{\"1\":{\"273\":1}}],[\"template\",{\"1\":{\"250\":1,\"251\":1,\"264\":1}}],[\"tempval\",{\"1\":{\"109\":2}}],[\"temp\",{\"1\":{\"109\":6}}],[\"try\",{\"1\":{\"258\":1}}],[\"treenode\",{\"1\":{\"79\":4,\"82\":10,\"83\":2,\"91\":2,\"92\":4,\"93\":3,\"99\":6,\"100\":1,\"102\":4,\"103\":4,\"106\":2,\"108\":3,\"109\":4}}],[\"tree\",{\"1\":{\"79\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"98\":1,\"113\":1}}],[\"true\",{\"1\":{\"73\":1,\"167\":3,\"222\":1,\"230\":1,\"240\":2,\"250\":2,\"251\":2}}],[\"traverse\",{\"1\":{\"13\":1}}],[\"t\",{\"1\":{\"73\":4,\"220\":5,\"222\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"240\":2,\"250\":9,\"251\":8,\"257\":15,\"262\":4,\"263\":2,\"300\":2,\"303\":2,\"370\":4}}],[\"th\",{\"1\":{\"238\":2,\"240\":2,\"241\":2,\"242\":2,\"243\":2,\"244\":2,\"245\":2,\"258\":4,\"259\":2,\"261\":2}}],[\"that\",{\"1\":{\"236\":2}}],[\"thread使线程的创建变得非常简单\",{\"1\":{\"264\":1}}],[\"thread高级些\",{\"1\":{\"263\":1}}],[\"threadguard\",{\"1\":{\"257\":8}}],[\"thread相关\",{\"0\":{\"257\":1},\"1\":{\"256\":1}}],[\"thread>\",{\"1\":{\"244\":1,\"245\":1}}],[\"threads\",{\"1\":{\"236\":1,\"238\":3,\"240\":3,\"241\":3,\"242\":3,\"243\":3,\"244\":3,\"245\":3,\"258\":6,\"259\":3,\"261\":3}}],[\"thread\",{\"1\":{\"236\":6,\"238\":5,\"239\":4,\"240\":5,\"241\":2,\"242\":4,\"243\":4,\"244\":2,\"245\":2,\"250\":2,\"251\":2,\"257\":10,\"258\":4,\"259\":2,\"261\":2,\"263\":2}}],[\"thread来创建线程\",{\"1\":{\"236\":1,\"257\":1}}],[\"throw\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1}}],[\"then\",{\"1\":{\"382\":2}}],[\"the\",{\"1\":{\"97\":1,\"245\":1,\"271\":1,\"382\":3}}],[\"this\",{\"1\":{\"60\":2,\"240\":1,\"242\":1,\"243\":1,\"257\":1,\"266\":1}}],[\"tar\",{\"1\":{\"369\":3,\"370\":3,\"372\":2}}],[\"targets\",{\"1\":{\"356\":1}}],[\"target\",{\"1\":{\"14\":2,\"24\":4,\"353\":2,\"354\":1,\"355\":2,\"373\":2,\"382\":2}}],[\"taskmanager\",{\"1\":{\"364\":1}}],[\"task和promise那么麻烦\",{\"1\":{\"264\":1}}],[\"task包装的是一个函数\",{\"1\":{\"263\":1}}],[\"task在future高一层\",{\"1\":{\"263\":1}}],[\"task<int\",{\"1\":{\"263\":1}}],[\"task与std\",{\"1\":{\"263\":1}}],[\"task则用来包装一个调用对象\",{\"1\":{\"263\":1}}],[\"task\",{\"1\":{\"263\":5,\"264\":1,\"364\":8}}],[\"tail\",{\"1\":{\"250\":5,\"251\":11,\"252\":2}}],[\"table\",{\"1\":{\"58\":1}}],[\"took\",{\"1\":{\"370\":1}}],[\"to\",{\"1\":{\"222\":3,\"277\":1,\"336\":1,\"382\":2}}],[\"tostring\",{\"1\":{\"189\":1}}],[\"tombstone\",{\"1\":{\"65\":19}}],[\"top\",{\"1\":{\"47\":2,\"49\":2,\"50\":2}}],[\"tovector\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1}}],[\"tmpfs\",{\"1\":{\"370\":1}}],[\"tmpval\",{\"1\":{\"93\":2}}],[\"tmp\",{\"1\":{\"43\":2,\"49\":2,\"63\":2,\"93\":11,\"370\":2}}],[\"f1\",{\"1\":{\"370\":1}}],[\"f1​\",{\"1\":{\"67\":2}}],[\"feature\",{\"1\":{\"314\":1,\"318\":1,\"322\":2,\"323\":2,\"324\":1}}],[\"fetch\",{\"1\":{\"241\":1,\"327\":1,\"329\":2}}],[\"fno\",{\"1\":{\"270\":2}}],[\"fut\",{\"1\":{\"263\":6}}],[\"future用于异步调用的包装和返回值\",{\"1\":{\"264\":1}}],[\"future用于访问异步操作的结果\",{\"1\":{\"263\":1}}],[\"future的析构函数将阻塞直至异步计算完成\",{\"1\":{\"264\":1}}],[\"future<int>\",{\"1\":{\"263\":3}}],[\"future配合使用\",{\"1\":{\"263\":2}}],[\"future是不可以复制的\",{\"1\":{\"263\":1}}],[\"future作为异步结果的传输通道\",{\"1\":{\"263\":1}}],[\"future比std\",{\"1\":{\"263\":1}}],[\"future\",{\"1\":{\"263\":4,\"264\":1}}],[\"future相关\",{\"0\":{\"263\":1},\"1\":{\"256\":1}}],[\"func1\",{\"1\":{\"257\":2,\"258\":4,\"259\":2}}],[\"func\",{\"1\":{\"207\":4,\"257\":3,\"263\":4,\"264\":3}}],[\"function主要是为了再不完全了解细节的情况下也能正确处理对象\",{\"1\":{\"210\":1}}],[\"function\",{\"1\":{\"60\":1}}],[\"fun\",{\"1\":{\"207\":2}}],[\"flag使用\",{\"1\":{\"261\":1}}],[\"flag\",{\"1\":{\"243\":5,\"261\":1}}],[\"float\",{\"1\":{\"133\":2,\"363\":1}}],[\"ftok\",{\"1\":{\"227\":1,\"228\":1,\"229\":1}}],[\"fd\",{\"1\":{\"226\":8,\"231\":5}}],[\"found\",{\"1\":{\"383\":1}}],[\"foundation\",{\"1\":{\"171\":1}}],[\"foo\",{\"1\":{\"204\":2,\"236\":6}}],[\"forward<args>\",{\"1\":{\"264\":1}}],[\"forward<f>\",{\"1\":{\"264\":1}}],[\"fork第二个子进程\",{\"1\":{\"222\":1}}],[\"fork子进程并退出父进程\",{\"1\":{\"222\":1}}],[\"fork\",{\"1\":{\"220\":10,\"222\":4,\"223\":4,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"303\":2,\"304\":1}}],[\"format=newc\",{\"1\":{\"370\":1}}],[\"form\",{\"1\":{\"133\":2}}],[\"for\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":2,\"43\":1,\"44\":1,\"49\":1,\"59\":2,\"60\":5,\"63\":9,\"65\":3,\"71\":1,\"97\":1,\"133\":1,\"230\":1,\"238\":2,\"239\":1,\"240\":3,\"241\":3,\"242\":3,\"243\":3,\"244\":2,\"245\":2,\"250\":2,\"251\":2,\"257\":4,\"258\":7,\"259\":3,\"261\":2,\"262\":1,\"271\":1,\"275\":1,\"287\":2,\"361\":1,\"363\":1,\"364\":1}}],[\"failure\",{\"1\":{\"222\":4}}],[\"failed\",{\"1\":{\"222\":4,\"303\":2}}],[\"false\",{\"1\":{\"167\":3,\"240\":1,\"250\":2,\"251\":2}}],[\"factory\",{\"1\":{\"160\":2,\"161\":7}}],[\"factor\",{\"1\":{\"61\":1,\"100\":1}}],[\"fssl\",{\"1\":{\"382\":1}}],[\"fs\",{\"1\":{\"145\":3}}],[\"f\",{\"1\":{\"75\":2,\"100\":1,\"264\":7,\"273\":4,\"276\":2,\"335\":1}}],[\"f3​\",{\"1\":{\"67\":1}}],[\"f2​\",{\"1\":{\"67\":2}}],[\"fin\",{\"1\":{\"292\":2,\"294\":1,\"295\":2}}],[\"final\",{\"1\":{\"241\":1}}],[\"finishes\",{\"1\":{\"236\":2}}],[\"findbucket\",{\"1\":{\"65\":4}}],[\"find\",{\"1\":{\"14\":1,\"24\":1,\"354\":2,\"370\":1}}],[\"fifo\",{\"1\":{\"226\":1}}],[\"file\",{\"1\":{\"313\":1,\"318\":1}}],[\"fileno\",{\"1\":{\"222\":6}}],[\"filestream\",{\"1\":{\"145\":4}}],[\"filespliter\",{\"1\":{\"133\":2}}],[\"filter\",{\"1\":{\"168\":1}}],[\"firsttombstone\",{\"1\":{\"65\":8}}],[\"first\",{\"1\":{\"59\":1,\"236\":4,\"382\":2}}],[\"from\",{\"1\":{\"226\":1,\"227\":2,\"228\":1,\"231\":2,\"277\":1}}],[\"front\",{\"1\":{\"41\":2,\"43\":11,\"44\":13}}],[\"free\",{\"1\":{\"201\":1,\"247\":1}}],[\"freememorylinkedlist\",{\"1\":{\"43\":1,\"49\":1}}],[\"线程池\",{\"1\":{\"264\":1}}],[\"线程同步\",{\"2\":{\"254\":1,\"279\":1}}],[\"线程同步机制\",{\"0\":{\"237\":1}}],[\"线程会持续等待直到成功取出元素\",{\"1\":{\"251\":1}}],[\"线程会持续等待直到成功插入\",{\"1\":{\"251\":1}}],[\"线程\",{\"1\":{\"246\":6}}],[\"线程等待直到锁存器倒数到零\",{\"1\":{\"245\":1}}],[\"线程将反复检查锁的状态\",{\"1\":{\"243\":1}}],[\"线程将自己添加到等待队列\",{\"1\":{\"240\":1}}],[\"线程在尝试获取锁时会反复检查锁的状态\",{\"1\":{\"243\":1}}],[\"线程在等待条件变量时\",{\"1\":{\"240\":1}}],[\"线程进入等待队列\",{\"1\":{\"242\":1}}],[\"线程再次进入等待状态\",{\"1\":{\"240\":1}}],[\"线程继续执行\",{\"1\":{\"239\":1,\"240\":1,\"242\":1}}],[\"线程资源在任务结束后会由操作系统自动回收\",{\"1\":{\"236\":1}}],[\"线程函数的返回值将会被忽略\",{\"1\":{\"236\":1,\"257\":1}}],[\"线程编程\",{\"0\":{\"235\":1},\"1\":{\"1\":1}}],[\"线性探测法会根据预先设定的步长依次向下查找\",{\"1\":{\"75\":1}}],[\"线性探测使用固定步长\",{\"1\":{\"74\":1}}],[\"线性探测到\",{\"1\":{\"65\":1}}],[\"线性探测到该空桶就会返回\",{\"1\":{\"65\":1}}],[\"线性探测容易产生\",{\"1\":{\"65\":1}}],[\"线性探测采用固定步长的线性搜索来进行探测\",{\"1\":{\"65\":1}}],[\"线性探测\",{\"0\":{\"65\":1},\"1\":{\"65\":4,\"67\":1}}],[\"线性结构\",{\"2\":{\"38\":1}}],[\"线性查找\",{\"1\":{\"14\":1}}],[\"若从\",{\"1\":{\"264\":1}}],[\"若删除节点为根节点\",{\"1\":{\"93\":1}}],[\"若无待删除节点\",{\"1\":{\"93\":1}}],[\"若无该\",{\"1\":{\"63\":1}}],[\"若树为空\",{\"1\":{\"92\":1,\"93\":1}}],[\"若树的高度为\",{\"1\":{\"85\":1}}],[\"若待插入节点在树中已存在\",{\"1\":{\"92\":1}}],[\"若哈希函数\",{\"1\":{\"67\":1}}],[\"若键值对不存在\",{\"1\":{\"65\":2}}],[\"若\",{\"1\":{\"65\":1,\"91\":3}}],[\"若之前遇到了删除标记\",{\"1\":{\"65\":1}}],[\"若之后不需要用到\",{\"1\":{\"54\":1}}],[\"若遇到空位或已尝试所有哈希函数\",{\"1\":{\"67\":1}}],[\"若遇到\",{\"1\":{\"65\":1}}],[\"若遇到指定\",{\"1\":{\"63\":1}}],[\"若发现哈希冲突\",{\"1\":{\"65\":1}}],[\"若发现桶内已有元素\",{\"1\":{\"65\":1}}],[\"若未找到\",{\"1\":{\"63\":1}}],[\"若找到键值对\",{\"1\":{\"65\":3}}],[\"若找到\",{\"1\":{\"63\":1}}],[\"若越过尾部\",{\"1\":{\"44\":1}}],[\"若插入元素时列表容量已满\",{\"1\":{\"34\":1}}],[\"若长度过大\",{\"1\":{\"28\":1}}],[\"若长度过小\",{\"1\":{\"28\":1}}],[\"若匹配则输出对应索引\",{\"1\":{\"14\":1}}],[\"若想删除索引\",{\"1\":{\"12\":1}}],[\"但保留工作目录更改\",{\"1\":{\"320\":1}}],[\"但只能使用一次\",{\"1\":{\"245\":1}}],[\"但需要特别注意初始化和更新嵌套结构时可能出现的复杂性\",{\"1\":{\"337\":1}}],[\"但需要进程间同步机制\",{\"1\":{\"228\":1}}],[\"但需要注意的是\",{\"1\":{\"53\":1}}],[\"但假设接着另一个更晚派生的构造函数被调用\",{\"1\":{\"210\":1}}],[\"但在写入时只允许一个线程操作\",{\"1\":{\"239\":1}}],[\"但在实际应用中\",{\"1\":{\"193\":1}}],[\"但在扩容过程中\",{\"1\":{\"53\":1}}],[\"但也带来了性能和调试方面的挑战\",{\"1\":{\"182\":1}}],[\"但也需要注意链条过长带来的性能问题\",{\"1\":{\"168\":1}}],[\"但不会自动合并\",{\"1\":{\"329\":1}}],[\"但不合并到本地分支\",{\"1\":{\"329\":1}}],[\"但不提供具体实现\",{\"1\":{\"150\":1}}],[\"但不同的是\",{\"1\":{\"65\":1}}],[\"但有些题目或教材可能会将其定义为\",{\"1\":{\"80\":1}}],[\"但空间效率变低了\",{\"1\":{\"75\":1}}],[\"但为什么效率可以比它们更高呢\",{\"1\":{\"75\":1}}],[\"但多个哈希函数增加了计算量\",{\"1\":{\"74\":1}}],[\"但多个哈希函数会带来额外的计算量\",{\"1\":{\"67\":1}}],[\"但它会占用一个进程表项\",{\"1\":{\"219\":1}}],[\"但它的进程描述符\",{\"1\":{\"218\":1}}],[\"但它的内存地址不变\",{\"1\":{\"73\":1}}],[\"但它没有显式的\",{\"1\":{\"192\":1}}],[\"但它是可哈希的\",{\"1\":{\"73\":1}}],[\"但目前使用覆盖度不如\",{\"1\":{\"72\":1}}],[\"但效率太低\",{\"1\":{\"62\":1}}],[\"但由于扩容是低频操作\",{\"1\":{\"51\":1}}],[\"但由于其长度不可变\",{\"1\":{\"28\":1}}],[\"但这已超出了栈的定义范畴\",{\"1\":{\"51\":1}}],[\"但这样做会造成部分内存空间浪费\",{\"1\":{\"12\":1}}],[\"但二维数组会有这个问题\",{\"1\":{\"36\":1}}],[\"但好像一些算法书上不怎么直接使用它\",{\"1\":{\"36\":1}}],[\"但是某些步骤的细节部分由子类实现\",{\"1\":{\"361\":1}}],[\"但是在实际应用中使用智能指针有一些需要注意的地方\",{\"1\":{\"266\":1}}],[\"但是我平时只存放整形\",{\"1\":{\"260\":1}}],[\"但是对象还没有实例化\",{\"1\":{\"210\":1}}],[\"但是这个指向vtable的指针事实上是存储在对象的内存空间的\",{\"1\":{\"210\":1}}],[\"但是\",{\"1\":{\"51\":1}}],[\"但是初始化\",{\"1\":{\"36\":1}}],[\"但是增删之前都需要\",{\"1\":{\"36\":1}}],[\"但可能导致部分内存空间浪费\",{\"1\":{\"35\":1,\"36\":1}}],[\"但可能浪费空间\",{\"1\":{\"25\":1}}],[\"但节点访问效率低\",{\"1\":{\"35\":1}}],[\"但插入和删除元素效率低\",{\"1\":{\"35\":1}}],[\"但插入和删除元素的效率仍与数组相同\",{\"1\":{\"32\":1}}],[\"但相应地也需要占用更多的内存空间\",{\"1\":{\"26\":1}}],[\"但实际上遍历此链表已经无法访问到\",{\"1\":{\"22\":1}}],[\"但从地址计算公式的角度看\",{\"1\":{\"10\":1}}],[\"的连接\",{\"1\":{\"372\":1}}],[\"的流程基本固定\",{\"1\":{\"361\":1}}],[\"的基本教程\",{\"1\":{\"341\":1}}],[\"的常见应用\",{\"0\":{\"305\":1}}],[\"的返回值\",{\"0\":{\"301\":1}}],[\"的任何子进程\",{\"1\":{\"300\":1}}],[\"的特定子进程\",{\"1\":{\"300\":1}}],[\"的语法\",{\"0\":{\"300\":1}}],[\"的一端已经发送了连接请求\",{\"1\":{\"292\":1}}],[\"的助手\",{\"1\":{\"266\":1}}],[\"的值\",{\"1\":{\"251\":2}}],[\"的值覆盖待删除节点的值\",{\"1\":{\"93\":1}}],[\"的进程\",{\"1\":{\"220\":1}}],[\"的表现力更强\",{\"1\":{\"194\":1}}],[\"的职责分散到\",{\"1\":{\"192\":1}}],[\"的设计将\",{\"1\":{\"192\":1}}],[\"的设计上\",{\"1\":{\"69\":1}}],[\"的主要职责\",{\"1\":{\"187\":1,\"188\":1,\"189\":1}}],[\"的应用\",{\"1\":{\"182\":1}}],[\"的代码\",{\"1\":{\"179\":1}}],[\"的解耦程度\",{\"1\":{\"177\":1}}],[\"的核心文件\",{\"1\":{\"343\":1}}],[\"的核心是\",{\"1\":{\"177\":1}}],[\"的核心概念\",{\"0\":{\"172\":1}}],[\"的控制器承担了较多的业务逻辑处理工作\",{\"1\":{\"177\":1}}],[\"的对比\",{\"0\":{\"177\":1}}],[\"的数据流\",{\"0\":{\"190\":1}}],[\"的数据流动也同步\",{\"1\":{\"176\":1}}],[\"的数据流动\",{\"1\":{\"176\":1}}],[\"的数据\",{\"1\":{\"188\":1}}],[\"的数据绑定和交互\",{\"1\":{\"181\":1}}],[\"的数据绑定和通信机制可能有一定的难度\",{\"1\":{\"180\":1}}],[\"的数量\",{\"1\":{\"99\":1}}],[\"的工作原理是通过数据绑定实现视图和模型的同步\",{\"1\":{\"176\":1}}],[\"的工作原理\",{\"0\":{\"176\":1},\"1\":{\"181\":1}}],[\"的用户操作\",{\"1\":{\"175\":1}}],[\"的变化\",{\"1\":{\"174\":1}}],[\"的展现层\",{\"1\":{\"174\":1}}],[\"的风险\",{\"1\":{\"126\":1}}],[\"的满二叉树\",{\"1\":{\"113\":1}}],[\"的父节点和\",{\"1\":{\"113\":1}}],[\"的优缺点\",{\"0\":{\"178\":1}}],[\"的优先级遍历树\",{\"1\":{\"113\":1}}],[\"的优势\",{\"1\":{\"88\":1}}],[\"的遍历方式\",{\"1\":{\"112\":1}}],[\"的遍历顺序\",{\"1\":{\"94\":1}}],[\"的逐层遍历方式\",{\"1\":{\"112\":1}}],[\"的平衡因子\",{\"1\":{\"106\":1}}],[\"的左旋操作\",{\"1\":{\"103\":1}}],[\"的左子节点\",{\"1\":{\"102\":1}}],[\"的左子树中\",{\"1\":{\"91\":2,\"92\":1,\"93\":1}}],[\"的右子节点\",{\"1\":{\"103\":1}}],[\"的右子树中\",{\"1\":{\"91\":2,\"92\":1,\"93\":1}}],[\"的右旋操作\",{\"1\":{\"102\":1}}],[\"的大小关系\",{\"1\":{\"94\":1}}],[\"的大小关系循环向下搜索\",{\"1\":{\"92\":1}}],[\"的下一个节点\",{\"1\":{\"93\":1}}],[\"的位置\",{\"1\":{\"92\":1}}],[\"的性质仍然满足\",{\"1\":{\"93\":1}}],[\"的性质\",{\"1\":{\"92\":1,\"93\":1,\"101\":1}}],[\"的性能会更好\",{\"1\":{\"36\":1}}],[\"的树的高度\",{\"1\":{\"88\":1}}],[\"的树的节点总数\",{\"1\":{\"88\":1}}],[\"的树的叶节点数量\",{\"1\":{\"88\":1}}],[\"的分离\",{\"1\":{\"190\":1}}],[\"的分治逻辑\",{\"1\":{\"79\":1,\"112\":1}}],[\"的分布存在某种周期性时\",{\"1\":{\"71\":1}}],[\"的查询效率\",{\"1\":{\"75\":1}}],[\"的查询功能\",{\"1\":{\"58\":1}}],[\"的成员变量是可变的\",{\"1\":{\"73\":1}}],[\"的哈希值为\",{\"1\":{\"73\":4}}],[\"的哈希表数据结构\",{\"1\":{\"70\":1}}],[\"的实现开销更低\",{\"1\":{\"72\":1}}],[\"的输出都相同\",{\"1\":{\"70\":1}}],[\"的问题\",{\"1\":{\"67\":1}}],[\"的步数\",{\"1\":{\"66\":1}}],[\"的索引\",{\"1\":{\"65\":1}}],[\"的增加\",{\"1\":{\"65\":1}}],[\"的两个学生时\",{\"1\":{\"61\":1}}],[\"的情况\",{\"1\":{\"61\":1}}],[\"的尾部即可\",{\"1\":{\"58\":1}}],[\"的体现\",{\"1\":{\"54\":1}}],[\"的每个元素引用相同的地址吗\",{\"1\":{\"36\":1}}],[\"的时间查找元素\",{\"1\":{\"36\":1}}],[\"的角度看\",{\"1\":{\"36\":1}}],[\"的引用\",{\"1\":{\"26\":1}}],[\"的首个节点\",{\"1\":{\"24\":1}}],[\"的节点称为\",{\"1\":{\"101\":1}}],[\"的节点\",{\"1\":{\"23\":1,\"24\":1}}],[\"的操作\",{\"1\":{\"15\":1}}],[\"的\",{\"1\":{\"12\":1,\"74\":2,\"95\":1,\"185\":2,\"191\":1,\"192\":2,\"194\":1,\"372\":1,\"374\":1}}],[\"+x\",{\"1\":{\"370\":1}}],[\"++count\",{\"1\":{\"260\":3}}],[\"++counter\",{\"1\":{\"241\":1}}],[\"++i\",{\"1\":{\"238\":1,\"240\":1,\"241\":2,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":2,\"251\":2,\"257\":3,\"258\":4,\"259\":2,\"261\":1,\"287\":2}}],[\"+1\",{\"1\":{\"202\":1}}],[\"+=\",{\"1\":{\"13\":1,\"33\":2}}],[\"+\",{\"0\":{\"362\":1},\"1\":{\"12\":1,\"15\":1,\"32\":2,\"36\":1,\"44\":4,\"54\":1,\"63\":1,\"65\":1,\"99\":2,\"201\":2,\"226\":1,\"250\":2,\"251\":4,\"263\":1,\"264\":1,\"270\":1}}],[\"<n>\",{\"1\":{\"374\":1}}],[\"<netinet\",{\"1\":{\"231\":1}}],[\"<variable>\",{\"1\":{\"374\":1}}],[\"<vector>\",{\"1\":{\"239\":1,\"244\":1,\"245\":1,\"250\":1,\"271\":1}}],[\"<path>\",{\"1\":{\"331\":1}}],[\"<p>hello\",{\"1\":{\"181\":1}}],[\"<repository\",{\"1\":{\"331\":1,\"332\":1}}],[\"<function>\",{\"1\":{\"374\":1}}],[\"<functional>\",{\"1\":{\"263\":2,\"264\":1}}],[\"<future>\",{\"1\":{\"263\":2,\"264\":1}}],[\"<fcntl\",{\"1\":{\"222\":1}}],[\"<typename\",{\"1\":{\"250\":1,\"251\":1,\"264\":1}}],[\"<thread>\",{\"1\":{\"236\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":1,\"257\":1,\"258\":2,\"259\":1,\"263\":2,\"264\":1}}],[\"<latch>\",{\"1\":{\"245\":1}}],[\"<barrier>\",{\"1\":{\"244\":1}}],[\"<address>\",{\"1\":{\"374\":2}}],[\"<atomic>\",{\"1\":{\"241\":1,\"243\":1,\"250\":1}}],[\"<arpa\",{\"1\":{\"231\":1}}],[\"<commit\",{\"1\":{\"336\":1}}],[\"<condition\",{\"1\":{\"240\":1}}],[\"<chrono>\",{\"1\":{\"258\":1,\"259\":1}}],[\"<csignal>\",{\"1\":{\"230\":1}}],[\"<cstring>\",{\"1\":{\"227\":1,\"228\":1}}],[\"<map>\",{\"1\":{\"271\":1}}],[\"<mutex>\",{\"1\":{\"238\":1,\"240\":1,\"258\":2,\"259\":1}}],[\"<memory>\",{\"1\":{\"151\":1,\"158\":1,\"167\":1}}],[\"<unistd\",{\"1\":{\"220\":1,\"222\":1,\"226\":1,\"230\":1,\"231\":2,\"303\":1}}],[\"<semaphore>\",{\"1\":{\"242\":1}}],[\"<shared\",{\"1\":{\"239\":1}}],[\"<stdlib\",{\"1\":{\"222\":1}}],[\"<string>\",{\"1\":{\"145\":1,\"271\":1}}],[\"<signal\",{\"1\":{\"220\":1,\"222\":1}}],[\"<sys\",{\"1\":{\"220\":1,\"222\":2,\"227\":2,\"228\":2,\"229\":2,\"231\":2,\"303\":1}}],[\"<script>\",{\"1\":{\"181\":1}}],[\"<script\",{\"1\":{\"181\":1}}],[\"<input\",{\"1\":{\"181\":1}}],[\"<iostream>\",{\"1\":{\"133\":1,\"145\":1,\"151\":1,\"158\":1,\"167\":1,\"207\":1,\"220\":1,\"222\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":2,\"236\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":1,\"257\":1,\"258\":2,\"259\":1,\"263\":2,\"264\":1,\"270\":1,\"271\":1,\"277\":1,\"287\":1,\"303\":1,\"347\":1}}],[\"<div\",{\"1\":{\"181\":1}}],[\"<=\",{\"1\":{\"106\":1,\"167\":2}}],[\"<−1\",{\"1\":{\"106\":2}}],[\"<0\",{\"1\":{\"106\":1}}],[\"<<endl\",{\"1\":{\"207\":2,\"270\":3,\"271\":6}}],[\"<<\",{\"1\":{\"44\":2,\"59\":8,\"60\":4,\"63\":6,\"65\":8,\"71\":1,\"133\":2,\"139\":4,\"145\":10,\"151\":6,\"158\":4,\"161\":8,\"167\":12,\"207\":2,\"222\":8,\"226\":3,\"227\":5,\"228\":3,\"229\":8,\"230\":4,\"231\":3,\"236\":2,\"238\":3,\"239\":3,\"240\":3,\"241\":3,\"242\":4,\"243\":4,\"244\":8,\"245\":8,\"250\":6,\"251\":6,\"257\":16,\"258\":6,\"259\":3,\"261\":2,\"263\":6,\"264\":2,\"275\":2,\"277\":5,\"287\":4,\"303\":24,\"347\":2}}],[\"<\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":1,\"43\":1,\"44\":1,\"63\":1,\"89\":2,\"91\":2,\"92\":4,\"93\":5,\"94\":2,\"106\":1,\"108\":1,\"109\":1,\"113\":2,\"133\":1,\"181\":3,\"222\":4,\"238\":1,\"240\":1,\"241\":2,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":2,\"251\":2,\"257\":3,\"258\":4,\"259\":2,\"261\":1,\"287\":2,\"300\":1}}],[\"删除子模块目录\",{\"1\":{\"335\":1}}],[\"删除子模块配置\",{\"1\":{\"335\":1}}],[\"删除子模块的条目\",{\"1\":{\"335\":1}}],[\"删除分支\",{\"1\":{\"323\":2}}],[\"删除远程仓库\",{\"1\":{\"311\":1}}],[\"删除信号量\",{\"1\":{\"229\":1}}],[\"删除消息队列\",{\"1\":{\"227\":1}}],[\"删除键值对和遍历哈希表等\",{\"1\":{\"74\":1}}],[\"删除标记\",{\"1\":{\"65\":1}}],[\"删除操作中的一步\",{\"1\":{\"113\":1}}],[\"删除操作\",{\"1\":{\"59\":1,\"60\":1,\"63\":1,\"65\":1,\"96\":1}}],[\"删除操作在链表的另一端进行\",{\"1\":{\"27\":1}}],[\"删除栈顶元素的操作叫作\",{\"1\":{\"46\":1}}],[\"删除头节点\",{\"1\":{\"43\":1}}],[\"删除队首元素的操作称为\",{\"1\":{\"40\":1}}],[\"删除和遍历等操作\",{\"1\":{\"28\":1}}],[\"删除链表的节点\",{\"1\":{\"22\":1}}],[\"删除节点操作要分三种情况处理\",{\"1\":{\"113\":1}}],[\"删除节点操作同样使用\",{\"1\":{\"93\":1}}],[\"删除节点\",{\"0\":{\"22\":1,\"93\":1,\"109\":1},\"1\":{\"36\":1,\"83\":1,\"93\":2}}],[\"删除索引\",{\"1\":{\"12\":1,\"32\":1}}],[\"删除元素完成后\",{\"1\":{\"12\":1}}],[\"删除元素\",{\"0\":{\"12\":1},\"1\":{\"25\":1,\"32\":1,\"58\":2,\"63\":1,\"95\":1}}],[\"了解这些状态对于网络调试\",{\"1\":{\"291\":1}}],[\"了\",{\"1\":{\"12\":1,\"36\":1,\"73\":1}}],[\"无锁编程主要依赖于原子操作和内存序列模型\",{\"1\":{\"247\":1}}],[\"无锁编程\",{\"0\":{\"247\":1},\"1\":{\"247\":1}}],[\"无法多个进程\",{\"1\":{\"246\":1}}],[\"无法通过哈希值反推出关于输入数据的任何信息\",{\"1\":{\"70\":1}}],[\"无需锁定\",{\"1\":{\"241\":1}}],[\"无名管道\",{\"1\":{\"226\":2}}],[\"无论是使用现成的模型类\",{\"1\":{\"194\":1}}],[\"无序数组\",{\"1\":{\"95\":1}}],[\"无返回值\",{\"1\":{\"47\":1}}],[\"无须旋转\",{\"1\":{\"106\":1}}],[\"无须进行额外的排序操作\",{\"1\":{\"94\":1}}],[\"无须使用者考虑容量限制的问题\",{\"1\":{\"28\":1}}],[\"无须额外的结构开销\",{\"1\":{\"16\":1}}],[\"无意义\",{\"1\":{\"12\":2}}],[\"无初始值\",{\"1\":{\"9\":1,\"30\":2}}],[\"处理子进程的终止状态\",{\"1\":{\"306\":1}}],[\"处理特定子进程\",{\"1\":{\"305\":1}}],[\"处理用户的输入\",{\"1\":{\"188\":1}}],[\"处理用户事件\",{\"1\":{\"177\":1}}],[\"处理业务逻辑\",{\"1\":{\"173\":1}}],[\"处理请求的各个过滤器\",{\"1\":{\"168\":1}}],[\"处理请假请求的虚函数\",{\"1\":{\"167\":1}}],[\"处理\",{\"1\":{\"167\":3,\"220\":1}}],[\"处理类\",{\"1\":{\"167\":3}}],[\"处理者\",{\"1\":{\"166\":1}}],[\"处插入数字\",{\"1\":{\"32\":1}}],[\"处插入元素\",{\"1\":{\"11\":1}}],[\"处的元素更新为\",{\"1\":{\"31\":1}}],[\"处的元素\",{\"1\":{\"11\":1,\"12\":2,\"31\":1,\"32\":1}}],[\"将任务逻辑和浏览器实现进行分离\",{\"0\":{\"364\":1}}],[\"将波形绘制配置的初始化逻辑抽象出来\",{\"1\":{\"361\":1}}],[\"将目录添加到编译器的包含路径中\",{\"1\":{\"353\":1}}],[\"将指针的变化保存到主仓库\",{\"1\":{\"338\":1}}],[\"将指定分支的更改合并到当前分支\",{\"1\":{\"324\":1}}],[\"将更改推送到远程分支\",{\"1\":{\"328\":1}}],[\"将本地分支的提交推送到远程仓库\",{\"1\":{\"328\":1}}],[\"将当前分支的更改应用到另一分支的顶端\",{\"1\":{\"325\":1}}],[\"将当前工作目录更改为根目录\",{\"1\":{\"223\":1}}],[\"将文件添加到暂存区\",{\"1\":{\"313\":1}}],[\"将返回导致子进程终止的信号编号\",{\"1\":{\"304\":1}}],[\"将返回子进程的退出状态码\",{\"1\":{\"304\":1}}],[\"将函数和future绑定起来\",{\"1\":{\"263\":1}}],[\"将数据和future绑定起来\",{\"1\":{\"263\":1}}],[\"将数组转化为\",{\"1\":{\"44\":1}}],[\"将头部指针所指向的元素存储到\",{\"1\":{\"251\":1}}],[\"将头节点作为栈顶\",{\"1\":{\"49\":1}}],[\"将新的尾部指针存储到\",{\"1\":{\"251\":1}}],[\"将元素存储在当前尾部指针所指向的位置\",{\"1\":{\"251\":1}}],[\"将元素插入其中\",{\"1\":{\"65\":1}}],[\"将线程和线程对象分离\",{\"1\":{\"236\":1,\"257\":1}}],[\"将标准文件描述符重定向到\",{\"1\":{\"222\":1,\"223\":1}}],[\"将子进程的父进程设置为\",{\"1\":{\"220\":1}}],[\"将重载函数重新命名成唯一的标识符\",{\"1\":{\"204\":1}}],[\"将事件沿着组件树传递\",{\"1\":{\"168\":1}}],[\"将对象的实例化过程封装在工厂类中\",{\"1\":{\"161\":1}}],[\"将其隔离到相同的模块\",{\"1\":{\"127\":1}}],[\"将调用模块与实现模块进行隔离\",{\"1\":{\"127\":1}}],[\"将该节点记为\",{\"1\":{\"102\":1}}],[\"将该节点置于\",{\"1\":{\"92\":1}}],[\"将待删除节点替换为其子节点即可\",{\"1\":{\"93\":1}}],[\"将所有构建文件放到单独的目录中\",{\"1\":{\"350\":1}}],[\"将所有的\",{\"1\":{\"103\":1}}],[\"将所有冲突元素存储在同一个链表中\",{\"1\":{\"74\":1}}],[\"将所有发生冲突的键值对都存储在同一链表中\",{\"1\":{\"63\":1}}],[\"将每个字符的\",{\"1\":{\"71\":1}}],[\"将输入数据的每个元素通过异或操作累积到一个哈希值中\",{\"1\":{\"71\":1}}],[\"将输入元素赋值给\",{\"1\":{\"44\":1}}],[\"将各个字符的\",{\"1\":{\"71\":1}}],[\"将得到的总和作为哈希值\",{\"1\":{\"71\":1}}],[\"将键值对从原哈希表搬运至新哈希表\",{\"1\":{\"63\":1,\"65\":1}}],[\"将键值对作为链表节点\",{\"1\":{\"63\":1}}],[\"将单个元素转换为链表\",{\"1\":{\"63\":1}}],[\"将哈希值对桶数量\",{\"1\":{\"60\":1}}],[\"将这个操作压入栈\",{\"1\":{\"54\":1}}],[\"将把元素添加到栈顶的操作叫作\",{\"1\":{\"46\":1}}],[\"将把元素加入队尾的操作称为\",{\"1\":{\"40\":1}}],[\"将链表转化为\",{\"1\":{\"43\":1}}],[\"将索引\",{\"1\":{\"31\":1}}],[\"将切换到下一个进程\",{\"1\":{\"27\":1}}],[\"将最后一个节点称为尾节点\",{\"1\":{\"26\":1}}],[\"将原数组中的所有元素复制到新数组\",{\"1\":{\"15\":1}}],[\"将\",{\"1\":{\"11\":1,\"44\":1,\"49\":1,\"102\":2,\"103\":2,\"182\":1}}],[\">play\",{\"1\":{\"364\":2}}],[\">update\",{\"1\":{\"363\":1}}],[\">malloc\",{\"1\":{\"362\":2}}],[\">initdrawoption\",{\"1\":{\"361\":1}}],[\">void\",{\"1\":{\"276\":1}}],[\">value\",{\"1\":{\"59\":2}}],[\">val\",{\"1\":{\"24\":1,\"43\":2,\"49\":2,\"60\":4,\"63\":4,\"65\":4,\"91\":2,\"92\":3,\"93\":5,\"108\":2,\"109\":5}}],[\">fun\",{\"1\":{\"207\":2}}],[\">first\",{\"1\":{\"59\":1}}],[\">sort\",{\"1\":{\"194\":1}}],[\">save\",{\"1\":{\"189\":1}}],[\">show\",{\"1\":{\"188\":1}}],[\">setbrower\",{\"1\":{\"364\":2}}],[\">setsourcemodel\",{\"1\":{\"194\":1}}],[\">setitemdelegate\",{\"1\":{\"189\":1}}],[\">setmodel\",{\"1\":{\"188\":1,\"194\":1}}],[\">sethorizontalheaderlabels\",{\"1\":{\"187\":1}}],[\">setnexthandler\",{\"1\":{\"167\":2}}],[\">second\",{\"1\":{\"59\":1}}],[\">appendrow\",{\"1\":{\"187\":1}}],[\">applycolor\",{\"1\":{\"151\":2}}],[\"><\",{\"1\":{\"181\":1}}],[\">handlerequest\",{\"1\":{\"167\":6}}],[\">height\",{\"1\":{\"99\":1}}],[\">type\",{\"1\":{\"161\":2}}],[\">click\",{\"1\":{\"161\":2}}],[\">createtextbox\",{\"1\":{\"161\":2}}],[\">createbutton\",{\"1\":{\"161\":2}}],[\">createvehicle\",{\"1\":{\"158\":2}}],[\">calculate\",{\"1\":{\"139\":1}}],[\">drive\",{\"1\":{\"158\":2}}],[\">drawtext\",{\"1\":{\"189\":1}}],[\">draw\",{\"1\":{\"151\":2,\"361\":1}}],[\">doprogress\",{\"1\":{\"133\":1}}],[\">run\",{\"1\":{\"364\":1}}],[\">restore\",{\"1\":{\"189\":1}}],[\">read\",{\"1\":{\"145\":5}}],[\">right\",{\"1\":{\"82\":2,\"91\":1,\"92\":2,\"93\":5,\"99\":1,\"100\":1,\"102\":2,\"103\":2,\"106\":3,\"108\":2,\"109\":7}}],[\">0\",{\"1\":{\"106\":1}}],[\">1\",{\"1\":{\"101\":1,\"106\":2}}],[\">left\",{\"1\":{\"82\":2,\"83\":3,\"91\":1,\"92\":2,\"93\":8,\"99\":1,\"100\":1,\"102\":2,\"103\":2,\"106\":3,\"108\":2,\"109\":7}}],[\">>\",{\"1\":{\"63\":2,\"71\":1}}],[\">key\",{\"1\":{\"60\":3,\"63\":5,\"65\":3}}],[\">=\",{\"1\":{\"49\":1,\"106\":1}}],[\">next\",{\"1\":{\"20\":4,\"21\":3,\"22\":4,\"23\":1,\"24\":1,\"43\":3,\"49\":3}}],[\">\",{\"1\":{\"11\":1,\"20\":4,\"22\":2,\"59\":2,\"60\":5,\"63\":2,\"65\":5,\"83\":1,\"91\":2,\"106\":1,\"108\":1,\"109\":1,\"167\":2,\"181\":2,\"220\":2,\"222\":2,\"262\":2,\"263\":1,\"287\":1,\"300\":1,\"303\":1,\"363\":1,\"364\":1,\"370\":2}}],[\"io\",{\"1\":{\"382\":1}}],[\"it\",{\"1\":{\"382\":1}}],[\"item\",{\"1\":{\"250\":7,\"251\":11}}],[\"item2\",{\"1\":{\"187\":2}}],[\"item1\",{\"1\":{\"187\":2}}],[\"iter++\",{\"1\":{\"59\":1}}],[\"iter\",{\"1\":{\"59\":4}}],[\"img\",{\"1\":{\"370\":1,\"372\":4}}],[\"implicit\",{\"1\":{\"277\":1}}],[\"implementor\",{\"1\":{\"150\":2}}],[\"iebrowser\",{\"1\":{\"364\":1}}],[\"iebrower\",{\"1\":{\"364\":1}}],[\"ipc\",{\"1\":{\"225\":2,\"226\":1,\"227\":3,\"228\":3,\"229\":3,\"232\":1}}],[\"iprogress\",{\"1\":{\"133\":4}}],[\"i+1\",{\"1\":{\"133\":1}}],[\"i++\",{\"1\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"23\":1,\"33\":1,\"43\":1,\"44\":1,\"63\":1,\"133\":1}}],[\"is\",{\"1\":{\"229\":2,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"271\":11,\"382\":1}}],[\"isp\",{\"1\":{\"126\":1}}],[\"isempty\",{\"1\":{\"43\":1,\"44\":2,\"49\":2,\"50\":2}}],[\"id=\",{\"1\":{\"181\":1}}],[\"id\",{\"1\":{\"36\":2,\"238\":4,\"240\":4,\"242\":2,\"243\":2,\"244\":3,\"245\":3,\"257\":1,\"300\":3}}],[\"i−1\",{\"1\":{\"23\":1}}],[\"if\",{\"1\":{\"14\":1,\"22\":1,\"23\":1,\"24\":1,\"43\":2,\"44\":2,\"49\":1,\"50\":1,\"60\":4,\"63\":4,\"65\":11,\"91\":2,\"92\":4,\"93\":7,\"100\":1,\"106\":4,\"108\":3,\"109\":5,\"133\":1,\"167\":6,\"193\":1,\"220\":5,\"222\":6,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"250\":2,\"251\":4,\"257\":4,\"262\":2,\"303\":7,\"363\":1,\"364\":1,\"382\":1}}],[\"i\",{\"1\":{\"11\":5,\"12\":6,\"13\":3,\"14\":4,\"15\":4,\"23\":3,\"33\":3,\"43\":3,\"44\":3,\"49\":4,\"63\":5,\"88\":1,\"133\":2,\"215\":1,\"216\":2,\"238\":4,\"240\":4,\"241\":5,\"242\":4,\"243\":4,\"244\":3,\"245\":3,\"250\":6,\"251\":7,\"257\":9,\"258\":12,\"259\":6,\"261\":3,\"275\":2,\"287\":10,\"314\":1}}],[\"info=y\",{\"1\":{\"374\":1}}],[\"info\",{\"1\":{\"374\":1}}],[\"information\",{\"1\":{\"97\":1}}],[\"installed\",{\"1\":{\"382\":2}}],[\"install\",{\"1\":{\"342\":2,\"356\":2,\"370\":4,\"371\":1,\"382\":3}}],[\"inserthelper\",{\"1\":{\"108\":3}}],[\"insert\",{\"1\":{\"11\":1,\"21\":1,\"32\":1,\"92\":1,\"271\":3}}],[\"inline\",{\"1\":{\"264\":1}}],[\"increment\",{\"1\":{\"241\":2}}],[\"include\",{\"1\":{\"133\":1,\"145\":2,\"151\":2,\"158\":2,\"167\":2,\"207\":1,\"220\":4,\"222\":7,\"226\":2,\"227\":4,\"228\":4,\"229\":3,\"230\":3,\"231\":8,\"236\":2,\"238\":3,\"239\":4,\"240\":4,\"241\":3,\"242\":3,\"243\":3,\"244\":4,\"245\":4,\"250\":4,\"257\":2,\"258\":7,\"259\":4,\"263\":8,\"264\":4,\"270\":1,\"271\":4,\"277\":1,\"287\":1,\"303\":3,\"347\":1,\"353\":3,\"354\":2}}],[\"inaddr\",{\"1\":{\"231\":1}}],[\"inet\",{\"1\":{\"231\":6}}],[\"initrd\",{\"1\":{\"372\":2}}],[\"initdrawoption\",{\"1\":{\"361\":3}}],[\"init\",{\"1\":{\"220\":7,\"243\":1,\"311\":3,\"332\":1,\"370\":5}}],[\"input\",{\"1\":{\"181\":1}}],[\"in\",{\"1\":{\"161\":2,\"229\":2,\"231\":3,\"263\":2,\"264\":2,\"382\":1}}],[\"internal\",{\"1\":{\"382\":1}}],[\"interact\",{\"1\":{\"382\":1}}],[\"interrupt\",{\"1\":{\"230\":1}}],[\"inter\",{\"1\":{\"225\":1}}],[\"int\",{\"0\":{\"202\":1},\"1\":{\"9\":6,\"10\":5,\"11\":5,\"12\":4,\"13\":4,\"14\":5,\"15\":7,\"18\":2,\"23\":2,\"24\":3,\"26\":2,\"31\":1,\"33\":3,\"36\":3,\"41\":2,\"43\":7,\"44\":14,\"47\":2,\"49\":7,\"50\":5,\"51\":1,\"60\":11,\"63\":12,\"65\":15,\"71\":4,\"73\":1,\"79\":2,\"91\":1,\"92\":1,\"93\":2,\"99\":3,\"100\":1,\"106\":1,\"108\":1,\"109\":2,\"133\":2,\"139\":1,\"145\":1,\"151\":1,\"158\":1,\"161\":1,\"167\":8,\"193\":3,\"202\":2,\"204\":1,\"207\":1,\"220\":2,\"222\":1,\"226\":2,\"227\":2,\"228\":2,\"229\":5,\"230\":2,\"231\":5,\"236\":2,\"238\":3,\"239\":2,\"240\":3,\"241\":3,\"242\":3,\"243\":3,\"244\":3,\"245\":3,\"250\":4,\"251\":4,\"257\":6,\"258\":8,\"259\":4,\"260\":3,\"261\":2,\"263\":6,\"264\":3,\"270\":1,\"271\":4,\"273\":2,\"274\":3,\"275\":1,\"276\":1,\"277\":4,\"287\":1,\"300\":3,\"303\":2,\"347\":1,\"363\":1}}],[\"index++\",{\"1\":{\"24\":1}}],[\"index\",{\"1\":{\"7\":1,\"11\":6,\"12\":4,\"23\":3,\"24\":2,\"60\":12,\"63\":7,\"65\":25,\"69\":1,\"189\":2,\"193\":3}}],[\"把索引\",{\"1\":{\"11\":1,\"12\":1}}],[\"如测试\",{\"1\":{\"357\":1}}],[\"如可执行文件或库\",{\"1\":{\"353\":1}}],[\"如互斥锁\",{\"1\":{\"247\":1}}],[\"如计数器\",{\"1\":{\"241\":1}}],[\"如管道\",{\"1\":{\"232\":1}}],[\"如信号量\",{\"1\":{\"228\":1}}],[\"如父子进程\",{\"1\":{\"226\":1}}],[\"如处理信号\",{\"1\":{\"224\":1}}],[\"如内存\",{\"1\":{\"218\":1}}],[\"如等待信号\",{\"1\":{\"216\":1}}],[\"如void\",{\"1\":{\"204\":1}}],[\"如点击\",{\"1\":{\"188\":1,\"190\":1}}],[\"如按钮点击\",{\"1\":{\"174\":1}}],[\"如增删改查等\",{\"1\":{\"173\":1}}],[\"如数据的获取\",{\"1\":{\"173\":1}}],[\"如控制台日志\",{\"1\":{\"168\":1}}],[\"如gui事件处理\",{\"1\":{\"131\":1}}],[\"如\",{\"1\":{\"126\":1,\"171\":1,\"173\":1,\"177\":1,\"181\":1,\"187\":1,\"190\":1,\"215\":1,\"216\":1,\"218\":1,\"224\":2,\"241\":1,\"243\":1,\"248\":1,\"252\":3,\"341\":1,\"343\":1,\"351\":1}}],[\"如观察者模式\",{\"1\":{\"125\":1}}],[\"如装饰器模式\",{\"1\":{\"125\":1}}],[\"如单例模式\",{\"1\":{\"125\":1}}],[\"如何创建线程\",{\"0\":{\"236\":1}}],[\"如何避免产生僵尸进程\",{\"0\":{\"220\":1}}],[\"如何使用virtual函数来完成你想完成的动作\",{\"1\":{\"210\":1}}],[\"如何从一组输入数据构建一棵二叉搜索树\",{\"1\":{\"113\":1}}],[\"如何基于\",{\"1\":{\"60\":1}}],[\"如下所示\",{\"1\":{\"348\":1}}],[\"如下\",{\"1\":{\"259\":1}}],[\"如下表所示\",{\"1\":{\"88\":1,\"106\":1}}],[\"如下图所示\",{\"1\":{\"11\":1,\"12\":1,\"21\":1,\"22\":1,\"26\":1,\"40\":1,\"43\":1,\"46\":1,\"49\":1,\"50\":1,\"58\":1,\"61\":2,\"65\":1,\"69\":1,\"79\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"91\":1,\"93\":2,\"94\":1,\"97\":1,\"102\":2,\"103\":1,\"105\":1}}],[\"如整数\",{\"1\":{\"46\":1}}],[\"如上一节所述\",{\"1\":{\"23\":1}}],[\"如以下代码所示\",{\"1\":{\"18\":1}}],[\"如果使用\",{\"1\":{\"352\":1}}],[\"如果子模块的上游仓库有新的提交\",{\"1\":{\"334\":1}}],[\"如果子进程已继续执行\",{\"1\":{\"302\":1}}],[\"如果子进程处于停止状态\",{\"1\":{\"302\":2}}],[\"如果子进程因信号终止\",{\"1\":{\"302\":2}}],[\"如果子进程正常终止\",{\"1\":{\"302\":2}}],[\"如果子进程在接收到\",{\"1\":{\"300\":1}}],[\"如果设置了\",{\"1\":{\"301\":1}}],[\"如果一块内存被shared\",{\"1\":{\"269\":1}}],[\"如果一个功能能够在相同的时间复杂度下使用数组或链表实现\",{\"1\":{\"75\":1}}],[\"如果你拷贝一个unique\",{\"1\":{\"268\":1}}],[\"如果引用计数减至0\",{\"1\":{\"267\":1}}],[\"如果引用计数为减至0\",{\"1\":{\"267\":1}}],[\"如果希望多个智能指针管理同一个资源\",{\"1\":{\"266\":1}}],[\"如果希望只有一个智能指针管理资源或者管理数组\",{\"1\":{\"266\":1}}],[\"如果需要复制放到容器中可以使用std\",{\"1\":{\"263\":1}}],[\"如果\",{\"1\":{\"251\":2}}],[\"如果是\",{\"1\":{\"248\":1,\"304\":2}}],[\"如果是先查找元素\",{\"1\":{\"36\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"243\":1}}],[\"如果计数器值为零或负\",{\"1\":{\"242\":1}}],[\"如果计数器值为正\",{\"1\":{\"242\":1}}],[\"如果条件不满足\",{\"1\":{\"240\":1}}],[\"如果条件满足\",{\"1\":{\"240\":1}}],[\"如果读计数器为0且有写线程在等待\",{\"1\":{\"239\":1}}],[\"如果有线程在等待队列中\",{\"1\":{\"242\":1}}],[\"如果有写线程在等待\",{\"1\":{\"239\":1}}],[\"如果有写锁存在\",{\"1\":{\"239\":1}}],[\"如果有读线程在等待\",{\"1\":{\"239\":1}}],[\"如果有读锁或写锁存在\",{\"1\":{\"239\":1}}],[\"如果有大量僵尸进程存在\",{\"1\":{\"219\":1}}],[\"如果没有子进程退出或状态变化\",{\"1\":{\"300\":1}}],[\"如果没有读锁和写锁存在\",{\"1\":{\"239\":1}}],[\"如果没有写锁存在\",{\"1\":{\"239\":1}}],[\"如果没有线程在等待\",{\"1\":{\"238\":1}}],[\"如果没有调用join或者detach函数\",{\"1\":{\"257\":1}}],[\"如果没有调用\",{\"1\":{\"236\":1}}],[\"如果等待队列中有其他线程\",{\"1\":{\"238\":1}}],[\"如果互斥量已锁定\",{\"1\":{\"238\":1}}],[\"如果互斥量未锁定\",{\"1\":{\"238\":1}}],[\"如果线程已经和对象分离\",{\"1\":{\"236\":1,\"257\":1}}],[\"如果不明确指定创建策略\",{\"1\":{\"264\":1}}],[\"如果不希望线程被阻塞执行\",{\"1\":{\"236\":1,\"257\":1}}],[\"如果不断开\",{\"1\":{\"36\":1}}],[\"如果父进程在子进程结束前退出\",{\"1\":{\"220\":1}}],[\"如果运行中的进程的时间片耗尽\",{\"1\":{\"216\":1}}],[\"如果派生类中申请了内存空间\",{\"1\":{\"210\":1}}],[\"如果在构造函数或析构函数中调用虚函数\",{\"1\":{\"209\":1}}],[\"如果对象类型是基类\",{\"1\":{\"207\":1}}],[\"如果对象类型是派生类\",{\"1\":{\"207\":1}}],[\"如果当前对象无法处理该请求\",{\"1\":{\"166\":1}}],[\"如果c++98的朋友想进阶到c++11\",{\"1\":{\"122\":1}}],[\"如果要对比值\",{\"1\":{\"113\":1}}],[\"如果要同时支持后退和前进\",{\"1\":{\"52\":1}}],[\"如果方法只在类内部使用\",{\"1\":{\"113\":1}}],[\"如果考虑上述失衡二叉树的\",{\"1\":{\"103\":1}}],[\"如果将\",{\"1\":{\"79\":1}}],[\"如果能够保证\",{\"1\":{\"71\":1}}],[\"如果输入\",{\"1\":{\"71\":1}}],[\"如果两者匹配\",{\"1\":{\"70\":2}}],[\"如果哈希冲突过于频繁\",{\"1\":{\"69\":1}}],[\"如果遇到空桶\",{\"1\":{\"65\":1}}],[\"如果后续仍需要使用弹出节点\",{\"1\":{\"54\":1}}],[\"如果入栈元素本身就是节点对象\",{\"1\":{\"51\":1}}],[\"如果入栈时超出数组容量\",{\"1\":{\"51\":1}}],[\"如果想取出底部的盘子\",{\"1\":{\"46\":1}}],[\"如果想在数组中间插入一个元素\",{\"1\":{\"11\":1}}],[\"如果队列已满\",{\"1\":{\"250\":1,\"251\":2}}],[\"如果队列不为空\",{\"1\":{\"43\":1}}],[\"如果队列为空\",{\"1\":{\"43\":1,\"250\":1,\"251\":2}}],[\"如果添加元素时超出列表长度\",{\"1\":{\"36\":1}}],[\"如果我们在二叉搜索树中不断地插入和删除节点\",{\"1\":{\"95\":1}}],[\"如果我们令单向链表的尾节点指向头节点\",{\"1\":{\"26\":1}}],[\"如果我们想随机抽取一些样本\",{\"1\":{\"17\":1}}],[\"如果我们希望扩容数组\",{\"1\":{\"15\":1}}],[\"如果数组分配的大小超过实际所需\",{\"1\":{\"16\":1}}],[\"紧挨着的\",{\"1\":{\"11\":1}}],[\"rm\",{\"1\":{\"335\":1}}],[\"rmid\",{\"1\":{\"227\":1,\"228\":1,\"229\":1}}],[\"r\",{\"1\":{\"277\":4}}],[\"rw\",{\"1\":{\"239\":3}}],[\"rdwr\",{\"1\":{\"222\":1}}],[\"runs\",{\"1\":{\"382\":1}}],[\"runtasks\",{\"1\":{\"364\":1}}],[\"run\",{\"1\":{\"364\":3,\"382\":4}}],[\"running\",{\"1\":{\"215\":1,\"303\":1,\"382\":2}}],[\"rust\",{\"1\":{\"18\":1}}],[\"raw\",{\"1\":{\"287\":2}}],[\"raii\",{\"1\":{\"201\":1}}],[\"range\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1}}],[\"rand\",{\"1\":{\"10\":1}}],[\"randomnum\",{\"1\":{\"10\":2}}],[\"randomindex\",{\"1\":{\"10\":2}}],[\"randomaccess\",{\"1\":{\"10\":1}}],[\"riding\",{\"1\":{\"158\":1}}],[\"rightrotate\",{\"1\":{\"102\":1,\"106\":3}}],[\"right\",{\"1\":{\"79\":4,\"91\":1,\"99\":1,\"102\":3,\"103\":2,\"113\":1}}],[\"rocess\",{\"1\":{\"225\":1}}],[\"rodata\",{\"1\":{\"208\":1}}],[\"role\",{\"1\":{\"193\":2}}],[\"row\",{\"1\":{\"193\":2}}],[\"rowsremoved\",{\"1\":{\"191\":1}}],[\"rowsinserted\",{\"1\":{\"191\":1}}],[\"rowcount\",{\"1\":{\"190\":1,\"193\":2}}],[\"rotate\",{\"1\":{\"102\":3,\"106\":1,\"108\":1,\"109\":1,\"113\":1}}],[\"rothash\",{\"1\":{\"71\":1}}],[\"rootfs\",{\"1\":{\"370\":1,\"372\":4}}],[\"root\",{\"1\":{\"80\":1,\"90\":1,\"91\":2,\"92\":3,\"93\":4,\"113\":1,\"224\":1,\"270\":6,\"271\":1}}],[\"required\",{\"1\":{\"344\":2,\"348\":1,\"354\":1}}],[\"rebase\",{\"1\":{\"314\":2,\"325\":2}}],[\"repo\",{\"1\":{\"311\":2,\"331\":4,\"334\":2,\"335\":1,\"336\":2}}],[\"repository\",{\"0\":{\"311\":1},\"1\":{\"311\":1}}],[\"remote\",{\"1\":{\"311\":6,\"373\":2}}],[\"removehelper\",{\"1\":{\"109\":4}}],[\"remove\",{\"1\":{\"12\":1,\"22\":1,\"60\":1,\"63\":1,\"65\":1,\"93\":5,\"311\":1,\"335\":1}}],[\"reference\",{\"1\":{\"275\":1}}],[\"ref\",{\"1\":{\"263\":1}}],[\"refined\",{\"1\":{\"150\":1}}],[\"relaxed\",{\"1\":{\"248\":1,\"250\":2,\"251\":5,\"252\":2}}],[\"release\",{\"1\":{\"242\":2,\"243\":1,\"248\":1,\"250\":3,\"251\":6,\"252\":3}}],[\"recurse\",{\"1\":{\"332\":2}}],[\"recursive\",{\"1\":{\"258\":2}}],[\"received状态\",{\"1\":{\"294\":1}}],[\"received\",{\"1\":{\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"292\":1,\"294\":1,\"295\":1}}],[\"rect\",{\"1\":{\"189\":1}}],[\"redcircle\",{\"1\":{\"151\":2}}],[\"redcolor\",{\"1\":{\"151\":1}}],[\"red\",{\"1\":{\"151\":3,\"277\":3}}],[\"redo\",{\"1\":{\"54\":1}}],[\"reallyasync\",{\"1\":{\"264\":1}}],[\"reached\",{\"1\":{\"245\":1}}],[\"react+redux\",{\"1\":{\"171\":1}}],[\"reader\",{\"1\":{\"239\":3}}],[\"ready\",{\"1\":{\"215\":1,\"240\":6}}],[\"read\",{\"1\":{\"145\":9,\"226\":1,\"231\":1,\"239\":1}}],[\"rear\",{\"1\":{\"43\":6,\"44\":9}}],[\"restartsec=3\",{\"1\":{\"382\":1}}],[\"restart=always\",{\"1\":{\"382\":1}}],[\"restart\",{\"1\":{\"382\":2}}],[\"reset\",{\"1\":{\"320\":4}}],[\"result\",{\"1\":{\"263\":1,\"303\":3}}],[\"responsibility\",{\"1\":{\"165\":1}}],[\"resize\",{\"1\":{\"63\":2}}],[\"res\",{\"1\":{\"15\":3,\"36\":3,\"43\":4,\"49\":4,\"264\":3}}],[\"return\",{\"1\":{\"10\":1,\"14\":2,\"15\":1,\"22\":1,\"23\":2,\"24\":2,\"43\":5,\"44\":7,\"49\":5,\"50\":5,\"60\":6,\"63\":6,\"65\":8,\"71\":1,\"91\":1,\"92\":2,\"93\":2,\"100\":2,\"102\":1,\"103\":1,\"106\":5,\"108\":3,\"109\":3,\"113\":1,\"139\":4,\"145\":7,\"151\":1,\"158\":3,\"161\":5,\"167\":8,\"193\":4,\"207\":1,\"220\":1,\"222\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":2,\"236\":1,\"238\":1,\"239\":1,\"240\":2,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"250\":5,\"251\":5,\"257\":3,\"258\":2,\"259\":1,\"260\":2,\"261\":1,\"262\":1,\"263\":3,\"264\":3,\"270\":2,\"271\":1,\"287\":3,\"303\":2,\"347\":1,\"362\":2}}],[\"ollama\",{\"1\":{\"382\":9}}],[\"ok\",{\"1\":{\"273\":3,\"274\":3,\"277\":1}}],[\"online\",{\"1\":{\"382\":1}}],[\"once保证函数在多线程环境下只调用一次\",{\"1\":{\"264\":1}}],[\"onceflag\",{\"1\":{\"261\":2}}],[\"once\",{\"1\":{\"261\":4,\"382\":1}}],[\"once来保证某一函数在多线程环境中只调用一次\",{\"1\":{\"261\":1}}],[\"once相关\",{\"0\":{\"261\":1},\"1\":{\"256\":1}}],[\"oneline\",{\"1\":{\"316\":3}}],[\"one\",{\"1\":{\"240\":1,\"273\":1}}],[\"op\",{\"1\":{\"361\":12,\"362\":4}}],[\"optimizer\",{\"1\":{\"271\":1}}],[\"options\",{\"1\":{\"300\":2,\"355\":2,\"370\":1}}],[\"option\",{\"1\":{\"189\":2,\"364\":3}}],[\"operator=\",{\"1\":{\"257\":1}}],[\"open\",{\"1\":{\"64\":1,\"222\":1,\"292\":2,\"382\":7}}],[\"over\",{\"1\":{\"382\":1}}],[\"override\",{\"1\":{\"133\":1,\"139\":2,\"145\":1,\"151\":4,\"158\":4,\"161\":8,\"167\":3,\"189\":1,\"193\":3,\"207\":1,\"361\":4,\"364\":4}}],[\"ovverride\",{\"1\":{\"145\":2}}],[\"other\",{\"1\":{\"139\":1,\"271\":3}}],[\"observer\",{\"1\":{\"131\":1,\"132\":2,\"363\":4}}],[\"object\",{\"1\":{\"36\":1,\"189\":1,\"193\":1}}],[\"ocp\",{\"1\":{\"126\":1}}],[\"org\",{\"1\":{\"369\":1}}],[\"organization\",{\"1\":{\"97\":1}}],[\"origins=\",{\"1\":{\"382\":1}}],[\"origin\",{\"1\":{\"311\":3,\"327\":1,\"328\":1,\"329\":1,\"334\":1}}],[\"origincounter\",{\"1\":{\"260\":1}}],[\"order\",{\"1\":{\"139\":7,\"243\":2,\"248\":3,\"250\":7,\"251\":15,\"252\":6}}],[\"or\",{\"1\":{\"93\":1}}],[\"of\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"97\":1,\"165\":1,\"343\":1,\"350\":1}}],[\"out\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"270\":3,\"271\":1,\"343\":1,\"350\":1}}],[\"o\",{\"1\":{\"10\":1,\"12\":1,\"15\":1,\"16\":1,\"21\":2,\"23\":2,\"25\":6,\"31\":1,\"32\":2,\"36\":9,\"41\":3,\"44\":2,\"47\":3,\"50\":1,\"51\":1,\"53\":1,\"58\":14,\"63\":2,\"69\":1,\"74\":1,\"75\":6,\"88\":1,\"91\":1,\"92\":1,\"93\":3,\"94\":1,\"95\":7,\"97\":3,\"112\":2,\"215\":1,\"216\":2,\"222\":1,\"370\":1}}],[\"在特定内存地址设置断点\",{\"1\":{\"374\":1}}],[\"在函数入口处设置断点\",{\"1\":{\"374\":1}}],[\"在另一个终端中启动\",{\"1\":{\"373\":1}}],[\"在当前目录linux\",{\"1\":{\"369\":1}}],[\"在构建目录中运行\",{\"1\":{\"351\":1}}],[\"在构造函数执行时会对虚表指针进行初始化\",{\"1\":{\"208\":1}}],[\"在构造函数中创建虚表并对虚表初始化\",{\"1\":{\"207\":1}}],[\"在构造子类对象时\",{\"1\":{\"207\":1}}],[\"在构造时\",{\"1\":{\"207\":1}}],[\"在你的项目中添加一个子模块\",{\"1\":{\"331\":1}}],[\"在一个空目录中运行\",{\"1\":{\"311\":1}}],[\"在一个复杂的系统运行环境下\",{\"1\":{\"18\":1}}],[\"在子进程中执行特定代码\",{\"1\":{\"304\":1}}],[\"在极少见的情况下\",{\"1\":{\"292\":1}}],[\"在tcp连接的生命周期中\",{\"1\":{\"292\":1}}],[\"在运行时对加密的字符串进行解密并返回\",{\"1\":{\"288\":1}}],[\"在我们的例子中\",{\"1\":{\"285\":1}}],[\"在没有返回值优化的情况下\",{\"1\":{\"270\":1}}],[\"在使用之前使用函数lock\",{\"1\":{\"269\":1}}],[\"在多任务操作系统中\",{\"1\":{\"225\":1}}],[\"在多次插入和删除操作后\",{\"1\":{\"97\":1}}],[\"在守护进程的主循环中执行具体任务\",{\"1\":{\"223\":1}}],[\"在实际开发中\",{\"1\":{\"220\":1}}],[\"在实际中\",{\"1\":{\"72\":1}}],[\"在系统中\",{\"1\":{\"219\":1}}],[\"在对象生命期仅仅运行一次\",{\"1\":{\"210\":1}}],[\"在调用构造函数时还不能确定对象的真实类型\",{\"1\":{\"210\":1}}],[\"在销毁一个对象时\",{\"1\":{\"209\":1}}],[\"在c++中\",{\"1\":{\"209\":1}}],[\"在class中用于声明类成员或函数\",{\"1\":{\"200\":1}}],[\"在编译时就构造完成\",{\"1\":{\"208\":1}}],[\"在自己的虚表中将此虚函数地址添加在后面\",{\"1\":{\"207\":1}}],[\"在派生类定义对象时\",{\"1\":{\"207\":1}}],[\"在派生类中重写该函数\",{\"1\":{\"207\":1}}],[\"在含有虚函数的类实例化对象时\",{\"1\":{\"207\":1}}],[\"在预编译时期会被完整替换\",{\"1\":{\"203\":1}}],[\"在申请\",{\"1\":{\"201\":1}}],[\"在视图中使用自定义委托\",{\"1\":{\"189\":1}}],[\"在这个示例中\",{\"1\":{\"181\":1}}],[\"在这种情况下\",{\"1\":{\"80\":1,\"97\":1}}],[\"在这种设定下\",{\"1\":{\"63\":1}}],[\"在复杂的场景下\",{\"1\":{\"180\":1}}],[\"在复杂的系统环境中\",{\"1\":{\"15\":1}}],[\"在代码的分离和维护性方面优于\",{\"1\":{\"177\":1}}],[\"在代码实现中\",{\"1\":{\"92\":1}}],[\"在某些场景下\",{\"1\":{\"336\":1}}],[\"在某些需要链式处理请求的场景中\",{\"1\":{\"168\":1}}],[\"在某些数据缓冲区的实现中\",{\"1\":{\"27\":1}}],[\"在日志框架中\",{\"1\":{\"168\":1}}],[\"在图形用户界面\",{\"1\":{\"168\":1}}],[\"在基类的函数前加上virtual关键字\",{\"1\":{\"207\":1}}],[\"在基础类上存在多维度功能的扩展\",{\"1\":{\"145\":1}}],[\"在基于链表的实现中\",{\"1\":{\"51\":1}}],[\"在基于数组的实现中\",{\"1\":{\"51\":1}}],[\"在插入或删除节点后\",{\"1\":{\"112\":1}}],[\"在需要频繁进行增删查改操作的场景中\",{\"1\":{\"97\":1}}],[\"在论文\",{\"1\":{\"97\":1}}],[\"在下图所示的完美二叉树中插入两个节点后\",{\"1\":{\"97\":1}}],[\"在理想情况下\",{\"1\":{\"95\":1}}],[\"在二叉搜索树的删除节点方法的基础上\",{\"1\":{\"109\":1}}],[\"在二叉搜索树中删除节点\",{\"1\":{\"93\":3}}],[\"在二叉搜索树中插入节点\",{\"1\":{\"92\":1}}],[\"在二叉树中插入与删除节点\",{\"1\":{\"83\":1}}],[\"在二叉树中插入与删除节点可以通过修改指针来实现\",{\"1\":{\"83\":1}}],[\"在二叉树中\",{\"1\":{\"79\":1,\"80\":1,\"83\":1}}],[\"在最佳结构和最差结构下\",{\"1\":{\"88\":1}}],[\"在中文社区中\",{\"1\":{\"85\":1}}],[\"在中间插入元素\",{\"1\":{\"32\":1}}],[\"在完美二叉树中\",{\"1\":{\"85\":1}}],[\"在扩容后可能会被分配到多个桶中\",{\"1\":{\"75\":1}}],[\"在扩容后\",{\"1\":{\"75\":1}}],[\"在密码学中\",{\"1\":{\"74\":1}}],[\"在许多编程语言中\",{\"1\":{\"73\":1}}],[\"在随机输入\",{\"1\":{\"70\":1}}],[\"在相同的哈希函数顺序下进行查找\",{\"1\":{\"67\":1}}],[\"在该位置插入节点\",{\"1\":{\"92\":1}}],[\"在该机制下\",{\"1\":{\"65\":1}}],[\"在该方案中\",{\"1\":{\"27\":1}}],[\"在开放寻址中删除元素导致的查询问题\",{\"1\":{\"65\":1}}],[\"在原始哈希表中\",{\"1\":{\"63\":1}}],[\"在哈希表中访问对应的桶\",{\"1\":{\"60\":1}}],[\"在哈希表中\",{\"1\":{\"60\":2,\"74\":1}}],[\"在哈希表中删除键值对\",{\"1\":{\"59\":1}}],[\"在哈希表中添加键值对\",{\"1\":{\"59\":1}}],[\"在哈希表中进行增删查改的时间复杂度都是\",{\"1\":{\"58\":1}}],[\"在出栈后\",{\"1\":{\"54\":1}}],[\"在时间效率和空间效率的对比上\",{\"1\":{\"53\":1}}],[\"在时间效率方面\",{\"1\":{\"53\":1}}],[\"在空间效率方面\",{\"1\":{\"53\":1}}],[\"在递归函数中\",{\"1\":{\"52\":1}}],[\"在初始化列表时\",{\"1\":{\"51\":1}}],[\"在此基础上\",{\"1\":{\"357\":1}}],[\"在此处执行需要守护的任务\",{\"1\":{\"220\":1}}],[\"在此\",{\"1\":{\"47\":1}}],[\"在此不再赘述\",{\"1\":{\"44\":1,\"110\":1}}],[\"在双十一期间\",{\"1\":{\"45\":1}}],[\"在越过数组尾部时\",{\"1\":{\"44\":1}}],[\"在不断进行入队和出队的过程中\",{\"1\":{\"44\":1}}],[\"在尾节点后添加\",{\"1\":{\"43\":1}}],[\"在尾部添加元素\",{\"1\":{\"32\":1}}],[\"在列表末尾添加元素是否时时刻刻都为\",{\"1\":{\"36\":1}}],[\"在列表尾部添加元素的时间复杂度为\",{\"1\":{\"32\":1}}],[\"在选择数据结构时\",{\"1\":{\"35\":1}}],[\"在本示例中\",{\"1\":{\"34\":2}}],[\"在索引\",{\"1\":{\"32\":1}}],[\"在接下来的讨论中\",{\"1\":{\"28\":1}}],[\"在操作系统中\",{\"1\":{\"27\":1}}],[\"在缓存淘汰\",{\"1\":{\"27\":1}}],[\"在网页浏览器中\",{\"1\":{\"27\":1}}],[\"在环形链表中\",{\"1\":{\"26\":1}}],[\"在链表中插入和删除操作的时间复杂度是\",{\"1\":{\"36\":1}}],[\"在链表中插入节点非常容易\",{\"1\":{\"21\":1}}],[\"在链表中查找值为\",{\"1\":{\"24\":1}}],[\"在链表中访问节点的效率较低\",{\"1\":{\"23\":1}}],[\"在链表中删除节点也非常方便\",{\"1\":{\"22\":1}}],[\"在链表的节点\",{\"1\":{\"21\":1}}],[\"在大数据量下的效率较低\",{\"1\":{\"21\":1}}],[\"在大多数编程语言中\",{\"1\":{\"13\":1}}],[\"在\",{\"1\":{\"18\":1,\"36\":1,\"54\":1,\"73\":1,\"75\":1,\"83\":1,\"97\":1,\"108\":1,\"113\":3,\"191\":1,\"221\":1,\"251\":1,\"347\":1,\"373\":1}}],[\"在数组很大的情况下非常耗时\",{\"1\":{\"15\":1}}],[\"在数组中删除首元素的时间复杂度为\",{\"1\":{\"44\":1}}],[\"在数组中插入元素的时间复杂度为\",{\"1\":{\"21\":1}}],[\"在数组中查找指定元素\",{\"1\":{\"14\":1}}],[\"在数组中查找指定元素需要遍历数组\",{\"1\":{\"14\":1}}],[\"在数组中访问元素非常高效\",{\"1\":{\"10\":1}}],[\"在数组的索引\",{\"1\":{\"11\":1}}],[\"在区间\",{\"1\":{\"10\":1}}],[\"在未指定初始值的情况下\",{\"1\":{\"9\":1}}],[\"是最常用的版本控制工具之一\",{\"1\":{\"309\":1}}],[\"是最安全的哈希算法之一\",{\"1\":{\"72\":1}}],[\"是因为我们不需要同步其他内存操作\",{\"1\":{\"251\":1}}],[\"是操作系统提供的功能\",{\"1\":{\"225\":1}}],[\"是在大型项目或多仓库项目中非常有用的功能\",{\"1\":{\"338\":1}}],[\"是在\",{\"1\":{\"218\":1}}],[\"是内存地址偏移一个元素的位置\",{\"1\":{\"202\":1}}],[\"是c++\",{\"1\":{\"201\":1}}],[\"是c语言标准库提供的一组用于动态申请释放内存的api\",{\"1\":{\"201\":1}}],[\"是\",{\"1\":{\"189\":1,\"266\":1,\"285\":1,\"299\":1}}],[\"是用户与数据进行交互的界面部分\",{\"1\":{\"188\":1}}],[\"是用户界面\",{\"1\":{\"174\":1}}],[\"是数据的抽象表示\",{\"1\":{\"187\":1}}],[\"是负责视图与模型之间通信的中介\",{\"1\":{\"177\":1}}],[\"是访问节点高度\",{\"1\":{\"113\":1}}],[\"是没有意义的\",{\"1\":{\"113\":1}}],[\"是的\",{\"1\":{\"113\":3}}],[\"是指从该节点到它的最远叶节点的距离\",{\"1\":{\"99\":1}}],[\"是随机均匀分布的\",{\"1\":{\"71\":1}}],[\"是两个独立的概念\",{\"1\":{\"70\":1}}],[\"是哈希表的一个重要概念\",{\"1\":{\"61\":1}}],[\"是乱序的\",{\"1\":{\"58\":1}}],[\"是否需要释放出栈节点的内存\",{\"1\":{\"54\":1}}],[\"是否需要把\",{\"1\":{\"36\":1}}],[\"是不是因为有什么局限性呢\",{\"1\":{\"36\":1}}],[\"是一个非常灵活和强大的构建工具\",{\"1\":{\"357\":1}}],[\"是一个非常有用的功能\",{\"1\":{\"330\":1}}],[\"是一个跨平台的构建系统生成工具\",{\"1\":{\"341\":1}}],[\"是一个强大的系统调用\",{\"1\":{\"306\":1}}],[\"是一个抽象的数据结构概念\",{\"1\":{\"28\":1}}],[\"是一种在多线程环境中实现并发访问的技术\",{\"1\":{\"247\":1}}],[\"是一种在后台运行的进程\",{\"1\":{\"221\":1}}],[\"是一种典型的\",{\"1\":{\"181\":1}}],[\"是一种常用于前端开发中的架构模式\",{\"1\":{\"171\":1}}],[\"是一种行为设计模式\",{\"1\":{\"165\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"131\":1,\"137\":1}}],[\"是一种结构型设计模式\",{\"1\":{\"143\":1,\"149\":1}}],[\"是一种形象化的说法\",{\"1\":{\"102\":1}}],[\"是一种非线性数据结构\",{\"1\":{\"79\":1}}],[\"是一种遵循先入后出逻辑的线性数据结构\",{\"1\":{\"46\":1}}],[\"是一种遵循先入先出规则的线性数据结构\",{\"1\":{\"40\":1}}],[\"是一种线性数据结构\",{\"1\":{\"7\":1,\"18\":1}}],[\"是合理的\",{\"1\":{\"10\":1}}],[\"因请求资源阻塞时\",{\"1\":{\"246\":1}}],[\"因而只会调用基类的析构函数\",{\"1\":{\"210\":1}}],[\"因而构造函数不可能成为虚函数从实际含义上看\",{\"1\":{\"210\":1}}],[\"因为编译器知道要返回的对象将要被销毁\",{\"1\":{\"268\":1}}],[\"因为不是本文的主题\",{\"1\":{\"262\":1}}],[\"因为条件变量在wait时需要有手动释放锁的能力\",{\"1\":{\"259\":1}}],[\"因为构造函数本来就是为了明确初始化对象成员才产生的\",{\"1\":{\"210\":1}}],[\"因为父类对象会在子类之前进行构造\",{\"1\":{\"209\":1}}],[\"因为高度和深度通常定义为\",{\"1\":{\"113\":1}}],[\"因为质数不与其他数字存在公约数\",{\"1\":{\"71\":1}}],[\"因为线性探测可能需要跳过多个\",{\"1\":{\"65\":1}}],[\"因为其之下可能还存在键值对\",{\"1\":{\"65\":1}}],[\"因为需要线性遍历链表来查找对应元素\",{\"1\":{\"63\":1}}],[\"因为哈希表扩容需要进行大量的数据搬运与哈希值计算\",{\"1\":{\"62\":1}}],[\"因为数组中包含了两种\",{\"1\":{\"36\":1}}],[\"因为数组是线性数据结构\",{\"1\":{\"14\":1}}],[\"因为从\",{\"1\":{\"10\":1}}],[\"因此也就规定构造函数不能是虚函数\",{\"1\":{\"210\":1}}],[\"因此也可以用\",{\"1\":{\"113\":1}}],[\"因此调用子类的虚函数时不安全的\",{\"1\":{\"209\":1}}],[\"因此最有可能存在全局数据区\",{\"1\":{\"208\":1}}],[\"因此设置成\",{\"1\":{\"113\":1}}],[\"因此是一种平衡二叉搜索树\",{\"1\":{\"98\":1}}],[\"因此这个节点可以是右子树的最小节点或左子树的最大节点\",{\"1\":{\"93\":1}}],[\"因此执行\",{\"1\":{\"91\":2}}],[\"因此哈希函数的最后一步往往是对数组长度取模\",{\"1\":{\"75\":1}}],[\"因此常用在各类安全应用与协议中\",{\"1\":{\"72\":1}}],[\"因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串\",{\"1\":{\"72\":1}}],[\"因此输出的哈希值的均匀性会明显提升\",{\"1\":{\"71\":1}}],[\"因此理论上哈希冲突是不可避免的\",{\"1\":{\"62\":1}}],[\"因此需要遍历其中的所有元素\",{\"1\":{\"58\":1}}],[\"因此可以通过扩容哈希表来缓解哈希冲突\",{\"1\":{\"74\":1}}],[\"因此可以实现栈与队列的所有应用\",{\"1\":{\"54\":1}}],[\"因此可以在\",{\"1\":{\"31\":1}}],[\"因此不需要手动释放内存\",{\"1\":{\"54\":1}}],[\"因此链表节点占用的空间相对较大\",{\"1\":{\"51\":1}}],[\"因此平均效率更高\",{\"1\":{\"51\":1}}],[\"因此效率相对较低\",{\"1\":{\"51\":1}}],[\"因此效率较高\",{\"1\":{\"51\":1}}],[\"因此一般不会用到\",{\"1\":{\"51\":1}}],[\"因此我们只要按照\",{\"1\":{\"113\":1}}],[\"因此我们只能在栈顶添加或删除元素\",{\"1\":{\"48\":1}}],[\"因此我们需要为节点类添加\",{\"1\":{\"99\":1}}],[\"因此我们可以很容易地从哈希值反推出可用的\",{\"1\":{\"70\":1}}],[\"因此我们可以使用动态数组\",{\"1\":{\"50\":1}}],[\"因此栈可以视为一种受限制的数组或链表\",{\"1\":{\"48\":1}}],[\"因此堆更加适合存储大型数组\",{\"1\":{\"36\":1}}],[\"因此\",{\"1\":{\"36\":3,\"51\":1,\"60\":1,\"61\":2,\"75\":1,\"83\":1,\"92\":1,\"93\":1,\"108\":1,\"113\":1,\"210\":1,\"225\":1}}],[\"因此它们被各类安全应用弃用\",{\"1\":{\"72\":1}}],[\"因此它通常比链表更高效\",{\"1\":{\"35\":1}}],[\"因此它的索引为\",{\"1\":{\"10\":1}}],[\"因此只能看作一个具有长度限制的列表\",{\"1\":{\"28\":1}}],[\"因此各种性质和操作效率也呈现对立的特点\",{\"1\":{\"25\":1}}],[\"因此在高并发场景下具有更好的性能\",{\"1\":{\"241\":1}}],[\"因此在应用时需要根据具体情况权衡\",{\"1\":{\"182\":1}}],[\"因此在该空桶之下的元素都无法再被访问到\",{\"1\":{\"65\":1}}],[\"因此在相同数据量下\",{\"1\":{\"18\":1}}],[\"因此在大多数编程语言中\",{\"1\":{\"15\":1}}],[\"因此在插入元素后\",{\"1\":{\"12\":1}}],[\"因此插入一个元素必定会导致数组尾部元素\",{\"1\":{\"11\":1}}],[\"这会生成一个适合当前平台的构建系统文件\",{\"1\":{\"351\":1}}],[\"这会将\",{\"1\":{\"331\":1}}],[\"这会导致出队操作效率较低\",{\"1\":{\"44\":1}}],[\"这对于需要将多个项目组合在一起的场景非常实用\",{\"1\":{\"330\":1}}],[\"这两个unique\",{\"1\":{\"268\":1}}],[\"这两种模式都可以提高代码的灵活性和可维护性\",{\"1\":{\"161\":1}}],[\"这两种初始化方法\",{\"1\":{\"30\":1}}],[\"这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由\",{\"1\":{\"210\":1}}],[\"这就代表有哈希冲突\",{\"1\":{\"75\":1}}],[\"这大家都知道\",{\"1\":{\"210\":1}}],[\"这与微软的编译器将虚函数表存放在常量段存在一些差别\",{\"1\":{\"208\":1}}],[\"这与数组等价\",{\"1\":{\"75\":1}}],[\"这里会以cppreference为主\",{\"1\":{\"264\":1}}],[\"这里暂不介绍\",{\"1\":{\"262\":1}}],[\"这里使用条件变量实现一个countdownlatch\",{\"1\":{\"262\":1}}],[\"这里主要介绍两种raii方式的锁封装\",{\"1\":{\"259\":1}}],[\"这里可以对thread进行封装\",{\"1\":{\"257\":1}}],[\"这里按照如下顺序介绍\",{\"1\":{\"256\":1}}],[\"这里需要注意\",{\"1\":{\"236\":1,\"257\":1}}],[\"这里需要引出虚表和虚基表指针的概念\",{\"1\":{\"207\":1}}],[\"这里有两种解决办法\",{\"1\":{\"236\":1,\"257\":1}}],[\"这里的锁就是上面介绍的std\",{\"1\":{\"262\":1}}],[\"这里的\",{\"1\":{\"113\":1}}],[\"这里的空间浪费主要有两方面含义\",{\"1\":{\"36\":1}}],[\"这里的空间浪费是指额外增加的变量如容量\",{\"1\":{\"36\":1}}],[\"这3者的区别\",{\"0\":{\"202\":1}}],[\"这使得\",{\"1\":{\"177\":1}}],[\"这三部分通过数据绑定\",{\"1\":{\"172\":1}}],[\"这三个哈希值\",{\"1\":{\"71\":1}}],[\"这方面有什么考量吗\",{\"1\":{\"113\":1}}],[\"这棵二叉搜索树便会退化为链表\",{\"1\":{\"97\":1}}],[\"这可能会加剧哈希冲突\",{\"1\":{\"72\":1}}],[\"这可以通过在节点中保存一个指向父节点的引用来实现\",{\"1\":{\"27\":1}}],[\"这进一步增加了扩容过程的计算开销\",{\"1\":{\"61\":1}}],[\"这显然是不对的\",{\"1\":{\"61\":1}}],[\"这时可能会发生错误\",{\"1\":{\"257\":1}}],[\"这时可能会发生crash\",{\"1\":{\"236\":1}}],[\"这时需要特别注意权限管理\",{\"1\":{\"224\":1}}],[\"这时各种操作的时间复杂度也会退化为\",{\"1\":{\"95\":1}}],[\"这时我们可以将该语言的\",{\"1\":{\"47\":1}}],[\"这时候假设析构函数不是虚函数\",{\"1\":{\"210\":1}}],[\"这时候时间复杂度就会是\",{\"1\":{\"36\":1}}],[\"这时候使用双向链表就非常合适\",{\"1\":{\"27\":1}}],[\"这个是正常的数据传输状态\",{\"1\":{\"292\":1}}],[\"这个状态通常由服务器处于被动打开\",{\"1\":{\"292\":1}}],[\"这个操作是原子的\",{\"1\":{\"248\":1}}],[\"这个构造函数又将设置vptr指向它的\",{\"1\":{\"210\":1}}],[\"这个时候再调用子类的虚函数没有任何意义\",{\"1\":{\"209\":1}}],[\"这个示例模拟了请假请求根据天数由不同级别的领导审批的场景\",{\"1\":{\"167\":1}}],[\"这个模式主要包括以下几个部分\",{\"1\":{\"166\":1}}],[\"这个类是装饰器模式的核心\",{\"1\":{\"144\":1}}],[\"这个在\",{\"1\":{\"54\":1}}],[\"这个问题不难解决\",{\"1\":{\"44\":1}}],[\"这个公式计算出的\",{\"1\":{\"44\":1}}],[\"这些子模块的操作与普通子模块类似\",{\"1\":{\"337\":1}}],[\"这些指令能够确保在多个线程操作同一数据时不会产生竞争条件\",{\"1\":{\"241\":1}}],[\"这些操作会通过委托发送到\",{\"1\":{\"190\":1}}],[\"这些连续位置发生哈希冲突的可能性越大\",{\"1\":{\"65\":1}}],[\"这些元素的地址不连续\",{\"1\":{\"36\":1}}],[\"这些数据都是以数组的形式构建的\",{\"1\":{\"17\":1}}],[\"这\",{\"1\":{\"36\":1}}],[\"这样会导致\",{\"1\":{\"372\":1}}],[\"这样两个指针指向的内存都无法释放\",{\"1\":{\"269\":1}}],[\"这样指向派生类的基类指针在运行时\",{\"1\":{\"207\":1}}],[\"这样\",{\"1\":{\"204\":1,\"286\":1}}],[\"这样当\",{\"1\":{\"176\":1}}],[\"这样在遍历至\",{\"1\":{\"92\":1}}],[\"这样在插入数据时\",{\"1\":{\"12\":1}}],[\"这样做可以最大程度保证树的平衡性\",{\"1\":{\"113\":1}}],[\"这样做既能保持哈希表的探测序列不变\",{\"1\":{\"75\":1}}],[\"这样做的好处是当每次查询或添加元素时\",{\"1\":{\"65\":1}}],[\"这样就可以解决c代码调用c++\",{\"1\":{\"204\":1}}],[\"这样就可以在\",{\"1\":{\"95\":1}}],[\"这样就不会有冲突了\",{\"1\":{\"75\":1}}],[\"这样就无须自行处理数组扩容问题\",{\"1\":{\"50\":1}}],[\"这样才能确保哈希表是可靠的\",{\"1\":{\"70\":1}}],[\"这样才能通过计算偏移量来获取对应元素位置\",{\"1\":{\"36\":1}}],[\"这样我们就可以通过后退操作回到上一个网页\",{\"1\":{\"52\":1}}],[\"这样一来\",{\"1\":{\"36\":1}}],[\"这是无锁编程的核心操作之一\",{\"1\":{\"248\":1}}],[\"这是为了允许父进程能够获取子进程的退出状态\",{\"1\":{\"218\":1}}],[\"这是通过哈希函数\",{\"1\":{\"60\":1}}],[\"这是因为哈希函数计算需要开销\",{\"1\":{\"75\":1}}],[\"这是因为\",{\"1\":{\"73\":1}}],[\"这是因为对象的哈希值通常是基于内存地址生成的\",{\"1\":{\"73\":1}}],[\"这是因为每次删除操作都会产生一个删除标记\",{\"1\":{\"65\":1}}],[\"这是因为删除元素会在数组内产生一个空桶\",{\"1\":{\"65\":1}}],[\"这是因为数组中存储的是节点的引用\",{\"1\":{\"36\":1}}],[\"这是因为我们通常无法事先确定需要存储多少数据\",{\"1\":{\"28\":1}}],[\"这是一个有趣的问题\",{\"1\":{\"71\":1}}],[\"这是一个\",{\"1\":{\"15\":1}}],[\"这种方式也可以\",{\"1\":{\"260\":1}}],[\"这种模式使得我们可以在不改变原始类代码的情况下\",{\"1\":{\"143\":1}}],[\"这种现象被称为哈希冲突\",{\"1\":{\"74\":1}}],[\"这种做法可以有效防止\",{\"1\":{\"73\":1}}],[\"这种做法包含丰富的先验信息\",{\"1\":{\"16\":1}}],[\"这种节点插入方法被称为\",{\"1\":{\"49\":1}}],[\"这种周期性规律可以通过\",{\"1\":{\"44\":1}}],[\"这种循环操作可以通过环形链表来实现\",{\"1\":{\"27\":1}}],[\"这意味着某些计算可以在编译时完成\",{\"1\":{\"285\":1}}],[\"这意味着在二叉搜索树中进行中序遍历时\",{\"1\":{\"94\":1}}],[\"这意味着即使哈希表中有空桶\",{\"1\":{\"66\":1}}],[\"这意味着节点\",{\"1\":{\"36\":1}}],[\"这意味着\",{\"1\":{\"22\":1,\"69\":1}}],[\"这意味着计算数组元素的内存地址非常容易\",{\"1\":{\"10\":1}}],[\"这似乎有些反直觉\",{\"1\":{\"10\":1}}],[\"观察模型\",{\"1\":{\"177\":1}}],[\"观察者\",{\"1\":{\"132\":1}}],[\"观察者模式非常适用于需要动态更新和通知机制的场景\",{\"1\":{\"133\":1}}],[\"观察者模式提供了一种将对象之间的依赖关系解耦的方式\",{\"1\":{\"133\":1}}],[\"观察者模式主要涉及以下几个角色\",{\"1\":{\"132\":1}}],[\"观察者模式通常用于事件驱动的系统\",{\"1\":{\"131\":1}}],[\"观察者模式\",{\"0\":{\"130\":1},\"1\":{\"3\":1,\"131\":1,\"133\":1},\"2\":{\"135\":1}}],[\"观察下表\",{\"1\":{\"95\":1}}],[\"观察以上公式\",{\"1\":{\"69\":1}}],[\"观察发现\",{\"1\":{\"58\":1,\"71\":1}}],[\"观察上图\",{\"1\":{\"10\":1,\"18\":1}}],[\"首先整理一下虚函数表的特征\",{\"1\":{\"208\":1}}],[\"首先初始化节点\",{\"1\":{\"82\":1}}],[\"首先\",{\"1\":{\"75\":1}}],[\"首先通过哈希函数访问链表头节点\",{\"1\":{\"63\":1}}],[\"首尾相接\",{\"1\":{\"26\":1}}],[\"首个元素的地址偏移量是\",{\"1\":{\"10\":1}}],[\"首元素内存地址\",{\"1\":{\"10\":1,\"36\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"给定一组数据\",{\"1\":{\"95\":1}}],[\"给定一个待插入元素\",{\"1\":{\"92\":1}}],[\"给定一个列表索引\",{\"1\":{\"36\":1}}],[\"给定目标节点值\",{\"1\":{\"91\":1}}],[\"给定\",{\"1\":{\"58\":1}}],[\"给定数组内存地址\",{\"1\":{\"10\":1}}],[\"给定初始值\",{\"1\":{\"9\":1}}],[\"nproc\",{\"1\":{\"369\":1}}],[\"npm\",{\"1\":{\"181\":1}}],[\"ninja\",{\"1\":{\"341\":1,\"343\":1,\"352\":3,\"357\":2}}],[\"native\",{\"1\":{\"257\":2}}],[\"named\",{\"1\":{\"226\":1}}],[\"namespace\",{\"1\":{\"207\":1,\"257\":1,\"258\":2,\"259\":1,\"263\":2,\"264\":1,\"270\":1,\"271\":1}}],[\"name\",{\"1\":{\"59\":1,\"181\":7,\"187\":1,\"271\":4,\"323\":2,\"382\":1}}],[\"n=7\",{\"1\":{\"113\":1}}],[\"n−1\",{\"1\":{\"88\":1}}],[\"n+1\",{\"1\":{\"88\":1,\"113\":1}}],[\"n5\",{\"1\":{\"36\":1,\"82\":2}}],[\"n4\",{\"1\":{\"20\":2,\"36\":1,\"82\":2}}],[\"n3\",{\"1\":{\"20\":3,\"36\":1,\"82\":2}}],[\"n2\",{\"1\":{\"20\":3,\"36\":1,\"82\":4,\"83\":3}}],[\"n1\",{\"1\":{\"20\":3,\"21\":3,\"22\":4,\"36\":1,\"82\":3,\"83\":3}}],[\"n0\",{\"1\":{\"20\":3,\"21\":5,\"22\":6}}],[\"net\",{\"1\":{\"181\":1,\"370\":1}}],[\"networkstream\",{\"1\":{\"145\":2}}],[\"nexttail\",{\"1\":{\"250\":3,\"251\":7,\"252\":1}}],[\"nexthandler\",{\"1\":{\"167\":8}}],[\"next\",{\"1\":{\"18\":2,\"20\":1,\"26\":2,\"36\":2,\"373\":1,\"374\":1}}],[\"newcounter\",{\"1\":{\"260\":1}}],[\"new的区别\",{\"0\":{\"201\":1}}],[\"new\",{\"0\":{\"201\":1},\"1\":{\"9\":2,\"15\":1,\"20\":5,\"43\":1,\"44\":1,\"49\":1,\"60\":1,\"63\":1,\"65\":2,\"82\":5,\"83\":1,\"92\":2,\"108\":1,\"139\":2,\"145\":4,\"181\":1,\"187\":3,\"188\":1,\"189\":1,\"194\":1,\"201\":3,\"207\":2,\"215\":1,\"222\":1,\"231\":3,\"236\":2,\"250\":1,\"251\":1,\"314\":1,\"362\":2,\"364\":2}}],[\"not\",{\"1\":{\"383\":1}}],[\"notifyobservers\",{\"1\":{\"363\":2}}],[\"notify\",{\"1\":{\"240\":4,\"262\":1}}],[\"nographic\",{\"1\":{\"372\":2}}],[\"nokaslr\",{\"1\":{\"372\":3}}],[\"normal\",{\"1\":{\"370\":1}}],[\"no\",{\"1\":{\"246\":1,\"273\":1,\"277\":1,\"370\":1}}],[\"now\",{\"1\":{\"236\":1}}],[\"nodiscount\",{\"1\":{\"139\":2}}],[\"node\",{\"1\":{\"18\":1,\"43\":9,\"49\":7,\"79\":3,\"80\":2,\"92\":3,\"99\":4,\"100\":4,\"102\":8,\"103\":7,\"104\":1,\"105\":1,\"106\":14,\"108\":13,\"109\":26,\"113\":3}}],[\"none\",{\"1\":{\"18\":1,\"26\":1,\"36\":1,\"65\":3,\"67\":1,\"80\":1,\"92\":3,\"370\":4}}],[\"nullptr\",{\"1\":{\"18\":2,\"22\":1,\"23\":2,\"24\":1,\"26\":2,\"43\":3,\"49\":1,\"60\":6,\"65\":10,\"79\":2,\"91\":1,\"92\":3,\"93\":9,\"100\":1,\"108\":1,\"109\":8,\"133\":1,\"145\":2,\"167\":3,\"189\":1,\"193\":1,\"361\":1,\"364\":1}}],[\"null\",{\"1\":{\"18\":1,\"207\":1,\"220\":3,\"222\":2,\"223\":1,\"227\":1,\"228\":2,\"229\":1,\"231\":2}}],[\"num\",{\"1\":{\"11\":4,\"31\":1,\"33\":2,\"43\":5,\"44\":5,\"49\":4,\"50\":4,\"73\":2,\"91\":8,\"92\":9,\"93\":3}}],[\"nums1\",{\"1\":{\"9\":1,\"30\":1}}],[\"nums\",{\"1\":{\"9\":1,\"10\":2,\"11\":4,\"12\":3,\"13\":2,\"14\":2,\"15\":3,\"20\":3,\"30\":2,\"31\":2,\"32\":10,\"33\":3,\"44\":6}}],[\"n\",{\"1\":{\"12\":2,\"15\":1,\"21\":1,\"23\":1,\"25\":3,\"32\":1,\"36\":7,\"44\":1,\"51\":1,\"53\":1,\"58\":7,\"61\":1,\"63\":2,\"69\":1,\"75\":5,\"88\":2,\"94\":1,\"95\":3,\"97\":1,\"112\":1,\"230\":2,\"236\":2,\"277\":8}}],[\"404\",{\"1\":{\"383\":1}}],[\"42\",{\"1\":{\"303\":1}}],[\"4=2h=\",{\"1\":{\"113\":1}}],[\"4614256650576692846\",{\"1\":{\"73\":1}}],[\"4\",{\"0\":{\"203\":1,\"229\":1,\"251\":1,\"316\":1,\"325\":1,\"334\":1,\"345\":1,\"346\":1,\"347\":1,\"348\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":1,\"36\":2,\"41\":1,\"47\":1,\"63\":1,\"65\":1,\"66\":1,\"71\":2,\"79\":2,\"82\":1,\"207\":1,\"210\":1,\"222\":1,\"271\":3,\"275\":1,\"368\":2}}],[\"22\",{\"1\":{\"368\":1}}],[\"224\",{\"1\":{\"72\":1}}],[\"25\",{\"1\":{\"187\":1}}],[\"256\",{\"1\":{\"72\":3}}],[\"2h\",{\"1\":{\"88\":1,\"113\":1}}],[\"2h+1−1\",{\"1\":{\"85\":1,\"88\":1}}],[\"2i−1\",{\"1\":{\"88\":1}}],[\"20\",{\"1\":{\"250\":2,\"251\":2,\"257\":1,\"277\":1}}],[\"200\",{\"1\":{\"258\":3,\"259\":1}}],[\"2005\",{\"1\":{\"171\":1}}],[\"2008\",{\"1\":{\"72\":1}}],[\"2002\",{\"1\":{\"72\":1}}],[\"20336\",{\"1\":{\"61\":2}}],[\"27\",{\"1\":{\"71\":2}}],[\"24\",{\"1\":{\"71\":2}}],[\"21\",{\"1\":{\"71\":2,\"277\":2}}],[\"28\",{\"1\":{\"71\":1}}],[\"236\",{\"1\":{\"61\":1}}],[\"2\",{\"0\":{\"174\":1,\"201\":1,\"227\":1,\"249\":1,\"314\":1,\"323\":1,\"328\":1,\"332\":1,\"343\":1,\"347\":1,\"351\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":1,\"34\":1,\"36\":2,\"41\":1,\"47\":1,\"51\":1,\"61\":1,\"63\":3,\"65\":2,\"71\":1,\"72\":6,\"74\":2,\"79\":1,\"80\":1,\"82\":1,\"85\":1,\"93\":4,\"108\":1,\"109\":2,\"113\":1,\"167\":2,\"181\":1,\"193\":1,\"207\":1,\"210\":1,\"222\":2,\"226\":1,\"229\":2,\"239\":1,\"246\":1,\"273\":1,\"275\":1,\"292\":1,\"295\":1,\"303\":1,\"368\":1}}],[\"384\",{\"1\":{\"72\":1}}],[\"33\",{\"1\":{\"71\":2}}],[\"3000\",{\"1\":{\"382\":2}}],[\"30\",{\"1\":{\"71\":2}}],[\"32​\",{\"1\":{\"63\":1}}],[\"36\",{\"1\":{\"61\":2,\"370\":4,\"372\":2}}],[\"3\",{\"0\":{\"175\":1,\"202\":1,\"228\":1,\"250\":1,\"315\":1,\"324\":1,\"329\":1,\"333\":1,\"344\":1,\"348\":1,\"352\":1},\"1\":{\"9\":2,\"20\":2,\"30\":1,\"32\":5,\"36\":3,\"41\":1,\"47\":1,\"63\":1,\"65\":1,\"71\":10,\"72\":3,\"73\":5,\"74\":1,\"82\":1,\"102\":1,\"104\":1,\"167\":2,\"193\":2,\"207\":1,\"210\":1,\"222\":1,\"231\":1,\"275\":1,\"344\":1,\"348\":1,\"368\":1}}],[\"1ubuntu1~22\",{\"1\":{\"368\":1}}],[\"1状态\",{\"1\":{\"294\":1}}],[\"144\",{\"1\":{\"263\":1}}],[\"14159\",{\"1\":{\"73\":2}}],[\"1962\",{\"1\":{\"97\":1}}],[\"1995\",{\"1\":{\"72\":1}}],[\"1992\",{\"1\":{\"72\":1}}],[\"160\",{\"1\":{\"72\":1}}],[\"16750\",{\"1\":{\"59\":1}}],[\"18\",{\"1\":{\"71\":2}}],[\"15466937326284535026\",{\"1\":{\"73\":1}}],[\"15\",{\"1\":{\"71\":2}}],[\"15937\",{\"1\":{\"59\":2}}],[\"1234\",{\"1\":{\"372\":1,\"373\":1}}],[\"127\",{\"1\":{\"231\":1}}],[\"128\",{\"1\":{\"72\":1,\"226\":1}}],[\"12836\",{\"1\":{\"59\":1,\"61\":2}}],[\"12\",{\"1\":{\"71\":3,\"368\":2}}],[\"13\",{\"1\":{\"71\":1}}],[\"136\",{\"1\":{\"61\":1}}],[\"13276\",{\"1\":{\"59\":1}}],[\"1024\",{\"1\":{\"228\":1,\"231\":1}}],[\"1000\",{\"1\":{\"241\":1,\"370\":1}}],[\"1000000007\",{\"1\":{\"71\":2}}],[\"100\",{\"1\":{\"60\":5,\"61\":2,\"70\":1,\"133\":3,\"139\":2,\"227\":1}}],[\"10583\",{\"1\":{\"59\":2}}],[\"10\",{\"0\":{\"202\":1,\"357\":1},\"1\":{\"34\":1,\"167\":2,\"202\":1,\"222\":1,\"238\":2,\"240\":2,\"241\":2,\"242\":2,\"243\":2,\"244\":2,\"245\":2,\"250\":1,\"251\":2,\"257\":2,\"344\":1,\"348\":1,\"369\":5,\"372\":2}}],[\"1\",{\"0\":{\"173\":1,\"200\":1,\"226\":1,\"248\":1,\"313\":1,\"322\":1,\"327\":1,\"331\":1,\"342\":1,\"346\":1,\"350\":1},\"1\":{\"9\":2,\"10\":2,\"11\":2,\"12\":2,\"14\":1,\"16\":1,\"20\":3,\"21\":1,\"23\":1,\"24\":1,\"25\":3,\"30\":1,\"31\":5,\"32\":2,\"36\":7,\"41\":4,\"44\":7,\"47\":4,\"49\":1,\"50\":1,\"58\":8,\"65\":8,\"66\":1,\"68\":1,\"71\":1,\"72\":3,\"73\":2,\"74\":2,\"75\":3,\"80\":3,\"82\":1,\"87\":1,\"88\":2,\"89\":1,\"93\":5,\"95\":1,\"99\":2,\"106\":2,\"108\":1,\"109\":2,\"193\":1,\"202\":1,\"207\":1,\"210\":1,\"220\":2,\"222\":2,\"226\":4,\"227\":2,\"229\":6,\"230\":1,\"231\":1,\"239\":1,\"240\":1,\"242\":4,\"243\":1,\"244\":1,\"245\":1,\"246\":1,\"250\":2,\"251\":4,\"257\":1,\"263\":1,\"264\":1,\"273\":2,\"275\":1,\"287\":4,\"292\":1,\"294\":1,\"295\":1,\"300\":2,\"301\":1,\"303\":1,\"344\":1,\"368\":2,\"370\":8,\"372\":4,\"382\":1}}],[\"11434\",{\"1\":{\"382\":1}}],[\"11\",{\"1\":{\"1\":1,\"71\":1,\"368\":2}}],[\"=x\",{\"1\":{\"75\":2}}],[\"==dbg==\",{\"1\":{\"370\":2}}],[\"==\",{\"1\":{\"14\":1,\"22\":1,\"23\":1,\"24\":1,\"43\":3,\"44\":2,\"49\":1,\"50\":1,\"60\":1,\"63\":3,\"65\":6,\"92\":2,\"93\":6,\"100\":1,\"108\":1,\"109\":4,\"113\":3,\"193\":1,\"220\":4,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"250\":2,\"251\":4,\"257\":1,\"262\":1,\"300\":2,\"303\":2}}],[\"=\",{\"1\":{\"9\":3,\"10\":2,\"11\":3,\"12\":2,\"13\":2,\"14\":1,\"15\":3,\"20\":9,\"21\":3,\"22\":3,\"23\":2,\"24\":3,\"30\":1,\"31\":2,\"33\":3,\"36\":6,\"41\":3,\"43\":15,\"44\":12,\"47\":3,\"49\":12,\"50\":1,\"59\":8,\"60\":17,\"61\":2,\"63\":10,\"65\":32,\"69\":1,\"71\":5,\"73\":8,\"82\":9,\"83\":4,\"91\":7,\"92\":10,\"93\":21,\"99\":3,\"100\":1,\"102\":4,\"103\":4,\"106\":3,\"108\":3,\"109\":15,\"113\":2,\"133\":4,\"139\":4,\"145\":7,\"151\":8,\"158\":8,\"161\":13,\"167\":11,\"187\":3,\"188\":1,\"189\":1,\"193\":4,\"194\":1,\"201\":2,\"207\":3,\"220\":5,\"222\":5,\"226\":2,\"227\":3,\"228\":4,\"229\":5,\"231\":7,\"238\":2,\"240\":4,\"241\":3,\"242\":2,\"243\":3,\"244\":1,\"245\":1,\"250\":8,\"251\":12,\"257\":8,\"258\":8,\"259\":4,\"261\":2,\"262\":2,\"263\":3,\"264\":1,\"270\":2,\"271\":2,\"274\":4,\"275\":1,\"276\":1,\"277\":5,\"287\":7,\"303\":2,\"361\":5,\"362\":2,\"363\":3,\"364\":6}}],[\"512\",{\"1\":{\"72\":2}}],[\"5\",{\"0\":{\"204\":1,\"230\":1,\"317\":1,\"335\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1},\"1\":{\"9\":6,\"20\":2,\"30\":1,\"32\":1,\"36\":2,\"41\":1,\"47\":1,\"71\":1,\"79\":2,\"82\":1,\"167\":2,\"193\":2,\"210\":1,\"222\":1,\"258\":4,\"259\":2,\"261\":2,\"263\":1,\"264\":1,\"274\":1,\"275\":1}}],[\"0ubuntu1~22\",{\"1\":{\"368\":1}}],[\"04\",{\"1\":{\"368\":3}}],[\"0666\",{\"1\":{\"227\":1,\"228\":1,\"229\":1}}],[\"0\",{\"0\":{\"202\":1},\"1\":{\"9\":1,\"10\":4,\"13\":2,\"14\":1,\"15\":1,\"20\":1,\"23\":1,\"24\":1,\"31\":2,\"33\":3,\"36\":3,\"43\":4,\"44\":3,\"49\":3,\"50\":1,\"61\":1,\"63\":5,\"65\":4,\"71\":9,\"80\":1,\"83\":1,\"85\":1,\"93\":5,\"99\":2,\"100\":3,\"106\":2,\"109\":1,\"113\":1,\"133\":2,\"139\":3,\"145\":1,\"151\":3,\"158\":3,\"161\":5,\"167\":2,\"194\":2,\"202\":3,\"207\":1,\"220\":12,\"222\":11,\"223\":1,\"226\":5,\"227\":4,\"228\":6,\"229\":8,\"230\":1,\"231\":8,\"236\":4,\"238\":2,\"239\":1,\"240\":2,\"241\":4,\"242\":2,\"243\":2,\"244\":2,\"245\":2,\"250\":5,\"251\":6,\"257\":5,\"258\":6,\"259\":3,\"261\":2,\"262\":5,\"263\":2,\"264\":1,\"270\":1,\"271\":1,\"273\":1,\"274\":2,\"275\":1,\"287\":6,\"300\":3,\"301\":1,\"303\":4,\"304\":2,\"344\":1,\"347\":1,\"361\":2,\"363\":1,\"364\":2,\"368\":2,\"382\":3}}],[\"我们使用\",{\"1\":{\"285\":1}}],[\"我们使用编程语言内置的哈希表时\",{\"1\":{\"75\":1}}],[\"我们往往通过基类的指针来销毁对象\",{\"1\":{\"210\":1}}],[\"我们往往更青睐使用数组实现算法\",{\"1\":{\"36\":1}}],[\"我们应该使用\",{\"1\":{\"113\":1}}],[\"我们应当将注意力集中在哈希算法\",{\"1\":{\"69\":1}}],[\"我们通过定义一个\",{\"1\":{\"286\":1}}],[\"我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号\",{\"1\":{\"106\":1}}],[\"我们通常会将输入数据排序\",{\"1\":{\"113\":1}}],[\"我们通常会用一些标准哈希算法\",{\"1\":{\"72\":1}}],[\"我们通常将\",{\"1\":{\"80\":1}}],[\"我们通常将头节点当作链表的代称\",{\"1\":{\"20\":1}}],[\"我们通常选取质数作为模数\",{\"1\":{\"71\":1}}],[\"我们通常不能完全填满它们\",{\"1\":{\"36\":1}}],[\"我们通常使用\",{\"1\":{\"30\":1}}],[\"我们只需将右旋的实现代码中的所有的\",{\"1\":{\"103\":1}}],[\"我们只需将元素插入链表头部\",{\"1\":{\"49\":1}}],[\"我们关注以该失衡节点为根节点的子树\",{\"1\":{\"102\":1}}],[\"我们同样将获取节点平衡因子的功能封装成函数\",{\"1\":{\"100\":1}}],[\"我们考虑使用数组或二叉搜索树存储\",{\"1\":{\"95\":1}}],[\"我们在二叉搜索树中获取有序数据仅需\",{\"1\":{\"94\":1}}],[\"我们在此采用与栈相同的方法命名\",{\"1\":{\"41\":1}}],[\"我们无法直接删除它\",{\"1\":{\"93\":1}}],[\"我们根据目标节点的子节点数量\",{\"1\":{\"93\":1}}],[\"我们声明一个节点\",{\"1\":{\"91\":1}}],[\"我们采取在链表或红黑树中执行查找操作\",{\"1\":{\"75\":1}}],[\"我们希望哈希算法具有确定性\",{\"1\":{\"74\":1}}],[\"我们也能设计一些简单的哈希算法\",{\"1\":{\"71\":1}}],[\"我们就能对各种失衡情况进行旋转\",{\"1\":{\"106\":1}}],[\"我们就无法在哈希表中查询到原先的\",{\"1\":{\"73\":1}}],[\"我们就进行哈希表扩容\",{\"1\":{\"62\":1}}],[\"我们就可以利用\",{\"1\":{\"60\":1}}],[\"我们就可以从链表的头节点出发\",{\"1\":{\"20\":1}}],[\"我们得到\",{\"1\":{\"61\":1}}],[\"我们先考虑最简单的情况\",{\"1\":{\"60\":1}}],[\"我们向哈希表中输入一个键\",{\"1\":{\"58\":1}}],[\"我们不能在开放寻址哈希表中直接删除元素\",{\"1\":{\"65\":1}}],[\"我们不能简单地确定哪种实现更加节省内存\",{\"1\":{\"51\":1}}],[\"我们不一定需要用这么多\",{\"1\":{\"36\":1}}],[\"我们来尝试自己实现一个栈类\",{\"1\":{\"48\":1}}],[\"我们以常见的\",{\"1\":{\"47\":1}}],[\"我们把堆叠元素的顶部称为\",{\"1\":{\"46\":1}}],[\"我们会发现两个数组中的相同数字拥有同一个\",{\"1\":{\"36\":1}}],[\"我们仍然可以在\",{\"1\":{\"36\":1}}],[\"我们维护一个指针变量始终指向头节点\",{\"1\":{\"36\":1}}],[\"我们规定每次将数组扩容至之前的\",{\"1\":{\"34\":1}}],[\"我们选择\",{\"1\":{\"34\":1}}],[\"我们尝试实现一个简易版列表\",{\"1\":{\"34\":1}}],[\"我们需要从递归的视角来看这个问题\",{\"1\":{\"113\":1}}],[\"我们需要从这个节点开始\",{\"1\":{\"108\":1}}],[\"我们需要保证在删除操作完成后\",{\"1\":{\"93\":1}}],[\"我们需要借助节点\",{\"1\":{\"92\":1}}],[\"我们需要通过哈希函数来重新计算所有键值对的存储位置\",{\"1\":{\"61\":1}}],[\"我们需要让\",{\"1\":{\"44\":1}}],[\"我们需要一种数据结构\",{\"1\":{\"42\":1}}],[\"我们需要快速找到最近最少使用的数据\",{\"1\":{\"27\":1}}],[\"我们需要访问节点的父节点\",{\"1\":{\"27\":1}}],[\"我们知道\",{\"1\":{\"18\":1,\"73\":1}}],[\"我们既可以通过索引遍历数组\",{\"1\":{\"13\":1}}],[\"我们将旋转操作封装成一个函数\",{\"1\":{\"106\":1}}],[\"我们将平衡因子绝对值\",{\"1\":{\"101\":1}}],[\"我们将创建两个工具函数\",{\"1\":{\"99\":1}}],[\"我们将二叉搜索树封装为一个类\",{\"1\":{\"90\":1}}],[\"我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树\",{\"1\":{\"79\":1}}],[\"我们将哈希表看作一个\",{\"1\":{\"65\":1}}],[\"我们将哈希表扩容至原先的\",{\"1\":{\"63\":1}}],[\"我们将这种多个输入对应同一输出的情况称为哈希冲突\",{\"1\":{\"61\":1}}],[\"我们将这个问题的解决方案留在\",{\"1\":{\"11\":1}}],[\"我们将\",{\"1\":{\"60\":1}}],[\"我们将数组中的每个空位称为桶\",{\"1\":{\"60\":1}}],[\"我们将盘子替换为各种类型的元素\",{\"1\":{\"46\":1}}],[\"我们将队列头部称为\",{\"1\":{\"40\":1}}],[\"我们将把\",{\"1\":{\"28\":1}}],[\"我们将首个节点称为头节点\",{\"1\":{\"26\":1}}],[\"我们将元素在数组中的位置称为该元素的索引\",{\"1\":{\"7\":1}}],[\"我们发现数组首个元素的索引为\",{\"1\":{\"10\":1}}],[\"我们可以利用这个特点做一些性能优化\",{\"1\":{\"270\":1}}],[\"我们可以获取到其父节点\",{\"1\":{\"92\":1}}],[\"我们可以调用\",{\"1\":{\"73\":1}}],[\"我们可以采用懒删除\",{\"1\":{\"65\":1}}],[\"我们可以采用以下策略\",{\"1\":{\"62\":1}}],[\"我们可以采用以下巧妙方法来避免这个问题\",{\"1\":{\"44\":1}}],[\"我们可以通过扩容哈希表来减少哈希冲突\",{\"1\":{\"61\":1}}],[\"我们可以通过哈希函数得到该\",{\"1\":{\"60\":1}}],[\"我们可以得出以下结论\",{\"1\":{\"51\":1}}],[\"我们可以\",{\"1\":{\"48\":1}}],[\"我们可以直接使用编程语言内置的栈类\",{\"1\":{\"47\":1}}],[\"我们可以直接使用编程语言中现成的队列类\",{\"1\":{\"41\":1}}],[\"我们可以将栈类比为桌面上的一摞盘子\",{\"1\":{\"46\":1}}],[\"我们可以将数组的尾部作为栈顶\",{\"1\":{\"50\":1}}],[\"我们可以将数组替换为动态数组\",{\"1\":{\"44\":1}}],[\"我们可以将数组视为首尾相接的\",{\"1\":{\"44\":1}}],[\"我们可以将链表的头节点视为栈顶\",{\"1\":{\"49\":1}}],[\"我们可以将链表的\",{\"1\":{\"43\":1}}],[\"我们可以定位列表尾部\",{\"1\":{\"34\":1}}],[\"我们可以使用它们得到一个特定顺序的遍历结果\",{\"1\":{\"113\":1}}],[\"我们可以使用一个变量\",{\"1\":{\"44\":1}}],[\"我们可以使用\",{\"1\":{\"28\":1}}],[\"我们可以使用下图所示的公式计算得到该元素的内存地址\",{\"1\":{\"10\":1}}],[\"我们可以初始化一个比较长的数组\",{\"1\":{\"12\":1}}],[\"我们可以在\",{\"1\":{\"10\":1,\"23\":1}}],[\"我们可以根据需求选用数组的两种初始化方式\",{\"1\":{\"9\":1}}],[\"多次提交合并\",{\"1\":{\"314\":1}}],[\"多次哈希是开放寻址的一种\",{\"1\":{\"75\":1}}],[\"多次哈希有不能直接删除元素的缺陷吗\",{\"1\":{\"75\":1}}],[\"多次哈希使用多个哈希函数进行探测\",{\"1\":{\"74\":1}}],[\"多次哈希方法不易产生聚集\",{\"1\":{\"67\":1}}],[\"多次哈希方法使用多个哈希函数\",{\"1\":{\"67\":1}}],[\"多次哈希\",{\"0\":{\"67\":1}}],[\"多次探测\",{\"1\":{\"64\":1}}],[\"多个线程对同一变量进行原子操作时\",{\"1\":{\"248\":1}}],[\"多个日志处理器\",{\"1\":{\"168\":1}}],[\"多个\",{\"1\":{\"61\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"61\":1}}],[\"多进程\",{\"2\":{\"5\":1,\"234\":1}}],[\"多线程\",{\"2\":{\"5\":1,\"254\":1,\"279\":1}}],[\"cttyhack\",{\"1\":{\"370\":1}}],[\"ctrl+c\",{\"1\":{\"230\":1}}],[\"cxx\",{\"1\":{\"344\":1}}],[\"cmakelists\",{\"1\":{\"343\":2,\"344\":1,\"346\":1,\"348\":1}}],[\"cmake\",{\"0\":{\"341\":1,\"351\":1},\"1\":{\"341\":2,\"342\":4,\"343\":4,\"344\":4,\"348\":1,\"351\":2,\"354\":1,\"356\":1,\"357\":3},\"2\":{\"359\":1}}],[\"cd\",{\"1\":{\"334\":1,\"336\":1,\"350\":1,\"369\":1,\"370\":2}}],[\"cdn\",{\"1\":{\"181\":1,\"369\":1}}],[\"centos7\",{\"1\":{\"270\":6,\"271\":1}}],[\"cerr\",{\"1\":{\"222\":4,\"303\":2}}],[\"circular\",{\"1\":{\"246\":1}}],[\"circle\",{\"1\":{\"151\":3}}],[\"cv\",{\"1\":{\"240\":6,\"262\":4}}],[\"cpio\",{\"1\":{\"370\":1}}],[\"cp\",{\"1\":{\"369\":2}}],[\"cpp\",{\"1\":{\"231\":2,\"270\":3,\"344\":1,\"346\":1,\"347\":1,\"348\":1,\"353\":1}}],[\"cpu\",{\"1\":{\"27\":2,\"35\":1,\"215\":2,\"216\":3,\"219\":1,\"372\":1}}],[\"cut\",{\"1\":{\"370\":1}}],[\"customtablemodel\",{\"1\":{\"193\":2}}],[\"customdelegate\",{\"1\":{\"189\":3}}],[\"curl\",{\"1\":{\"382\":1}}],[\"currenthead\",{\"1\":{\"250\":4,\"251\":8}}],[\"currenttail\",{\"1\":{\"250\":3,\"251\":5}}],[\"cur\",{\"1\":{\"91\":22,\"92\":11,\"93\":25}}],[\"css\",{\"1\":{\"174\":1}}],[\"critical\",{\"1\":{\"229\":4}}],[\"creat\",{\"1\":{\"227\":1,\"228\":1,\"229\":1}}],[\"create\",{\"1\":{\"222\":1,\"362\":2}}],[\"createdaemon\",{\"1\":{\"222\":2}}],[\"createtextbox\",{\"1\":{\"161\":3}}],[\"createbutton\",{\"1\":{\"161\":3}}],[\"createvehicle\",{\"1\":{\"158\":3}}],[\"creator\",{\"1\":{\"157\":2}}],[\"crypto\",{\"1\":{\"145\":1}}],[\"cryptostream\",{\"1\":{\"145\":6}}],[\"cbfs\",{\"1\":{\"145\":2}}],[\"cfs\",{\"1\":{\"145\":2}}],[\"can\",{\"1\":{\"382\":2}}],[\"cavas\",{\"1\":{\"361\":1}}],[\"cast<int>\",{\"1\":{\"277\":1}}],[\"case\",{\"1\":{\"277\":3}}],[\"case3\",{\"1\":{\"93\":3}}],[\"cas\",{\"1\":{\"241\":1,\"248\":1,\"249\":1}}],[\"callonce\",{\"1\":{\"261\":2}}],[\"call\",{\"0\":{\"261\":1},\"1\":{\"256\":1,\"261\":3,\"264\":1}}],[\"calls\",{\"1\":{\"236\":2}}],[\"calculate\",{\"1\":{\"139\":3}}],[\"carfactory\",{\"1\":{\"158\":3}}],[\"car\",{\"1\":{\"158\":4}}],[\"capacity\",{\"1\":{\"44\":4,\"60\":3,\"61\":1,\"63\":7,\"65\":7,\"69\":2,\"250\":7,\"251\":9}}],[\"chmod\",{\"1\":{\"370\":1}}],[\"chrome\",{\"1\":{\"364\":1}}],[\"chromebrowser\",{\"1\":{\"364\":1}}],[\"chrono\",{\"1\":{\"240\":1,\"242\":1,\"243\":1,\"257\":1,\"258\":1,\"262\":1}}],[\"checkout\",{\"1\":{\"318\":3,\"322\":3,\"336\":1}}],[\"chdir\",{\"1\":{\"222\":1}}],[\"child\",{\"1\":{\"79\":2,\"93\":5,\"102\":11,\"103\":10,\"104\":1,\"105\":1,\"109\":3,\"113\":3,\"226\":1,\"227\":2,\"228\":1,\"229\":2,\"303\":7}}],[\"change\",{\"1\":{\"222\":1}}],[\"chain\",{\"1\":{\"165\":1}}],[\"chaining\",{\"1\":{\"63\":1}}],[\"character\",{\"1\":{\"287\":3,\"288\":2}}],[\"char\",{\"1\":{\"71\":1,\"226\":2,\"227\":1,\"228\":4,\"231\":2,\"287\":5}}],[\"clone\",{\"1\":{\"311\":3,\"332\":1}}],[\"closing\",{\"1\":{\"292\":1}}],[\"closed\",{\"1\":{\"292\":2,\"294\":1}}],[\"close\",{\"1\":{\"222\":3,\"226\":4,\"231\":3,\"292\":1,\"294\":1,\"295\":1}}],[\"clients\",{\"1\":{\"371\":1}}],[\"client\",{\"1\":{\"231\":1}}],[\"clicked\",{\"1\":{\"161\":2}}],[\"click\",{\"1\":{\"161\":3}}],[\"class\",{\"1\":{\"43\":1,\"44\":1,\"49\":1,\"50\":1,\"60\":1,\"63\":1,\"65\":1,\"133\":3,\"139\":4,\"145\":6,\"151\":6,\"158\":6,\"161\":9,\"167\":4,\"189\":1,\"193\":1,\"207\":3,\"243\":1,\"250\":1,\"251\":1,\"257\":2,\"262\":1,\"277\":1,\"287\":1,\"361\":7,\"362\":2,\"363\":2,\"364\":7}}],[\"clear\",{\"1\":{\"32\":1,\"60\":1,\"63\":1,\"243\":1}}],[\"c\",{\"0\":{\"204\":1},\"1\":{\"18\":1,\"28\":1,\"54\":1,\"71\":2,\"151\":6,\"204\":2,\"271\":2,\"287\":2,\"341\":1,\"344\":1,\"357\":1,\"373\":1,\"374\":1}}],[\"corrected\",{\"1\":{\"314\":1}}],[\"core\",{\"1\":{\"122\":1}}],[\"copy\",{\"1\":{\"270\":4,\"382\":1}}],[\"command\",{\"1\":{\"382\":1}}],[\"commands\",{\"1\":{\"382\":1}}],[\"commit\",{\"1\":{\"314\":4,\"333\":1,\"334\":1,\"335\":1,\"336\":4,\"338\":1}}],[\"communication\",{\"1\":{\"225\":1}}],[\"com\",{\"1\":{\"311\":3,\"331\":1,\"382\":1}}],[\"compile\",{\"1\":{\"355\":2}}],[\"complicated>\",{\"1\":{\"271\":1}}],[\"complicated\",{\"1\":{\"271\":7}}],[\"completed\",{\"1\":{\"236\":1}}],[\"complete\",{\"1\":{\"86\":1}}],[\"compare\",{\"1\":{\"241\":1,\"243\":1,\"248\":1}}],[\"component\",{\"1\":{\"144\":2}}],[\"column\",{\"1\":{\"193\":2}}],[\"columncount\",{\"1\":{\"190\":1,\"193\":2}}],[\"color\",{\"1\":{\"151\":9,\"277\":6,\"361\":1}}],[\"collision\",{\"1\":{\"61\":1}}],[\"config\",{\"1\":{\"335\":1,\"369\":1,\"370\":1,\"374\":1}}],[\"conversion\",{\"1\":{\"277\":1}}],[\"continue\",{\"1\":{\"373\":1}}],[\"continued\",{\"1\":{\"303\":1}}],[\"contains\",{\"1\":{\"273\":3}}],[\"controller\",{\"1\":{\"177\":2,\"192\":3}}],[\"console=ttys0\",{\"1\":{\"372\":3}}],[\"consumed\",{\"1\":{\"250\":1,\"251\":1}}],[\"consumer\",{\"1\":{\"250\":2,\"251\":3}}],[\"constucted\",{\"1\":{\"271\":5}}],[\"constructors\",{\"1\":{\"270\":2}}],[\"construct\",{\"1\":{\"270\":8}}],[\"const\",{\"0\":{\"205\":1},\"1\":{\"60\":1,\"65\":2,\"71\":1,\"139\":4,\"145\":2,\"151\":6,\"158\":6,\"161\":12,\"189\":3,\"193\":6,\"205\":1,\"226\":1,\"231\":1,\"239\":1,\"250\":1,\"251\":1,\"262\":1,\"270\":1,\"271\":1,\"274\":3,\"275\":2,\"287\":2,\"361\":8,\"362\":2,\"364\":3}}],[\"constexpr\",{\"0\":{\"284\":1},\"1\":{\"4\":1,\"203\":1,\"284\":1,\"285\":2,\"286\":1,\"287\":3,\"288\":2},\"2\":{\"290\":1}}],[\"condition\",{\"0\":{\"262\":1},\"1\":{\"240\":1,\"256\":1,\"262\":1,\"264\":1}}],[\"concurrency\",{\"1\":{\"257\":1}}],[\"concurrently\",{\"1\":{\"236\":1}}],[\"concrete\",{\"1\":{\"132\":2,\"144\":2,\"150\":1,\"157\":2,\"160\":2,\"166\":1}}],[\"connection\",{\"1\":{\"291\":1}}],[\"connect\",{\"1\":{\"231\":1}}],[\"cout<<\",{\"1\":{\"270\":3,\"271\":6}}],[\"cout\",{\"1\":{\"44\":1,\"59\":2,\"60\":1,\"63\":3,\"65\":3,\"133\":1,\"139\":2,\"145\":5,\"151\":4,\"158\":2,\"161\":4,\"167\":3,\"207\":2,\"226\":1,\"227\":2,\"228\":1,\"229\":4,\"230\":2,\"231\":1,\"236\":3,\"238\":1,\"239\":2,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":2,\"250\":2,\"251\":2,\"257\":8,\"258\":4,\"259\":2,\"261\":1,\"263\":2,\"264\":1,\"275\":1,\"277\":4,\"287\":2,\"303\":7,\"347\":1}}],[\"countdown\",{\"1\":{\"262\":1}}],[\"countdownlatch\",{\"1\":{\"262\":2}}],[\"counting\",{\"1\":{\"242\":1}}],[\"counter\",{\"1\":{\"241\":3}}],[\"count\",{\"1\":{\"13\":2,\"33\":4,\"245\":1,\"260\":9,\"262\":8}}],[\"c++中基类的析构函数应采用virtual虚析构函数\",{\"1\":{\"210\":1}}],[\"c++中基类采用virtual虚析构函数是为了防止内存泄漏\",{\"1\":{\"210\":1}}],[\"c++的多态性\",{\"1\":{\"207\":1}}],[\"c++的多态如何实现\",{\"0\":{\"207\":1}}],[\"c++不能只学习语言本身\",{\"1\":{\"122\":1}}],[\"c++之父大作\",{\"1\":{\"122\":1}}],[\"c++程序设计\",{\"1\":{\"122\":1}}],[\"c++实战经验\",{\"1\":{\"121\":1}}],[\"c++20各种新特性\",{\"1\":{\"121\":1}}],[\"c++20高级编程\",{\"1\":{\"121\":1}}],[\"c++进阶\",{\"1\":{\"121\":1}}],[\"c++基础\",{\"1\":{\"121\":1}}],[\"c++基础知识介绍的非常全面\",{\"1\":{\"121\":1}}],[\"c++11关于异步操作提供了future相关的类\",{\"1\":{\"263\":1}}],[\"c++11关于并发引入了好多好东西\",{\"1\":{\"256\":1}}],[\"c++11提供了std\",{\"1\":{\"261\":1}}],[\"c++11提供了原子类型\",{\"1\":{\"260\":1}}],[\"c++11主要有std\",{\"1\":{\"259\":1}}],[\"c++11还提供了获取线程id\",{\"1\":{\"257\":1}}],[\"c++11引入了std\",{\"1\":{\"236\":1,\"257\":1}}],[\"c++11\",{\"0\":{\"255\":1},\"1\":{\"249\":1,\"285\":1},\"2\":{\"5\":1,\"279\":1}}],[\"c++面试题\",{\"1\":{\"1\":1}}],[\"c++\",{\"0\":{\"120\":1,\"199\":1,\"249\":1},\"1\":{\"0\":3,\"1\":1,\"18\":2,\"28\":1,\"30\":1,\"34\":1,\"36\":1,\"54\":1,\"73\":1,\"113\":1,\"121\":1,\"122\":2,\"167\":1,\"204\":1,\"221\":1,\"241\":1,\"248\":1,\"270\":6,\"271\":2,\"341\":1,\"347\":1,\"357\":1},\"2\":{\"5\":1,\"38\":1,\"56\":1,\"77\":1,\"115\":1,\"123\":1,\"129\":1,\"135\":1,\"141\":1,\"147\":1,\"153\":1,\"163\":1,\"170\":1,\"212\":1,\"234\":1,\"254\":1,\"290\":1}}],[\"其实现原理如下\",{\"1\":{\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1}}],[\"其父进程没有及时调用\",{\"1\":{\"218\":1}}],[\"其底层的原理是什么\",{\"1\":{\"207\":1}}],[\"其节点总数\",{\"1\":{\"113\":1}}],[\"其查找\",{\"1\":{\"112\":1}}],[\"其左\",{\"1\":{\"112\":1}}],[\"其左子节点记为\",{\"1\":{\"102\":1}}],[\"其余所有节点的度都为\",{\"1\":{\"85\":1}}],[\"其两个指针均指向\",{\"1\":{\"80\":1}}],[\"其次\",{\"1\":{\"75\":1}}],[\"其操作方法与普通哈希表有所不同\",{\"1\":{\"65\":1}}],[\"其定义为哈希表的元素数量除以桶数量\",{\"1\":{\"61\":1}}],[\"其长度不可变\",{\"1\":{\"44\":1}}],[\"其支持元素增删查改操作\",{\"1\":{\"28\":1}}],[\"其存在以下局限性\",{\"1\":{\"16\":1}}],[\"其中的函数为虚函数\",{\"1\":{\"207\":1}}],[\"其中的每个元素都是一个节点对象\",{\"1\":{\"18\":1}}],[\"其中a\",{\"1\":{\"202\":1}}],[\"其中某个维度的扩展是可以叠加的\",{\"1\":{\"145\":1}}],[\"其中每种情况都需要进行多个步骤的节点操作\",{\"1\":{\"113\":1}}],[\"其中查找待删除节点需要\",{\"1\":{\"93\":1}}],[\"其中图的每个顶点都与一个链表相关联\",{\"1\":{\"27\":1}}],[\"其中\",{\"1\":{\"12\":1,\"60\":1,\"372\":1}}],[\"其将相同类型的元素存储在连续的内存空间中\",{\"1\":{\"7\":1}}],[\"其他资料2\",{\"1\":{\"375\":1}}],[\"其他资料1\",{\"1\":{\"375\":1}}],[\"其他线程能正确地看到更新的头部指针\",{\"1\":{\"251\":1}}],[\"其他线程能正确地看到更新的尾部指针\",{\"1\":{\"251\":1}}],[\"其他线程可以成功获取锁并继续执行\",{\"1\":{\"243\":1}}],[\"其他所有节点都包含子节点和非空子树\",{\"1\":{\"79\":1}}],[\"其他\",{\"0\":{\"4\":1,\"378\":1},\"2\":{\"289\":1,\"297\":1,\"307\":1,\"339\":1,\"358\":1,\"365\":1,\"376\":1,\"379\":1}}],[\"其目的在于帮助想学习\",{\"1\":{\"0\":1}}],[\"责任链模式非常有用\",{\"1\":{\"168\":1}}],[\"责任链模式通过将请求沿着一条链传递\",{\"1\":{\"168\":1}}],[\"责任链模式的核心思想是将请求沿着一条链传递\",{\"1\":{\"166\":1}}],[\"责任链模式\",{\"0\":{\"164\":1},\"1\":{\"3\":1,\"125\":1,\"165\":1},\"2\":{\"170\":1}}],[\"桥接模式非常适合在一个类有多个维度的变化\",{\"1\":{\"151\":1}}],[\"桥接模式涉及以下几个角色\",{\"1\":{\"150\":1}}],[\"桥接模式通过将类的功能层次与实现层次分离\",{\"1\":{\"149\":1}}],[\"桥接模式\",{\"0\":{\"148\":1},\"1\":{\"3\":1,\"125\":1,\"149\":1,\"364\":1},\"2\":{\"153\":1}}],[\"架构设计\",{\"0\":{\"3\":1,\"197\":1},\"2\":{\"128\":1,\"134\":1,\"140\":1,\"146\":1,\"152\":1,\"162\":1,\"169\":1,\"183\":1,\"195\":1,\"198\":1}}],[\"数字签名等\",{\"1\":{\"72\":1}}],[\"数量记录\",{\"1\":{\"34\":1}}],[\"数据处理\",{\"1\":{\"364\":2}}],[\"数据可以传输\",{\"1\":{\"295\":1}}],[\"数据可以在客户端和服务器之间双向传输\",{\"1\":{\"292\":1}}],[\"数据只能单向流动\",{\"1\":{\"226\":1}}],[\"数据已更改\",{\"1\":{\"191\":1}}],[\"数据更新主要依赖于信号与槽机制\",{\"1\":{\"191\":1}}],[\"数据发生变化时\",{\"1\":{\"190\":1}}],[\"数据发送方可以计算数据的哈希值并将其一同发送\",{\"1\":{\"70\":1}}],[\"数据流的方向如下\",{\"1\":{\"190\":1}}],[\"数据流可能会被分成多个缓冲块并放入一个环形链表\",{\"1\":{\"27\":1}}],[\"数据保持一致\",{\"1\":{\"188\":1}}],[\"数据同步\",{\"0\":{\"326\":1},\"1\":{\"188\":1}}],[\"数据的变化\",{\"1\":{\"187\":1}}],[\"数据绑定与更新\",{\"0\":{\"191\":1}}],[\"数据绑定使得\",{\"1\":{\"179\":1}}],[\"数据绑定机制\",{\"1\":{\"179\":1}}],[\"数据绑定机制确保视图能够实时反映\",{\"1\":{\"174\":1}}],[\"数据完整性检查\",{\"1\":{\"70\":1}}],[\"数据操作效率基本一致\",{\"1\":{\"36\":1}}],[\"数据主要存储在内存中\",{\"1\":{\"35\":1}}],[\"数据缓冲区\",{\"1\":{\"27\":1}}],[\"数据结构的哈希值\",{\"0\":{\"73\":1}}],[\"数据结构实现\",{\"1\":{\"17\":1}}],[\"数据结构\",{\"0\":{\"2\":1,\"116\":1},\"2\":{\"5\":1,\"37\":1,\"55\":1,\"76\":1,\"114\":1,\"117\":1}}],[\"数组比二叉搜索树的效率更高\",{\"1\":{\"95\":1}}],[\"数组中\",{\"1\":{\"288\":1}}],[\"数组中连续被占用的位置越长\",{\"1\":{\"65\":1}}],[\"数组中包含元素的有效区间为\",{\"1\":{\"44\":1}}],[\"数组长度\",{\"1\":{\"60\":1,\"75\":2}}],[\"数组索引\",{\"1\":{\"60\":1}}],[\"数组实现额外支持随机访问\",{\"1\":{\"51\":1}}],[\"数组或链表的部分无关操作\",{\"1\":{\"48\":1}}],[\"数组和链表也可以实现查询功能\",{\"1\":{\"58\":1}}],[\"数组和链表都可以在任意位置添加和删除元素\",{\"1\":{\"48\":1}}],[\"数组和链表是两种基本的数据结构\",{\"1\":{\"35\":1}}],[\"数组内存地址\",{\"1\":{\"36\":1}}],[\"数组同时包含\",{\"1\":{\"36\":1}}],[\"数组存储在栈上和存储在堆上\",{\"1\":{\"36\":1}}],[\"数组存储在连续的内存空间内\",{\"1\":{\"16\":1}}],[\"数组可提供更高的内存空间效率\",{\"1\":{\"35\":1}}],[\"数组可以用于实现栈\",{\"1\":{\"17\":1}}],[\"数组支持随机访问\",{\"1\":{\"35\":1}}],[\"数组也支持元素增删查改\",{\"1\":{\"28\":1}}],[\"数组整体是一个变量\",{\"1\":{\"20\":1}}],[\"数组是神经网络编程中最常使用的数据结构\",{\"1\":{\"17\":1}}],[\"数组是排序和搜索算法最常用的数据结构\",{\"1\":{\"17\":1}}],[\"数组是一种基础且常见的数据结构\",{\"1\":{\"17\":1}}],[\"数组典型应用\",{\"0\":{\"17\":1}}],[\"数组在初始化后长度就固定了\",{\"1\":{\"16\":1}}],[\"数组允许在\",{\"1\":{\"16\":1}}],[\"数组为数据分配了连续的内存块\",{\"1\":{\"16\":1}}],[\"数组的优点与局限性\",{\"0\":{\"16\":1}}],[\"数组的长度是不可变的\",{\"1\":{\"15\":1}}],[\"数组的插入和删除的平均时间复杂度均为\",{\"1\":{\"12\":1}}],[\"数组的插入与删除操作有以下缺点\",{\"1\":{\"12\":1}}],[\"数组删除元素示例\",{\"1\":{\"12\":1}}],[\"数组插入元素示例\",{\"1\":{\"11\":1}}],[\"数组元素则必须是相同类型的\",{\"1\":{\"36\":1}}],[\"数组元素在内存中是\",{\"1\":{\"11\":1}}],[\"数组元素的内存地址计算\",{\"1\":{\"10\":1}}],[\"数组元素被存储在连续的内存空间中\",{\"1\":{\"10\":1}}],[\"数组常用操作\",{\"0\":{\"8\":1}}],[\"数组定义与存储方式\",{\"1\":{\"7\":1}}],[\"数组\",{\"0\":{\"7\":1,\"25\":1},\"1\":{\"7\":1,\"25\":1,\"47\":1,\"58\":1,\"63\":1,\"73\":1},\"2\":{\"38\":1}}],[\"数组与链表\",{\"0\":{\"6\":1},\"1\":{\"2\":1}}],[\"面试题\",{\"2\":{\"211\":1,\"233\":1,\"253\":1,\"278\":1,\"281\":1}}],[\"面试题和数据结构算法\",{\"1\":{\"0\":1}}],[\"面试\",{\"2\":{\"5\":1}}],[\"面试集锦\",{\"0\":{\"1\":1,\"280\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
