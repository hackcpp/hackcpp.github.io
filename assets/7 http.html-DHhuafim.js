import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as n,e as r}from"./app-CxUyNCM_.js";const a={},s=r('<h3 id="http-基础知识" tabindex="-1"><a class="header-anchor" href="#http-基础知识"><span>HTTP 基础知识</span></a></h3><h4 id="请求-响应模型" tabindex="-1"><a class="header-anchor" href="#请求-响应模型"><span>请求/响应模型</span></a></h4><ul><li><p><strong>请求方法</strong>：</p><ul><li><strong>GET</strong>：从服务器获取资源。请求参数附加在 URL 上。</li><li><strong>POST</strong>：向服务器发送数据，通常用于提交表单或上传文件。数据包含在请求体中。</li><li><strong>PUT</strong>：更新资源，将客户端提供的资源完整替换。</li><li><strong>DELETE</strong>：删除指定资源。</li><li><strong>HEAD</strong>：与 GET 类似，但只返回响应头，不包含响应体。</li><li><strong>PATCH</strong>：部分更新资源，而非完全替换。</li></ul></li><li><p><strong>请求的构成</strong>：</p><ul><li><strong>请求行</strong>：包括 HTTP 方法、目标 URL 和 HTTP 版本。</li><li><strong>请求头</strong>：包含元数据（如 <code>User-Agent</code>、<code>Accept</code>、<code>Authorization</code>）。</li><li><strong>请求体</strong>：携带数据内容（如表单数据、JSON 数据）。</li></ul></li><li><p><strong>响应的构成</strong>：</p><ul><li><strong>状态行</strong>：包括 HTTP 版本、状态码和状态描述（如 <code>HTTP/1.1 200 OK</code>）。</li><li><strong>响应头</strong>：包含元数据（如 <code>Content-Type</code>、<code>Content-Length</code>）。</li><li><strong>响应体</strong>：实际的内容数据（如 HTML 文档、图片）。</li></ul></li></ul><h4 id="http-状态码" tabindex="-1"><a class="header-anchor" href="#http-状态码"><span>HTTP 状态码</span></a></h4><ul><li><p><strong>1xx 信息性状态码</strong>：</p><ul><li><strong>100 Continue</strong>：表示客户端可以继续发送请求。</li></ul></li><li><p><strong>2xx 成功状态码</strong>：</p><ul><li><strong>200 OK</strong>：请求成功，服务器返回所请求的数据。</li><li><strong>201 Created</strong>：资源已创建，通常用于 POST 请求。</li></ul></li><li><p><strong>3xx 重定向状态码</strong>：</p><ul><li><strong>301 Moved Permanently</strong>：永久重定向。</li><li><strong>302 Found</strong>：临时重定向。</li></ul></li><li><p><strong>4xx 客户端错误状态码</strong>：</p><ul><li><strong>400 Bad Request</strong>：请求格式错误。</li><li><strong>401 Unauthorized</strong>：未授权，需要身份验证。</li><li><strong>404 Not Found</strong>：请求的资源不存在。</li></ul></li><li><p><strong>5xx 服务器错误状态码</strong>：</p><ul><li><strong>500 Internal Server Error</strong>：服务器内部错误。</li><li><strong>503 Service Unavailable</strong>：服务器暂时无法处理请求。</li></ul></li></ul><h4 id="http-头" tabindex="-1"><a class="header-anchor" href="#http-头"><span>HTTP 头</span></a></h4><ul><li><p><strong>请求头</strong>：</p><ul><li><strong>Content-Type</strong>：说明请求体的内容类型（如 <code>application/json</code>）。</li><li><strong>Accept</strong>：客户端愿意接受的响应类型（如 <code>Accept: text/html</code>）。</li><li><strong>Authorization</strong>：用于传递身份验证信息（如 <code>Bearer</code> 令牌）。</li></ul></li><li><p><strong>响应头</strong>：</p><ul><li><strong>Content-Type</strong>：响应体的内容类型（如 <code>Content-Type: text/html</code>）。</li><li><strong>Cache-Control</strong>：控制缓存行为（如 <code>no-cache</code>、<code>max-age=3600</code>）。</li></ul></li></ul><h4 id="url-和-uri" tabindex="-1"><a class="header-anchor" href="#url-和-uri"><span>URL 和 URI</span></a></h4><ul><li><strong>URL 的组成部分</strong>： <ul><li><strong>协议</strong>：如 <code>http://</code> 或 <code>https://</code>。</li><li><strong>域名</strong>：如 <code>www.example.com</code>。</li><li><strong>端口</strong>：如 <code>:80</code> 或 <code>:443</code>。</li><li><strong>路径</strong>：如 <code>/path/to/resource</code>。</li><li><strong>查询参数</strong>：如 <code>?key=value</code>。</li></ul></li></ul><h4 id="http-方法的幂等性和安全性" tabindex="-1"><a class="header-anchor" href="#http-方法的幂等性和安全性"><span>HTTP 方法的幂等性和安全性</span></a></h4><ul><li><strong>幂等性</strong>：方法执行多次和执行一次的效果相同。例如，GET 和 DELETE 是幂等的，POST 通常不是。</li><li><strong>安全性</strong>：指该操作不会对服务器上的资源进行修改，如 GET 方法是安全的，而 POST 则不是。</li></ul><hr><h3 id="http-协议版本" tabindex="-1"><a class="header-anchor" href="#http-协议版本"><span>HTTP 协议版本</span></a></h3><h4 id="http-1-0-和-http-1-1" tabindex="-1"><a class="header-anchor" href="#http-1-0-和-http-1-1"><span>HTTP/1.0 和 HTTP/1.1</span></a></h4><ul><li><strong>HTTP/1.0</strong>：每个请求需要建立单独的 TCP 连接，请求完成后关闭连接。</li><li><strong>HTTP/1.1</strong>：引入了连接保持（Keep-Alive），允许在同一连接上发送多个请求。还引入了分块传输编码（chunked transfer encoding），支持部分内容请求（Range 请求）。</li></ul><h4 id="http-2" tabindex="-1"><a class="header-anchor" href="#http-2"><span>HTTP/2</span></a></h4><ul><li><strong>多路复用</strong>：在同一个 TCP 连接上并发发送多个请求，解决了 HTTP/1.1 的队头阻塞问题。</li><li><strong>头部压缩</strong>：使用 HPACK 压缩请求和响应头，减少了带宽消耗。</li><li><strong>服务器推送</strong>：服务器可以主动向客户端推送资源，避免客户端需要再次请求。</li></ul><h4 id="http-3" tabindex="-1"><a class="header-anchor" href="#http-3"><span>HTTP/3</span></a></h4><ul><li><strong>基于 QUIC 协议</strong>：使用 UDP 而非 TCP 进行传输，减少了连接建立时间，提升了传输效率。</li><li><strong>抗网络抖动</strong>：改善了在高丢包率、抖动较大的网络环境下的性能。</li></ul><hr><h3 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性"><span>安全性</span></a></h3><h4 id="https" tabindex="-1"><a class="header-anchor" href="#https"><span>HTTPS</span></a></h4><ul><li><strong>工作原理</strong>：HTTP over TLS，使用公钥和私钥对传输的数据进行加密，确保数据的保密性和完整性。需要配置 SSL/TLS 证书。</li><li><strong>证书链</strong>：理解根证书、中间证书和服务器证书之间的信任关系。</li></ul><h4 id="cors-跨域资源共享" tabindex="-1"><a class="header-anchor" href="#cors-跨域资源共享"><span>CORS（跨域资源共享）</span></a></h4><ul><li><strong>原理</strong>：浏览器的同源策略限制了跨域请求，CORS 通过设置 <code>Access-Control-Allow-Origin</code> 等响应头来允许跨域访问。</li></ul><h4 id="身份验证" tabindex="-1"><a class="header-anchor" href="#身份验证"><span>身份验证</span></a></h4><ul><li><strong>基本认证和摘要认证</strong>：基于用户名和密码的简单验证方法。</li><li><strong>基于令牌的身份验证</strong>：如 JSON Web Token (JWT)，在请求头中传递令牌来验证身份。</li></ul><h4 id="csrf-xss-攻击" tabindex="-1"><a class="header-anchor" href="#csrf-xss-攻击"><span>CSRF/XSS 攻击</span></a></h4><ul><li><strong>CSRF 防御</strong>：通过使用令牌（如 CSRF Token）或 <code>SameSite</code> Cookie 来防止跨站请求伪造攻击。</li><li><strong>XSS 防御</strong>：通过输入输出的严格验证和编码来防止跨站脚本攻击。</li></ul><hr><h3 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存"><span>HTTP 缓存</span></a></h3><h4 id="缓存控制头" tabindex="-1"><a class="header-anchor" href="#缓存控制头"><span>缓存控制头</span></a></h4><ul><li><strong>Cache-Control</strong>：如 <code>no-store</code>（不缓存），<code>no-cache</code>（需重新验证），<code>max-age=3600</code>（缓存时长为 3600 秒）。</li><li><strong>ETag 和 Last-Modified</strong>：用于缓存验证，ETag 是资源的唯一标识符，而 Last-Modified 则基于资源的最后修改时间。</li></ul><h4 id="强缓存和协商缓存" tabindex="-1"><a class="header-anchor" href="#强缓存和协商缓存"><span>强缓存和协商缓存</span></a></h4><ul><li><strong>强缓存</strong>：在缓存有效期内不会与服务器通信，直接使用本地缓存。</li><li><strong>协商缓存</strong>：在缓存有效期过后，通过 ETag 或 Last-Modified 验证资源是否更新，决定是否重新获取资源。</li></ul><h4 id="cdn-和缓存层" tabindex="-1"><a class="header-anchor" href="#cdn-和缓存层"><span>CDN 和缓存层</span></a></h4><ul><li><strong>CDN</strong>：通过将资源缓存到靠近用户的节点，减少访问延迟，提高网站加载速度。</li><li><strong>缓存层</strong>：可以在服务器端配置反向代理或缓存服务器（如 Varnish）来提高性能。</li></ul><hr><h3 id="http-在实际开发中的应用" tabindex="-1"><a class="header-anchor" href="#http-在实际开发中的应用"><span>HTTP 在实际开发中的应用</span></a></h3><h4 id="api-开发和调用" tabindex="-1"><a class="header-anchor" href="#api-开发和调用"><span>API 开发和调用</span></a></h4><ul><li><strong>RESTful API</strong>：设计基于资源的接口，使用 HTTP 方法来表示不同的操作（如 GET 获取资源，POST 创建资源）。</li><li><strong>状态码的使用</strong>：合理使用状态码来表示不同的操作结果，如 201 表示资源创建成功，204 表示删除成功但无返回内容。</li></ul><h4 id="调试工具" tabindex="-1"><a class="header-anchor" href="#调试工具"><span>调试工具</span></a></h4><ul><li><strong><code>curl</code></strong>：命令行工具，用于发送 HTTP 请求并查看响应。</li><li><strong>Postman</strong>：用于调试和测试 API 的图形化工具。</li><li><strong>浏览器开发者工具（DevTools）</strong>：用于查看页面的 HTTP 请求和响应，分析网络性能。</li><li><strong>Fiddler 和 Wireshark</strong>：用于捕获和分析 HTTP 流量，帮助调试网络问题。</li></ul><h4 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket"><span>WebSocket</span></a></h4><ul><li><strong>WebSocket</strong>：提供全双工的通信能力，允许服务器和客户端实时通信。WebSocket 在 HTTP 协议的基础上进行升级，之后切换为专用的 WebSocket 协议。</li></ul><hr><h3 id="http-性能优化" tabindex="-1"><a class="header-anchor" href="#http-性能优化"><span>HTTP 性能优化</span></a></h3><h4 id="压缩" tabindex="-1"><a class="header-anchor" href="#压缩"><span>压缩</span></a></h4><ul><li><strong>Gzip/Brotli</strong>：通过压缩响应内容，减少传输的数据量，从而提升页面加载速度。Brotli 在压缩效率上优于 Gzip。</li></ul><h4 id="请求优化" tabindex="-1"><a class="header-anchor" href="#请求优化"><span>请求优化</span></a></h4><ul><li><strong>减少 HTTP 请求数量</strong>：通过合并 CSS、JavaScript 文件，使用 CSS Sprites 合并图片，减少页面加载时的请求数量。</li><li><strong>懒加载</strong>：对于图片或其他资源，使用懒加载技术，即在用户滚动到相应位置时才加载资源。</li></ul><h4 id="http-2-和-http-3-的性能优势" tabindex="-1"><a class="header-anchor" href="#http-2-和-http-3-的性能优势"><span>HTTP/2 和 HTTP/3 的性能优势</span></a></h4><ul><li><strong>HTTP/2</strong>：多路复用、服务器推送、头部压缩等特性显著减少了请求延迟，提高了页面加载速度。</li><li><strong>HTTP/3</strong>：通过使用基于 UDP 的 QUIC 协议，进一步减少了网络延迟，改善了不良网络环境下的传输效率。</li></ul><hr><h3 id="高级-http-特性" tabindex="-1"><a class="header-anchor" href="#高级-http-特性"><span>高级 HTTP 特性</span></a></h3><h4 id="代理和负载均衡" tabindex="-1"><a class="header-anchor" href="#代理和负载均衡"><span>代理和负载均衡</span></a></h4><ul><li><strong>反向代理</strong>：通过反向代理服务器（如 Nginx、HAProxy）处理客户端请求，并将请求转发到后端服务器。可以提高安全性、扩展性和负载分担能力</li></ul><p>。</p><ul><li><strong>负载均衡器</strong>：通过负载均衡器分配流量，确保多个服务器间的请求均衡，避免单一服务器过载。</li></ul><h4 id="webhooks" tabindex="-1"><a class="header-anchor" href="#webhooks"><span>Webhooks</span></a></h4><ul><li><strong>Webhooks</strong>：一种基于 HTTP 的事件回调机制，当特定事件发生时，服务器自动向预设的 URL 发送 POST 请求。</li></ul><h4 id="sse-server-sent-events" tabindex="-1"><a class="header-anchor" href="#sse-server-sent-events"><span>SSE（Server-Sent Events）</span></a></h4><ul><li><strong>SSE</strong>：一种单向的服务器推送技术，通过 HTTP 连接，服务器可以持续向客户端推送更新的数据，常用于实时通知等场景。</li></ul><hr><h3 id="http-的扩展和定制" tabindex="-1"><a class="header-anchor" href="#http-的扩展和定制"><span>HTTP 的扩展和定制</span></a></h3><h4 id="http-扩展机制" tabindex="-1"><a class="header-anchor" href="#http-扩展机制"><span>HTTP 扩展机制</span></a></h4><ul><li><strong>自定义 HTTP 头</strong>：可以通过添加自定义的请求头或响应头来传递额外的信息（如 <code>X-Custom-Header</code>）。</li><li><strong>扩展状态码和方法</strong>：某些特定场景下，可以定义私有的状态码或方法（尽量避免与标准规范冲突）。</li></ul><h4 id="传输编码" tabindex="-1"><a class="header-anchor" href="#传输编码"><span>传输编码</span></a></h4><ul><li><strong>Chunked Transfer-Encoding</strong>：用于分块传输大数据，服务器分批发送数据块，客户端将其组装成完整的响应体。</li></ul><hr><h3 id="http-的错误处理" tabindex="-1"><a class="header-anchor" href="#http-的错误处理"><span>HTTP 的错误处理</span></a></h3><h4 id="重试策略" tabindex="-1"><a class="header-anchor" href="#重试策略"><span>重试策略</span></a></h4><ul><li><strong>幂等操作</strong>：对于幂等的操作（如 GET、PUT），在请求失败时可以安全地进行重试，而不会导致数据重复提交或操作错误。</li></ul><h4 id="网络故障恢复" tabindex="-1"><a class="header-anchor" href="#网络故障恢复"><span>网络故障恢复</span></a></h4><ul><li><strong>重试延迟</strong>：实现指数退避算法，逐步增加重试的时间间隔，以避免在网络恢复前过度占用资源。</li></ul><hr><h3 id="http-协议在架构中的角色" tabindex="-1"><a class="header-anchor" href="#http-协议在架构中的角色"><span>HTTP 协议在架构中的角色</span></a></h3><h4 id="微服务通信" tabindex="-1"><a class="header-anchor" href="#微服务通信"><span>微服务通信</span></a></h4><ul><li><strong>RESTful API 与 gRPC</strong>：REST API 基于 HTTP 进行通信，适用于跨平台和跨语言的微服务架构；gRPC 则基于 HTTP/2，更适合高性能需求的服务间通信。</li></ul><h4 id="异步-http-调用" tabindex="-1"><a class="header-anchor" href="#异步-http-调用"><span>异步 HTTP 调用</span></a></h4><ul><li><strong>消息队列和任务系统</strong>：在高并发或长时间任务处理中，结合队列（如 RabbitMQ）和任务系统（如 Celery）进行异步处理，减少 HTTP 请求的等待时间。</li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>HTTP 协议在现代网络应用开发中无处不在。要真正熟悉 HTTP，不仅要掌握其基础知识，还需要深入了解各个版本的特性、安全性要求、缓存机制、性能优化以及实际开发中的应用场景。通过不断学习和实践，尤其是在 API 开发、调试、优化和安全性方面的应用，可以逐步提高对 HTTP 的掌握程度。</p>',84),l=[s];function o(i,h){return n(),e("div",null,l)}const d=t(a,[["render",o],["__file","7 http.html.vue"]]),g=JSON.parse('{"path":"/other/7%20http.html","title":"http 介绍","lang":"zh-CN","frontmatter":{"title":"http 介绍","order":2,"category":["其他"],"tag":["http"],"editLink":false,"description":"HTTP 基础知识 请求/响应模型 请求方法： GET：从服务器获取资源。请求参数附加在 URL 上。 POST：向服务器发送数据，通常用于提交表单或上传文件。数据包含在请求体中。 PUT：更新资源，将客户端提供的资源完整替换。 DELETE：删除指定资源。 HEAD：与 GET 类似，但只返回响应头，不包含响应体。 PATCH：部分更新资源，而非完全...","head":[["meta",{"property":"og:url","content":"https://hackcpp.github.io/other/7%20http.html"}],["meta",{"property":"og:site_name","content":"程序员的白粥馆"}],["meta",{"property":"og:title","content":"http 介绍"}],["meta",{"property":"og:description","content":"HTTP 基础知识 请求/响应模型 请求方法： GET：从服务器获取资源。请求参数附加在 URL 上。 POST：向服务器发送数据，通常用于提交表单或上传文件。数据包含在请求体中。 PUT：更新资源，将客户端提供的资源完整替换。 DELETE：删除指定资源。 HEAD：与 GET 类似，但只返回响应头，不包含响应体。 PATCH：部分更新资源，而非完全..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-24T00:42:54.000Z"}],["meta",{"property":"article:author","content":"Mr.Hackcpp"}],["meta",{"property":"article:tag","content":"http"}],["meta",{"property":"article:modified_time","content":"2024-08-24T00:42:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"http 介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-24T00:42:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hackcpp\\",\\"url\\":\\"/portfolio.html\\"}]}"]]},"headers":[{"level":3,"title":"HTTP 基础知识","slug":"http-基础知识","link":"#http-基础知识","children":[]},{"level":3,"title":"HTTP 协议版本","slug":"http-协议版本","link":"#http-协议版本","children":[]},{"level":3,"title":"安全性","slug":"安全性","link":"#安全性","children":[]},{"level":3,"title":"HTTP 缓存","slug":"http-缓存","link":"#http-缓存","children":[]},{"level":3,"title":"HTTP 在实际开发中的应用","slug":"http-在实际开发中的应用","link":"#http-在实际开发中的应用","children":[]},{"level":3,"title":"HTTP 性能优化","slug":"http-性能优化","link":"#http-性能优化","children":[]},{"level":3,"title":"高级 HTTP 特性","slug":"高级-http-特性","link":"#高级-http-特性","children":[]},{"level":3,"title":"HTTP 的扩展和定制","slug":"http-的扩展和定制","link":"#http-的扩展和定制","children":[]},{"level":3,"title":"HTTP 的错误处理","slug":"http-的错误处理","link":"#http-的错误处理","children":[]},{"level":3,"title":"HTTP 协议在架构中的角色","slug":"http-协议在架构中的角色","link":"#http-协议在架构中的角色","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1724460174000,"updatedTime":1724460174000,"contributors":[{"name":"hackcpp","email":"liuheng2015@gmail.com","commits":1}]},"readingTime":{"minutes":7.75,"words":2325},"filePathRelative":"other/7 http.md","localizedDate":"2024年8月24日","excerpt":"","autoDesc":true}');export{d as comp,g as data};
